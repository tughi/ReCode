LibC_File :: struct

stdout: @LibC_File = external

fputc :: (char: Int, out: @LibC_File) -> Int

fputs :: (data: @Char, out: @LibC_File) -> Int

print_char :: (char: Char) -> Int {
	return fputc(char as Int, stdout)
}

print_cstring :: (message: @Char) -> Nothing {
	fputs(message, stdout)
	return
}

print_number :: (n: Int) -> Nothing {
	if (n >= 10) {
		print_number(n / 10)
	}
	print_char('0' + (n // 10) as Char)
	return
}

String :: struct {
	chars: @Char
	length: Int
}

String :: (chars: @Char) -> String {
	self: String
	self.chars = chars
	self.length = 0
	loop {
		if (chars[self.length] == 0) {
			break
		}
		self.length += 1
	}
	return self
}

Source :: struct {
    data: String
    current_index: Int
    current_line: Int
    current_column: Int
}

\ returns the next character that will be consumed
peek :: (@self: Source) -> Char {
	if (self.current_index < self.data.length) {
		return self.data.chars[self.current_index]
	}
	return 0 as Char
}

\ consume and return the current character if it's accepted by the provided function
consume :: (@self: Source, is_accepted: (char: Char) -> Bool) -> Char {
	if (self.current_index < self.data.length) {
		current := self.data.chars[self.current_index]
		if (current.is_accepted()) {
			self.current_index += 1
			if (current == '\n') {
				self.current_line += 1
				self.current_column = 1
			} else {
				self.current_column += 1
			}
			return current
		}
	}
	return 0 as Char
}

is_valid :: (char: Char) -> Bool {
	return char >= ' ' && char < 127 || char == '\n' || char == '\t'
}

main :: () -> Int {
	source: Source
	source.data = String("Hello world!")
	source.current_index = 0
	source.current_line = 0
	source.current_column = 0

	loops := 0
	loop {
		consumed := source.consume(is_valid)
		if (consumed == 0) {
			break
		}
		loops += 1
	}

	print_char('\n')

	return loops
}
