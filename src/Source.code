String :: struct {
	chars: @Char
	length: Int
}

String :: (chars: @Char) -> String {
	self: String
	self.chars = chars
	self.length = 0
	loop {
		if (chars[self.length] == 0) {
			break
		}
		self.length += 1
	}
	return self
}

Source :: struct {
    data: String
    current_index: Int
    current_line: Int
    current_column: Int
}

\ returns the next character that will be consumed
peek :: (@self: Source) -> Char {
	if (self.current_index < self.data.length) {
		return self.data.chars[self.current_index]
	}
	return 0 as Char
}

\ consume and return the current character if it's accepted by the provided function
consume :: (@self: Source, accepted: (char: Char) -> Bool) -> Char {
	if (self.current_index < self.data.length) {
		current := self.data.chars[self.current_index]
		if (accepted(current)) {
			self.current_index += 1
			if (current == '\n') {
				self.current_line += 1
				self.current_column = 1
			} else {
				self.current_column += 1
			}
			return current
		}
	}
	return 0
}

is_valid :: (char: Char) -> Bool {
	return char > 0 && char < 128
}

main :: () -> Nothing {
	source: Source
	source.data = String("Hello world!")

	loop {
		consumed := source.consume(is_valid)
		if (consumed == 0) {
			break
		}
		if (consumed == '!') {
			skip
		}
		echo(consumed)
	}
}
