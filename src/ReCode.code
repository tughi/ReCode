\ Copyright (c) 2020, Stefan Selariu

\ TODO: change main to: program :: (arguments: @String) -> Nothing
main :: (argc: Int, argv: @@Int8) -> Nothing {
    if (argc != 3) {
        stdout.write("Usage:").end_line()
        stdout.write('\t').write(argv[0]).write(" <INPUT FILE> <OUTPUT FILE>").end_line()
        exit(1)
    }

    source_file_name: String
    source_file_name.init(argv[1])
    if (source_file_name.ends_with(".code") == false) {
        stdout.write("'").write(source_file_name).write("' doesn't end with '.code'.").end_line()
        exit(1)
    }

    output_file_name: String
    output_file_name.init(argv[2])
    if (output_file_name.ends_with(".s") == false) {
        stdout.write("'").write(output_file_name).write("' doesn't end with '.s'.").end_line()
        exit(1)
    }

    tokens: @List = scan(source_file_name)

    compilation_unit: @Compilation_Unit = parse(tokens)
    stdout.write(compilation_unit).end_line()

    output_file: @FILE = fopen(argv[2], "w".data)

    output_file.write("  .file 1 \"").write(source_file_name).write("\"")
    output_file.write_line("  .intel_syntax noprefix")
    output_file.write_line("")
    output_file.write_line("  .text")
    output_file.write_line("  .globl main")
    output_file.write_line("main:")
    output_file.write_line("  push rbp")
    output_file.write_line("  mov rbp, rsp")
    \ TODO: call program function
    output_file.write_line("main__end:")
    output_file.write_line("  xor rax, rax")
    output_file.write_line("  mov rsp, rbp")
    output_file.write_line("  pop rbp")
    output_file.write_line("  ret")
    output_file.write_line("")
}

\ -------------------------------------------------------------------------------------------------
\       Parser
\ -------------------------------------------------------------------------------------------------

Parser :: struct {
    tokens: @List_Iterator
    current_alignment: Int
    optional_comment: @Matcher
    optional_space: @Matcher
    required_ampersand: @Matcher
    required_as: @Matcher
    required_asterisk: @Matcher
    required_at: @Matcher
    required_break: @Matcher
    required_close_brace: @Matcher
    required_close_bracket: @Matcher
    required_close_paren: @Matcher
    required_colon: @Matcher
    required_comma: @Matcher
    required_comment: @Matcher
    required_dot: @Matcher
    required_else: @Matcher
    required_end_of_file: @Matcher
    required_end_of_line: @Matcher
    required_equals: @Matcher
    required_exclamation_mark: @Matcher
    required_external: @Matcher
    required_greater_than: @Matcher
    required_hyphen: @Matcher
    required_identifier: @Matcher
    required_if: @Matcher
    required_is: @Matcher
    required_less_than: @Matcher
    required_literal: @Matcher
    required_loop: @Matcher
    required_new: @Matcher
    required_open_brace: @Matcher
    required_open_bracket: @Matcher
    required_open_paren: @Matcher
    required_plus: @Matcher
    required_return: @Matcher
    required_slash: @Matcher
    required_struct: @Matcher
    required_vertical_bar: @Matcher
    required_while: @Matcher
}

create_parser :: (tokens: @List) -> @Parser {
    parser: @Parser = new Parser
    parser.tokens = tokens.create_iterator()
    parser.tokens.next()
    parser.current_alignment = 0

    parser.optional_comment = create_comment_matcher(false)
    parser.optional_space = create_space_matcher(false)

    parser.required_ampersand = create_other_matcher(true, "&")
    parser.required_as = create_keyword_matcher(true, "as")
    parser.required_asterisk = create_other_matcher(true, "*")
    parser.required_at = create_other_matcher(true, "@")
    parser.required_break = create_keyword_matcher(true, "break")
    parser.required_close_brace = create_other_matcher(true, "}")
    parser.required_close_bracket = create_other_matcher(true, "]")
    parser.required_close_paren = create_other_matcher(true, ")")
    parser.required_colon = create_other_matcher(true, ":")
    parser.required_comma = create_other_matcher(true, ",")
    parser.required_comment = create_comment_matcher(true)
    parser.required_dot = create_other_matcher(true, ".")
    parser.required_else = create_keyword_matcher(true, "else")
    parser.required_end_of_file = create_end_of_file_matcher(true)
    parser.required_end_of_line = create_end_of_line_matcher(true)
    parser.required_equals = create_other_matcher(true, "=")
    parser.required_exclamation_mark = create_other_matcher(true, "!")
    parser.required_external = create_keyword_matcher(true, "external")
    parser.required_greater_than = create_other_matcher(true, ">")
    parser.required_hyphen = create_other_matcher(true, "-")
    parser.required_identifier = create_identifier_matcher(true)
    parser.required_if = create_keyword_matcher(true, "if")
    parser.required_is = create_keyword_matcher(true, "is")
    parser.required_less_than = create_other_matcher(true, "<")
    parser.required_literal = create_literal_matcher(true)
    parser.required_loop = create_keyword_matcher(true, "loop")
    parser.required_new = create_keyword_matcher(true, "new")
    parser.required_open_brace = create_other_matcher(true, "{")
    parser.required_open_bracket = create_other_matcher(true, "[")
    parser.required_open_paren = create_other_matcher(true, "(")
    parser.required_plus = create_other_matcher(true, "+")
    parser.required_return = create_keyword_matcher(true, "return")
    parser.required_slash = create_other_matcher(true, "/")
    parser.required_struct = create_keyword_matcher(true, "struct")
    parser.required_vertical_bar = create_other_matcher(true, "|")
    parser.required_while = create_keyword_matcher(true, "while")

    return parser
}

parse :: (tokens: @List) -> @Compilation_Unit {
    parser: @Parser = create_parser(tokens)
    statements: @List = parser.parse_statements()
    token: @Token = parser.tokens.current()
    if ((token is End_Of_File_Token) == false) {
        abort()
    }
    return create_compilation_unit(token.location.source, statements)
}

\ statements
\   : ( statement <EOL> )*
parse_statements :: (self: @Parser) -> @List {
    statements: @List = create_list()

    loop {
        statement: @Statement = self.parse_statement()
        if (statement == null) {
            break
        }
        self.consume_end_of_line()
        statements.append(statement)
    }

    return statements
}

\ statement
\   : if
\   | "return" expression?
\   | loop
\   | while
\   | "break"
\   | expression ( "::" ( struct | function ) | ":" value_type? ( "=" expression )? )?
parse_statement :: (self: @Parser) -> @Statement {
    while (self.consume_empty_line()) {
    }

    if (self.matches(self.optional_space, self.required_close_brace) || self.matches(self.required_end_of_file)) {
        return null
    }

    self.consume_space(self.current_alignment * 4)

    if (self.matches(self.required_if)) {
        return self.parse_if()
    }
    if (self.matches(self.required_return)) {
        token: @Token = self.consume(self.required_return)
        value_expression: @Expression = null
        if (self.matches_end_of_line() == false) {
            self.consume_space(1)
            value_expression = self.parse_expression()
        }
        return create_return_statement(token.location, value_expression)
    }
    if (self.matches(self.required_loop)) {
        return self.parse_loop()
    }
    if (self.matches(self.required_while)) {
        return self.parse_while()
    }
    if (self.matches(self.required_break)) {
        token: @Token = self.consume(self.required_break)
        return create_break_statement(token.location)
    }

    expression: @Expression = self.parse_expression()

    if (self.matches(self.optional_space, self.optional_comment, self.required_end_of_line)) {
        return create_expression_statement(expression)
    }

    if (self.matches(self.optional_space, self.required_colon, self.required_colon)) {
        self.consume_space(1)
        self.consume(self.required_colon, self.required_colon)
        self.consume_space(1)
        if (self.matches(self.required_struct)) {
            return self.parse_struct(expression)
        }
        return self.parse_function(expression)
    }

    if (self.matches(self.optional_space, self.required_colon)) {
        if (expression is Variable_Expression) {
            expression: @Variable_Expression = expression
            if (self.matches(self.optional_space, self.required_colon, self.required_equals)) {
                self.consume_space(1)
                self.consume(self.required_colon, self.required_equals)
                self.consume_space(1)
                return create_variable_statement(expression.name, null, self.parse_expression(), false)
            }
            self.consume_space(0)
            self.consume(self.required_colon)
            self.consume_space(1)
            value_type: @Value_Type = self.parse_value_type()
            if (self.matches(self.optional_space, self.required_equals)) {
                self.consume_space(1)
                self.consume(self.required_equals)
                self.consume_space(1)
                if (self.matches(self.required_external)) {
                    self.consume(self.required_external)
                    return create_variable_statement(expression.name, value_type, null, true)
                }
                return create_variable_statement(expression.name, value_type, self.parse_expression(), false)
            }
            return create_variable_statement(expression.name, value_type, null, false)
        }
        stderr.write(expression.location).write(": Cannot use expression as variable name").end_line()
        abort()
    }

    if (self.matches(self.optional_space, self.required_equals)) {
        self.consume_space(1)
        operator: @Other_Token = self.consume(self.required_equals)
        self.consume_space(1)
        return create_assignment_statement(expression, operator, self.parse_expression())
    }

    return null
}

\ struct
\   : "struct" ( ":" IDENTIFIER )? ( "{" <EOL> struct_members "}" )?
parse_struct :: (self: @Parser, name_expression: @Expression) -> @Statement {
    if (name_expression is Variable_Expression) {
        struct_name: @Identifier_Token = (name_expression as @Variable_Expression).name
        self.consume(self.required_struct)
        base_type: @Value_Type = null
        if (self.matches(self.optional_space, self.required_colon)) {
            self.consume_space(1)
            self.consume(self.required_colon)
            self.consume_space(1)
            base_type = self.parse_value_type()
        }
        if (self.matches(self.optional_space, self.required_open_brace)) {
            self.consume_space(1)
            self.consume(self.required_open_brace)
            self.consume_end_of_line()
            self.current_alignment = self.current_alignment + 1
            struct_members: @List = create_list()
            self.parse_struct_members(struct_members)
            self.current_alignment = self.current_alignment - 1
            self.consume_space(self.current_alignment * 4)
            self.consume(self.required_close_brace)
            return create_struct_statement(struct_name, base_type, struct_members)
        }
        return create_struct_statement(struct_name, base_type, null)
    } else {
        stderr.write(name_expression.location).write(": Cannot use expression as struct name").end_line()
        abort()
    }
}

\ struct_members
\   : ( IDENTIFIER ":" value_type <EOL> )*
parse_struct_members :: (self: @Parser, struct_members: @List) -> Nothing {
    loop {
        while (self.consume_empty_line()) {
        }

        if (self.matches(self.optional_space, self.required_identifier)) {
            self.consume_space(self.current_alignment * 4)
            member_name: @Identifier_Token = self.consume(self.required_identifier)
            self.consume_space(0)
            self.consume(self.required_colon)
            self.consume_space(1)
            member_value_type: @Value_Type = self.parse_value_type()
            struct_members.append(create_struct_member(member_name, member_value_type))
        } else {
            break
        }
    }
}

\ function
\   : "(" function_parameters? ")" "->" value_type block?
parse_function :: (self: @Parser, name_expression: @Expression) -> @Statement {
    if (name_expression is Variable_Expression) {
        function_name: @Identifier_Token = (name_expression as @Variable_Expression).name
        self.consume(self.required_open_paren)
        function_parameters: @List
        if (self.matches(self.optional_space, self.required_close_paren)) {
            function_parameters = create_list()
        } else {
            function_parameters = self.parse_function_parameters()
        }
        self.consume_space(0)
        self.consume(self.required_close_paren)
        self.consume_space(1)
        self.consume(self.required_hyphen, self.required_greater_than)
        self.consume_space(1)
        function_return_type: @Value_Type = self.parse_value_type()
        function_body: @Block_Statement
        if (self.matches(self.optional_space, self.required_open_brace)) {
            self.consume_space(1)
            function_body = self.parse_block()
        } else {
            function_body = null
        }
        return create_function_statement(function_name, function_parameters, function_return_type, function_body)
    } else {
        stderr.write(name_expression.location).write(": Cannot use expression as function name").end_line()
        abort()
    }
}

\ function_parameters
\   : function_parameter ( "," function_parameter )*
parse_function_parameters :: (self: @Parser) -> @List {
    function_parameters: @List = create_list()
    expected_space: Int = 0
    loop {
        self.consume_space(expected_space)
        function_parameters.append(self.parse_function_parameter())
        if (self.matches(self.optional_space, self.required_comma)) {
            self.consume_space(0)
            self.consume(self.required_comma)
            expected_space = 1
        } else {
            break
        }
    }
    return function_parameters
}

\ function_parameter
\   : IDENTIFIER ":" value_type
parse_function_parameter :: (self: @Parser) -> @Function_Parameter {
    parameter_name: @Identifier_Token = self.consume(self.required_identifier)
    self.consume_space(0)
    self.consume(self.required_colon)
    self.consume_space(1)
    parameter_type: @Value_Type = self.parse_value_type()
    return create_function_parameter(parameter_name, parameter_type)
}

\ block
\   : "{" statements "}"
parse_block :: (self: @Parser) -> @Block_Statement {
    token: @Token = self.consume(self.required_open_brace)
    self.consume_end_of_line()
    self.current_alignment = self.current_alignment + 1
    statements: @List = self.parse_statements()
    self.current_alignment = self.current_alignment - 1
    self.consume_space(self.current_alignment * 4)
    self.consume(self.required_close_brace)
    return create_block_statement(token, statements)
}

\ if
\   : "if" "(" expression ")" block ( "else" block )?
parse_if :: (self: @Parser) -> @Statement {
    token: @Token = self.consume(self.required_if)
    self.consume_space(1)
    self.consume(self.required_open_paren)
    self.consume_space(0)
    condition: @Expression = self.parse_expression()
    self.consume_space(0)
    self.consume(self.required_close_paren)
    self.consume_space(1)
    true_block: @Block_Statement = self.parse_block()
    false_block: @Block_Statement = null
    if (self.matches(self.optional_space, self.required_else)) {
        self.consume_space(1)
        self.consume(self.required_else)
        self.consume_space(1)
        false_block = self.parse_block()
    }
    return create_if_statement(token.location, condition, true_block, false_block)
}

\ loop
\   : "loop" block
parse_loop :: (self: @Parser) -> @Statement {
    token: @Token = self.consume(self.required_loop)
    self.consume_space(1)
    loop_block: @Block_Statement = self.parse_block()
    return create_loop_statement(token.location, loop_block)
}

\ while
\   : "while" "(" expression ")" block
parse_while :: (self: @Parser) -> @Statement {
    token: @Token = self.consume(self.required_while)
    self.consume_space(1)
    self.consume(self.required_open_paren)
    self.consume_space(0)
    condition: @Expression = self.parse_expression()
    self.consume_space(0)
    self.consume(self.required_close_paren)
    self.consume_space(1)
    loop_block: @Block_Statement = self.parse_block()
    return create_while_statement(token.location, condition, loop_block)
}

\ value_type
\   : "@" value_type
\   | IDENTIFIER
\   | "[" value_type ( ";" INTEGER )? "]"
\   | "(" comma_separated_members? ")" "->" value_type
parse_value_type :: (self: @Parser) -> @Value_Type {
    if (self.matches(self.required_at)) {
        token: @Token = self.consume(self.required_at)
        self.consume_space(0)
        value_type: @Value_Type = self.parse_value_type()
        return create_pointer_type(token.location, value_type)
    }
    return create_named_type(self.consume(self.required_identifier) as @Identifier_Token)
}

parse_expression :: (self: @Parser) -> @Expression {
    return self.parse_logic_or_expression()
}

\ logic_or_expression
\   : logic_and_expression ( "||" logic_or_expression )?
parse_logic_or_expression :: (self: @Parser) -> @Expression {
    expression: @Expression = self.parse_logic_and_expression()
    if (self.matches(self.optional_space, self.required_vertical_bar, self.required_vertical_bar)) {
        self.consume_space(1)
        self.consume(self.required_vertical_bar, self.required_vertical_bar)
        self.consume_space(1)
        return new Logic_Or_Expression.init(expression, self.parse_logic_or_expression())
    }
    return expression
}

\ parse_logic_and_expression
\   : parse_equality_expression ( "&&" parse_logic_and_expression )?
parse_logic_and_expression :: (self: @Parser) -> @Expression {
    expression: @Expression = self.parse_equality_expression()
    if (self.matches(self.optional_space, self.required_ampersand, self.required_ampersand)) {
        self.consume_space(1)
        self.consume(self.required_ampersand, self.required_ampersand)
        self.consume_space(1)
        return new Logic_And_Expression.init(expression, self.parse_logic_and_expression())
    }
    return expression
}

\ equality_expression
\   : is_expression ( ( "==" | "!=" ) equality_expression )?
parse_equality_expression :: (self: @Parser) -> @Expression {
    expression: @Expression = self.parse_is_expression()
    if (self.matches(self.optional_space, self.required_equals, self.required_equals) || self.matches(self.optional_space, self.required_exclamation_mark, self.required_equals)) {
        self.consume_space(1)
        binary_expression: @Binary_Expression
        if (self.matches(self.required_equals)) {
            self.consume(self.required_equals)
            binary_expression = new Equals_Expression
        } else {
            self.consume(self.required_exclamation_mark)
            binary_expression = new Not_Equals_Expression
        }
        self.consume(self.required_equals)
        self.consume_space(1)
        return binary_expression.init(expression, self.parse_equality_expression())
    }
    return expression
}

\ is_expression
\   : comparison_expression ( "is" value_type )?
parse_is_expression :: (self: @Parser) -> @Expression {
    expression: @Expression = self.parse_comparison_expression()
    if (self.matches(self.optional_space, self.required_is)) {
        self.consume_space(1)
        self.consume(self.required_is)
        self.consume_space(1)
        return create_is_expression(expression, self.parse_value_type())
    }
    return expression
}

\ parse_comparison_expression
\   : parse_addition_expression ( ( "<" | "<=" | ">" | ">=" ) parse_comparison_expression )?
parse_comparison_expression :: (self: @Parser) -> @Expression {
    expression: @Expression = self.parse_addition_expression()
    if (self.matches(self.optional_space, self.required_less_than) || self.matches(self.optional_space, self.required_greater_than)) {
        self.consume_space(1)
        binary_expression: @Binary_Expression
        if (self.matches(self.required_less_than)) {
            self.consume(self.required_less_than)
            if (self.matches(self.required_equals)) {
                self.consume(self.required_equals)
                binary_expression = new Less_Than_Or_Equals_Expression
            } else {
                binary_expression = new Less_Than_Expression
            }
        } else {
            self.consume(self.required_greater_than)
            if (self.matches(self.required_equals)) {
                self.consume(self.required_equals)
                binary_expression = new Greater_Than_Or_Equals_Expression
            } else {
                binary_expression = new Greater_Than_Expression
            }
        }
        self.consume_space(1)
        return binary_expression.init(expression, self.parse_comparison_expression())
    }
    return expression
}

\ parse_addition_expression
\   : parse_multiplication_expression ( ( "+" | "-" ) parse_addition_expression )?
parse_addition_expression :: (self: @Parser) -> @Expression {
    expression: @Expression = self.parse_multiplication_expression()
    if (self.matches(self.optional_space, self.required_plus) || self.matches(self.optional_space, self.required_hyphen)) {
        self.consume_space(1)
        binary_expression: @Binary_Expression
        if (self.matches(self.required_plus)) {
            self.consume(self.required_plus)
            binary_expression = new Add_Expression
        } else {
            self.consume(self.required_hyphen)
            binary_expression = new Substract_Expression
        }
        self.consume_space(1)
        return binary_expression.init(expression, self.parse_addition_expression())
    }
    return expression
}

\ parse_multiplication_expression
\   : parse_unary_expression ( ( "*" | "/" | "//" ) parse_multiplication_expression )?
parse_multiplication_expression :: (self: @Parser) -> @Expression {
    expression: @Expression = self.parse_unary_expression()
    if (self.matches(self.optional_space, self.required_asterisk) || self.matches(self.optional_space, self.required_slash)) {
        self.consume_space(1)
        binary_expression: @Binary_Expression
        if (self.matches(self.required_slash)) {
            self.consume(self.required_slash)
            if (self.matches(self.required_slash)) {
                self.consume(self.required_slash)
                binary_expression = new Modulo_Expression
            } else {
                binary_expression = new Divide_Expression
            }
        } else {
            self.consume(self.required_asterisk)
            binary_expression = new Multiply_Expression
        }
        self.consume_space(1)
        return binary_expression.init(expression, self.parse_multiplication_expression())
    }
    return expression
}

parse_unary_expression :: (self: @Parser) -> @Expression {
    return self.parse_cast_expression()
}

\ cast_expression
\   : access_expression ( "as" value_type )?
parse_cast_expression :: (self: @Parser) -> @Expression {
    expression: @Expression = self.parse_access_expression()
    if (self.matches(self.optional_space, self.required_as)) {
        self.consume_space(1)
        self.consume(self.required_as)
        self.consume_space(1)
        value_type: @Value_Type = self.parse_value_type()
        return create_cast_expression(expression, value_type)
    }
    return expression
}

\ access_expression
\   : primary_expression ( "." IDENTIFIER | "(" call_arguments? ")" | "[" expression "]" )*
parse_access_expression :: (self: @Parser) -> @Expression {
    expression: @Expression = self.parse_primary_expression()
    loop {
        old_expression: @Expression = expression
        if (self.matches(self.optional_space, self.required_dot)) {
            self.consume_space(0)
            self.consume(self.required_dot)
            self.consume_space(0)
            expression = create_member_access_expression(expression, self.consume(self.required_identifier) as @Identifier_Token)
        }
        if (self.matches(self.optional_space, self.required_open_paren)) {
            self.consume_space(0)
            self.consume(self.required_open_paren)
            self.consume_space(0)
            call_arguments: @List = create_list()
            if (self.matches(self.optional_space, self.required_close_paren) == false) {
                self.parse_call_arguments(call_arguments)
            }
            self.consume_space(0)
            self.consume(self.required_close_paren)
            expression = create_call_expression(expression, call_arguments)
        }
        if (self.matches(self.optional_space, self.required_open_bracket)) {
            self.consume_space(0)
            self.consume(self.required_open_bracket)
            self.consume_space(0)
            index_expression: @Expression = self.parse_expression()
            self.consume_space(0)
            self.consume(self.required_close_bracket)
            expression = create_array_access_expression(expression, index_expression)
        }
        if (expression == old_expression) {
            break
        }
    }
    return expression
}

\ call_arguments
\   : expression ( "," expression )*
parse_call_arguments :: (self: @Parser, call_arguments: @List) -> Nothing {
    call_arguments.append(self.parse_expression())
    while (self.matches(self.optional_space, self.required_comma)) {
        self.consume_space(0)
        self.consume(self.required_comma)
        self.consume_space(1)
        call_arguments.append(self.parse_expression())
    }
}

\ primary_expression
\   : IDENTIFIER
\   | INTEGER
\   | STRING
\   | CHARACTER
\   | "null"
\   | "false"
\   | "true"
\   | "(" expression ")"
\   | "new" value_type
parse_primary_expression :: (self: @Parser) -> @Expression {
    if (self.matches(self.required_identifier)) {
        return create_variable_expression(self.consume(self.required_identifier) as @Identifier_Token)
    }
    if (self.matches(self.required_literal)) {
        return create_literal_expression(self.consume(self.required_literal) as @Literal_Token)
    }
    if (self.matches(self.required_open_paren)) {
        self.consume(self.required_open_paren)
        self.consume_space(0)
        expression: @Expression = self.parse_expression()
        self.consume_space(0)
        self.consume(self.required_close_paren)
        return expression
    }
    if (self.matches(self.required_new)) {
        token: @Token = self.consume(self.required_new)
        self.consume_space(1)
        value_type: @Value_Type = self.parse_value_type()
        return create_new_expression(token.location, value_type)
    }
    return null
}

abort :: (self: @Parser, unexpected_token: @Token) -> Nothing {
    stderr.write(unexpected_token.location).write(": Unexpected token: ").write(unexpected_token).end_line()
    abort()
}

consume_end_of_line :: (self: @Parser) -> Nothing {
    if (self.matches(self.optional_space, self.required_comment)) {
        self.consume_space(1)
        self.consume(self.required_comment)
    } else {
        self.consume_space(0)
    }
    self.consume(self.required_end_of_line)
}

consume_empty_line :: (self: @Parser) -> Boolean {
    if (self.matches(self.optional_space, self.optional_comment, self.required_end_of_line)) {
        if (self.matches(self.optional_space, self.required_comment)) {
            self.consume_space(self.current_alignment * 4)
            self.consume(self.required_comment)
        } else {
            self.consume_space(0)
        }
        self.consume(self.required_end_of_line)
        return true
    }
    return false
}

consume_space :: (self: @Parser, expected_space_count: Int) -> Nothing {
    space_count: Int
    token: @Token = self.tokens.current()
    if (token is Space_Token) {
        self.tokens.next()
        space: @Space_Token = token
        space_count = space.count
    } else {
        space_count = 0
    }
    if (space_count != expected_space_count) {
        stderr.write(token.location).write(": Consumed ").write(space_count).write(" spaces where ").write(expected_space_count).write(" are expected").end_line()
    }
}

consume :: (self: @Parser, first_matcher: @Matcher) -> @Token {
    return self.consume(first_matcher, null)
}

consume :: (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher) -> @Token {
    return self.consume(first_matcher, second_matcher, null)
}

consume :: (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher, third_matcher: @Matcher) -> @Token {
    token: @Token = self.tokens.current()
    first_token: @Token = token
    if (first_matcher.accepts(token)) {
        token = self.tokens.next() as @Token
    } else {
        if (first_matcher.is_required) {
            self.abort(token)
        }
    }
    if (second_matcher != null) {
        if (second_matcher.accepts(token)) {
            token = self.tokens.next() as @Token
        } else {
            if (second_matcher.is_required) {
                self.abort(token)
            }
        }
    }
    if (third_matcher != null) {
        if (third_matcher.accepts(token)) {
            token = self.tokens.next() as @Token
        } else {
            if (third_matcher.is_required) {
                self.abort(token)
            }
        }
    }
    return first_token
}

matches_end_of_line :: (self: @Parser) -> Boolean {
    return self.matches(self.optional_space, self.optional_comment, self.required_end_of_line)
}

matches :: (self: @Parser, first_matcher: @Matcher) -> Boolean {
    return self.matches(first_matcher, null)
}

matches :: (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher) -> Boolean {
    return self.matches(first_matcher, second_matcher, null)
}

matches :: (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher, third_matcher: @Matcher) -> Boolean {
    self.tokens.save_state()
    token: @Token = self.tokens.current()
    if (first_matcher.accepts(token)) {
        token = self.tokens.next() as @Token
    } else {
        if (first_matcher.is_required) {
            self.tokens.restore_state()
            return false
        }
    }
    if (second_matcher != null) {
        if (second_matcher.accepts(token)) {
            token = self.tokens.next() as @Token
        } else {
            if (second_matcher.is_required) {
                self.tokens.restore_state()
                return false
            }
        }
    }
    if (third_matcher != null) {
        if (third_matcher.accepts(token)) {
            token = self.tokens.next() as @Token
        } else {
            if (third_matcher.is_required) {
                self.tokens.restore_state()
                return false
            }
        }
    }
    self.tokens.restore_state()
    return true
}

Matcher :: struct : Object {
    is_required: Boolean
}

Comment_Matcher :: struct : Matcher {
}

create_comment_matcher :: (required: Boolean) -> @Comment_Matcher {
    matcher: @Comment_Matcher = new Comment_Matcher
    matcher.is_required = required
    return matcher
}

End_Of_File_Matcher :: struct : Matcher {
}

create_end_of_file_matcher :: (required: Boolean) -> @End_Of_File_Matcher {
    matcher: @End_Of_File_Matcher = new End_Of_File_Matcher
    matcher.is_required = required
    return matcher
}

End_Of_Line_Matcher :: struct : Matcher {
}

create_end_of_line_matcher :: (required: Boolean) -> @End_Of_Line_Matcher {
    matcher: @End_Of_Line_Matcher = new End_Of_Line_Matcher
    matcher.is_required = required
    return matcher
}

Identifier_Matcher :: struct : Matcher {
}

create_identifier_matcher :: (required: Boolean) -> @Identifier_Matcher {
    matcher: @Identifier_Matcher = new Identifier_Matcher
    matcher.is_required = required
    return matcher
}

Keyword_Matcher :: struct : Matcher {
    lexeme: @String
}

create_keyword_matcher :: (required: Boolean, lexeme: @String) -> @Keyword_Matcher {
    matcher: @Keyword_Matcher = new Keyword_Matcher
    matcher.is_required = required
    matcher.lexeme = lexeme
    return matcher
}

Literal_Matcher :: struct : Matcher {
}

create_literal_matcher :: (required: Boolean) -> @Literal_Matcher {
    matcher: @Literal_Matcher = new Literal_Matcher
    matcher.is_required = required
    return matcher
}

Other_Matcher :: struct : Matcher {
    lexeme: @String
}

create_other_matcher :: (required: Boolean, lexeme: @String) -> @Other_Matcher {
    matcher: @Other_Matcher = new Other_Matcher
    matcher.is_required = required
    matcher.lexeme = lexeme
    return matcher
}

Space_Matcher :: struct : Matcher {
}

create_space_matcher :: (required: Boolean) -> @Space_Matcher {
    matcher: @Space_Matcher = new Space_Matcher
    matcher.is_required = required
    return matcher
}

accepts :: (self: @Matcher, token: @Token) -> Boolean {
    if (self is Other_Matcher) {
        self: @Other_Matcher = self
        if (token is Other_Token) {
            return token.lexeme.equals(self.lexeme)
        }
        return false
    }
    if (self is Space_Matcher) {
        return token is Space_Token
    }
    if (self is Identifier_Matcher) {
        return token is Identifier_Token
    }
    if (self is Keyword_Matcher) {
        self: @Keyword_Matcher = self
        if (token is Keyword_Token) {
            return token.lexeme.equals(self.lexeme)
        }
        return false
    }
    if (self is Literal_Matcher) {
        return token is Integer_Token || token is String_Token || token is Character_Token || token is Boolean_Token || token is Null_Token
    }
    if (self is End_Of_Line_Matcher) {
        return token is End_Of_Line_Token
    }
    if (self is Comment_Matcher) {
        return token is Comment_Token
    }
    if (self is End_Of_File_Matcher) {
        return token is End_Of_File_Token
    }
    stderr.write("Unsupported token matcher").end_line()
    abort()
}

\ -------------------------------------------------------------------------------------------------
\       AST
\ -------------------------------------------------------------------------------------------------

Compilation_Unit :: struct {
    source: @Source
    statements: @List
}

create_compilation_unit :: (source: @Source, statements: @List) -> @Compilation_Unit {
    compilation_unit: @Compilation_Unit = new Compilation_Unit
    compilation_unit.source = source
    compilation_unit.statements = statements
    return compilation_unit
}

Statement :: struct : Object {
    location: @Source_Location
}

Function_Statement :: struct : Statement {
    name: @Identifier_Token
    parameters: @List
    return_type: @Value_Type
    body: @Block_Statement
}

create_function_statement :: (name: @Identifier_Token, parameters: @List, return_type: @Value_Type, body: @Block_Statement) -> @Function_Statement {
    function_statement: @Function_Statement = new Function_Statement
    function_statement.location = name.location
    function_statement.name = name
    function_statement.parameters = parameters
    function_statement.return_type = return_type
    function_statement.body = body
    return function_statement
}

Function_Parameter :: struct {
    location: @Source_Location
    name: @Identifier_Token
    value_type: @Value_Type
}

create_function_parameter :: (name: @Identifier_Token, value_type: @Value_Type) -> @Function_Parameter {
    function_parameter: @Function_Parameter = new Function_Parameter
    function_parameter.location = name.location
    function_parameter.name = name
    function_parameter.value_type = value_type
    return function_parameter
}

Block_Statement :: struct : Statement {
    statements: @List
}

create_block_statement :: (open_brace: @Token, statements: @List) -> @Block_Statement {
    block_statement: @Block_Statement = new Block_Statement
    block_statement.location = open_brace.location
    block_statement.statements = statements
    return block_statement
}

Expression_Statement :: struct : Statement {
    expression: @Expression
}

create_expression_statement :: (expression: @Expression) -> @Expression_Statement {
    statement: @Expression_Statement = new Expression_Statement
    statement.location = expression.location
    statement.expression = expression
    return statement
}

If_Statement :: struct : Statement {
    condition: @Expression
    true_block: @Block_Statement
    false_block: @Block_Statement
}

create_if_statement :: (location: @Source_Location, condition: @Expression, true_block: @Block_Statement, false_block: @Block_Statement) -> @If_Statement {
    statement: @If_Statement = new If_Statement
    statement.location = location
    statement.condition = condition
    statement.true_block = true_block
    statement.false_block = false_block
    return statement
}

Loop_Statement :: struct : Statement {
    block: @Block_Statement
}

create_loop_statement :: (location: @Source_Location, block: @Block_Statement) -> @Loop_Statement {
    statement: @Loop_Statement = new Loop_Statement
    statement.location = location
    statement.block = block
    return statement
}

While_Statement :: struct : Statement {
    condition: @Expression
    block: @Block_Statement
}

create_while_statement :: (location: @Source_Location, condition: @Expression, block: @Block_Statement) -> @While_Statement {
    statement: @While_Statement = new While_Statement
    statement.location = location
    statement.condition = condition
    statement.block = block
    return statement
}

Break_Statement :: struct : Statement {
}

create_break_statement :: (location: @Source_Location) -> @Break_Statement {
    statement: @Break_Statement = new Break_Statement
    statement.location = location
    return statement
}

Return_Statement :: struct : Statement {
    value_expression: @Expression
}

create_return_statement :: (location: @Source_Location, value_expression: @Expression) -> @Return_Statement {
    statement: @Return_Statement = new Return_Statement
    statement.location = location
    statement.value_expression = value_expression
    return statement
}

Variable_Statement :: struct : Statement {
    name: @Identifier_Token
    value_type: @Value_Type
    value_expression: @Expression
    is_external: Boolean
}

create_variable_statement :: (name: @Identifier_Token, value_type: @Value_Type, value_expression: @Expression, is_external: Boolean) -> @Variable_Statement {
    statement: @Variable_Statement = new Variable_Statement
    statement.location = name.location
    statement.name = name
    statement.value_type = value_type
    statement.value_expression = value_expression
    statement.is_external = is_external
    return statement
}

Struct_Statement :: struct : Statement {
    name: @Identifier_Token
    base_type: @Value_Type
    members: @List
}

create_struct_statement :: (name: @Identifier_Token, base_type: @Value_Type, members: @List) -> @Struct_Statement {
    statement: @Struct_Statement = new Struct_Statement
    statement.location = name.location
    statement.name = name
    statement.base_type = base_type
    statement.members = members
    return statement
}

Struct_Member :: struct {
    location: @Source_Location
    name: @Identifier_Token
    value_type: @Value_Type
}

create_struct_member :: (name: @Identifier_Token, value_type: @Value_Type) -> @Struct_Member {
    struct_member: @Struct_Member = new Struct_Member
    struct_member.location = name.location
    struct_member.name = name
    struct_member.value_type = value_type
    return struct_member
}

Assignment_Statement :: struct : Statement {
    destination: @Expression
    operator: @Other_Token
    value_expression: @Expression
}

create_assignment_statement :: (destination: @Expression, operator: @Other_Token, value_expression: @Expression) -> @Assignment_Statement {
    statement: @Assignment_Statement = new Assignment_Statement
    statement.location = destination.location
    statement.destination = destination
    statement.operator = operator
    statement.value_expression = value_expression
    return statement
}

Value_Type :: struct : Object {
    location: @Source_Location
}

Named_Type :: struct : Value_Type {
    name: @Identifier_Token
}

create_named_type :: (name: @Identifier_Token) -> @Value_Type {
    named_type: @Named_Type = new Named_Type
    named_type.location = name.location
    named_type.name = name
    return named_type
}

Pointer_Type :: struct : Value_Type {
    value_type: @Value_Type
}

create_pointer_type :: (location: @Source_Location, value_type: @Value_Type) -> @Pointer_Type {
    pointer_type: @Pointer_Type = new Pointer_Type
    pointer_type.location = location
    pointer_type.value_type = value_type
    return pointer_type
}

Expression :: struct : Object {
    location: @Source_Location
}

Literal_Expression :: struct : Expression {
    literal: @Literal_Token
}

create_literal_expression :: (literal: @Literal_Token) -> @Literal_Expression {
    expression: @Literal_Expression = new Literal_Expression
    expression.location = literal.location
    expression.literal = literal
    return expression
}

Variable_Expression :: struct : Expression {
    name: @Identifier_Token
}

create_variable_expression :: (name: @Identifier_Token) -> @Variable_Expression {
    expression: @Variable_Expression = new Variable_Expression
    expression.location = name.location
    expression.name = name
    return expression
}

Binary_Expression :: struct : Expression {
    left_expression: @Expression
    right_expression: @Expression
}

init :: (self: @Binary_Expression, left_expression: @Expression, right_expression: @Expression) -> @Binary_Expression {
    self.location = left_expression.location
    self.left_expression = left_expression
    self.right_expression = right_expression
    return self
}

Add_Expression :: struct : Binary_Expression {
}

Divide_Expression :: struct : Binary_Expression {
}

Equals_Expression :: struct : Binary_Expression {
}

Greater_Than_Expression :: struct : Binary_Expression {
}

Greater_Than_Or_Equals_Expression :: struct : Binary_Expression {
}

Less_Than_Expression :: struct : Binary_Expression {
}

Less_Than_Or_Equals_Expression :: struct : Binary_Expression {
}

Logic_And_Expression :: struct : Binary_Expression {
}

Logic_Or_Expression :: struct : Binary_Expression {
}

Modulo_Expression :: struct : Binary_Expression {
}

Multiply_Expression :: struct : Binary_Expression {
}

Not_Equals_Expression :: struct : Binary_Expression {
}

Substract_Expression :: struct : Binary_Expression {
}

Cast_Expression :: struct : Expression {
    value_expression: @Expression
    value_type: @Value_Type
}

create_cast_expression :: (value_expression: @Expression, value_type: @Value_Type) -> @Cast_Expression {
    expression: @Cast_Expression = new Cast_Expression
    expression.location = value_expression.location
    expression.value_expression = value_expression
    expression.value_type = value_type
    return expression
}

Is_Expression :: struct : Expression {
    value_expression: @Expression
    value_type: @Value_Type
}

create_is_expression :: (value_expression: @Expression, value_type: @Value_Type) -> @Is_Expression {
    expression: @Is_Expression = new Is_Expression
    expression.location = value_expression.location
    expression.value_expression = value_expression
    expression.value_type = value_type
    return expression
}

New_Expression :: struct : Expression {
    value_type: @Value_Type
}

create_new_expression :: (location: @Source_Location, value_type: @Value_Type) -> @New_Expression {
    expression: @New_Expression = new New_Expression
    expression.location = location
    expression.value_type = value_type
    return expression
}

Call_Expression :: struct : Expression {
    callee: @Expression
    arguments: @List
}

create_call_expression :: (callee: @Expression, arguments: @List) -> @Call_Expression {
    expression: @Call_Expression = new Call_Expression
    expression.location = callee.location
    expression.callee = callee
    expression.arguments = arguments
    return expression
}

Access_Expression :: struct : Expression {
}

Member_Access_Expression :: struct : Access_Expression {
    object: @Expression
    member_name: @Identifier_Token
}

create_member_access_expression :: (object: @Expression, member_name: @Identifier_Token) -> @Member_Access_Expression {
    expression: @Member_Access_Expression = new Member_Access_Expression
    expression.location = object.location
    expression.object = object
    expression.member_name = member_name
    return expression
}

Array_Access_Expression :: struct : Access_Expression {
    object: @Expression
    index_expression: @Expression
}

create_array_access_expression :: (object: @Expression, index_expression: @Expression) -> @Array_Access_Expression {
    expression: @Array_Access_Expression = new Array_Access_Expression
    expression.location = object.location
    expression.object = object
    expression.index_expression = index_expression
    return expression
}

write :: (file: @FILE, compilation_unit: @Compilation_Unit) -> @FILE {
    statements: @List_Iterator = compilation_unit.statements.create_iterator()
    while (statements.has_next()) {
        statement: @Statement = statements.next()
        file.write_source_line(statement.location, 0).write(statement, 0).end_line()
    }
    return file
}

write :: (file: @FILE, statement: @Statement, alignment: Int) -> @FILE {
    if (statement is Assignment_Statement) {
        statement: @Assignment_Statement = statement
        return file.write(statement.destination).write(' ').write(statement.operator).write(' ').write(statement.value_expression)
    }

    if (statement is Block_Statement) {
        file.write('{').end_line()
        block_statements: @List_Iterator = (statement as @Block_Statement).statements.create_iterator()
        while (block_statements.has_next()) {
            block_statement: @Statement = block_statements.next()
            file.write_source_line(block_statement.location, alignment + 1).write(block_statement, alignment + 1).end_line()
        }
        return file.write_source_line(statement.location, alignment).write('}')
    }

    if (statement is Break_Statement) {
        return file.write("break")
    }

    if (statement is Expression_Statement) {
        return file.write((statement as @Expression_Statement).expression)
    }

    if (statement is Function_Statement) {
        statement: @Function_Statement = statement
        file.write(statement.name).write(" :: (")
        function_parameters: @List_Iterator = statement.parameters.create_iterator()
        if (function_parameters.has_next()) {
            loop {
                file.write(function_parameters.next() as @Function_Parameter)
                if (function_parameters.has_next()) {
                    file.write(", ")
                } else {
                    break
                }
            }
        }
        file.write(") -> ").write(statement.return_type)
        if (statement.body == null) {
            return file
        }
        return file.write(" ").write(statement.body, alignment)
    }

    if (statement is If_Statement) {
        statement: @If_Statement = statement
        file.write("if (").write(statement.condition).write(") ").write(statement.true_block, alignment)
        if (statement.false_block != null) {
            file.write(" else ").write(statement.false_block, alignment)
        }
        return file
    }

    if (statement is Loop_Statement) {
        statement: @Loop_Statement = statement
        return file.write("loop ").write(statement.block, alignment)
    }

    if (statement is Return_Statement) {
        statement: @Return_Statement = statement
        file.write("return")
        if (statement.value_expression != null) {
            file.write(" ").write(statement.value_expression)
        }
        return file
    }

    if (statement is Struct_Statement) {
        statement: @Struct_Statement = statement
        file.write(statement.name).write(" :: struct")
        if (statement.base_type != null) {
            file.write(" : ").write(statement.base_type)
        }
        if (statement.members == null) {
            return file
        }
        file.write(" {").end_line()
        members: @List_Iterator = statement.members.create_iterator()
        while (members.has_next()) {
            member: @Struct_Member = members.next()
            file.write_source_line(member.location, alignment + 1).write(member.name).write(": ").write(member.value_type).end_line()
        }
        return file.write_source_line(statement.location, alignment).write('}')
    }

    if (statement is Variable_Statement) {
        statement: @Variable_Statement = statement
        file.write((statement as @Variable_Statement).name)
        if (statement.value_type != null) {
            file.write(": ").write(statement.value_type)
            if (statement.value_expression != null) {
                file.write(" = ").write(statement.value_expression)
            }
            if (statement.is_external) {
                file.write(" = external")
            }
        } else {
            file.write(" := ").write(statement.value_expression)
        }
        return file
    }

    if (statement is While_Statement) {
        statement: @While_Statement = statement
        return file.write("while (").write(statement.condition).write(") ").write(statement.block, alignment)
    }

    file.fflush()
    stderr.end_line().end_line().write("Unsupported Statement type: ").write(statement.object_type.id).end_line()
    abort()
}

write_source_line :: (file: @FILE, location: @Source_Location, alignment: Int) -> @FILE {
    file.write(location.source.file_name).write(':')
    line: Int = location.line
    if (line < 1000) {
        file.write('0')
    }
    if (line < 100) {
        file.write('0')
    }
    if (line < 10) {
        file.write('0')
    }
    file.write(line).write(": ")

    space_count: Int = alignment * 2
    while (space_count > 0) {
        file.write(' ')
        space_count = space_count - 1
    }

    return file
}

write :: (file: @FILE, parameter: @Function_Parameter) -> @FILE {
    return file.write(parameter.name).write(": ").write(parameter.value_type)
}

write :: (file: @FILE, value_type: @Value_Type) -> @FILE {
    if (value_type is Named_Type) {
        return file.write((value_type as @Named_Type).name)
    }

    if (value_type is Pointer_Type) {
        return file.write('@').write((value_type as @Pointer_Type).value_type)
    }

    file.fflush()
    stderr.end_line().end_line().write("Unsupported Value_Type type: ").write(value_type.object_type.id).end_line()
    abort()
}

write :: (file: @FILE, expression: @Expression) -> @FILE {
    if (expression is Array_Access_Expression) {
        return file.write((expression as @Array_Access_Expression).object).write('[').write((expression as @Array_Access_Expression).index_expression).write(']')
    }

    if (expression is Binary_Expression) {
        file.write((expression as @Binary_Expression).left_expression)
        if (expression is Add_Expression) {
            return file.write(" + ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression is Divide_Expression) {
            return file.write(" / ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression is Equals_Expression) {
            return file.write(" == ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression is Greater_Than_Expression) {
            return file.write(" > ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression is Greater_Than_Or_Equals_Expression) {
            return file.write(" >= ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression is Less_Than_Expression) {
            return file.write(" < ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression is Less_Than_Or_Equals_Expression) {
            return file.write(" <= ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression is Logic_And_Expression) {
            return file.write(" && ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression is Logic_Or_Expression) {
            return file.write(" || ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression is Modulo_Expression) {
            return file.write(" // ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression is Multiply_Expression) {
            return file.write(" * ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression is Not_Equals_Expression) {
            return file.write(" != ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression is Substract_Expression) {
            return file.write(" - ").write((expression as @Binary_Expression).right_expression)
        }
    }

    if (expression is Call_Expression) {
        file.write((expression as @Call_Expression).callee).write('(')
        call_arguments: @List_Iterator = (expression as @Call_Expression).arguments.create_iterator()
        if (call_arguments.has_next()) {
            loop {
                file.write(call_arguments.next() as @Expression)
                if (call_arguments.has_next()) {
                    file.write(", ")
                } else {
                    break
                }
            }
        }
        return file.write(')')
    }

    if (expression is Cast_Expression) {
        return file.write((expression as @Cast_Expression).value_expression).write(" as ").write((expression as @Cast_Expression).value_type)
    }

    if (expression is Is_Expression) {
        return file.write((expression as @Is_Expression).value_expression).write(" is ").write((expression as @Is_Expression).value_type)
    }

    if (expression is Literal_Expression) {
        return file.write((expression as @Literal_Expression).literal)
    }

    if (expression is New_Expression) {
        return file.write("new ").write((expression as @New_Expression).value_type)
    }

    if (expression is Member_Access_Expression) {
        return file.write((expression as @Member_Access_Expression).object).write('.').write((expression as @Member_Access_Expression).member_name)
    }

    if (expression is Variable_Expression) {
        return file.write((expression as @Variable_Expression).name)
    }

    file.fflush()
    stderr.end_line().end_line().write(expression.location).write(": Unsupported Expression type: ").write(expression.object_type.id).end_line()
    abort()
}

\ -------------------------------------------------------------------------------------------------
\       Scanner
\ -------------------------------------------------------------------------------------------------

scan :: (file_name: @String) -> @List {
    scanner: @Scanner = create_scanner(create_source(file_name))
    tokens: @List = create_list()

    loop {
        token: @Token = scanner.next_token()
        tokens.append(token)
        if (token is End_Of_File_Token) {
            break
        }
    }

    \ tokens: @List_Iterator = tokens.create_iterator()
    \ while (tokens.has_next()) {
    \     token: @Token = tokens.next() as @Token
    \     if (token is End_Of_Line_Token) {
    \         stdout.end_line()
    \     } else {
    \         stdout.write(token)
    \     }
    \ }

    return tokens
}

Scanner :: struct {
    source: @Source
    current_char_index: Int
    current_line: Int
    current_column: Int
}

create_scanner :: (source: @Source) -> @Scanner {
    scanner: @Scanner = new Scanner
    scanner.source = source
    scanner.current_char_index = 0
    scanner.current_line = 1
    scanner.current_column = 1
    return scanner
}

peek_char :: (self: @Scanner) -> Int8 {
    return self.source.content[self.current_char_index]
}

next_char :: (self: @Scanner) -> Int8 {
    next_char: Int8 = self.source.content[self.current_char_index]
    if (next_char != '\0') {
        self.current_char_index = self.current_char_index + 1
        if (next_char == '\n') {
            self.current_line = self.current_line + 1
            self.current_column = 1
        } else {
            self.current_column = self.current_column + 1
        }
    }
    return next_char
}

next_token :: (self: @Scanner) -> @Token {
    token_lexeme: @String = new String
    token_lexeme.init()

    token_location: @Source_Location = new Source_Location
    token_location.source = self.source
    token_location.line = self.current_line
    token_location.column = self.current_column

    next_char: Int8 = self.peek_char()
    if (next_char.is_identifier_start()) {
        return self.scan_identifier_token(token_lexeme, token_location)
    }
    if (next_char.is_digit()) {
        return self.scan_integer_token(token_lexeme, token_location)
    }
    if (next_char == '\'') {
        return self.scan_character_token(token_lexeme, token_location)
    }
    if (next_char == '"') {
        return self.scan_string_token(token_lexeme, token_location)
    }
    if (next_char == '\\') {
        return self.scan_comment_token(token_lexeme, token_location)
    }
    if (next_char.is_space()) {
        return self.scan_space_token(token_lexeme, token_location)
    }
    if (next_char == '\n') {
        self.next_char()
        return create_end_of_line_token(token_lexeme, token_location)
    }
    if (next_char == '\0') {
        self.next_char()
        return create_end_of_file_token(token_lexeme, token_location)
    }
    token_lexeme.append(self.next_char())
    return create_other_token(token_lexeme, token_location)
}

is_digit :: (char: Int8) -> Boolean {
    return char as Int >= '0' as Int && char as Int <= '9' as Int
}

is_identifier_start :: (char: Int8) -> Boolean {
    return char.is_letter() || char == '_'
}

is_identifier_body :: (char: Int8) -> Boolean {
    if (char.is_identifier_start()) {
        return true
    }
    return char.is_digit()
}

is_letter :: (char: Int8) -> Boolean {
    return (char as Int >= 'a' as Int && char as Int <= 'z' as Int) || (char as Int >= 'A' as Int && char as Int <= 'Z' as Int)
}

is_space :: (char: Int8) -> Boolean {
    return char == ' '
}

scan_character_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    if (self.peek_char() == '\'') {
        token_lexeme.append(self.next_char())
        char: Int8 = self.next_char()
        token_lexeme.append(char)
        if (char == '\'') {
            return create_error_token(token_lexeme, token_location)
        }
        if (char == '\\') {
            char = self.next_char()
            token_lexeme.append(char)
            if (char.is_escape() == false) {
                return create_error_token(token_lexeme, token_location)
            }
            char = self.next_char()
            token_lexeme.append(char)
            if (char != '\'') {
                return create_error_token(token_lexeme, token_location)
            }
        } else {
            if (char == '\0' || char == '\n' || char == '\t') {
                return create_error_token(token_lexeme, token_location)
            }
            char = self.next_char()
            token_lexeme.append(char)
            if (char != '\'') {
                return create_error_token(token_lexeme, token_location)
            }
        }
    }
    return create_character_token(token_lexeme, token_location)
}

is_escape :: (char: Int8) -> Boolean {
    return char == 'n' || char == 't' || char == '\"' || char == '\'' || char == '\\' || char == '0'
}

scan_comment_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    while (self.peek_char() != '\n') {
        token_lexeme.append(self.next_char())
    }
    return create_comment_token(token_lexeme, token_location)
}

scan_identifier_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    while (self.peek_char().is_identifier_body()) {
        token_lexeme.append(self.next_char())
    }
    if (token_lexeme.equals("as")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("break")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("else")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("external")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("false")) {
        return create_boolean_token(token_lexeme, token_location, false)
    }
    if (token_lexeme.equals("if")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("is")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("loop")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("new")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("null")) {
        return create_null_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("return")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("struct")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("true")) {
        return create_boolean_token(token_lexeme, token_location, true)
    }
    if (token_lexeme.equals("while")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    return create_identifier_token(token_lexeme, token_location)
}

scan_integer_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    value: Int = 0
    while (self.peek_char().is_digit()) {
        char: Int8 = self.next_char()
        value = value * 10 + (char as Int - '0' as Int)
        token_lexeme.append(char)
    }
    return create_integer_token(token_lexeme, token_location, value)
}

scan_space_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    count: Int = 0
    while (self.peek_char() == ' ') {
        char: Int8 = self.next_char()
        count = count + 1
        token_lexeme.append(char)
    }
    return create_space_token(token_lexeme, token_location, count)
}

scan_string_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    if (self.peek_char() == '"') {
        value: @String = new String
        value.init()

        token_lexeme.append(self.next_char())
        loop {
            char: Int8 = self.peek_char()
            if (char == '\0' || char == '\n') {
                return create_error_token(token_lexeme, token_location)
            }
            char = self.next_char()
            token_lexeme.append(char)
            if (char == '"') {
                return create_string_token(token_lexeme, token_location, value)
            }
            if (char == '\\') {
                char = self.peek_char()
                if (char == '\0' || char == '\n') {
                    return create_error_token(token_lexeme, token_location)
                }
                char = self.next_char()
                token_lexeme.append(char)
                if (char.is_escape() == false) {
                    return create_error_token(token_lexeme, token_location)
                }
            }
        }
    }
}

\ -------------------------------------------------------------------------------------------------
\       Token
\ -------------------------------------------------------------------------------------------------

Token :: struct : Object {
    lexeme: @String
    location: @Source_Location
}

init :: (self: @Token, lexeme: @String, location: @Source_Location) -> Nothing {
    self.location = location
    self.lexeme = lexeme
}

write :: (file: @FILE, token: @Token) -> @FILE {
    if (token is Other_Token || token is Keyword_Token) {
        file.write(27 as Int8).write("[2;37m")
    } else {
        if (token is Literal_Token) {
            file.write(27 as Int8).write("[1;33m")
        } else {
            if (token is Comment_Token) {
                file.write(27 as Int8).write("[2;33m")
            }
        }
    }
    file.write(token.lexeme)
    file.write(27 as Int8).write("[0m")
    return file
}

Literal_Token :: struct : Token {
}

Character_Token :: struct : Literal_Token {
}

create_character_token :: (lexeme: @String, location: @Source_Location) -> @Character_Token {
    token: @Character_Token = new Character_Token
    token.init(lexeme, location)
    return token
}

Boolean_Token :: struct : Literal_Token {
    value: Boolean
}

create_boolean_token :: (lexeme: @String, location: @Source_Location, value: Boolean) -> @Boolean_Token {
    token: @Boolean_Token = new Boolean_Token
    token.init(lexeme, location)
    token.value = value
    return token
}

Comment_Token :: struct : Token {
}

create_comment_token :: (lexeme: @String, location: @Source_Location) -> @Comment_Token {
    token: @Comment_Token = new Comment_Token
    token.init(lexeme, location)
    return token
}

End_Of_File_Token :: struct : Token {
}

create_end_of_file_token :: (lexeme: @String, location: @Source_Location) -> @End_Of_File_Token {
    token: @End_Of_File_Token = new End_Of_File_Token
    token.init(lexeme, location)
    return token
}

End_Of_Line_Token :: struct : Token {
}

create_end_of_line_token :: (lexeme: @String, location: @Source_Location) -> @End_Of_Line_Token {
    token: @End_Of_Line_Token = new End_Of_Line_Token
    token.init(lexeme, location)
    return token
}

Error_Token :: struct : Token {
}

create_error_token :: (lexeme: @String, location: @Source_Location) -> @Error_Token {
    token: @Error_Token = new Error_Token
    token.init(lexeme, location)
    return token
}

Identifier_Token :: struct : Token {
}

create_identifier_token :: (lexeme: @String, location: @Source_Location) -> @Identifier_Token {
    token: @Identifier_Token = new Identifier_Token
    token.init(lexeme, location)
    return token
}

Integer_Token :: struct : Literal_Token {
    value: Int
}

create_integer_token :: (lexeme: @String, location: @Source_Location, value: Int) -> @Integer_Token {
    token: @Integer_Token = new Integer_Token
    token.init(lexeme, location)
    token.value = value
    return token
}

Keyword_Token :: struct : Token {
}

create_keyword_token :: (lexeme: @String, location: @Source_Location) -> @Keyword_Token {
    token: @Keyword_Token = new Keyword_Token
    token.init(lexeme, location)
    return token
}

Null_Token :: struct : Literal_Token {
}

create_null_token :: (lexeme: @String, location: @Source_Location) -> @Null_Token {
    token: @Null_Token = new Null_Token
    token.init(lexeme, location)
    return token
}

Other_Token :: struct : Token {
}

create_other_token :: (lexeme: @String, location: @Source_Location) -> @Other_Token {
    token: @Other_Token = new Other_Token
    token.init(lexeme, location)
    return token
}

Space_Token :: struct : Token {
    count: Int
}

create_space_token :: (lexeme: @String, location: @Source_Location, count: Int) -> @Space_Token {
    token: @Space_Token = new Space_Token
    token.init(lexeme, location)
    token.count = count
    return token
}

String_Token :: struct : Literal_Token {
    value: @String
}

create_string_token :: (lexeme: @String, location: @Source_Location, value: @String) -> @String_Token {
    token: @String_Token = new String_Token
    token.init(lexeme, location)
    token.value = value
    return token
}

\ -------------------------------------------------------------------------------------------------
\       Source_Location
\ -------------------------------------------------------------------------------------------------

Source_Location :: struct {
    source: @Source
    line: Int
    column: Int
}

write :: (self: @FILE, location: @Source_Location) -> @FILE {
    return self.write(location.source.file_name).write(':').write(location.line).write(':').write(location.column)
}

\ -------------------------------------------------------------------------------------------------
\       Source
\ -------------------------------------------------------------------------------------------------

Source :: struct {
    file_name: @String
    content: @Int8
}

create_source :: (file_name: @String) -> @Source {
    source: @Source = new Source

    file: @FILE = fopen(file_name.data, "r".data)

    content_size: Int = 1024
    content: @Int8 = malloc(content_size)
    content_length: Int = 0
    loop {
        char: Int32 = fgetc(file)
        if (feof(file) as Int != 0) {
            break
        }
        if (content_length + 1 > content_size - 1) {
            content_size = content_size + 1024
            content = realloc(content, content_size) as @Int8
        }
        content[content_length] = char as Int8
        content_length = content_length + 1
    }

    source.file_name = file_name
    source.content = content

    return source
}

\ -------------------------------------------------------------------------------------------------
\       List
\ -------------------------------------------------------------------------------------------------

List :: struct {
    first_item: @List_Item
    last_item: @List_Item
}

create_list :: () -> @List {
    list: @List = new List
    list.first_item = null
    list.last_item = null
    return list
}

append :: (self: @List, data: @Any) -> Nothing {
    item: @List_Item = new List_Item
    item.data = data
    item.prev_item = self.last_item
    item.next_item = null
    if (self.last_item == null) {
        self.first_item = item
    } else {
        self.last_item.next_item = item
    }
    self.last_item = item
}

prepend :: (self: @List, data: @Any) -> Nothing {
    item: @List_Item = new List_Item
    item.data = data
    item.prev_item = null
    item.next_item = self.first_item
    if (self.first_item == null) {
        self.last_item = item
    } else {
        self.first_item.prev_item = item
    }
    self.first_item = item
}

List_Item :: struct {
    prev_item: @List_Item
    next_item: @List_Item
    data: @Any
}

List_Iterator :: struct {
    current_item: @List_Item
    next_item: @List_Item
    saved_current_item: @List_Item
    saved_next_item: @List_Item
}

create_iterator :: (list: @List) -> @List_Iterator {
    iterator: @List_Iterator = new List_Iterator
    iterator.current_item = null
    iterator.next_item = list.first_item
    return iterator
}

current :: (self: @List_Iterator) -> @Any {
    if (self.current_item != null) {
        return self.current_item.data
    }
    return null
}

has_next :: (self: @List_Iterator) -> Boolean {
    return self.next_item != null
}

next :: (self: @List_Iterator) -> @Any {
    if (self.next_item == null) {
        return null
    }
    self.current_item = self.next_item
    self.next_item = self.next_item.next_item
    return self.current_item.data
}

save_state :: (self: @List_Iterator) -> Nothing {
    self.saved_current_item = self.current_item
    self.saved_next_item = self.next_item
}

restore_state :: (self: @List_Iterator) -> Nothing {
    self.current_item = self.saved_current_item
    self.next_item = self.saved_next_item
}

\ -------------------------------------------------------------------------------------------------
\       Object
\ -------------------------------------------------------------------------------------------------

Object :: struct {
    object_type: @Object_Type
}

\ -------------------------------------------------------------------------------------------------
\       Type
\ -------------------------------------------------------------------------------------------------

Object_Type :: struct {
    id: Int
    base_type: @Object_Type
}

\ -------------------------------------------------------------------------------------------------
\       String
\ -------------------------------------------------------------------------------------------------

String :: struct {
    data: @Int8
    data_size: Int
    length: Int
}

init :: (self: @String) -> Nothing {
    self.data_size = 16
    self.data = malloc(self.data_size) as @Int8
    self.length = 0
}

init :: (self: @String, data: @Int8) -> Nothing {
    self.length = data.length()
    self.data_size = self.length + 1
    self.data = data
}

append :: (self: @String, char: Int8) -> @String {
    if (self.length + 1 >= self.data_size) {
        self.data_size = self.data_size + 16
        self.data = realloc(self.data, self.data_size) as @Int8
    }
    self.data[self.length] = char
    self.length = self.length + 1
    self.data[self.length] = '\0'
    return self
}

append :: (self: @String, other: @String) -> @String {
    if (self.length + other.length >= self.data_size) {
        self.data_size = self.length + other.length + 1
        self.data = realloc(self.data, self.data_size) as @Int8
    }
    index: Int = 0
    other_data: @Int8 = other.data
    self_data: @Int8 = self.data
    self_length: Int = self.length
    loop {
        char: Int8 = other_data[index]
        if (char == '\0') {
            break
        }
        self_data[self_length] = char
        self_length = self_length + 1
        index = index + 1
    }
    self.length = self_length
    return self
}

ends_with :: (self: @String, suffix: @String) -> Boolean {
    index: Int = 0
    while (index < suffix.length) {
        if (self.data[self.length - suffix.length + index] != suffix.data[index]) {
            return false
        }
        index = index + 1
    }
    return true
}

equals :: (self: @String, other: @String) -> Boolean {
    if (self.length == other.length) {
        index: Int = 0
        while (index < self.length) {
            if (self.data[index] != other.data[index]) {
                return false
            }
            index = index + 1
        }
        return true
    }
    return false
}

length :: (string: @Int8) -> Int {
    length: Int = 0
    loop {
        char: Int8 = string[length]
        if (char == '\0') {
            return length
        }
        length = length + 1
    }
}

write_line :: (file: @FILE, string: @String) -> @FILE {
    return file.end_line().write(string)
}

write :: (self: @FILE, number: Int) -> @FILE {
    if (number >= 10) {
        self.write(number / 10)
    }
    fputc((number // 10 + '0' as Int) as Int32, self)
    return self
}

write :: (self: @FILE, string: @String) -> @FILE {
    return self.write(string.data)
}

write :: (self: @FILE, chars: @Int8) -> @FILE {
    index: Int = 0
    loop {
        char: Int8 = chars[index]
        if (char == '\0') {
            break
        }
        self.write(char)
        index = index + 1
    }
    return self
}

write :: (self: @FILE, char: Int8) -> @FILE {
    c: Int32 = char as Int32
    if (fputc(c, self) != c) {
        stderr.write("Error: Failed to write character")
        abort()
    }
    return self
}

end_line :: (self: @FILE) -> @FILE {
    return self.write('\n')
}

\ -------------------------------------------------------------------------------------------------
\       LibC stuff
\ -------------------------------------------------------------------------------------------------

\ ----- stdio.h -----------------------------------------------------------------------------------

FILE :: struct

stdout: @FILE = external
stderr: @FILE = external

fclose :: (file: @FILE) -> Int32
feof :: (file: @FILE) -> Int32
fflush :: (file: @FILE) -> Int32
fgetc :: (file: @FILE) -> Int32
fopen :: (file: @Int8, mode: @Int8) -> @FILE
fputc :: (char: Int32, file: @FILE) -> Int32

\ ----- stdlib.h ----------------------------------------------------------------------------------

abort :: () -> Nothing
exit :: (code: Int) -> Nothing
free :: (block: @Any) -> Nothing
malloc :: (size: Int) -> @Any
realloc :: (block: @Int8, size: Int) -> @Any
