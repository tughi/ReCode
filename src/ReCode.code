\ Copyright (c) 2020, Stefan Selariu

\ TODO: change main to: program :: (arguments: @String) -> Nothing
main :: (argc: Int, argv: @@Int8) -> Nothing {
    if (argc != 3) {
        stdout.write("Usage:").end_line()
        stdout.write('\t').write(argv[0]).write(" <INPUT FILE> <OUTPUT FILE>").end_line()
        exit(1)
    }

    source_file_name: @String = new String.init(argv[1])
    if (source_file_name.ends_with(".code") == false) {
        stdout.write("'").write(source_file_name).write("' doesn't end with '.code'.").end_line()
        exit(1)
    }

    output_file_name: @String
    output_file_name = new String.init(argv[2])
    if (output_file_name.ends_with(".s") == false) {
        stdout.write("'").write(output_file_name).write("' doesn't end with '.s'.").end_line()
        exit(1)
    }

    tokens: @List = scan(source_file_name)

    compilation_unit: @Compilation_Unit = parse(tokens)
    \ stdout.write(compilation_unit).end_line()

    generate(compilation_unit, output_file_name)
}

\ -------------------------------------------------------------------------------------------------
\       Generator
\ -------------------------------------------------------------------------------------------------

generate :: (compilation_unit: @Compilation_Unit, output_file_name: @String) -> Nothing {
    builder: @IR_Builder = create_ir_builder(compilation_unit)
    builder.build()

    output_file: @FILE = fopen(output_file_name.data, "w".data)

    output_file.write("  .file 1 \"").write(compilation_unit.source.file_name).write("\"")
    output_file.write_line("  .intel_syntax noprefix")
    output_file.write_line("")
    output_file.write_line("  .text")
    output_file.write_line("  .globl main")
    output_file.write_line("main:")
    output_file.write_line("  push rbp")
    output_file.write_line("  mov rbp, rsp")
    \ TODO: call program function
    output_file.write_line("main__end:")
    output_file.write_line("  xor rax, rax")
    output_file.write_line("  mov rsp, rbp")
    output_file.write_line("  pop rbp")
    output_file.write_line("  ret")
    output_file.write_line("")
}

write :: (file: @FILE, function: @IR_Function) -> @FILE {
    file.write(function.name).write(" :: (")
    function_parameters: @List_Iterator = function.parameters.create_iterator()
    while (function_parameters.has_next()) {
        function_parameter: @IR_Function_Parameter = function_parameters.next() as @IR_Function_Parameter
        file.write(function_parameter.name).write(": ").write(function_parameter.type.name)
        if (function_parameters.has_next()) {
            file.write(", ")
        }
    }
    file.write(") -> ").write(function.return_type.name).write(" {").end_line()
    function_blocks: @List_Iterator = function.blocks.create_iterator()
    while (function_blocks.has_next()) {
        function_block: @IR_Block = function_blocks.next() as @IR_Block
        file.write(function_block)
    }
    file.write('}').end_line()
    return file
}

write :: (file: @FILE, block: @IR_Block) -> @FILE {
    file.write("block.").write(block.id).write(':').end_line()
    block_instructions: @List_Iterator = block.instructions.create_iterator()
    while (block_instructions.has_next()) {
        block_instruction: @IR_Instruction = block_instructions.next() as @IR_Instruction
        file.write(block_instruction)
    }
    return file
}

write :: (file: @FILE, instruction: @IR_Instruction) -> @FILE {
    file.write("   ")
    if (instruction.is(IR_Call_Instruction)) {
        file.write(instruction.result_value).write(": ").write(instruction.result_value.type.name).write(" = ").write("call").write('(').write((instruction as @IR_Call_Instruction).function.name).write(", ")
        call_arguments: @List_Iterator = (instruction as @IR_Call_Instruction).arguments.create_iterator()
        while (call_arguments.has_next()) {
            call_argument: @IR_Value = call_arguments.next() as @IR_Value
            file.write(call_argument)
            if (call_arguments.has_next()) {
                file.write(", ")
            }
        }
        return file.write(')').end_line()
    }
    if (instruction.is(IR_Conditional_Jump_Instruction)) {
        instruction: @IR_Conditional_Jump_Instruction = instruction as @IR_Conditional_Jump_Instruction
        return file.write("jump").write('(').write(instruction.condition_value).write(", block.").write(instruction.true_block.id).write(", block.").write(instruction.false_block.id).write(')').end_line()
    }
    if (instruction.is(IR_Direct_Jump_Instruction)) {
        instruction: @IR_Direct_Jump_Instruction = instruction as @IR_Direct_Jump_Instruction
        return file.write("jump").write('(').write("block.").write(instruction.block.id).write(')').end_line()
    }
    if (instruction.is(IR_Equals_Comparison_Instruction)) {
        return file.write(instruction.result_value).write(": ").write(instruction.result_value.type.name).write(" = ").write("cmp").write('(').write("EQUALS, ").write((instruction as @IR_Binary_Instruction).left_value).write(", ").write((instruction as @IR_Binary_Instruction).right_value).write(')').end_line()
    }
    if (instruction.is(IR_Load_Array_Item_Instruction)) {
        return file.write(instruction.result_value).write(": ").write(instruction.result_value.type.name).write(" = ").write("load_array_item").write('(').write((instruction as @IR_Load_Array_Item_Instruction).array_value).write(", ").write((instruction as @IR_Load_Array_Item_Instruction).index_value).write(')').end_line()
    }
    if (instruction.is(IR_Load_Struct_Member_Instruction)) {
        return file.write(instruction.result_value).write(": ").write(instruction.result_value.type.name).write(" = ").write("load_struct_member").write('(').write((instruction as @IR_Load_Struct_Member_Instruction).struct_pointer_value).write(", ").write((instruction as @IR_Load_Struct_Member_Instruction).struct_type_member.name).write(')').end_line()
    }
    if (instruction.is(IR_New_Instruction)) {
        return file.write(instruction.result_value).write(": ").write(instruction.result_value.type.name).write(" = ").write("new").write('(').write((instruction as @IR_New_Instruction).type.name).write(')').end_line()
    }
    if (instruction.is(IR_Not_Equals_Comparison_Instruction)) {
        return file.write(instruction.result_value).write(": ").write(instruction.result_value.type.name).write(" = ").write("cmp").write('(').write("NOT_EQUALS, ").write((instruction as @IR_Binary_Instruction).left_value).write(", ").write((instruction as @IR_Binary_Instruction).right_value).write(')').end_line()
    }
    if (instruction.is(IR_Return_Instruction)) {
        instruction: @IR_Return_Instruction = instruction as @IR_Return_Instruction
        return file.write("return").write('(').write(instruction.return_value).write(')').end_line()
    }
    if (instruction.is(IR_Set_Instruction)) {
        return file.write(instruction.result_value).write(": ").write(instruction.result_value.type.name).write(" = ").write((instruction as @IR_Set_Instruction).value).end_line()
    }
    if (instruction.is(IR_Store_Struct_Member_Instruction)) {
        instruction: @IR_Store_Struct_Member_Instruction = instruction as @IR_Store_Struct_Member_Instruction
        return file.write("store_struct_member").write('(').write(instruction.struct_pointer_value).write(", ").write(instruction.struct_type_member.name).write(", ").write(instruction.value).write(')').end_line()
    }
    abort(clone("Unsupported type: ").append(instruction.object_type.name))
}

write :: (file: @FILE, value: @IR_Value) -> @FILE {
    if (value.is(IR_Constant_Value)) {
        return file.write((value as @IR_Constant_Value).literal)
    }
    if (value.is(IR_Named_Value)) {
        return file.write((value as @IR_Named_Value).name).write('.').write((value as @IR_Named_Value).version)
    }
    if (value.is(IR_Undefined_Value)) {
        return file.write("undefined")
    }
    abort(clone("Unsupported type: ").append(value.object_type.name))
}

\ -------------------------------------------------------------------------------------------------
\       IR_Builder
\ -------------------------------------------------------------------------------------------------

IR_Builder :: struct {
    context: @IR_Builder_Context
    compilation_unit: @Compilation_Unit
    named_types: @List
    named_functions: @List
    current_block: @IR_Block
}

IR_Builder_Context :: struct {
    parent: @IR_Builder_Context
    variables: @List
    named_values: @List
}

create_ir_builder :: (compilation_unit: @Compilation_Unit) -> @IR_Builder {
    builder: @IR_Builder = new IR_Builder
    builder.compilation_unit = compilation_unit
    builder.context = create_ir_builder_context(null)
    builder.named_types = create_list()
    builder.named_types.append(new IR_Any_Type.init("Any"))
    builder.named_types.append(new IR_Boolean_Type.init("Boolean"))
    builder.named_types.append(new IR_Int_Type.init("Int"))
    builder.named_types.append(new IR_Int8_Type.init("Int8"))
    builder.named_types.append(new IR_Int16_Type.init("Int16"))
    builder.named_types.append(new IR_Int32_Type.init("Int32"))
    builder.named_types.append(new IR_Int64_Type.init("Int64"))
    builder.named_types.append(new IR_Nothing_Type.init("Nothing"))
    builder.named_types.append(new IR_Null_Type.init("Null"))
    builder.named_functions = create_list()
    builder.current_block = null
    return builder
}

create_ir_builder_context :: (parent: @IR_Builder_Context) -> @IR_Builder_Context {
    context: @IR_Builder_Context = new IR_Builder_Context
    context.parent = parent
    context.variables = create_list()
    context.named_values = create_list()
    return context
}

get_named_type :: (self: @IR_Builder, name: @String) -> @IR_Type {
    named_types: @List_Iterator = self.named_types.create_iterator()
    while (named_types.has_next()) {
        named_type: @IR_Type = named_types.next() as @IR_Type
        if (name.equals(named_type.name)) {
            return named_type
        }
    }
    return null
}

add_variable :: (self: @IR_Builder, variable: @IR_Variable) -> @IR_Variable {
    self.context.variables.prepend(variable)
}

get_variable :: (self: @IR_Builder, name: @String) -> @IR_Variable {
    context: @IR_Builder_Context = self.context
    loop {
        variables: @List_Iterator = context.variables.create_iterator()
        while (variables.has_next()) {
            variable: @IR_Variable = variables.next() as @IR_Variable
            if (name.equals(variable.name)) {
                return variable
            }
        }
        context = context.parent
        if (context == null) {
            return null
        }
    }
}

get_variable_value :: (self: @IR_Builder, variable: @IR_Variable) -> @IR_Value {
    context: @IR_Builder_Context = self.context
    loop {
        values: @List_Iterator = context.named_values.create_iterator()
        while (values.has_next()) {
            value: @IR_Named_Value = values.next() as @IR_Named_Value
            if (value.is(IR_Variable_Value) && (value as @IR_Variable_Value).variable == variable) {
                return value
            }
        }
        context = context.parent
        if (context == null) {
            return null
        }
    }
}

add_named_value :: (self: @IR_Builder, value: @IR_Named_Value) -> @IR_Value {
    other_value: @IR_Named_Value = self.get_named_value(value.name)
    if (other_value != null) {
        value.version = other_value.version + 1
    }
    self.context.named_values.prepend(value)
    return value
}

get_named_value :: (self: @IR_Builder, name: @String) -> @IR_Named_Value {
    context: @IR_Builder_Context = self.context
    loop {
        values: @List_Iterator = context.named_values.create_iterator()
        while (values.has_next()) {
            value: @IR_Named_Value = values.next()
            if (name.equals(value.name)) {
                return value
            }
        }
        context = context.parent
        if (context == null) {
            return null
        }
    }
}

get_named_function :: (self: @IR_Builder, name: @Identifier_Token, argument_types: @List) -> @IR_Function {
    function: @IR_Function = self.get_named_function(name.lexeme, argument_types)
    if (function == null) {
        message: @String = clone("Undefined function: ").append(name.lexeme).append(" :: (")
        argument_types: @List_Iterator = argument_types.create_iterator()
        while (argument_types.has_next()) {
            argument_type: @IR_Type = argument_types.next() as @IR_Type
            message.append(argument_type.name)
            if (argument_types.has_next()) {
                message.append(", ")
            }
        }
        message.append(")")
        abort(name.location, message)
    }
    return function
}

get_named_function :: (self: @IR_Builder, name: @String, argument_types: @List) -> @IR_Function {
    function: @IR_Function = null
    named_functions: @List_Iterator = self.named_functions.create_iterator()
    while (named_functions.has_next()) {
        named_function: @IR_Function = named_functions.next()
        if (name.equals(named_function.name)) {
            is_match: Boolean = true
            argument_types: @List_Iterator = argument_types.create_iterator()
            named_function_parameters: @List_Iterator = named_function.parameters.create_iterator()
            while (argument_types.has_next() && named_function_parameters.has_next()) {
                argument_type: @IR_Type = argument_types.next()
                named_function_parameter: @IR_Function_Parameter = named_function_parameters.next()
                if (named_function_parameter.type.accepts(argument_type) == false) {
                    is_match = false
                    break
                }
            }
            if (is_match && argument_types.has_next() == false && named_function_parameters.has_next() == false) {
                if (function != null) {
                    abort(name)
                }
                function = named_function
            }
        }
    }
    return function
}

accepts :: (self: @IR_Type, other: @IR_Type) -> Boolean {
    if (self == other) {
        return true
    }
    if (self.is(IR_Pointer_Type)) {
        self: @IR_Pointer_Type = self
        if (other.is(IR_Pointer_Type)) {
            other: @IR_Pointer_Type = other
            if (self.pointed_type == other.pointed_type) {
                return true
            }
            if (self.pointed_type.is(IR_Any_Type)) {
                return true
            }
            if (self.pointed_type.is(IR_Struct_Type) && other.pointed_type.is(IR_Struct_Type)) {
                return (self.pointed_type as @IR_Struct_Type).is_base_type(other.pointed_type as @IR_Struct_Type)
            }
        }
        if (other.is(IR_Null_Type)) {
            return true
        }
        return false
    }
    return false
}

create_temp_value :: (self: @IR_Builder, type: @IR_Type) -> @IR_Value {
    return self.add_named_value(new IR_Temp_Value.init(type, "$"))
}

build :: (self: @IR_Builder) -> Nothing {
    types: @List_Iterator = self.compilation_unit.types.create_iterator()
    while (types.has_next()) {
        statement: @Statement = types.next()
        self.convert_type_statement(statement)
    }

    global_variables: @List_Iterator = self.compilation_unit.global_variables.create_iterator()
    while (global_variables.has_next()) {
        variable_statement: @Variable_Statement = global_variables.next()
        self.create_global_variable(variable_statement)
    }

    functions: @List_Iterator = self.compilation_unit.functions.create_iterator()
    while (functions.has_next()) {
        function_statement: @Function_Statement = functions.next()
        self.create_function(function_statement)
    }

    functions: @List_Iterator = self.compilation_unit.functions.create_iterator()
    while (functions.has_next()) {
        function_statement: @Function_Statement = functions.next()
        self.build_function(function_statement)
    }
}

convert_type_statement :: (self: @IR_Builder, statement: @Statement) -> @IR_Type {
    if (statement.is(Struct_Statement)) {
        return self.convert_struct_statement(statement as @Struct_Statement)
    }
    abort(statement.location, statement.object_type)
}

convert_struct_statement :: (self: @IR_Builder, struct_statement: @Struct_Statement) -> @IR_Type {
    struct_name: @String = struct_statement.name.lexeme
    type: @IR_Type = self.get_named_type(struct_name)
    if (type != null) {
        if (type.is(IR_Struct_Type) && (type as @IR_Struct_Type).statement == struct_statement) {
            return type
        }
        abort(struct_statement.location, clone("Duplicate type declaration: ").append(struct_name))
    }
    type: @IR_Struct_Type = create_ir_struct_type(struct_name, struct_statement)
    self.named_types.append(type)
    if (struct_statement.base_type != null) {
        base_type: @IR_Type = self.convert_value_type(struct_statement.base_type)
        if ((base_type.is(IR_Struct_Type)) == false) {
            abort(struct_statement.base_type.location, "Not a struct type.")
        }
        type.base_type = base_type as @IR_Struct_Type
    }
    if (struct_statement.members != null) {
        struct_members: @List_Iterator = struct_statement.members.create_iterator()
        while (struct_members.has_next()) {
            struct_member: @Struct_Member = struct_members.next()
            struct_member_name: @String = struct_member.name.lexeme
            struct_member_type: @IR_Type = self.convert_value_type(struct_member.value_type)
            type.add_member(struct_member_name, struct_member_type)
        }
    }
    if (type.is_object_type()) {
        self.create_global_variable(create_variable_statement(struct_statement.name, create_pointer_type(null, create_named_type(create_identifier_token("Object_Type", null))), null, false))
    }
    return type
}

convert_value_type :: (self: @IR_Builder, type: @Value_Type) -> @IR_Type {
    if (type.is(Named_Type)) {
        return self.convert_named_type(type as @Named_Type)
    }
    if (type.is(Pointer_Type)) {
        return self.convert_pointer_type(type as @Pointer_Type)
    }
    abort(type.location, type.object_type)
}

convert_named_type :: (self: @IR_Builder, type: @Named_Type) -> @IR_Type {
    type_name: @Identifier_Token = type.name
    type: @IR_Type = self.get_named_type(type_name.lexeme)
    if (type == null) {
        types: @List_Iterator = self.compilation_unit.types.create_iterator()
        while (types.has_next()) {
            statement: @Statement = types.next()
            if (statement.is(Struct_Statement)) {
                statement: @Struct_Statement = statement
                if (statement.name.lexeme.equals(type_name.lexeme)) {
                    return self.convert_struct_statement(statement)
                }
            } else {
                abort(statement.location, statement.object_type)
            }
        }
        abort(type_name.location, clone("Unknown type: ").append(type_name.lexeme))
    }
    return type
}

convert_pointer_type :: (self: @IR_Builder, type: @Pointer_Type) -> @IR_Type {
    return create_ir_pointer_type(self.convert_value_type(type.value_type))
}

create_global_variable :: (self: @IR_Builder, variable_statement: @Variable_Statement) -> Nothing {
    variable_name: @String = variable_statement.name.lexeme
    variable_type: @IR_Type
    if (variable_statement.value_type != null) {
        variable_type = self.convert_value_type(variable_statement.value_type)
    } else {
        abort(variable_statement.location, "Type inference is not supported yet.")
    }
    variable: @IR_Variable = create_ir_global_variable(variable_name, variable_type)
    if (variable_statement.value_expression != null) {
        abort(variable_statement.value_expression.location, "Initialized global variables are not supported yet.")
    }
    self.add_variable(variable)
    self.add_named_value(create_ir_variable_value(variable))
}

create_function :: (self: @IR_Builder, function_statement: @Function_Statement) -> @IR_Function {
    function: @IR_Function = new IR_Function
    function.location = function_statement.location
    function.blocks = create_list()
    function.name = function_statement.name.lexeme
    function.parameters = create_list()
    function.return_type = self.convert_value_type(function_statement.return_type)

    parameters: @List_Iterator = function_statement.parameters.create_iterator()
    while (parameters.has_next()) {
        parameter: @Function_Parameter = parameters.next()
        parameter_type: @IR_Type = self.convert_value_type(parameter.value_type)
        parameter_name: @String = parameter.name.lexeme
        function_parameter: @IR_Function_Parameter = new IR_Function_Parameter.init(parameter_name, parameter_type)
        function.parameters.append(function_parameter)
    }

    function_statement.ir_function = function
    self.named_functions.append(function)

    return function
}

build_function :: (self: @IR_Builder, function_statement: @Function_Statement) -> Nothing {
    function: @IR_Function = function_statement.ir_function

    self.context = create_ir_builder_context(self.context)

    function_parameters: @List_Iterator = function.parameters.create_iterator()
    while (function_parameters.has_next()) {
        function_parameter: @IR_Function_Parameter = function_parameters.next()
        self.add_variable(function_parameter)
        self.add_named_value(create_ir_variable_value(function_parameter))
    }

    self.current_block = function.create_block()
    self.convert_block_statement(function_statement.body)
    stdout.write("----------------------------------------- CURRENT FUNCTION -----------------------------------------").end_line().write(self.current_block.function).write("----------------------------------------------------------------------------------------------------").end_line().fflush()
    self.current_block = null

    self.named_functions.append(function)

    self.context = self.context.parent
}

convert_statement :: (self: @IR_Builder, statement: @Statement) -> Nothing {
    if (self.current_block == null) {
        abort(statement.location, clone(statement.object_type.name).append(" requires a basic block."))
    }
    if (statement.is(Assignment_Statement)) {
        self.convert_assignment_statement(statement as @Assignment_Statement)
        return
    }
    if (statement.is(Block_Statement)) {
        self.convert_block_statement(statement as @Block_Statement)
        return
    }
    if (statement.is(Expression_Statement)) {
        self.convert_expression_statement(statement as @Expression_Statement)
        return
    }
    if (statement.is(If_Statement)) {
        self.convert_if_statement(statement as @If_Statement)
        return
    }
    if (statement.is(Loop_Statement)) {
        self.convert_loop_statement(statement as @Loop_Statement)
        return
    }
    if (statement.is(Return_Statement)) {
        self.convert_return_statement(statement as @Return_Statement)
        return
    }
    if (statement.is(Variable_Statement)) {
        self.convert_variable_statement(statement as @Variable_Statement)
        return
    }
    if (statement.is(While_Statement)) {
        self.convert_while_statement(statement as @While_Statement)
        return
    }
    abort(statement.location, statement.object_type)
}

convert_assignment_statement :: (self: @IR_Builder, assignment_statement: @Assignment_Statement) -> Nothing {
    value: @IR_Value = self.convert_expression(assignment_statement.value_expression)
    if (assignment_statement.destination.is(Variable_Expression)) {
        variable_expression: @Variable_Expression = assignment_statement.destination
        variable_name: @String = variable_expression.name.lexeme
        variable: @IR_Variable = self.get_variable(variable_name)
        if (variable == null) {
            abort(variable_expression.location, clone("Undeclared variable: ").append(variable_name))
        }
        if (variable.type.accepts(value.type) == false) {
            abort(variable_expression.location, clone("Cannot assign a '").append(value.type.name).append("' value to a '").append(variable.type.name).append("' variable"))
        }
        self.current_block.append(create_ir_set_instruction(self.add_named_value(create_ir_variable_value(variable)), value))
        return
    }
    if (assignment_statement.destination.is(Member_Access_Expression)) {
        member_access_expression: @Member_Access_Expression = assignment_statement.destination as @Member_Access_Expression
        object_address_value: @IR_Value = self.convert_expression_address(member_access_expression.object)
        if (object_address_value.type.is(IR_Pointer_Type) == false) {
            abort(assignment_statement.location, clone("Not a '").append(IR_Pointer_Type.name).append("' value"))
        }
        object_type: @IR_Type = (object_address_value.type as @IR_Pointer_Type).pointed_type
        if (object_type.is(IR_Struct_Type) == false) {
            abort(assignment_statement.location, clone("Not a '").append(IR_Struct_Type.name).append("' value"))
        }
        struct_type_member: @IR_Struct_Type_Member = (object_type as @IR_Struct_Type).get_member(member_access_expression.member_name.lexeme)
        if (struct_type_member == null) {
            abort(member_access_expression.member_name.location, clone(object_type.name).append(" doesn't have a '").append(member_access_expression.member_name.lexeme).append("' member"))
        }
        if (struct_type_member.type.accepts(value.type) == false) {
            abort(assignment_statement.value_expression.location, clone("Cannot assign a '").append(value.type.name).append("' value to a '").append(struct_type_member.type.name).append("' struct member"))
        }
        self.current_block.append(create_ir_store_struct_member_instruction(object_address_value, struct_type_member, value))
        return
    }
    abort(assignment_statement.location, assignment_statement.destination.object_type)
}

convert_block_statement :: (self: @IR_Builder, statement: @Block_Statement) -> Nothing {
    block_statements: @List_Iterator = statement.statements.create_iterator()
    while (block_statements.has_next()) {
        block_statement: @Statement = block_statements.next()
        self.convert_statement(block_statement)
    }
}

convert_expression_statement :: (self: @IR_Builder, statement: @Expression_Statement) -> Nothing {
    self.convert_expression(statement.expression)
}

convert_if_statement :: (self: @IR_Builder, statement: @If_Statement) -> Nothing {
    condition_value: @IR_Value = self.convert_expression(statement.condition)
    true_block: @IR_Block = self.current_block.function.create_block()
    end_block: @IR_Block = self.current_block.function.create_block()
    if (statement.false_block != null) {
        false_block: @IR_Block = self.current_block.function.create_block()
        self.current_block.append(create_ir_jump_instruction(condition_value, true_block, false_block))
        self.current_block = false_block
        self.convert_block_statement(statement.false_block)
        self.current_block.append(create_ir_jump_instruction(end_block))
    } else {
        self.current_block.append(create_ir_jump_instruction(condition_value, true_block, end_block))
    }
    self.current_block = true_block
    self.convert_block_statement(statement.true_block)
    self.current_block.append(create_ir_jump_instruction(end_block))
    self.current_block = end_block
}

convert_loop_statement :: (self: @IR_Builder, statement: @Loop_Statement) -> Nothing {
    loop_block: @IR_Block = self.current_block.function.create_block()
    end_block: @IR_Block = self.current_block.function.create_block()
    self.current_block.append(create_ir_jump_instruction(loop_block))
    self.current_block = loop_block
    self.convert_block_statement(statement.block)
    self.current_block.append(create_ir_jump_instruction(loop_block))
    self.current_block = end_block
}

convert_return_statement :: (self: @IR_Builder, statement: @Return_Statement) -> Nothing {
    return_value: @IR_Value = self.convert_expression(statement.value_expression)
    \ TODO: validate return value type
    self.current_block.append(create_ir_return_instruction(return_value))
}

convert_variable_statement :: (self: @IR_Builder, variable_statement: @Variable_Statement) -> Nothing {
    variable_name: @String = variable_statement.name.lexeme
    variable_type: @IR_Type
    if (variable_statement.value_type != null) {
        variable_type = self.convert_value_type(variable_statement.value_type)
    } else {
        abort(variable_statement.location, "Type inference is not supported yet.")
    }
    variable: @IR_Variable = new IR_Variable.init(variable_name, variable_type)
    if (variable_statement.value_expression != null) {
        variable_value: @IR_Value = self.convert_expression(variable_statement.value_expression)
        if (variable.type.accepts(variable_value.type) == false) {
            abort(variable_statement.value_expression.location, clone("Cannot assign a '").append(variable_value.type.name).append("' value to a '").append(variable.type.name).append("' variable"))
        }
        self.add_variable(variable)
        self.current_block.append(create_ir_set_instruction(self.add_named_value(create_ir_variable_value(variable)), variable_value))
    } else {
        self.add_variable(variable)
        self.current_block.append(create_ir_set_instruction(self.add_named_value(create_ir_variable_value(variable)), new IR_Undefined_Value.init(variable.type)))
    }
}

convert_while_statement :: (self: @IR_Builder, statement: @While_Statement) -> Nothing {
    condition_block: @IR_Block = self.current_block.function.create_block()
    loop_block: @IR_Block = self.current_block.function.create_block()
    end_block: @IR_Block = self.current_block.function.create_block()
    self.current_block.append(create_ir_jump_instruction(condition_block))
    self.current_block = condition_block
    condition_value: @IR_Value = self.convert_expression(statement.condition)
    self.current_block.append(create_ir_jump_instruction(condition_value, loop_block, end_block))
    self.current_block = loop_block
    self.convert_block_statement(statement.block)
    self.current_block.append(create_ir_jump_instruction(condition_block))
    self.current_block = end_block
}

convert_expression :: (self: @IR_Builder, expression: @Expression) -> @IR_Value {
    if (expression.is(Array_Access_Expression)) {
        return self.convert_array_access_expression(expression as @Array_Access_Expression)
    }
    if (expression.is(Call_Expression)) {
        return self.convert_call_expression(expression as @Call_Expression)
    }
    if (expression.is(Cast_Expression)) {
        return self.convert_cast_expression(expression as @Cast_Expression)
    }
    if (expression.is(Equals_Expression)) {
        return self.convert_equals_expression(expression as @Equals_Expression)
    }
    if (expression.is(Literal_Expression)) {
        return self.convert_literal_expression(expression as @Literal_Expression)
    }
    if (expression.is(Logic_And_Expression)) {
        return self.convert_logic_and_expression(expression as @Logic_And_Expression)
    }
    if (expression.is(Member_Access_Expression)) {
        return self.convert_member_access_expression(expression as @Member_Access_Expression)
    }
    if (expression.is(New_Expression)) {
        return self.convert_new_expression(expression as @New_Expression)
    }
    if (expression.is(Not_Equals_Expression)) {
        return self.convert_not_equals_expression(expression as @Not_Equals_Expression)
    }
    if (expression.is(Variable_Expression)) {
        return self.convert_variable_expression(expression as @Variable_Expression)
    }
    abort(expression.location, expression.object_type)
}

convert_expression_address :: (self: @IR_Builder, expression: @Expression) -> @IR_Value {
    if (expression.is(Variable_Expression)) {
        return self.convert_variable_expression_address(expression as @Variable_Expression)
    }
    abort(expression.location, expression.object_type)
}

convert_array_access_expression :: (self: @IR_Builder, array_access_expression: @Array_Access_Expression) -> @IR_Value {
    index_value: @IR_Value = self.convert_expression(array_access_expression.index_expression)
    object_value: @IR_Value = self.convert_expression(array_access_expression.object)
    object_value_type: @IR_Type = object_value.type
    if ((object_value_type.is(IR_Pointer_Type)) == false) {
        abort(array_access_expression.location, clone("Not an IR_Pointer_Type value: ").append(object_value_type.name))
    }
    object_value_type: @IR_Pointer_Type = object_value_type
    result_value: @IR_Temp_Value = self.create_temp_value(object_value_type.pointed_type)
    self.current_block.append(create_ir_load_array_item_instruction(result_value, object_value, index_value))
    return result_value
}

convert_call_expression :: (self: @IR_Builder, call_expression: @Call_Expression) -> @IR_Value {
    if (call_expression.callee.is(Member_Access_Expression)) {
        callee: @Member_Access_Expression = call_expression.callee
        call_arguments: @List = create_list()
        call_argument_types: @List = create_list()
        first_argument: @IR_Value = self.convert_expression(callee.object)
        call_arguments.append(first_argument)
        call_argument_types.append(first_argument.type)
        call_expression_arguments: @List_Iterator = call_expression.arguments.create_iterator()
        while (call_expression_arguments.has_next()) {
            call_expression_argument: @Expression = call_expression_arguments.next()
            call_argument: @IR_Value = self.convert_expression(call_expression_argument)
            call_arguments.append(call_argument)
            call_argument_types.append(call_argument.type)
        }
        call_function: @IR_Function = self.get_named_function(callee.member_name, call_argument_types)
        if (call_function == null) {
            abort(callee.member_name.location, clone("No such function: ").append(callee.member_name.lexeme))
        }
        result_value: @IR_Temp_Value = self.create_temp_value(call_function.return_type)
        self.current_block.append(create_ir_call_instruction(result_value, call_function, call_arguments))
        return result_value
    }
    if (call_expression.callee.is(Variable_Expression)) {
        callee: @Variable_Expression = call_expression.callee
        call_arguments: @List = create_list()
        call_argument_types: @List = create_list()
        call_expression_arguments: @List_Iterator = call_expression.arguments.create_iterator()
        while (call_expression_arguments.has_next()) {
            call_expression_argument: @Expression = call_expression_arguments.next()
            call_argument: @IR_Value = self.convert_expression(call_expression_argument)
            call_arguments.append(call_argument)
            call_argument_types.append(call_argument.type)
        }
        call_function: @IR_Function = self.get_named_function(callee.name, call_argument_types)
        if (call_function == null) {
            abort(callee.name.location, clone("No such function: ").append(callee.name.lexeme))
        }
        result_value: @IR_Temp_Value = self.create_temp_value(call_function.return_type)
        self.current_block.append(create_ir_call_instruction(result_value, call_function, call_arguments))
        return result_value
    }
    abort(call_expression.location, call_expression.callee.object_type)
}

convert_cast_expression :: (self: @IR_Builder, cast_expression: @Cast_Expression) -> @IR_Value {
    value: @IR_Value = self.convert_expression(cast_expression.value_expression)
    result_value: @IR_Value = self.create_temp_value(self.convert_value_type(cast_expression.value_type))
    if (value.type.is(IR_Pointer_Type) && result_value.type.is(IR_Pointer_Type)) {
        self.current_block.append(create_ir_set_instruction(result_value, value))
    } else {
        abort(cast_expression.location, clone("Cannot cast ").append(value.type.name).append(" to ").append(result_value.type.name))
    }
    return result_value
}

convert_equals_expression :: (self: @IR_Builder, expression: @Equals_Expression) -> @IR_Value {
    left_value: @IR_Value = self.convert_expression(expression.left_expression)
    right_value: @IR_Value = self.convert_expression(expression.right_expression)
    if (left_value.type.equals(right_value.type) == false && (left_value.type.is(IR_Pointer_Type) && right_value.type.is(IR_Null_Type) == false)) {
        abort(expression.location, "Operands are not the same type")
    }
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    result_value: @IR_Value = self.create_temp_value(self.get_named_type("Boolean"))
    self.current_block.append(new IR_Equals_Comparison_Instruction.init(result_value, left_value, right_value))
    return result_value
}

convert_literal_expression :: (self: @IR_Builder, expression: @Literal_Expression) -> @IR_Value {
    if (expression.literal.is(Boolean_Token)) {
        return create_ir_constant_value(self.get_named_type("Boolean"), expression.literal)
    }
    if (expression.literal.is(Character_Token)) {
        return create_ir_constant_value(self.get_named_type("Int8"), expression.literal)
    }
    if (expression.literal.is(Integer_Token)) {
        return create_ir_constant_value(self.get_named_type("Int"), expression.literal)
    }
    if (expression.literal.is(Null_Token)) {
        return create_ir_constant_value(self.get_named_type("Null"), expression.literal)
    }
    if (expression.literal.is(String_Token)) {
        return create_ir_constant_value(create_ir_pointer_type(self.get_named_type("String")), expression.literal)
    }
    abort(expression.location, expression.literal.object_type)
}

convert_logic_and_expression :: (self: @IR_Builder, expression: @Logic_And_Expression) -> @IR_Value {
    next_block: @IR_Block = self.current_block.function.create_block()
    end_block: @IR_Block = self.current_block.function.create_block()
    left_value: @IR_Value = self.convert_expression(expression.left_expression)
    if (left_value.type.is(IR_Boolean_Type) == false) {
        abort(expression.left_expression.location, "Must be a boolean expression")
    }
    self.current_block.append(create_ir_jump_instruction(left_value, next_block, end_block))
    self.current_block = next_block
    right_value: @IR_Value = self.convert_expression(expression.right_expression)
    if (right_value.type.is(IR_Boolean_Type) == false) {
        abort(expression.right_expression.location, "Must be a boolean expression")
    }
    self.current_block.append(create_ir_jump_instruction(end_block))
    self.current_block = end_block
    result_value: @IR_Value = self.create_temp_value(self.get_named_type("Boolean"))
    \ TODO: self.current_block.append(new IR_Phi_Instruction.init(result_value, left_value, right_value))
    return result_value
}

convert_member_access_expression :: (self: @IR_Builder, member_access_expression: @Member_Access_Expression) -> @IR_Value {
    object_value: @IR_Value = self.convert_expression(member_access_expression.object)
    object_value_type: @IR_Type = object_value.type
    if ((object_value_type.is(IR_Pointer_Type)) == false) {
        abort(member_access_expression.location, clone("Not an IR_Pointer_Type value: ").append(object_value_type.name))
    }
    object_value_type: @IR_Pointer_Type = object_value_type
    if ((object_value_type.pointed_type.is(IR_Struct_Type)) == false) {
        abort(member_access_expression.location, clone("Not a IR_Struct_Type pointer value: ").append(object_value_type.name))
    }
    struct_type: @IR_Struct_Type = object_value_type.pointed_type
    struct_type_member: @IR_Struct_Type_Member = struct_type.get_member(member_access_expression.member_name.lexeme)
    if (struct_type_member == null) {
        abort(member_access_expression.member_name.location, clone(struct_type.name).append(" has no such member: ").append(member_access_expression.member_name.lexeme))
    }
    if (struct_type_member.type.is(IR_Struct_Type)) {
        result_value: @IR_Temp_Value = self.create_temp_value(create_ir_pointer_type(struct_type_member.type))
        self.current_block.append(create_ir_load_struct_member_instruction(result_value, object_value, struct_type_member, true))
        return result_value
    }
    result_value: @IR_Temp_Value = self.create_temp_value(struct_type_member.type)
    self.current_block.append(create_ir_load_struct_member_instruction(result_value, object_value, struct_type_member, false))
    return result_value
}

convert_new_expression :: (self: @IR_Builder, expression: @New_Expression) -> @IR_Value {
    type: @IR_Type = self.convert_value_type(expression.value_type)
    result_value: @IR_Temp_Value = self.create_temp_value(create_ir_pointer_type(type))
    self.current_block.append(create_ir_new_instruction(result_value, type))
    return result_value
}

convert_not_equals_expression :: (self: @IR_Builder, expression: @Not_Equals_Expression) -> @IR_Value {
    left_value: @IR_Value = self.convert_expression(expression.left_expression)
    right_value: @IR_Value = self.convert_expression(expression.right_expression)
    if (left_value.type.equals(right_value.type) == false && (left_value.type.is(IR_Pointer_Type) && right_value.type.is(IR_Null_Type) == false)) {
        abort(expression.location, "Operands are not the same type")
    }
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    result_value: @IR_Value = self.create_temp_value(self.get_named_type("Boolean"))
    self.current_block.append(new IR_Not_Equals_Comparison_Instruction.init(result_value, left_value, right_value))
    return result_value
}

convert_variable_expression :: (self: @IR_Builder, expression: @Variable_Expression) -> @IR_Value {
    variable: @IR_Variable = self.get_variable(expression.name.lexeme)
    if (variable == null) {
        abort(expression.location, clone("Undeclared variable: ").append(expression.name.lexeme))
    }
    value: @IR_Value = self.get_variable_value(variable)
    if (value == null) {
        abort(expression.location, clone("Undeclared variable value: ").append(expression.name.lexeme))
    }
    return value
}

convert_variable_expression_address :: (self: @IR_Builder, expression: @Variable_Expression) -> @IR_Value {
    variable: @IR_Variable = self.get_variable(expression.name.lexeme)
    if (variable == null) {
        abort(expression.location, clone("Undeclared variable: ").append(expression.name.lexeme))
    }
    if (variable.type.is(IR_Pointer_Type)) {
        return self.get_variable_value(variable)
    }
    abort(expression.location, clone("Variable type without address: ").append(variable.type.name))
}

deduce_expression_type :: (self: @IR_Builder, expression: @Expression) -> @IR_Type {
    if (expression.is(Call_Expression)) {
        return self.deduce_call_expression_type(expression as @Call_Expression)
    }
    if (expression.is(Variable_Expression)) {
        return self.deduce_variable_expression_type(expression as @Variable_Expression)
    }
    if (expression.is(Literal_Expression)) {
        return self.deduce_literal_expression_type(expression as @Literal_Expression)
    }
    abort(expression.location, expression.object_type)
}

deduce_call_expression_type :: (self: @IR_Builder, expression: @Call_Expression) -> @IR_Type {
    argument_types: @List = create_list()
    arguments: @List_Iterator = expression.arguments.create_iterator()
    while (arguments.has_next()) {
        argument: @Expression = arguments.next()
        argument_type: @IR_Type = self.deduce_expression_type(argument)
        argument_types.append(argument_type)
    }
    if (expression.callee.is(Member_Access_Expression)) {
        callee: @Member_Access_Expression = expression.callee
        object_type: @IR_Type = self.deduce_expression_type(callee.object)
        if (object_type.is(IR_Struct_Type)) {
            argument_types.prepend(create_ir_pointer_type(object_type))
        } else {
            argument_types.prepend(object_type)
        }
        function: @IR_Function = self.get_named_function(callee.member_name.lexeme, argument_types)
        if (function == null) {
            abort(callee.member_name.location, clone("Unknown function: ").append(callee.member_name.lexeme))
        }
        return function.return_type
    }
    abort(expression.location, expression.callee.object_type)
}

deduce_literal_expression_type :: (self: @IR_Builder, expression: @Literal_Expression) -> @IR_Type {
    literal: @Literal_Token = expression.literal
    if (literal.is(String_Token)) {
        return create_ir_pointer_type(self.get_named_type("String"))
    }
    abort(literal.location, literal.object_type)
}

deduce_variable_expression_type :: (self: @IR_Builder, expression: @Variable_Expression) -> @IR_Type {
    value: @IR_Value = self.get_named_value(expression.name.lexeme)
    if (value == null) {
        abort(expression.location, clone("Unknown variable: ").append(expression.name.lexeme))
    }
    return value.type
}

abort :: (location: @Source_Location, unexpected_type: @Object_Type) -> Nothing {
    stderr.end_line().end_line().write(location).write(": Unexpected type: ").write(unexpected_type.name).end_line()
    abort()
}

\ -------------------------------------------------------------------------------------------------
\       IR
\ -------------------------------------------------------------------------------------------------

IR :: struct {
}

IR_Type :: struct : Object {
    name: @String
}

init :: (self: @IR_Type, name: @String) -> @IR_Type {
    self.name = name
    return self
}

IR_Any_Type :: struct : IR_Type {
}

IR_Boolean_Type :: struct : IR_Type {
}

IR_Int_Type :: struct : IR_Type {
}

IR_Int8_Type :: struct : IR_Type {
}

IR_Int16_Type :: struct : IR_Type {
}

IR_Int32_Type :: struct : IR_Type {
}

IR_Int64_Type :: struct : IR_Type {
}

IR_Nothing_Type :: struct : IR_Type {
}

IR_Null_Type :: struct : IR_Type {
}

IR_Pointer_Type :: struct : IR_Type {
    pointed_type: @IR_Type
}

equals :: (self: @IR_Type, other: @IR_Type) -> Boolean {
    if (self.is(IR_Pointer_Type) && other.is(IR_Pointer_Type)) {
        self: @IR_Pointer_Type = self
        other: @IR_Pointer_Type = other
        return self.pointed_type.equals(other.pointed_type)
    }
    return self == other
}

create_ir_pointer_type :: (pointed_type: @IR_Type) -> @IR_Pointer_Type {
    type: @IR_Pointer_Type = new IR_Pointer_Type
    type.init(clone("@").append(pointed_type.name))
    type.pointed_type = pointed_type
    return type
}

IR_Struct_Type :: struct : IR_Type {
    base_type: @IR_Struct_Type
    members: @List
    statement: @Struct_Statement
}

IR_Struct_Type_Member :: struct : Object {
    name: @String
    type: @IR_Type
}

create_ir_struct_type :: (name: @String, statement: @Struct_Statement) -> @IR_Struct_Type {
    type: @IR_Struct_Type = new IR_Struct_Type
    type.init(name)
    type.members = create_list()
    type.statement = statement
    return type
}

add_member :: (self: @IR_Struct_Type, name: @String, type: @IR_Type) -> @IR_Struct_Type_Member {
    member: @IR_Struct_Type_Member = new IR_Struct_Type_Member
    member.name = name
    member.type = type
    self.members.append(member)
    return member
}

get_member :: (self: @IR_Struct_Type, name: @String) -> @IR_Struct_Type_Member {
    struct_type: @IR_Struct_Type = self
    loop {
        members: @List_Iterator = struct_type.members.create_iterator()
        while (members.has_next()) {
            member: @IR_Struct_Type_Member = members.next()
            if (member.name.equals(name)) {
                return member
            }
        }
        struct_type = struct_type.base_type
        if (struct_type == null) {
            return null
        }
    }
}

is_base_type :: (self: @IR_Struct_Type, other: @IR_Struct_Type) -> Boolean {
    struct_type: @IR_Struct_Type = other
    loop {
        if (self == struct_type.base_type) {
            return true
        }
        struct_type = struct_type.base_type
        if (struct_type == null) {
            return false
        }
    }
}

is_object_type :: (self: @IR_Struct_Type) -> Boolean {
    struct_type: @IR_Struct_Type = self
    loop {
        if (struct_type.name.equals("Object")) {
            return true
        }
        struct_type = struct_type.base_type
        if (struct_type == null) {
            return false
        }
    }
}

IR_Node :: struct : Object {
}

IR_Value :: struct : IR_Node {
    type: @IR_Type
}

init :: (self: @IR_Value, type: @IR_Type) -> @IR_Value {
    self.type = type
    return self
}

IR_Undefined_Value :: struct : IR_Value {
}

IR_Constant_Value :: struct : IR_Value {
    literal: @Literal_Token
}

create_ir_constant_value :: (type: @IR_Type, literal: @Literal_Token) -> @IR_Constant_Value {
    value: @IR_Constant_Value = new IR_Constant_Value
    value.init(type)
    value.literal = literal
    return value
}

IR_Named_Value :: struct : IR_Value {
    name: @String
    version: Int
}

init :: (self: @IR_Named_Value, type: @IR_Type, name: @String) -> @IR_Named_Value {
    self.init(type)
    self.name = name
    self.version = 0
    return self
}

IR_Temp_Value :: struct : IR_Named_Value {
}

IR_Block :: struct : IR_Node {
    id: Int
    function: @IR_Function
    predecessors: @List
    instructions: @List
}

append :: (self: @IR_Block, instruction: @IR_Instruction) -> Nothing {
    self.instructions.append(instruction)
}

IR_Function :: struct : Object {
    location: @Source_Location
    name: @String
    parameters: @List
    return_type: @IR_Type
    blocks: @List
}

create_block :: (self: @IR_Function) -> @IR_Block {
    block: @IR_Block = new @IR_Block
    block.id = self.blocks.size
    block.function = self
    block.predecessors = create_list()
    block.instructions = create_list()
    self.blocks.append(block)
    return block
}

IR_Variable :: struct : Object {
    name: @String
    type: @IR_Type
    address_value: @IR_Value
}

init :: (self: @IR_Variable, name: @String, type: @IR_Type) -> @IR_Variable {
    self.name = name
    self.type = type
    self.address_value = null
    return self
}

IR_Variable_Value :: struct : IR_Named_Value {
    variable: @IR_Variable
}

create_ir_variable_value :: (variable: @IR_Variable) -> @IR_Variable_Value {
    value: @IR_Variable_Value = new IR_Variable_Value
    value.init(variable.type, variable.name)
    value.variable = variable
    return value
}

IR_Global_Variable :: struct : IR_Variable {
}

create_ir_global_variable :: (name: @String, type: @IR_Type) -> @IR_Global_Variable {
    variable: @IR_Global_Variable = new IR_Global_Variable
    variable.init(name, type)
    return variable
}

IR_Function_Parameter :: struct : IR_Variable {
}

IR_Instruction :: struct : Object {
    result_value: @IR_Value
}

init :: (self: @IR_Instruction, result_value: @IR_Value) -> @IR_Instruction {
    self.result_value = result_value
    return self
}

IR_Call_Instruction :: struct : IR_Instruction {
    function: @IR_Function
    arguments: @List
}

create_ir_call_instruction :: (result_value: @IR_Value, function: @IR_Function, arguments: @List) -> @IR_Call_Instruction {
    instruction: @IR_Call_Instruction = new IR_Call_Instruction
    instruction.init(result_value)
    instruction.function = function
    instruction.arguments = arguments
    return instruction
}

IR_Jump_Instruction :: struct : IR_Instruction {
}

IR_Conditional_Jump_Instruction :: struct : IR_Instruction {
    condition_value: @IR_Value
    true_block: @IR_Block
    false_block: @IR_Block
}

create_ir_jump_instruction :: (condition_value: @IR_Value, true_block: @IR_Block, false_block: @IR_Block) -> @IR_Conditional_Jump_Instruction {
    instruction: @IR_Conditional_Jump_Instruction = new IR_Conditional_Jump_Instruction
    instruction.init(null)
    instruction.condition_value = condition_value
    instruction.true_block = true_block
    instruction.false_block = false_block
    return instruction
}

IR_Direct_Jump_Instruction :: struct : IR_Instruction {
    block: @IR_Block
}

create_ir_jump_instruction :: (block: @IR_Block) -> @IR_Direct_Jump_Instruction {
    instruction: @IR_Direct_Jump_Instruction = new IR_Direct_Jump_Instruction
    instruction.init(null)
    instruction.block = block
    return instruction
}

IR_Load_Array_Item_Instruction :: struct : IR_Instruction {
    array_value: @IR_Value
    index_value: @IR_Value
}

create_ir_load_array_item_instruction :: (result_value: @IR_Value, array_value: @IR_Value, index_value: @IR_Value) -> @IR_Load_Array_Item_Instruction {
    instruction: @IR_Load_Array_Item_Instruction = new IR_Load_Array_Item_Instruction
    instruction.init(result_value)
    instruction.array_value = array_value
    instruction.index_value = index_value
    return instruction
}

IR_Load_Struct_Member_Instruction :: struct : IR_Instruction {
    struct_pointer_value: @IR_Value
    struct_type_member: @IR_Struct_Type_Member
    load_address: Boolean
}

create_ir_load_struct_member_instruction :: (result_value: @IR_Value, struct_pointer_value: @IR_Value, struct_type_member: @IR_Struct_Type_Member, load_address: Boolean) -> @IR_Load_Struct_Member_Instruction {
    instruction: @IR_Load_Struct_Member_Instruction = new IR_Load_Struct_Member_Instruction
    instruction.init(result_value)
    instruction.struct_pointer_value = struct_pointer_value
    instruction.struct_type_member = struct_type_member
    instruction.load_address = load_address
    return instruction
}

IR_New_Instruction :: struct : IR_Instruction {
    type: @IR_Type
}

create_ir_new_instruction :: (result_value: @IR_Value, type: @IR_Type) -> @IR_New_Instruction {
    instruction: @IR_New_Instruction = new IR_New_Instruction
    instruction.init(result_value)
    instruction.type = type
    return instruction
}

IR_Return_Instruction :: struct : IR_Instruction {
    return_value: @IR_Value
}

create_ir_return_instruction :: (return_value: @IR_Value) -> @IR_Return_Instruction {
    instruction: @IR_Return_Instruction = new IR_Return_Instruction
    instruction.init(null)
    instruction.return_value = return_value
    return instruction
}

IR_Set_Instruction :: struct : IR_Instruction {
    value: @IR_Value
}

create_ir_set_instruction :: (result_value: @IR_Value, value: @IR_Value) -> @IR_Set_Instruction {
    instruction: @IR_Set_Instruction = new IR_Set_Instruction
    instruction.init(result_value)
    instruction.value = value
    return instruction
}

IR_Store_Struct_Member_Instruction :: struct : IR_Instruction {
    struct_pointer_value: @IR_Value
    struct_type_member: @IR_Struct_Type_Member
    value: @IR_Value
}

create_ir_store_struct_member_instruction :: (struct_pointer_value: @IR_Value, struct_type_member: @IR_Struct_Type_Member, value: @IR_Value) -> @IR_Store_Struct_Member_Instruction {
    instruction: @IR_Store_Struct_Member_Instruction = new IR_Store_Struct_Member_Instruction
    instruction.init(null)
    instruction.struct_pointer_value = struct_pointer_value
    instruction.struct_type_member = struct_type_member
    instruction.value = value
    return instruction
}

IR_Binary_Instruction :: struct : IR_Instruction {
    left_value: @IR_Value
    right_value: @IR_Value
}

init :: (self: @IR_Binary_Instruction, result_value: @IR_Value, left_value: @IR_Value, right_value: @IR_Value) -> @IR_Binary_Instruction {
    self.init(result_value)
    self.left_value = left_value
    self.right_value = right_value
    return self
}

IR_Comparison_Instruction :: struct : IR_Binary_Instruction {
}

IR_Equals_Comparison_Instruction :: struct : IR_Comparison_Instruction {
}

IR_Logic_And_Instruction :: struct : IR_Binary_Instruction {
}

IR_Not_Equals_Comparison_Instruction :: struct : IR_Comparison_Instruction {
}

\ -------------------------------------------------------------------------------------------------
\       Parser
\ -------------------------------------------------------------------------------------------------

Parser :: struct {
    tokens: @List_Iterator
    compilation_unit: @Compilation_Unit
    current_alignment: Int
    optional_comment: @Matcher
    optional_space: @Matcher
    required_ampersand: @Matcher
    required_as: @Matcher
    required_asterisk: @Matcher
    required_at: @Matcher
    required_break: @Matcher
    required_close_brace: @Matcher
    required_close_bracket: @Matcher
    required_close_paren: @Matcher
    required_colon: @Matcher
    required_comma: @Matcher
    required_comment: @Matcher
    required_dot: @Matcher
    required_else: @Matcher
    required_end_of_file: @Matcher
    required_end_of_line: @Matcher
    required_equals: @Matcher
    required_exclamation_mark: @Matcher
    required_external: @Matcher
    required_greater_than: @Matcher
    required_hyphen: @Matcher
    required_identifier: @Matcher
    required_if: @Matcher
    required_is: @Matcher
    required_less_than: @Matcher
    required_literal: @Matcher
    required_loop: @Matcher
    required_new: @Matcher
    required_open_brace: @Matcher
    required_open_bracket: @Matcher
    required_open_paren: @Matcher
    required_plus: @Matcher
    required_return: @Matcher
    required_slash: @Matcher
    required_struct: @Matcher
    required_vertical_bar: @Matcher
    required_while: @Matcher
}

create_parser :: (tokens: @List) -> @Parser {
    parser: @Parser = new Parser
    parser.tokens = tokens.create_iterator()
    token: @Token = parser.tokens.next()
    parser.compilation_unit = create_compilation_unit(token.location.source)
    parser.current_alignment = 0

    parser.optional_comment = create_comment_matcher(false)
    parser.optional_space = create_space_matcher(false)

    parser.required_ampersand = create_other_matcher(true, "&")
    parser.required_as = create_keyword_matcher(true, "as")
    parser.required_asterisk = create_other_matcher(true, "*")
    parser.required_at = create_other_matcher(true, "@")
    parser.required_break = create_keyword_matcher(true, "break")
    parser.required_close_brace = create_other_matcher(true, "}")
    parser.required_close_bracket = create_other_matcher(true, "]")
    parser.required_close_paren = create_other_matcher(true, ")")
    parser.required_colon = create_other_matcher(true, ":")
    parser.required_comma = create_other_matcher(true, ",")
    parser.required_comment = create_comment_matcher(true)
    parser.required_dot = create_other_matcher(true, ".")
    parser.required_else = create_keyword_matcher(true, "else")
    parser.required_end_of_file = create_end_of_file_matcher(true)
    parser.required_end_of_line = create_end_of_line_matcher(true)
    parser.required_equals = create_other_matcher(true, "=")
    parser.required_exclamation_mark = create_other_matcher(true, "!")
    parser.required_external = create_keyword_matcher(true, "external")
    parser.required_greater_than = create_other_matcher(true, ">")
    parser.required_hyphen = create_other_matcher(true, "-")
    parser.required_identifier = create_identifier_matcher(true)
    parser.required_if = create_keyword_matcher(true, "if")
    parser.required_less_than = create_other_matcher(true, "<")
    parser.required_literal = create_literal_matcher(true)
    parser.required_loop = create_keyword_matcher(true, "loop")
    parser.required_new = create_keyword_matcher(true, "new")
    parser.required_open_brace = create_other_matcher(true, "{")
    parser.required_open_bracket = create_other_matcher(true, "[")
    parser.required_open_paren = create_other_matcher(true, "(")
    parser.required_plus = create_other_matcher(true, "+")
    parser.required_return = create_keyword_matcher(true, "return")
    parser.required_slash = create_other_matcher(true, "/")
    parser.required_struct = create_keyword_matcher(true, "struct")
    parser.required_vertical_bar = create_other_matcher(true, "|")
    parser.required_while = create_keyword_matcher(true, "while")

    return parser
}

parse :: (tokens: @List) -> @Compilation_Unit {
    parser: @Parser = create_parser(tokens)
    parser.compilation_unit.statements = parser.parse_statements()
    token: @Token = parser.tokens.current()
    if ((token.is(End_Of_File_Token)) == false) {
        abort(parser, token)
    }
    return parser.compilation_unit
}

\ statements
\   : ( statement <EOL> )*
parse_statements :: (self: @Parser) -> @List {
    statements: @List = create_list()

    loop {
        statement: @Statement = self.parse_statement()
        if (statement == null) {
            break
        }
        self.consume_end_of_line()
        statements.append(statement)
    }

    return statements
}

\ statement
\   : if
\   | "return" expression?
\   | loop
\   | while
\   | "break"
\   | expression ( "::" ( struct | function ) | ":" value_type? ( "=" expression )? )?
parse_statement :: (self: @Parser) -> @Statement {
    while (self.consume_empty_line()) {
    }

    if (self.matches(self.optional_space, self.required_close_brace) || self.matches(self.required_end_of_file)) {
        return null
    }

    self.consume_space(self.current_alignment * 4)

    if (self.matches(self.required_if)) {
        return self.parse_if()
    }
    if (self.matches(self.required_return)) {
        token: @Token = self.consume(self.required_return)
        value_expression: @Expression = null
        if (self.matches_end_of_line() == false) {
            self.consume_space(1)
            value_expression = self.parse_expression()
        }
        return create_return_statement(token.location, value_expression)
    }
    if (self.matches(self.required_loop)) {
        return self.parse_loop()
    }
    if (self.matches(self.required_while)) {
        return self.parse_while()
    }
    if (self.matches(self.required_break)) {
        token: @Token = self.consume(self.required_break)
        return create_break_statement(token.location)
    }

    expression: @Expression = self.parse_expression()

    if (self.matches(self.optional_space, self.optional_comment, self.required_end_of_line)) {
        return create_expression_statement(expression)
    }

    if (self.matches(self.optional_space, self.required_colon, self.required_colon)) {
        self.consume_space(1)
        self.consume(self.required_colon, self.required_colon)
        self.consume_space(1)
        if (self.matches(self.required_struct)) {
            return self.parse_struct(expression)
        }
        return self.parse_function(expression)
    }

    if (self.matches(self.optional_space, self.required_colon)) {
        if (expression.is(Variable_Expression)) {
            expression: @Variable_Expression = expression
            variable_name: @Identifier_Token = expression.name
            variable_value_type: @Value_Type = null
            variable_value_expression: @Expression = null
            variable_is_external: Boolean = false
            if (self.matches(self.optional_space, self.required_colon, self.required_equals)) {
                self.consume_space(1)
                self.consume(self.required_colon, self.required_equals)
                self.consume_space(1)
                variable_value_expression = self.parse_expression()
            } else {
                self.consume_space(0)
                self.consume(self.required_colon)
                self.consume_space(1)
                variable_value_type = self.parse_value_type()
                if (self.matches(self.optional_space, self.required_equals)) {
                    self.consume_space(1)
                    self.consume(self.required_equals)
                    self.consume_space(1)
                    if (self.matches(self.required_external)) {
                        self.consume(self.required_external)
                        variable_is_external = true
                    } else {
                        variable_value_expression = self.parse_expression()
                    }
                }
            }
            variable_statement: @Variable_Statement = create_variable_statement(variable_name, variable_value_type, variable_value_expression, variable_is_external)
            if (self.current_alignment == 0) {
                self.compilation_unit.global_variables.append(variable_statement)
            }
            return variable_statement
        }
        abort(expression.location, "Cannot use expression as variable name")
    }

    if (self.matches(self.optional_space, self.required_equals)) {
        self.consume_space(1)
        operator: @Other_Token = self.consume(self.required_equals)
        self.consume_space(1)
        return create_assignment_statement(expression, operator, self.parse_expression())
    }

    return null
}

\ struct
\   : "struct" ( ":" IDENTIFIER )? ( "{" <EOL> struct_members "}" )?
parse_struct :: (self: @Parser, name_expression: @Expression) -> @Statement {
    if (name_expression.is(Variable_Expression)) {
        struct_name: @Identifier_Token = (name_expression as @Variable_Expression).name
        self.consume(self.required_struct)
        base_type: @Value_Type
        if (self.matches(self.optional_space, self.required_colon)) {
            self.consume_space(1)
            self.consume(self.required_colon)
            self.consume_space(1)
            base_type = self.parse_value_type()
        } else {
            base_type = null
        }
        struct_members: @List
        if (self.matches(self.optional_space, self.required_open_brace)) {
            struct_members = create_list()
            self.consume_space(1)
            self.consume(self.required_open_brace)
            self.consume_end_of_line()
            self.current_alignment = self.current_alignment + 1
            self.parse_struct_members(struct_members)
            self.current_alignment = self.current_alignment - 1
            self.consume_space(self.current_alignment * 4)
            self.consume(self.required_close_brace)
        } else {
            struct_members = null
        }
        struct_statement: @Struct_Statement = create_struct_statement(struct_name, base_type, struct_members)
        self.compilation_unit.types.append(struct_statement)
        return struct_statement
    } else {
        abort(name_expression.location, "Cannot use expression as struct name")
    }
}

\ struct_members
\   : ( IDENTIFIER ":" value_type <EOL> )*
parse_struct_members :: (self: @Parser, struct_members: @List) -> Nothing {
    loop {
        while (self.consume_empty_line()) {
        }

        if (self.matches(self.optional_space, self.required_identifier)) {
            self.consume_space(self.current_alignment * 4)
            member_name: @Identifier_Token = self.consume(self.required_identifier)
            self.consume_space(0)
            self.consume(self.required_colon)
            self.consume_space(1)
            member_value_type: @Value_Type = self.parse_value_type()
            struct_members.append(create_struct_member(member_name, member_value_type))
        } else {
            break
        }
    }
}

\ function
\   : "(" function_parameters? ")" "->" value_type block?
parse_function :: (self: @Parser, name_expression: @Expression) -> @Statement {
    if (name_expression.is(Variable_Expression)) {
        function_name: @Identifier_Token = (name_expression as @Variable_Expression).name
        self.consume(self.required_open_paren)
        function_parameters: @List
        if (self.matches(self.optional_space, self.required_close_paren)) {
            function_parameters = create_list()
        } else {
            function_parameters = self.parse_function_parameters()
        }
        self.consume_space(0)
        self.consume(self.required_close_paren)
        self.consume_space(1)
        self.consume(self.required_hyphen, self.required_greater_than)
        self.consume_space(1)
        function_return_type: @Value_Type = self.parse_value_type()
        function_body: @Block_Statement
        if (self.matches(self.optional_space, self.required_open_brace)) {
            self.consume_space(1)
            function_body = self.parse_block()
        } else {
            function_body = null
        }
        function_statement: @Function_Statement = create_function_statement(function_name, function_parameters, function_return_type, function_body)
        self.compilation_unit.functions.append(function_statement)
        return function_statement
    } else {
        abort(name_expression.location, "Cannot use expression as function name")
    }
}

\ function_parameters
\   : function_parameter ( "," function_parameter )*
parse_function_parameters :: (self: @Parser) -> @List {
    function_parameters: @List = create_list()
    expected_space: Int = 0
    loop {
        self.consume_space(expected_space)
        function_parameters.append(self.parse_function_parameter())
        if (self.matches(self.optional_space, self.required_comma)) {
            self.consume_space(0)
            self.consume(self.required_comma)
            expected_space = 1
        } else {
            break
        }
    }
    return function_parameters
}

\ function_parameter
\   : IDENTIFIER ":" value_type
parse_function_parameter :: (self: @Parser) -> @Function_Parameter {
    parameter_name: @Identifier_Token = self.consume(self.required_identifier)
    self.consume_space(0)
    self.consume(self.required_colon)
    self.consume_space(1)
    parameter_type: @Value_Type = self.parse_value_type()
    return create_function_parameter(parameter_name, parameter_type)
}

\ block
\   : "{" statements "}"
parse_block :: (self: @Parser) -> @Block_Statement {
    token: @Token = self.consume(self.required_open_brace)
    self.consume_end_of_line()
    self.current_alignment = self.current_alignment + 1
    statements: @List = self.parse_statements()
    self.current_alignment = self.current_alignment - 1
    self.consume_space(self.current_alignment * 4)
    self.consume(self.required_close_brace)
    return create_block_statement(token, statements)
}

\ if
\   : "if" "(" expression ")" block ( "else" block )?
parse_if :: (self: @Parser) -> @Statement {
    token: @Token = self.consume(self.required_if)
    self.consume_space(1)
    self.consume(self.required_open_paren)
    self.consume_space(0)
    condition: @Expression = self.parse_expression()
    self.consume_space(0)
    self.consume(self.required_close_paren)
    self.consume_space(1)
    true_block: @Block_Statement = self.parse_block()
    false_block: @Block_Statement = null
    if (self.matches(self.optional_space, self.required_else)) {
        self.consume_space(1)
        self.consume(self.required_else)
        self.consume_space(1)
        false_block = self.parse_block()
    }
    return create_if_statement(token.location, condition, true_block, false_block)
}

\ loop
\   : "loop" block
parse_loop :: (self: @Parser) -> @Statement {
    token: @Token = self.consume(self.required_loop)
    self.consume_space(1)
    loop_block: @Block_Statement = self.parse_block()
    return create_loop_statement(token.location, loop_block)
}

\ while
\   : "while" "(" expression ")" block
parse_while :: (self: @Parser) -> @Statement {
    token: @Token = self.consume(self.required_while)
    self.consume_space(1)
    self.consume(self.required_open_paren)
    self.consume_space(0)
    condition: @Expression = self.parse_expression()
    self.consume_space(0)
    self.consume(self.required_close_paren)
    self.consume_space(1)
    loop_block: @Block_Statement = self.parse_block()
    return create_while_statement(token.location, condition, loop_block)
}

\ value_type
\   : "@" value_type
\   | IDENTIFIER
\   | "[" value_type ( ";" INTEGER )? "]"
\   | "(" comma_separated_members? ")" "->" value_type
parse_value_type :: (self: @Parser) -> @Value_Type {
    if (self.matches(self.required_at)) {
        token: @Token = self.consume(self.required_at)
        self.consume_space(0)
        value_type: @Value_Type = self.parse_value_type()
        return create_pointer_type(token.location, value_type)
    }
    return create_named_type(self.consume(self.required_identifier) as @Identifier_Token)
}

parse_expression :: (self: @Parser) -> @Expression {
    return self.parse_logic_or_expression()
}

\ logic_or_expression
\   : logic_and_expression ( "||" logic_or_expression )?
parse_logic_or_expression :: (self: @Parser) -> @Expression {
    expression: @Expression = self.parse_logic_and_expression()
    if (self.matches(self.optional_space, self.required_vertical_bar, self.required_vertical_bar)) {
        self.consume_space(1)
        self.consume(self.required_vertical_bar, self.required_vertical_bar)
        self.consume_space(1)
        return new Logic_Or_Expression.init(expression, self.parse_logic_or_expression())
    }
    return expression
}

\ logic_and_expression
\   : equality_expression ( "&&" logic_and_expression )?
parse_logic_and_expression :: (self: @Parser) -> @Expression {
    expression: @Expression = self.parse_equality_expression()
    if (self.matches(self.optional_space, self.required_ampersand, self.required_ampersand)) {
        self.consume_space(1)
        self.consume(self.required_ampersand, self.required_ampersand)
        self.consume_space(1)
        return new Logic_And_Expression.init(expression, self.parse_logic_and_expression())
    }
    return expression
}

\ equality_expression
\   : comparison_expression ( ( "==" | "!=" ) equality_expression )?
parse_equality_expression :: (self: @Parser) -> @Expression {
    expression: @Expression = self.parse_comparison_expression()
    if (self.matches(self.optional_space, self.required_equals, self.required_equals) || self.matches(self.optional_space, self.required_exclamation_mark, self.required_equals)) {
        self.consume_space(1)
        binary_expression: @Binary_Expression
        if (self.matches(self.required_equals)) {
            self.consume(self.required_equals)
            binary_expression = new Equals_Expression
        } else {
            self.consume(self.required_exclamation_mark)
            binary_expression = new Not_Equals_Expression
        }
        self.consume(self.required_equals)
        self.consume_space(1)
        return binary_expression.init(expression, self.parse_equality_expression())
    }
    return expression
}

\ comparison_expression
\   : addition_expression ( ( "<" | "<=" | ">" | ">=" ) comparison_expression )?
parse_comparison_expression :: (self: @Parser) -> @Expression {
    expression: @Expression = self.parse_addition_expression()
    if (self.matches(self.optional_space, self.required_less_than) || self.matches(self.optional_space, self.required_greater_than)) {
        self.consume_space(1)
        binary_expression: @Binary_Expression
        if (self.matches(self.required_less_than)) {
            self.consume(self.required_less_than)
            if (self.matches(self.required_equals)) {
                self.consume(self.required_equals)
                binary_expression = new Less_Than_Or_Equals_Expression
            } else {
                binary_expression = new Less_Than_Expression
            }
        } else {
            self.consume(self.required_greater_than)
            if (self.matches(self.required_equals)) {
                self.consume(self.required_equals)
                binary_expression = new Greater_Than_Or_Equals_Expression
            } else {
                binary_expression = new Greater_Than_Expression
            }
        }
        self.consume_space(1)
        return binary_expression.init(expression, self.parse_comparison_expression())
    }
    return expression
}

\ addition_expression
\   : multiplication_expression ( ( "+" | "-" ) addition_expression )?
parse_addition_expression :: (self: @Parser) -> @Expression {
    expression: @Expression = self.parse_multiplication_expression()
    if (self.matches(self.optional_space, self.required_plus) || self.matches(self.optional_space, self.required_hyphen)) {
        self.consume_space(1)
        binary_expression: @Binary_Expression
        if (self.matches(self.required_plus)) {
            self.consume(self.required_plus)
            binary_expression = new Add_Expression
        } else {
            self.consume(self.required_hyphen)
            binary_expression = new Substract_Expression
        }
        self.consume_space(1)
        return binary_expression.init(expression, self.parse_addition_expression())
    }
    return expression
}

\ multiplication_expression
\   : unary_expression ( ( "*" | "/" | "//" ) multiplication_expression )?
parse_multiplication_expression :: (self: @Parser) -> @Expression {
    expression: @Expression = self.parse_unary_expression()
    if (self.matches(self.optional_space, self.required_asterisk) || self.matches(self.optional_space, self.required_slash)) {
        self.consume_space(1)
        binary_expression: @Binary_Expression
        if (self.matches(self.required_slash)) {
            self.consume(self.required_slash)
            if (self.matches(self.required_slash)) {
                self.consume(self.required_slash)
                binary_expression = new Modulo_Expression
            } else {
                binary_expression = new Divide_Expression
            }
        } else {
            self.consume(self.required_asterisk)
            binary_expression = new Multiply_Expression
        }
        self.consume_space(1)
        return binary_expression.init(expression, self.parse_multiplication_expression())
    }
    return expression
}

parse_unary_expression :: (self: @Parser) -> @Expression {
    return self.parse_cast_expression()
}

\ cast_expression
\   : access_expression ( "as" value_type )?
parse_cast_expression :: (self: @Parser) -> @Expression {
    expression: @Expression = self.parse_access_expression()
    if (self.matches(self.optional_space, self.required_as)) {
        self.consume_space(1)
        self.consume(self.required_as)
        self.consume_space(1)
        value_type: @Value_Type = self.parse_value_type()
        return create_cast_expression(expression, value_type)
    }
    return expression
}

\ access_expression
\   : primary_expression ( "." IDENTIFIER | "(" call_arguments? ")" | "[" expression "]" )*
parse_access_expression :: (self: @Parser) -> @Expression {
    expression: @Expression = self.parse_primary_expression()
    loop {
        old_expression: @Expression = expression
        if (self.matches(self.optional_space, self.required_dot)) {
            self.consume_space(0)
            self.consume(self.required_dot)
            self.consume_space(0)
            expression = create_member_access_expression(expression, self.consume(self.required_identifier) as @Identifier_Token)
        }
        if (self.matches(self.optional_space, self.required_open_paren)) {
            self.consume_space(0)
            self.consume(self.required_open_paren)
            self.consume_space(0)
            call_arguments: @List = create_list()
            if (self.matches(self.optional_space, self.required_close_paren) == false) {
                self.parse_call_arguments(call_arguments)
            }
            self.consume_space(0)
            self.consume(self.required_close_paren)
            expression = create_call_expression(expression, call_arguments)
        }
        if (self.matches(self.optional_space, self.required_open_bracket)) {
            self.consume_space(0)
            self.consume(self.required_open_bracket)
            self.consume_space(0)
            index_expression: @Expression = self.parse_expression()
            self.consume_space(0)
            self.consume(self.required_close_bracket)
            expression = create_array_access_expression(expression, index_expression)
        }
        if (expression == old_expression) {
            break
        }
    }
    return expression
}

\ call_arguments
\   : expression ( "," expression )*
parse_call_arguments :: (self: @Parser, call_arguments: @List) -> Nothing {
    call_arguments.append(self.parse_expression())
    while (self.matches(self.optional_space, self.required_comma)) {
        self.consume_space(0)
        self.consume(self.required_comma)
        self.consume_space(1)
        call_arguments.append(self.parse_expression())
    }
}

\ primary_expression
\   : IDENTIFIER
\   | INTEGER
\   | STRING
\   | CHARACTER
\   | "null"
\   | "false"
\   | "true"
\   | "(" expression ")"
\   | "new" value_type
parse_primary_expression :: (self: @Parser) -> @Expression {
    if (self.matches(self.required_identifier)) {
        return create_variable_expression(self.consume(self.required_identifier) as @Identifier_Token)
    }
    if (self.matches(self.required_literal)) {
        return create_literal_expression(self.consume(self.required_literal) as @Literal_Token)
    }
    if (self.matches(self.required_open_paren)) {
        self.consume(self.required_open_paren)
        self.consume_space(0)
        expression: @Expression = self.parse_expression()
        self.consume_space(0)
        self.consume(self.required_close_paren)
        return expression
    }
    if (self.matches(self.required_new)) {
        token: @Token = self.consume(self.required_new)
        self.consume_space(1)
        value_type: @Value_Type = self.parse_value_type()
        return create_new_expression(token.location, value_type)
    }
    return null
}

abort :: (self: @Parser, unexpected_token: @Token) -> Nothing {
    stderr.write(unexpected_token.location).write(": Unexpected token: ").write(unexpected_token).end_line()
    abort()
}

consume_end_of_line :: (self: @Parser) -> Nothing {
    if (self.matches(self.optional_space, self.required_comment)) {
        self.consume_space(1)
        self.consume(self.required_comment)
    } else {
        self.consume_space(0)
    }
    self.consume(self.required_end_of_line)
}

consume_empty_line :: (self: @Parser) -> Boolean {
    if (self.matches(self.optional_space, self.optional_comment, self.required_end_of_line)) {
        if (self.matches(self.optional_space, self.required_comment)) {
            self.consume_space(self.current_alignment * 4)
            self.consume(self.required_comment)
        } else {
            self.consume_space(0)
        }
        self.consume(self.required_end_of_line)
        return true
    }
    return false
}

consume_space :: (self: @Parser, expected_space_count: Int) -> Nothing {
    space_count: Int
    token: @Token = self.tokens.current()
    if (token.is(Space_Token)) {
        self.tokens.next()
        space: @Space_Token = token
        space_count = space.count
    } else {
        space_count = 0
    }
    if (space_count != expected_space_count) {
        stderr.write(token.location).write(": Consumed ").write(space_count).write(" spaces where ").write(expected_space_count).write(" are expected").end_line()
    }
}

consume :: (self: @Parser, first_matcher: @Matcher) -> @Token {
    return self.consume(first_matcher, null)
}

consume :: (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher) -> @Token {
    return self.consume(first_matcher, second_matcher, null)
}

consume :: (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher, third_matcher: @Matcher) -> @Token {
    token: @Token = self.tokens.current()
    first_token: @Token = token
    if (first_matcher.accepts(token)) {
        token = self.tokens.next() as @Token
    } else {
        if (first_matcher.is_required) {
            self.abort(token)
        }
    }
    if (second_matcher != null) {
        if (second_matcher.accepts(token)) {
            token = self.tokens.next() as @Token
        } else {
            if (second_matcher.is_required) {
                self.abort(token)
            }
        }
    }
    if (third_matcher != null) {
        if (third_matcher.accepts(token)) {
            token = self.tokens.next() as @Token
        } else {
            if (third_matcher.is_required) {
                self.abort(token)
            }
        }
    }
    return first_token
}

matches_end_of_line :: (self: @Parser) -> Boolean {
    return self.matches(self.optional_space, self.optional_comment, self.required_end_of_line)
}

matches :: (self: @Parser, first_matcher: @Matcher) -> Boolean {
    return self.matches(first_matcher, null)
}

matches :: (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher) -> Boolean {
    return self.matches(first_matcher, second_matcher, null)
}

matches :: (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher, third_matcher: @Matcher) -> Boolean {
    self.tokens.save_state()
    token: @Token = self.tokens.current()
    if (first_matcher.accepts(token)) {
        token = self.tokens.next() as @Token
    } else {
        if (first_matcher.is_required) {
            self.tokens.restore_state()
            return false
        }
    }
    if (second_matcher != null) {
        if (second_matcher.accepts(token)) {
            token = self.tokens.next() as @Token
        } else {
            if (second_matcher.is_required) {
                self.tokens.restore_state()
                return false
            }
        }
    }
    if (third_matcher != null) {
        if (third_matcher.accepts(token)) {
            token = self.tokens.next() as @Token
        } else {
            if (third_matcher.is_required) {
                self.tokens.restore_state()
                return false
            }
        }
    }
    self.tokens.restore_state()
    return true
}

Matcher :: struct : Object {
    is_required: Boolean
}

Comment_Matcher :: struct : Matcher {
}

create_comment_matcher :: (required: Boolean) -> @Comment_Matcher {
    matcher: @Comment_Matcher = new Comment_Matcher
    matcher.is_required = required
    return matcher
}

End_Of_File_Matcher :: struct : Matcher {
}

create_end_of_file_matcher :: (required: Boolean) -> @End_Of_File_Matcher {
    matcher: @End_Of_File_Matcher = new End_Of_File_Matcher
    matcher.is_required = required
    return matcher
}

End_Of_Line_Matcher :: struct : Matcher {
}

create_end_of_line_matcher :: (required: Boolean) -> @End_Of_Line_Matcher {
    matcher: @End_Of_Line_Matcher = new End_Of_Line_Matcher
    matcher.is_required = required
    return matcher
}

Identifier_Matcher :: struct : Matcher {
}

create_identifier_matcher :: (required: Boolean) -> @Identifier_Matcher {
    matcher: @Identifier_Matcher = new Identifier_Matcher
    matcher.is_required = required
    return matcher
}

Keyword_Matcher :: struct : Matcher {
    lexeme: @String
}

create_keyword_matcher :: (required: Boolean, lexeme: @String) -> @Keyword_Matcher {
    matcher: @Keyword_Matcher = new Keyword_Matcher
    matcher.is_required = required
    matcher.lexeme = lexeme
    return matcher
}

Literal_Matcher :: struct : Matcher {
}

create_literal_matcher :: (required: Boolean) -> @Literal_Matcher {
    matcher: @Literal_Matcher = new Literal_Matcher
    matcher.is_required = required
    return matcher
}

Other_Matcher :: struct : Matcher {
    lexeme: @String
}

create_other_matcher :: (required: Boolean, lexeme: @String) -> @Other_Matcher {
    matcher: @Other_Matcher = new Other_Matcher
    matcher.is_required = required
    matcher.lexeme = lexeme
    return matcher
}

Space_Matcher :: struct : Matcher {
}

create_space_matcher :: (required: Boolean) -> @Space_Matcher {
    matcher: @Space_Matcher = new Space_Matcher
    matcher.is_required = required
    return matcher
}

accepts :: (self: @Matcher, token: @Token) -> Boolean {
    if (self.is(Other_Matcher)) {
        self: @Other_Matcher = self
        if (token.is(Other_Token)) {
            return token.lexeme.equals(self.lexeme)
        }
        return false
    }
    if (self.is(Space_Matcher)) {
        return token.is(Space_Token)
    }
    if (self.is(Identifier_Matcher)) {
        return token.is(Identifier_Token)
    }
    if (self.is(Keyword_Matcher)) {
        self: @Keyword_Matcher = self
        if (token.is(Keyword_Token)) {
            return token.lexeme.equals(self.lexeme)
        }
        return false
    }
    if (self.is(Literal_Matcher)) {
        return token.is(Integer_Token) || token.is(String_Token) || token.is(Character_Token) || token.is(Boolean_Token) || token.is(Null_Token)
    }
    if (self.is(End_Of_Line_Matcher)) {
        return token.is(End_Of_Line_Token)
    }
    if (self.is(Comment_Matcher)) {
        return token.is(Comment_Token)
    }
    if (self.is(End_Of_File_Matcher)) {
        return token.is(End_Of_File_Token)
    }
    stderr.write("Unsupported token matcher").end_line()
    abort()
}

\ -------------------------------------------------------------------------------------------------
\       AST
\ -------------------------------------------------------------------------------------------------

Compilation_Unit :: struct {
    source: @Source
    types: @List
    global_variables: @List
    functions: @List
    statements: @List
}

create_compilation_unit :: (source: @Source) -> @Compilation_Unit {
    compilation_unit: @Compilation_Unit = new Compilation_Unit
    compilation_unit.source = source
    compilation_unit.types = create_list()
    compilation_unit.global_variables = create_list()
    compilation_unit.functions = create_list()
    compilation_unit.statements = null
    return compilation_unit
}

Statement :: struct : Object {
    location: @Source_Location
}

Function_Statement :: struct : Statement {
    name: @Identifier_Token
    parameters: @List
    return_type: @Value_Type
    body: @Block_Statement
    ir_function: @IR_Function
}

create_function_statement :: (name: @Identifier_Token, parameters: @List, return_type: @Value_Type, body: @Block_Statement) -> @Function_Statement {
    function_statement: @Function_Statement = new Function_Statement
    function_statement.location = name.location
    function_statement.name = name
    function_statement.parameters = parameters
    function_statement.return_type = return_type
    function_statement.body = body
    function_statement.ir_function = null
    return function_statement
}

Function_Parameter :: struct {
    location: @Source_Location
    name: @Identifier_Token
    value_type: @Value_Type
}

create_function_parameter :: (name: @Identifier_Token, value_type: @Value_Type) -> @Function_Parameter {
    function_parameter: @Function_Parameter = new Function_Parameter
    function_parameter.location = name.location
    function_parameter.name = name
    function_parameter.value_type = value_type
    return function_parameter
}

Block_Statement :: struct : Statement {
    statements: @List
}

create_block_statement :: (open_brace: @Token, statements: @List) -> @Block_Statement {
    block_statement: @Block_Statement = new Block_Statement
    block_statement.location = open_brace.location
    block_statement.statements = statements
    return block_statement
}

Expression_Statement :: struct : Statement {
    expression: @Expression
}

create_expression_statement :: (expression: @Expression) -> @Expression_Statement {
    statement: @Expression_Statement = new Expression_Statement
    statement.location = expression.location
    statement.expression = expression
    return statement
}

If_Statement :: struct : Statement {
    condition: @Expression
    true_block: @Block_Statement
    false_block: @Block_Statement
}

create_if_statement :: (location: @Source_Location, condition: @Expression, true_block: @Block_Statement, false_block: @Block_Statement) -> @If_Statement {
    statement: @If_Statement = new If_Statement
    statement.location = location
    statement.condition = condition
    statement.true_block = true_block
    statement.false_block = false_block
    return statement
}

Loop_Statement :: struct : Statement {
    block: @Block_Statement
}

create_loop_statement :: (location: @Source_Location, block: @Block_Statement) -> @Loop_Statement {
    statement: @Loop_Statement = new Loop_Statement
    statement.location = location
    statement.block = block
    return statement
}

While_Statement :: struct : Statement {
    condition: @Expression
    block: @Block_Statement
}

create_while_statement :: (location: @Source_Location, condition: @Expression, block: @Block_Statement) -> @While_Statement {
    statement: @While_Statement = new While_Statement
    statement.location = location
    statement.condition = condition
    statement.block = block
    return statement
}

Break_Statement :: struct : Statement {
}

create_break_statement :: (location: @Source_Location) -> @Break_Statement {
    statement: @Break_Statement = new Break_Statement
    statement.location = location
    return statement
}

Return_Statement :: struct : Statement {
    value_expression: @Expression
}

create_return_statement :: (location: @Source_Location, value_expression: @Expression) -> @Return_Statement {
    statement: @Return_Statement = new Return_Statement
    statement.location = location
    statement.value_expression = value_expression
    return statement
}

Variable_Statement :: struct : Statement {
    name: @Identifier_Token
    value_type: @Value_Type
    value_expression: @Expression
    is_external: Boolean
}

create_variable_statement :: (name: @Identifier_Token, value_type: @Value_Type, value_expression: @Expression, is_external: Boolean) -> @Variable_Statement {
    statement: @Variable_Statement = new Variable_Statement
    statement.location = name.location
    statement.name = name
    statement.value_type = value_type
    statement.value_expression = value_expression
    statement.is_external = is_external
    return statement
}

Struct_Statement :: struct : Statement {
    name: @Identifier_Token
    base_type: @Value_Type
    members: @List
}

create_struct_statement :: (name: @Identifier_Token, base_type: @Value_Type, members: @List) -> @Struct_Statement {
    statement: @Struct_Statement = new Struct_Statement
    statement.location = name.location
    statement.name = name
    statement.base_type = base_type
    statement.members = members
    return statement
}

Struct_Member :: struct {
    location: @Source_Location
    name: @Identifier_Token
    value_type: @Value_Type
}

create_struct_member :: (name: @Identifier_Token, value_type: @Value_Type) -> @Struct_Member {
    struct_member: @Struct_Member = new Struct_Member
    struct_member.location = name.location
    struct_member.name = name
    struct_member.value_type = value_type
    return struct_member
}

Assignment_Statement :: struct : Statement {
    destination: @Expression
    operator: @Other_Token
    value_expression: @Expression
}

create_assignment_statement :: (destination: @Expression, operator: @Other_Token, value_expression: @Expression) -> @Assignment_Statement {
    statement: @Assignment_Statement = new Assignment_Statement
    statement.location = destination.location
    statement.destination = destination
    statement.operator = operator
    statement.value_expression = value_expression
    return statement
}

Value_Type :: struct : Object {
    location: @Source_Location
}

Named_Type :: struct : Value_Type {
    name: @Identifier_Token
}

create_named_type :: (name: @Identifier_Token) -> @Value_Type {
    named_type: @Named_Type = new Named_Type
    named_type.location = name.location
    named_type.name = name
    return named_type
}

Pointer_Type :: struct : Value_Type {
    value_type: @Value_Type
}

create_pointer_type :: (location: @Source_Location, value_type: @Value_Type) -> @Pointer_Type {
    pointer_type: @Pointer_Type = new Pointer_Type
    pointer_type.location = location
    pointer_type.value_type = value_type
    return pointer_type
}

Expression :: struct : Object {
    location: @Source_Location
}

Literal_Expression :: struct : Expression {
    literal: @Literal_Token
}

create_literal_expression :: (literal: @Literal_Token) -> @Literal_Expression {
    expression: @Literal_Expression = new Literal_Expression
    expression.location = literal.location
    expression.literal = literal
    return expression
}

Variable_Expression :: struct : Expression {
    name: @Identifier_Token
}

create_variable_expression :: (name: @Identifier_Token) -> @Variable_Expression {
    expression: @Variable_Expression = new Variable_Expression
    expression.location = name.location
    expression.name = name
    return expression
}

Binary_Expression :: struct : Expression {
    left_expression: @Expression
    right_expression: @Expression
}

init :: (self: @Binary_Expression, left_expression: @Expression, right_expression: @Expression) -> @Binary_Expression {
    self.location = left_expression.location
    self.left_expression = left_expression
    self.right_expression = right_expression
    return self
}

Add_Expression :: struct : Binary_Expression {
}

Divide_Expression :: struct : Binary_Expression {
}

Equals_Expression :: struct : Binary_Expression {
}

Greater_Than_Expression :: struct : Binary_Expression {
}

Greater_Than_Or_Equals_Expression :: struct : Binary_Expression {
}

Less_Than_Expression :: struct : Binary_Expression {
}

Less_Than_Or_Equals_Expression :: struct : Binary_Expression {
}

Logic_And_Expression :: struct : Binary_Expression {
}

Logic_Or_Expression :: struct : Binary_Expression {
}

Modulo_Expression :: struct : Binary_Expression {
}

Multiply_Expression :: struct : Binary_Expression {
}

Not_Equals_Expression :: struct : Binary_Expression {
}

Substract_Expression :: struct : Binary_Expression {
}

Cast_Expression :: struct : Expression {
    value_expression: @Expression
    value_type: @Value_Type
}

create_cast_expression :: (value_expression: @Expression, value_type: @Value_Type) -> @Cast_Expression {
    expression: @Cast_Expression = new Cast_Expression
    expression.location = value_expression.location
    expression.value_expression = value_expression
    expression.value_type = value_type
    return expression
}

Is_Expression :: struct : Expression {
    value_expression: @Expression
    value_type: @Value_Type
}

create_is_expression :: (value_expression: @Expression, value_type: @Value_Type) -> @Is_Expression {
    expression: @Is_Expression = new Is_Expression
    expression.location = value_expression.location
    expression.value_expression = value_expression
    expression.value_type = value_type
    return expression
}

New_Expression :: struct : Expression {
    value_type: @Value_Type
}

create_new_expression :: (location: @Source_Location, value_type: @Value_Type) -> @New_Expression {
    expression: @New_Expression = new New_Expression
    expression.location = location
    expression.value_type = value_type
    return expression
}

Call_Expression :: struct : Expression {
    callee: @Expression
    arguments: @List
}

create_call_expression :: (callee: @Expression, arguments: @List) -> @Call_Expression {
    expression: @Call_Expression = new Call_Expression
    expression.location = callee.location
    expression.callee = callee
    expression.arguments = arguments
    return expression
}

Access_Expression :: struct : Expression {
}

Member_Access_Expression :: struct : Access_Expression {
    object: @Expression
    member_name: @Identifier_Token
}

create_member_access_expression :: (object: @Expression, member_name: @Identifier_Token) -> @Member_Access_Expression {
    expression: @Member_Access_Expression = new Member_Access_Expression
    expression.location = object.location
    expression.object = object
    expression.member_name = member_name
    return expression
}

Array_Access_Expression :: struct : Access_Expression {
    object: @Expression
    index_expression: @Expression
}

create_array_access_expression :: (object: @Expression, index_expression: @Expression) -> @Array_Access_Expression {
    expression: @Array_Access_Expression = new Array_Access_Expression
    expression.location = object.location
    expression.object = object
    expression.index_expression = index_expression
    return expression
}

write :: (file: @FILE, compilation_unit: @Compilation_Unit) -> @FILE {
    statements: @List_Iterator = compilation_unit.statements.create_iterator()
    while (statements.has_next()) {
        statement: @Statement = statements.next()
        file.write_source_line(statement.location, 0).write(statement, 0).end_line()
    }
    return file
}

write :: (file: @FILE, statement: @Statement, alignment: Int) -> @FILE {
    if (statement.is(Assignment_Statement)) {
        statement: @Assignment_Statement = statement
        return file.write(statement.destination).write(' ').write(statement.operator).write(' ').write(statement.value_expression)
    }

    if (statement.is(Block_Statement)) {
        file.write('{').end_line()
        block_statements: @List_Iterator = (statement as @Block_Statement).statements.create_iterator()
        while (block_statements.has_next()) {
            block_statement: @Statement = block_statements.next()
            file.write_source_line(block_statement.location, alignment + 1).write(block_statement, alignment + 1).end_line()
        }
        return file.write_source_line(statement.location, alignment).write('}')
    }

    if (statement.is(Break_Statement)) {
        return file.write("break")
    }

    if (statement.is(Expression_Statement)) {
        return file.write((statement as @Expression_Statement).expression)
    }

    if (statement.is(Function_Statement)) {
        statement: @Function_Statement = statement
        file.write(statement.name).write(" :: (")
        function_parameters: @List_Iterator = statement.parameters.create_iterator()
        if (function_parameters.has_next()) {
            loop {
                file.write(function_parameters.next() as @Function_Parameter)
                if (function_parameters.has_next()) {
                    file.write(", ")
                } else {
                    break
                }
            }
        }
        file.write(") -> ").write(statement.return_type)
        if (statement.body == null) {
            return file
        }
        return file.write(" ").write(statement.body, alignment)
    }

    if (statement.is(If_Statement)) {
        statement: @If_Statement = statement
        file.write("if (").write(statement.condition).write(") ").write(statement.true_block, alignment)
        if (statement.false_block != null) {
            file.write(" else ").write(statement.false_block, alignment)
        }
        return file
    }

    if (statement.is(Loop_Statement)) {
        statement: @Loop_Statement = statement
        return file.write("loop ").write(statement.block, alignment)
    }

    if (statement.is(Return_Statement)) {
        statement: @Return_Statement = statement
        file.write("return")
        if (statement.value_expression != null) {
            file.write(" ").write(statement.value_expression)
        }
        return file
    }

    if (statement.is(Struct_Statement)) {
        statement: @Struct_Statement = statement
        file.write(statement.name).write(" :: struct")
        if (statement.base_type != null) {
            file.write(" : ").write(statement.base_type)
        }
        if (statement.members == null) {
            return file
        }
        file.write(" {").end_line()
        members: @List_Iterator = statement.members.create_iterator()
        while (members.has_next()) {
            member: @Struct_Member = members.next()
            file.write_source_line(member.location, alignment + 1).write(member.name).write(": ").write(member.value_type).end_line()
        }
        return file.write_source_line(statement.location, alignment).write('}')
    }

    if (statement.is(Variable_Statement)) {
        statement: @Variable_Statement = statement
        file.write((statement as @Variable_Statement).name)
        if (statement.value_type != null) {
            file.write(": ").write(statement.value_type)
            if (statement.value_expression != null) {
                file.write(" = ").write(statement.value_expression)
            }
            if (statement.is_external) {
                file.write(" = external")
            }
        } else {
            file.write(" := ").write(statement.value_expression)
        }
        return file
    }

    if (statement.is(While_Statement)) {
        statement: @While_Statement = statement
        return file.write("while (").write(statement.condition).write(") ").write(statement.block, alignment)
    }

    file.fflush()
    abort(statement.location, "Unsupported Statement type: ".clone().append(statement.object_type.id))
}

write_source_line :: (file: @FILE, location: @Source_Location, alignment: Int) -> @FILE {
    file.write(location.source.file_name).write(':')
    line: Int = location.line
    if (line < 1000) {
        file.write('0')
    }
    if (line < 100) {
        file.write('0')
    }
    if (line < 10) {
        file.write('0')
    }
    file.write(line).write(": ")

    space_count: Int = alignment * 2
    while (space_count > 0) {
        file.write(' ')
        space_count = space_count - 1
    }

    return file
}

write :: (file: @FILE, parameter: @Function_Parameter) -> @FILE {
    return file.write(parameter.name).write(": ").write(parameter.value_type)
}

write :: (file: @FILE, value_type: @Value_Type) -> @FILE {
    if (value_type.is(Named_Type)) {
        return file.write((value_type as @Named_Type).name)
    }

    if (value_type.is(Pointer_Type)) {
        return file.write('@').write((value_type as @Pointer_Type).value_type)
    }

    file.fflush()
    abort(value_type.location, "Unsupported Value_Type type: ".clone().append(value_type.object_type.id))
}

write :: (file: @FILE, expression: @Expression) -> @FILE {
    if (expression.is(Array_Access_Expression)) {
        return file.write((expression as @Array_Access_Expression).object).write('[').write((expression as @Array_Access_Expression).index_expression).write(']')
    }

    if (expression.is(Binary_Expression)) {
        file.write((expression as @Binary_Expression).left_expression)
        if (expression.is(Add_Expression)) {
            return file.write(" + ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression.is(Divide_Expression)) {
            return file.write(" / ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression.is(Equals_Expression)) {
            return file.write(" == ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression.is(Greater_Than_Expression)) {
            return file.write(" > ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression.is(Greater_Than_Or_Equals_Expression)) {
            return file.write(" >= ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression.is(Less_Than_Expression)) {
            return file.write(" < ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression.is(Less_Than_Or_Equals_Expression)) {
            return file.write(" <= ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression.is(Logic_And_Expression)) {
            return file.write(" && ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression.is(Logic_Or_Expression)) {
            return file.write(" || ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression.is(Modulo_Expression)) {
            return file.write(" // ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression.is(Multiply_Expression)) {
            return file.write(" * ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression.is(Not_Equals_Expression)) {
            return file.write(" != ").write((expression as @Binary_Expression).right_expression)
        }
        if (expression.is(Substract_Expression)) {
            return file.write(" - ").write((expression as @Binary_Expression).right_expression)
        }
    }

    if (expression.is(Call_Expression)) {
        file.write((expression as @Call_Expression).callee).write('(')
        call_arguments: @List_Iterator = (expression as @Call_Expression).arguments.create_iterator()
        if (call_arguments.has_next()) {
            loop {
                file.write(call_arguments.next() as @Expression)
                if (call_arguments.has_next()) {
                    file.write(", ")
                } else {
                    break
                }
            }
        }
        return file.write(')')
    }

    if (expression.is(Cast_Expression)) {
        return file.write((expression as @Cast_Expression).value_expression).write(" as ").write((expression as @Cast_Expression).value_type)
    }

    if (expression.is(Is_Expression)) {
        return file.write((expression as @Is_Expression).value_expression).write(" is ").write((expression as @Is_Expression).value_type)
    }

    if (expression.is(Literal_Expression)) {
        return file.write((expression as @Literal_Expression).literal)
    }

    if (expression.is(New_Expression)) {
        return file.write("new ").write((expression as @New_Expression).value_type)
    }

    if (expression.is(Member_Access_Expression)) {
        return file.write((expression as @Member_Access_Expression).object).write('.').write((expression as @Member_Access_Expression).member_name)
    }

    if (expression.is(Variable_Expression)) {
        return file.write((expression as @Variable_Expression).name)
    }

    file.fflush()
    abort(expression.location, "Unsupported Expression type: ".clone().append(expression.object_type.id))
}

abort :: (location: @Source_Location, message: @String) -> Nothing {
    stderr.end_line().write(location).write(": ").write(message).end_line()
    abort()
}

\ -------------------------------------------------------------------------------------------------
\       Scanner
\ -------------------------------------------------------------------------------------------------

scan :: (file_name: @String) -> @List {
    scanner: @Scanner = create_scanner(create_source(file_name))
    tokens: @List = create_list()

    loop {
        token: @Token = scanner.next_token()
        tokens.append(token)
        if (token.is(End_Of_File_Token)) {
            break
        }
    }

    \ tokens: @List_Iterator = tokens.create_iterator()
    \ while (tokens.has_next()) {
    \     token: @Token = tokens.next() as @Token
    \     if (token.is(End_Of_Line_Token)) {
    \         stdout.end_line()
    \     } else {
    \         stdout.write(token)
    \     }
    \ }

    return tokens
}

Scanner :: struct {
    source: @Source
    current_char_index: Int
    current_line: Int
    current_column: Int
}

create_scanner :: (source: @Source) -> @Scanner {
    scanner: @Scanner = new Scanner
    scanner.source = source
    scanner.current_char_index = 0
    scanner.current_line = 1
    scanner.current_column = 1
    return scanner
}

peek_char :: (self: @Scanner) -> Int8 {
    return self.source.content[self.current_char_index]
}

next_char :: (self: @Scanner) -> Int8 {
    next_char: Int8 = self.source.content[self.current_char_index]
    if (next_char != '\0') {
        self.current_char_index = self.current_char_index + 1
        if (next_char == '\n') {
            self.current_line = self.current_line + 1
            self.current_column = 1
        } else {
            self.current_column = self.current_column + 1
        }
    }
    return next_char
}

next_token :: (self: @Scanner) -> @Token {
    token_lexeme: @String = new String
    token_lexeme.init()

    token_location: @Source_Location = new Source_Location
    token_location.source = self.source
    token_location.line = self.current_line
    token_location.column = self.current_column

    next_char: Int8 = self.peek_char()
    if (next_char.is_identifier_start()) {
        return self.scan_identifier_token(token_lexeme, token_location)
    }
    if (next_char.is_digit()) {
        return self.scan_integer_token(token_lexeme, token_location)
    }
    if (next_char == '\'') {
        return self.scan_character_token(token_lexeme, token_location)
    }
    if (next_char == '"') {
        return self.scan_string_token(token_lexeme, token_location)
    }
    if (next_char == '\\') {
        return self.scan_comment_token(token_lexeme, token_location)
    }
    if (next_char.is_space()) {
        return self.scan_space_token(token_lexeme, token_location)
    }
    if (next_char == '\n') {
        self.next_char()
        return create_end_of_line_token(token_lexeme, token_location)
    }
    if (next_char == '\0') {
        self.next_char()
        return create_end_of_file_token(token_lexeme, token_location)
    }
    token_lexeme.append(self.next_char())
    return create_other_token(token_lexeme, token_location)
}

is_digit :: (char: Int8) -> Boolean {
    return char as Int >= '0' as Int && char as Int <= '9' as Int
}

is_identifier_start :: (char: Int8) -> Boolean {
    return char.is_letter() || char == '_'
}

is_identifier_body :: (char: Int8) -> Boolean {
    if (char.is_identifier_start()) {
        return true
    }
    return char.is_digit()
}

is_letter :: (char: Int8) -> Boolean {
    return (char as Int >= 'a' as Int && char as Int <= 'z' as Int) || (char as Int >= 'A' as Int && char as Int <= 'Z' as Int)
}

is_space :: (char: Int8) -> Boolean {
    return char == ' '
}

scan_character_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    if (self.peek_char() == '\'') {
        token_lexeme.append(self.next_char())
        char: Int8 = self.next_char()
        token_lexeme.append(char)
        if (char == '\'') {
            return create_error_token(token_lexeme, token_location)
        }
        if (char == '\\') {
            char = self.next_char()
            token_lexeme.append(char)
            if (char.is_escape() == false) {
                return create_error_token(token_lexeme, token_location)
            }
            char = self.next_char()
            token_lexeme.append(char)
            if (char != '\'') {
                return create_error_token(token_lexeme, token_location)
            }
        } else {
            if (char == '\0' || char == '\n' || char == '\t') {
                return create_error_token(token_lexeme, token_location)
            }
            char = self.next_char()
            token_lexeme.append(char)
            if (char != '\'') {
                return create_error_token(token_lexeme, token_location)
            }
        }
    }
    return create_character_token(token_lexeme, token_location)
}

is_escape :: (char: Int8) -> Boolean {
    return char == 'n' || char == 't' || char == '\"' || char == '\'' || char == '\\' || char == '0'
}

scan_comment_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    while (self.peek_char() != '\n') {
        token_lexeme.append(self.next_char())
    }
    return create_comment_token(token_lexeme, token_location)
}

scan_identifier_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    while (self.peek_char().is_identifier_body()) {
        token_lexeme.append(self.next_char())
    }
    if (token_lexeme.equals("as")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("break")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("else")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("external")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("false")) {
        return create_boolean_token(token_lexeme, token_location, false)
    }
    if (token_lexeme.equals("if")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("loop")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("new")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("null")) {
        return create_null_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("return")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("struct")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("true")) {
        return create_boolean_token(token_lexeme, token_location, true)
    }
    if (token_lexeme.equals("while")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    return create_identifier_token(token_lexeme, token_location)
}

scan_integer_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    value: Int = 0
    while (self.peek_char().is_digit()) {
        char: Int8 = self.next_char()
        value = value * 10 + (char as Int - '0' as Int)
        token_lexeme.append(char)
    }
    return create_integer_token(token_lexeme, token_location, value)
}

scan_space_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    count: Int = 0
    while (self.peek_char() == ' ') {
        char: Int8 = self.next_char()
        count = count + 1
        token_lexeme.append(char)
    }
    return create_space_token(token_lexeme, token_location, count)
}

scan_string_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    if (self.peek_char() == '"') {
        value: @String = new String
        value.init()

        token_lexeme.append(self.next_char())
        loop {
            char: Int8 = self.peek_char()
            if (char == '\0' || char == '\n') {
                return create_error_token(token_lexeme, token_location)
            }
            char = self.next_char()
            token_lexeme.append(char)
            if (char == '"') {
                return create_string_token(token_lexeme, token_location, value)
            }
            if (char == '\\') {
                char = self.peek_char()
                if (char == '\0' || char == '\n') {
                    return create_error_token(token_lexeme, token_location)
                }
                char = self.next_char()
                token_lexeme.append(char)
                if (char.is_escape() == false) {
                    return create_error_token(token_lexeme, token_location)
                }
            }
        }
    }
}

\ -------------------------------------------------------------------------------------------------
\       Token
\ -------------------------------------------------------------------------------------------------

Token :: struct : Object {
    lexeme: @String
    location: @Source_Location
}

init :: (self: @Token, lexeme: @String, location: @Source_Location) -> Nothing {
    self.location = location
    self.lexeme = lexeme
}

write :: (file: @FILE, token: @Token) -> @FILE {
    if (token.is(Other_Token) || token.is(Keyword_Token)) {
        file.write(27 as Int8).write("[2;37m")
    } else {
        if (token.is(Literal_Token)) {
            file.write(27 as Int8).write("[1;33m")
        } else {
            if (token.is(Comment_Token)) {
                file.write(27 as Int8).write("[2;33m")
            }
        }
    }
    file.write(token.lexeme)
    file.write(27 as Int8).write("[0m")
    return file
}

Literal_Token :: struct : Token {
}

Character_Token :: struct : Literal_Token {
}

create_character_token :: (lexeme: @String, location: @Source_Location) -> @Character_Token {
    token: @Character_Token = new Character_Token
    token.init(lexeme, location)
    return token
}

Boolean_Token :: struct : Literal_Token {
    value: Boolean
}

create_boolean_token :: (lexeme: @String, location: @Source_Location, value: Boolean) -> @Boolean_Token {
    token: @Boolean_Token = new Boolean_Token
    token.init(lexeme, location)
    token.value = value
    return token
}

Comment_Token :: struct : Token {
}

create_comment_token :: (lexeme: @String, location: @Source_Location) -> @Comment_Token {
    token: @Comment_Token = new Comment_Token
    token.init(lexeme, location)
    return token
}

End_Of_File_Token :: struct : Token {
}

create_end_of_file_token :: (lexeme: @String, location: @Source_Location) -> @End_Of_File_Token {
    token: @End_Of_File_Token = new End_Of_File_Token
    token.init(lexeme, location)
    return token
}

End_Of_Line_Token :: struct : Token {
}

create_end_of_line_token :: (lexeme: @String, location: @Source_Location) -> @End_Of_Line_Token {
    token: @End_Of_Line_Token = new End_Of_Line_Token
    token.init(lexeme, location)
    return token
}

Error_Token :: struct : Token {
}

create_error_token :: (lexeme: @String, location: @Source_Location) -> @Error_Token {
    token: @Error_Token = new Error_Token
    token.init(lexeme, location)
    return token
}

Identifier_Token :: struct : Token {
}

create_identifier_token :: (lexeme: @String, location: @Source_Location) -> @Identifier_Token {
    token: @Identifier_Token = new Identifier_Token
    token.init(lexeme, location)
    return token
}

Integer_Token :: struct : Literal_Token {
    value: Int
}

create_integer_token :: (lexeme: @String, location: @Source_Location, value: Int) -> @Integer_Token {
    token: @Integer_Token = new Integer_Token
    token.init(lexeme, location)
    token.value = value
    return token
}

Keyword_Token :: struct : Token {
}

create_keyword_token :: (lexeme: @String, location: @Source_Location) -> @Keyword_Token {
    token: @Keyword_Token = new Keyword_Token
    token.init(lexeme, location)
    return token
}

Null_Token :: struct : Literal_Token {
}

create_null_token :: (lexeme: @String, location: @Source_Location) -> @Null_Token {
    token: @Null_Token = new Null_Token
    token.init(lexeme, location)
    return token
}

Other_Token :: struct : Token {
}

create_other_token :: (lexeme: @String, location: @Source_Location) -> @Other_Token {
    token: @Other_Token = new Other_Token
    token.init(lexeme, location)
    return token
}

Space_Token :: struct : Token {
    count: Int
}

create_space_token :: (lexeme: @String, location: @Source_Location, count: Int) -> @Space_Token {
    token: @Space_Token = new Space_Token
    token.init(lexeme, location)
    token.count = count
    return token
}

String_Token :: struct : Literal_Token {
    value: @String
}

create_string_token :: (lexeme: @String, location: @Source_Location, value: @String) -> @String_Token {
    token: @String_Token = new String_Token
    token.init(lexeme, location)
    token.value = value
    return token
}

\ -------------------------------------------------------------------------------------------------
\       Source_Location
\ -------------------------------------------------------------------------------------------------

Source_Location :: struct {
    source: @Source
    line: Int
    column: Int
}

write :: (self: @FILE, location: @Source_Location) -> @FILE {
    return self.write(location.source.file_name).write(':').write(location.line).write(':').write(location.column)
}

\ -------------------------------------------------------------------------------------------------
\       Source
\ -------------------------------------------------------------------------------------------------

Source :: struct {
    file_name: @String
    content: @Int8
}

create_source :: (file_name: @String) -> @Source {
    source: @Source = new Source

    file: @FILE = fopen(file_name.data, "r".data)

    content_size: Int = 1024
    content: @Int8 = malloc(content_size)
    content_length: Int = 0
    loop {
        char: Int32 = fgetc(file)
        if (feof(file) as Int != 0) {
            break
        }
        if (content_length + 1 > content_size - 1) {
            content_size = content_size + 1024
            content = realloc(content, content_size) as @Int8
        }
        content[content_length] = char as Int8
        content_length = content_length + 1
    }

    source.file_name = file_name
    source.content = content

    return source
}

\ -------------------------------------------------------------------------------------------------
\       List
\ -------------------------------------------------------------------------------------------------

List :: struct {
    first_item: @List_Item
    last_item: @List_Item
    size: Int
}

create_list :: () -> @List {
    list: @List = new List
    list.first_item = null
    list.last_item = null
    list.size = 0
    return list
}

append :: (self: @List, data: @Any) -> Nothing {
    item: @List_Item = new List_Item
    item.data = data
    item.prev_item = self.last_item
    item.next_item = null
    if (self.last_item == null) {
        self.first_item = item
    } else {
        self.last_item.next_item = item
    }
    self.last_item = item
    self.size = self.size + 1
}

prepend :: (self: @List, data: @Any) -> Nothing {
    item: @List_Item = new List_Item
    item.data = data
    item.prev_item = null
    item.next_item = self.first_item
    if (self.first_item == null) {
        self.last_item = item
    } else {
        self.first_item.prev_item = item
    }
    self.first_item = item
    self.size = self.size + 1
}

List_Item :: struct {
    prev_item: @List_Item
    next_item: @List_Item
    data: @Any
}

List_Iterator :: struct {
    current_item: @List_Item
    next_item: @List_Item
    saved_current_item: @List_Item
    saved_next_item: @List_Item
}

create_iterator :: (list: @List) -> @List_Iterator {
    iterator: @List_Iterator = new List_Iterator
    iterator.current_item = null
    iterator.next_item = list.first_item
    return iterator
}

current :: (self: @List_Iterator) -> @Any {
    if (self.current_item != null) {
        return self.current_item.data
    }
    return null
}

has_next :: (self: @List_Iterator) -> Boolean {
    return self.next_item != null
}

next :: (self: @List_Iterator) -> @Any {
    if (self.next_item == null) {
        return null
    }
    self.current_item = self.next_item
    self.next_item = self.next_item.next_item
    return self.current_item.data
}

save_state :: (self: @List_Iterator) -> Nothing {
    self.saved_current_item = self.current_item
    self.saved_next_item = self.next_item
}

restore_state :: (self: @List_Iterator) -> Nothing {
    self.current_item = self.saved_current_item
    self.next_item = self.saved_next_item
}

\ -------------------------------------------------------------------------------------------------
\       Object
\ -------------------------------------------------------------------------------------------------

Object :: struct {
    object_type: @Object_Type
}

Object_Type :: struct {
    id: Int
    name: String
    base_type: @Object_Type
}

is :: (self: @Object, object_type: @Object_Type) -> Boolean {
    self_type: @Object_Type = self.object_type
    loop {
        if (self_type == object_type) {
            return true
        }
        self_type = self_type.base_type
        if (self_type == null) {
            return false
        }
    }
}

\ -------------------------------------------------------------------------------------------------
\       String
\ -------------------------------------------------------------------------------------------------

String :: struct {
    data: @Int8
    data_size: Int
    length: Int
}

init :: (self: @String) -> @String {
    self.init(16)
    return self
}

init :: (self: @String, data_size: Int) -> @String {
    self.data_size = data_size
    self.data = malloc(data_size) as @Int8
    self.length = 0
    return self
}

init :: (self: @String, data: @Int8) -> @String {
    self.length = data.length()
    self.data_size = self.length + 1
    self.data = data
    return self
}

clone :: (self: @String) -> @String {
    clone: @String = new String
    clone.init(self.data_size)
    clone.append(self)
    return clone
}

append :: (self: @String, char: Int8) -> @String {
    if (self.length + 1 >= self.data_size) {
        self.data_size = self.data_size + 16
        self.data = realloc(self.data, self.data_size) as @Int8
    }
    self.data[self.length] = char
    self.length = self.length + 1
    self.data[self.length] = '\0'
    return self
}

append :: (self: @String, number: Int) -> @String {
    if (number >= 10) {
        self.append(number / 10)
    }
    return self.append((number // 10 + '0' as Int) as Int8)
}

append :: (self: @String, other: @String) -> @String {
    if (self.length + other.length >= self.data_size) {
        self.data_size = self.length + other.length + 1
        self.data = realloc(self.data, self.data_size) as @Int8
    }
    index: Int = 0
    other_data: @Int8 = other.data
    self_data: @Int8 = self.data
    self_length: Int = self.length
    loop {
        char: Int8 = other_data[index]
        self_data[self_length] = char
        if (char == '\0') {
            break
        }
        self_length = self_length + 1
        index = index + 1
    }
    self.length = self_length
    return self
}

ends_with :: (self: @String, suffix: @String) -> Boolean {
    index: Int = 0
    while (index < suffix.length) {
        if (self.data[self.length - suffix.length + index] != suffix.data[index]) {
            return false
        }
        index = index + 1
    }
    return true
}

equals :: (self: @String, other: @String) -> Boolean {
    if (self.length == other.length) {
        index: Int = 0
        while (index < self.length) {
            if (self.data[index] != other.data[index]) {
                return false
            }
            index = index + 1
        }
        return true
    }
    return false
}

length :: (string: @Int8) -> Int {
    length: Int = 0
    loop {
        char: Int8 = string[length]
        if (char == '\0') {
            return length
        }
        length = length + 1
    }
}

write_line :: (file: @FILE, string: @String) -> @FILE {
    return file.end_line().write(string)
}

write :: (self: @FILE, number: Int) -> @FILE {
    if (number >= 10) {
        self.write(number / 10)
    }
    fputc((number // 10 + '0' as Int) as Int32, self)
    return self
}

write :: (self: @FILE, string: @String) -> @FILE {
    return self.write(string.data)
}

write :: (self: @FILE, chars: @Int8) -> @FILE {
    index: Int = 0
    loop {
        char: Int8 = chars[index]
        if (char == '\0') {
            break
        }
        self.write(char)
        index = index + 1
    }
    return self
}

write :: (self: @FILE, char: Int8) -> @FILE {
    c: Int32 = char as Int32
    if (fputc(c, self) != c) {
        stderr.end_line().end_line().write("Failed to write character: ").write(c as Int).end_line()
        abort()
    }
    return self
}

end_line :: (self: @FILE) -> @FILE {
    return self.write('\n')
}

abort :: (message: @String) -> Nothing {
    stderr.end_line().end_line().write(message).end_line()
    abort()
}

\ -------------------------------------------------------------------------------------------------
\       LibC stuff
\ -------------------------------------------------------------------------------------------------

\ ----- stdio.h -----------------------------------------------------------------------------------

FILE :: struct

stdout: @FILE = external
stderr: @FILE = external

fclose :: (file: @FILE) -> Int32
feof :: (file: @FILE) -> Int32
fflush :: (file: @FILE) -> Int32
fgetc :: (file: @FILE) -> Int32
fopen :: (file: @Int8, mode: @Int8) -> @FILE
fputc :: (char: Int32, file: @FILE) -> Int32

\ ----- stdlib.h ----------------------------------------------------------------------------------

abort :: () -> Nothing
exit :: (code: Int) -> Nothing
free :: (block: @Any) -> Nothing
malloc :: (size: Int) -> @Any
realloc :: (block: @Int8, size: Int) -> @Any
