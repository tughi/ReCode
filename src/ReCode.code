\ TODO: change main to: program :: (arguments: @String) -> Nothing
main :: (argc: Int, argv: @@Int8) -> Nothing {
    if (argc != 3) {
        stdout.write("Usage:").new_line()
        stdout.write('\t').write(argv[0]).write(" <INPUT FILE> <OUTPUT FILE>").new_line()
        exit(1)
    }

    source_file_name: String
    @source_file_name.init(argv[1])
    if (@source_file_name.ends_with(".code") == false) {
        stdout.write("'").write(@source_file_name).write("' doesn't end with '.code'.").new_line()
        exit(1)
    }

    output_file_name: String
    @output_file_name.init(argv[2])
    if (@output_file_name.ends_with(".s") == false) {
        stdout.write("'").write(@output_file_name).write("' doesn't end with '.s'.").new_line()
        exit(1)
    }

    output_file: @LibC_FILE = fopen(argv[2], "w".data)
    output_file.write("  .file 1 \"").write(argv[1]).write("\"").new_line()
    output_file.write("  .intel_syntax noprefix").new_line()
    output_file.new_line()
    output_file.write("  .text").new_line()
    output_file.write("  .globl main").new_line()
    output_file.write("main:").new_line()
    output_file.write("  push rbp").new_line()
    output_file.write("  mov rbp, rsp").new_line()
    \ TODO: call program function
    output_file.write("main__end:").new_line()
    output_file.write("  xor rax, rax").new_line()
    output_file.write("  mov rsp, rbp").new_line()
    output_file.write("  pop rbp").new_line()
    output_file.write("  ret").new_line()
}

String :: struct {
    length: Int
    data: @Int8
}

init :: (self: @String, data: @Int8) -> Nothing {
    self.length = data.length()
    self.data = data
}

ends_with :: (self: @String, suffix: @String) -> Boolean {
    index: Int = 0
    loop {
        if (index >= suffix.length) {
            break
        }
        if (self.data[self.length - suffix.length + index] != suffix.data[index]) {
            return false
        }
        index = index + 1
    }
    return true
}

length :: (string: @Int8) -> Int {
    length: Int = 0
    loop {
        char: Int8 = string[length]
        if (char == '\0') {
            return length
        }
        length = length + 1
    }
}

write :: (self: @LibC_FILE, string: @String) -> @LibC_FILE {
    return self.write(string.data)
}

write :: (self: @LibC_FILE, string: @Int8) -> @LibC_FILE {
    index: Int = 0
    loop {
        char: Int8 = string[index]
        if (char == '\0') {
            break
        }
        self.write(char)
        index = index + 1
    }
    return self
}

write :: (self: @LibC_FILE, char: Int8) -> @LibC_FILE {
    c: Int32 = char as Int32
    if (fputc(c, self) != c) {
        stderr.write("Error: Failed to write character")
        raise(6)
    }
    return self
}

new_line :: (self: @LibC_FILE) -> @LibC_FILE {
    return self.write('\n')
}

LibC_FILE :: struct

stdout: @LibC_FILE = external
stderr: @LibC_FILE = external

fopen :: (file: @Int8, mode: @Int8) -> @LibC_FILE

fputc :: (c: Int32, file: @LibC_FILE) -> Int32

exit :: (code: Int) -> Nothing

raise :: (signal: Int) -> Nothing
