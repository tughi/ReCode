\ TODO: change main to: program :: (arguments: @String) -> Nothing
main :: (argc: Int, argv: @@Int8) -> Nothing {
    if (argc != 3) {
        stdout.write("Usage:").end_line()
        stdout.write('\t').write(argv[0]).write(" <INPUT FILE> <OUTPUT FILE>").end_line()
        exit(1)
    }

    source_file_name: String
    source_file_name.init(argv[1])
    if (source_file_name.ends_with(".code") == false) {
        stdout.write("'").write(source_file_name).write("' doesn't end with '.code'.").end_line()
        exit(1)
    }

    output_file_name: String
    output_file_name.init(argv[2])
    if (output_file_name.ends_with(".s") == false) {
        stdout.write("'").write(output_file_name).write("' doesn't end with '.s'.").end_line()
        exit(1)
    }

    scan(source_file_name)

    output_file: @FILE = fopen(argv[2], "w".data)

    output_file.write("  .file 1 \"").write(source_file_name).write("\"")
    output_file.write_line("  .intel_syntax noprefix")
    output_file.write_line("")
    output_file.write_line("  .text")
    output_file.write_line("  .globl main")
    output_file.write_line("main:")
    output_file.write_line("  push rbp")
    output_file.write_line("  mov rbp, rsp")
    \ TODO: call program function
    output_file.write_line("main__end:")
    output_file.write_line("  xor rax, rax")
    output_file.write_line("  mov rsp, rbp")
    output_file.write_line("  pop rbp")
    output_file.write_line("  ret")
    output_file.write_line("")
}

scan :: (file_name: @String) -> Nothing {
    source: @Source = new Source
    source.init(file_name)

    scanner: @Scanner = new Scanner
    scanner.init(source)

    loop {
        token: @Token = scanner.next_token()
        stdout.write(token.location).write(": ").write(token.type.id).write(" :: ").write(token.lexeme).end_line()
        if (scanner.peek_char() == '\0') {
            token: @Token = scanner.next_token()
            stdout.write(token.location).write(": ").write(token.type.id).write(" :: ").write(token.lexeme).end_line()
            break
        }
    }
}

Scanner :: struct {
    source: @Source
    current_char_index: Int
    current_line: Int
    current_column: Int
}

init :: (self: @Scanner, source: @Source) -> Nothing {
    self.source = source
    self.current_char_index = 0
    self.current_line = 1
    self.current_column = 1
}

peek_char :: (self: @Scanner) -> Int8 {
    return self.source.content[self.current_char_index]
}

next_char :: (self: @Scanner) -> Int8 {
    next_char: Int8 = self.source.content[self.current_char_index]
    if (next_char != '\0') {
        self.current_char_index = self.current_char_index + 1
        if (next_char == '\n') {
            self.current_line = self.current_line + 1
            self.current_column = 1
        } else {
            self.current_column = self.current_column + 1
        }
    }
    return next_char
}

next_token :: (self: @Scanner) -> @Token {
    token_lexeme: @String = new String
    token_lexeme.init()

    token_location: @Source_Location = new Source_Location
    token_location.source = self.source
    token_location.line = self.current_line
    token_location.column = self.current_column

    next_char: Int8 = self.peek_char()
    if (next_char.is_identifier_start()) {
        return self.scan_identifier_token(token_lexeme, token_location)
    }
    if (next_char.is_digit()) {
        return self.scan_integer_token(token_lexeme, token_location)
    }
    if (next_char == '\'') {
        return self.scan_character_token(token_lexeme, token_location)
    }
    if (next_char == '"') {
        return self.scan_string_token(token_lexeme, token_location)
    }
    if (next_char == '\\') {
        return self.scan_comment_token(token_lexeme, token_location)
    }
    if (next_char.is_space()) {
        return self.scan_space_token(token_lexeme, token_location)
    }
    if (next_char == '\n') {
        self.next_char()
        return create_end_of_line_token(token_lexeme, token_location)
    }
    if (next_char == '\0') {
        self.next_char()
        return create_end_of_file_token(token_lexeme, token_location)
    }
    token_lexeme.append(self.next_char())
    return create_other_token(token_lexeme, token_location)
}

is_digit :: (char: Int8) -> Boolean {
    return char as Int >= '0' as Int && char as Int <= '9' as Int
}

is_identifier_start :: (char: Int8) -> Boolean {
    return char.is_letter() || char == '_'
}

is_identifier_body :: (char: Int8) -> Boolean {
    if (char.is_identifier_start()) {
        return true
    }
    return char.is_digit()
}

is_letter :: (char: Int8) -> Boolean {
    return (char as Int >= 'a' as Int && char as Int <= 'z' as Int) || (char as Int >= 'A' as Int && char as Int <= 'Z' as Int)
}

is_space :: (char: Int8) -> Boolean {
    return char == ' '
}

scan_character_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    if (self.peek_char() == '\'') {
        token_lexeme.append(self.next_char())
        char: Int8 = self.next_char()
        token_lexeme.append(char)
        if (char == '\'') {
            return create_error_token(token_lexeme, token_location)
        }
        if (char == '\\') {
            char = self.next_char()
            token_lexeme.append(char)
            if (char.is_escape() == false) {
                return create_error_token(token_lexeme, token_location)
            }
            char = self.next_char()
            token_lexeme.append(char)
            if (char != '\'') {
                return create_error_token(token_lexeme, token_location)
            }
        } else {
            if (char == '\0' || char == '\n' || char == '\t') {
                return create_error_token(token_lexeme, token_location)
            }
            char = self.next_char()
            token_lexeme.append(char)
            if (char != '\'') {
                return create_error_token(token_lexeme, token_location)
            }
        }
    }
    return create_character_token(token_lexeme, token_location)
}

is_escape :: (char: Int8) -> Boolean {
    return char == 'n' || char == 't' || char == '\"' || char == '\'' || char == '\\' || char == '0'
}

scan_comment_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    while (self.peek_char() != '\n') {
        token_lexeme.append(self.next_char())
    }
    return create_comment_token(token_lexeme, token_location)
}

scan_identifier_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    while (self.peek_char().is_identifier_body()) {
        token_lexeme.append(self.next_char())
    }
    if (token_lexeme.equals("as")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("break")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("else")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("external")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("false")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("if")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("loop")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("new")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("return")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("struct")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("true")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("while")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    return create_identifier_token(token_lexeme, token_location)
}

scan_integer_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    value: Int = 0
    while (self.peek_char().is_digit()) {
        char: Int8 = self.next_char()
        value = value * 10 + (char as Int - '0' as Int)
        token_lexeme.append(char)
    }
    return create_integer_token(token_lexeme, token_location, value)
}

scan_space_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    count: Int = 0
    while (self.peek_char() == ' ') {
        char: Int8 = self.next_char()
        count = count + 1
        token_lexeme.append(char)
    }
    return create_space_token(token_lexeme, token_location, count)
}

scan_string_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    if (self.peek_char() == '"') {
        value: @String = new String
        value.init()

        token_lexeme.append(self.next_char())
        loop {
            char: Int8 = self.peek_char()
            if (char == '\0' || char == '\n') {
                return create_error_token(token_lexeme, token_location)
            }
            char = self.next_char()
            token_lexeme.append(char)
            if (char == '"') {
                return create_string_token(token_lexeme, token_location, value)
            }
            if (char == '\\') {
                char = self.peek_char()
                if (char == '\0' || char == '\n') {
                    return create_error_token(token_lexeme, token_location)
                }
                char = self.next_char()
                token_lexeme.append(char)
                if (char.is_escape() == false) {
                    return create_error_token(token_lexeme, token_location)
                }
            }
        }
    }
}

Token :: struct : Object {
    lexeme: @String
    location: @Source_Location
}

init :: (self: @Token, lexeme: @String, location: @Source_Location) -> Nothing {
    self.location = location
    self.lexeme = lexeme
}

Character_Token :: struct : Token {
}

create_character_token :: (lexeme: @String, location: @Source_Location) -> @Token {
    token: @Character_Token = new Character_Token
    (token as @Token).init(lexeme, location)
    return token as @Token
}

Comment_Token :: struct : Token {
}

create_comment_token :: (lexeme: @String, location: @Source_Location) -> @Token {
    token: @Comment_Token = new Comment_Token
    (token as @Token).init(lexeme, location)
    return token as @Token
}

End_Of_File_Token :: struct : Token {
}

create_end_of_file_token :: (lexeme: @String, location: @Source_Location) -> @Token {
    token: @End_Of_File_Token = new End_Of_File_Token
    (token as @Token).init(lexeme, location)
    return token as @Token
}

End_Of_Line_Token :: struct : Token {
}

create_end_of_line_token :: (lexeme: @String, location: @Source_Location) -> @Token {
    token: @End_Of_Line_Token = new End_Of_Line_Token
    (token as @Token).init(lexeme, location)
    return token as @Token
}

Error_Token :: struct : Token {
}

create_error_token :: (lexeme: @String, location: @Source_Location) -> @Token {
    token: @Error_Token = new Error_Token
    (token as @Token).init(lexeme, location)
    return token as @Token
}

Identifier_Token :: struct : Token {
}

create_identifier_token :: (lexeme: @String, location: @Source_Location) -> @Token {
    token: @Identifier_Token = new Identifier_Token
    (token as @Token).init(lexeme, location)
    return token as @Token
}

Integer_Token :: struct : Token {
    value: Int
}

create_integer_token :: (lexeme: @String, location: @Source_Location, value: Int) -> @Token {
    token: @Integer_Token = new Integer_Token
    (token as @Token).init(lexeme, location)
    token.value = value
    return token as @Token
}

Keyword_Token :: struct : Token {
}

create_keyword_token :: (lexeme: @String, location: @Source_Location) -> @Token {
    token: @Integer_Token = new Integer_Token
    (token as @Token).init(lexeme, location)
    return token as @Token
}

Other_Token :: struct : Token {
}

create_other_token :: (lexeme: @String, location: @Source_Location) -> @Token {
    token: @Other_Token = new Other_Token
    (token as @Token).init(lexeme, location)
    return token as @Token
}

Space_Token :: struct : Token {
    count: Int
}

create_space_token :: (lexeme: @String, location: @Source_Location, count: Int) -> @Token {
    token: @Space_Token = new Space_Token
    (token as @Token).init(lexeme, location)
    token.count = count
    return token as @Token
}

String_Token :: struct : Token {
    value: @String
}

create_string_token :: (lexeme: @String, location: @Source_Location, value: @String) -> @Token {
    token: @String_Token = new String_Token
    (token as @Token).init(lexeme, location)
    token.value = value
    return token as @Token
}

Source_Location :: struct {
    source: @Source
    line: Int
    column: Int
}

write :: (self: @FILE, location: @Source_Location) -> @FILE {
    return self.write(location.source.file_name).write(':').write(location.line).write(':').write(location.column)
}

Source :: struct {
    file_name: @String
    content: @Int8
}

init :: (self: @Source, file_name: @String) -> Nothing {
    file: @FILE = fopen(file_name.data, "r".data)

    content_size: Int = 1024
    content: @Int8 = malloc(content_size)
    content_length: Int = 0
    loop {
        char: Int32 = fgetc(file)
        if (feof(file) as Int != 0) {
            break
        }
        if (content_length + 1 > content_size - 1) {
            content_size = content_size + 1024
            content = realloc(content, content_size)
        }
        content[content_length] = char as Int8
        content_length = content_length + 1
    }

    self.file_name = file_name
    self.content = content
}

\ -------------------------------------------------------------------------------------------------
\       Object
\ -------------------------------------------------------------------------------------------------

Object :: struct {
    type: @Type
}

\ -------------------------------------------------------------------------------------------------
\       Type
\ -------------------------------------------------------------------------------------------------

Type :: struct {
    id: Int
}

\ -------------------------------------------------------------------------------------------------
\       String
\ -------------------------------------------------------------------------------------------------

String :: struct {
    data: @Int8
    data_size: Int
    length: Int
}

init :: (self: @String) -> Nothing {
    self.data_size = 16
    self.data = malloc(self.data_size)
    self.length = 0
}

init :: (self: @String, data: @Int8) -> Nothing {
    self.length = data.length()
    self.data_size = self.length + 1
    self.data = data
}

append :: (self: @String, char: Int8) -> @String {
    if (self.length + 1 >= self.data_size) {
        self.data_size = self.data_size + 16
        self.data = realloc(self.data, self.data_size)
    }
    self.data[self.length] = char
    self.length = self.length + 1
    self.data[self.length] = '\0'
    return self
}

ends_with :: (self: @String, suffix: @String) -> Boolean {
    index: Int = 0
    while (index < suffix.length) {
        if (self.data[self.length - suffix.length + index] != suffix.data[index]) {
            return false
        }
        index = index + 1
    }
    return true
}

equals :: (self: @String, other: @String) -> Boolean {
    if (self.length == other.length) {
        index: Int = 0
        while (index < self.length) {
            if (self.data[index] != other.data[index]) {
                return false
            }
            index = index + 1
        }
        return true
    }
    return false
}

length :: (string: @Int8) -> Int {
    length: Int = 0
    loop {
        char: Int8 = string[length]
        if (char == '\0') {
            return length
        }
        length = length + 1
    }
}

write_line :: (file: @FILE, string: @String) -> @FILE {
    return file.end_line().write(string)
}

write :: (self: @FILE, number: Int) -> @FILE {
    if (number >= 10) {
        self.write(number / 10)
    }
    fputc((number // 10 + '0' as Int) as Int32, self)
    return self
}

write :: (self: @FILE, string: @String) -> @FILE {
    return self.write(string.data)
}

write :: (self: @FILE, chars: @Int8) -> @FILE {
    index: Int = 0
    loop {
        char: Int8 = chars[index]
        if (char == '\0') {
            break
        }
        self.write(char)
        index = index + 1
    }
    return self
}

write :: (self: @FILE, char: Int8) -> @FILE {
    c: Int32 = char as Int32
    if (fputc(c, self) != c) {
        stderr.write("Error: Failed to write character")
        abort()
    }
    return self
}

end_line :: (self: @FILE) -> @FILE {
    return self.write('\n')
}

\ -------------------------------------------------------------------------------------------------
\       LibC stuff
\ -------------------------------------------------------------------------------------------------

\ ----- stdio.h -----------------------------------------------------------------------------------

FILE :: struct

stdout: @FILE = external
stderr: @FILE = external

fclose :: (file: @FILE) -> Int32
feof :: (file: @FILE) -> Int32
fflush :: (file: @FILE) -> Int32
fgetc :: (file: @FILE) -> Int32
fopen :: (file: @Int8, mode: @Int8) -> @FILE
fputc :: (char: Int32, file: @FILE) -> Int32

\ ----- stdlib.h ----------------------------------------------------------------------------------

abort :: () -> Nothing
exit :: (code: Int) -> Nothing
free :: (block: @Int8) -> Nothing
malloc :: (size: Int) -> @Int8
realloc :: (block: @Int8, size: Int) -> @Int8
