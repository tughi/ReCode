\ Copyright (c) 2020, Stefan Selariu

main :: (argc: Int, argv: @@Int8) -> Nothing {
    if (argc < 3) {
        stdout.write("Usage:").end_line()
        stdout.write('\t').write(argv[0]).write(" <INPUT FILE> <OUTPUT FILE>").end_line()
        exit(1)
    }

    source_file_name: @String = new String.init(argv[1])
    if (source_file_name.ends_with(".code") == false) {
        stdout.write("'").write(source_file_name).write("' doesn't end with '.code'.").end_line()
        exit(1)
    }

    output_file_name: @String = new String.init(argv[2])
    if (output_file_name.ends_with(".s") == false) {
        stdout.write("'").write(output_file_name).write("' doesn't end with '.s'.").end_line()
        exit(1)
    }

    dump_file_name: @String = null
    if (argc >= 4) {
        dump_file_name = new String.init(argv[3])
        if (dump_file_name.ends_with(".ir") == false) {
            stdout.write("'").write(dump_file_name).write("' doesn't end with '.ir'.").end_line()
            exit(1)
        }
    }

    tokens: @List = scan(source_file_name)

    compilation_unit: @Compilation_Unit = parse(tokens)
    \ stdout.write(compilation_unit).end_line()

    build: @IR_Build = build(compilation_unit)
    if (dump_file_name != null) {
        dump_file: @FILE = fopen(dump_file_name.data, "w".data)
        build.dump(dump_file)
        dump_file.fclose()
    }

    generate(build, output_file_name)
}

\ -------------------------------------------------------------------------------------------------
\       Generator
\ -------------------------------------------------------------------------------------------------

generate :: (build: @IR_Build, output_file_name: @String) -> Nothing {
    generator: @MC_Generator = create_mc_generator(output_file_name)

    generator.output_file.write("  .file 1 \"").write(build.source.file_name).write("\"")
    generator.output_file.write_line("  .intel_syntax noprefix").end_line()

    functions: @List_Iterator = build.named_functions.create_iterator()
    while (functions.has_next()) {
        function: @IR_Function = functions.next() as @IR_Function
        if (function.blocks.size > 0) {
            generator.generate_function(function)
        }
        \ TODO: remove this break as soon as the first function is correctly generated
        break
    }

    generator.output_file.fclose()
}

generate_function :: (self: @MC_Generator, function: @IR_Function) -> Nothing {
    self.output_file.end_line()
    self.output_file.write("  .loc 1 ").write(function.location.line).write(' ').write(function.location.column).end_line()
    self.output_file.write("  .text").end_line()
    if (function.name.equals("main")) {
        self.output_file.write("  .globl main").end_line()
        self.output_file.write(function.name).write(':').end_line()
    } else {
        self.output_file.write(function.name).write('_').write(function.id).write(':').end_line()
    }
    self.output_file.write("  push rbp").end_line()
    self.output_file.write("  mov rbp, rsp").end_line()
    self.output_file.write("  sub rsp, .STACK_FRAME_SIZE_").write(function.name).write('_').write(function.id).end_line()

    self.generate_block(function.blocks.first() as @IR_Block)

    self.output_file.write("  .set .STACK_FRAME_SIZE_").write(function.name).write('_').write(function.id).write(", ").write(128).end_line()
    self.output_file.write(".L_").write(function.name).write('_').write(function.id).write("_end:").end_line()
    self.output_file.write("  mov rsp, rbp").end_line()
    self.output_file.write("  pop rbp").end_line()
    self.output_file.write("  ret").end_line()
}

generate_block :: (self: @MC_Generator, block: @IR_Block) -> Nothing {
    self.output_file.write_block_label(block).write(':').end_line()
    block_instruction: @IR_Instruction = block.first_instruction
    while (block_instruction != null) {
        self.generate_instruction(block_instruction)
        if (block_instruction.is(IR_Load_Variable_Instruction) == false && block_instruction.result_value.variable.is(IR_Global_Variable)) {
            self.spill_global_variable(self.get_variable(block_instruction.result_value.variable))
        }
        block_instruction = block_instruction.next_instruction
    }
}

write_block_label :: (file: @FILE, block: @IR_Block) -> @FILE {
    return file.write(".LABEL__").write(block.function.name).write('_').write(block.function.id).write("__").write(block.id)
}

generate_instruction :: (self: @MC_Generator, instruction: @IR_Instruction) -> Nothing {
    instruction.is_generated = true
    if (instruction.is(IR_Call_Instruction)) {
        self.generate_call_instruction(instruction as @IR_Call_Instruction)
        return
    }
    if (instruction.is(IR_Conditional_Jump_Instruction)) {
        self.generate_conditional_jump_instruction(instruction as @IR_Conditional_Jump_Instruction)
        return
    }
    if (instruction.is(IR_Comparison_Instruction)) {
        self.generate_comparison_instruction(instruction as @IR_Comparison_Instruction)
        return
    }
    if (instruction.is(IR_Load_Variable_Instruction)) {
        self.generate_load_variable_instruction(instruction as @IR_Load_Variable_Instruction)
        return
    }
    self.abort(clone("Unsupported instruction: ").append(instruction.object_type.name))
}

generate_call_instruction :: (self: @MC_Generator, instruction: @IR_Call_Instruction) -> Nothing {
    if (instruction.arguments.size > 0) {
        self.generate_load_value(self.register_rdi, instruction.arguments.first() as @IR_Value)
        if (instruction.arguments.size > 1) {
            self.generate_load_value(self.register_rsi, instruction.arguments.get(1) as @IR_Value)
            if (instruction.arguments.size > 2) {
                self.generate_load_value(self.register_rdx, instruction.arguments.get(2) as @IR_Value)
                if (instruction.arguments.size > 3) {
                    self.generate_load_value(self.register_rcx, instruction.arguments.get(3) as @IR_Value)
                    if (instruction.arguments.size > 4) {
                        self.generate_load_value(self.register_r8, instruction.arguments.get(4) as @IR_Value)
                        if (instruction.arguments.size > 5) {
                            self.generate_load_value(self.register_r9, instruction.arguments.get(5) as @IR_Value)
                        }
                    }
                }
            }
        }
    }
    self.release_all_registers()
    self.output_file.write("  call ").write(instruction.function.name).write('_').write(instruction.function.id).end_line()
    self.map_variable(instruction.result_value, self.register_rax)
}

generate_load_value :: (self: @MC_Generator, register: @MC_Register, ir_value: @IR_Value) -> Nothing {
    if (register.variable != null) {
        if (ir_value.is(IR_Variable_Value)) {
            ir_value: @IR_Variable_Value = ir_value as @IR_Variable_Value
            if (register.variable.ir_value == ir_value) {
                return
            }
        }
        if (register.variable.ir_variable.is(IR_Global_Variable) == false) {
            self.spill_local_variable(register.variable)
        }
        register.variable.register = null
        register.variable = null
    }
    if (ir_value.is(IR_Constant_Value)) {
        ir_value: @IR_Constant_Value = ir_value as @IR_Constant_Value
        if (ir_value.literal.is(Character_Token)) {
            self.output_file.write("  mov ").write(register.name_b).write(", ")
            lexeme: @String = ir_value.literal.lexeme
            index: Int = 0
            while (index < lexeme.length - 1) {
                self.output_file.write(lexeme.data[index])
                index = index + 1
            }
            self.output_file.end_line()
            return
        }
        if (ir_value.literal.is(String_Token)) {
            self.output_file.write("  lea ").write(register.name_q).write(", ").write(".STRING_42").write("[rip]").end_line()
            return
        }
        self.abort(clone("Unsupported literal type: ").append(ir_value.literal.object_type.name))
    }
    if (ir_value.is(IR_Variable_Value)) {
        ir_value: @IR_Variable_Value = ir_value as @IR_Variable_Value
        variable: @MC_Variable = self.get_variable(ir_value.variable)
        if (variable == null) {
            self.abort("Invalid state")
        }
        if (variable.register != null) {
            self.output_file.write("  mov ").write(register.name_q).write(", ").write(variable.register.name_q).end_line()
            return
        }
        self.output_file.write("  mov ").write(register.name_q).write(", ").write(variable.address).end_line()
        return
    }
    self.abort(clone("Unsupported value type: ").append(ir_value.object_type.name))
}

generate_conditional_jump_instruction :: (self: @MC_Generator, instruction: @IR_Conditional_Jump_Instruction) -> Nothing {
    condition_value: @IR_Value = instruction.get_condition_value()
    if (condition_value.is(IR_Variable_Value) == false) {
        self.abort("Unsupported value type")
    }
    condition_value: @IR_Variable_Value = condition_value as @IR_Variable_Value
    mc_variable: @MC_Variable = self.get_variable(condition_value.variable)
    if (mc_variable == null) {
        self.abort("Invalid state")
    }
    self.output_file.write("  dec ").write(mc_variable.register.name_b).end_line()
    \ TODO: release condition variable if possible
    \ TODO: spill all variables
    self.output_file.write("  jnz ").write_block_label(instruction.false_block).end_line()
    self.generate_block(instruction.true_block)
    self.generate_block(instruction.false_block)
}

generate_comparison_instruction :: (self: @MC_Generator, instruction: @IR_Comparison_Instruction) -> Nothing {
    self.output_file.write("  cmp ").write_operand(self, instruction.get_left_value()).write(", ").write_operand(self, instruction.get_right_value()).end_line()
    \ TODO: remove out-of-scope variables
    variable: @MC_Variable = self.map_variable(instruction.result_value, self.find_unused_register())
    if (instruction.is(IR_Less_Than_Comparison_Instruction)) {
        self.output_file.write("  setl ").write(variable.register.name_b).end_line()
        return
    }
    self.abort("Not implemented!")
}

generate_load_variable_instruction :: (self: @MC_Generator, instruction: @IR_Load_Variable_Instruction) -> Nothing {
    if (instruction.variable.is(IR_Function_Parameter)) {
        parameter: @IR_Function_Parameter = instruction.variable as @IR_Function_Parameter
        parameter_index: Int = instruction.parent_block.function.parameters.index_of(parameter)
        if (parameter_index < 0) {
            self.abort("Invalid state")
        }
        if (parameter_index == 0) {
            self.map_variable(instruction.result_value, self.register_rdi, null)
            return
        }
        if (parameter_index == 1) {
            self.map_variable(instruction.result_value, self.register_rsi, null)
            return
        }
        if (parameter_index == 2) {
            self.map_variable(instruction.result_value, self.register_rdx, null)
            return
        }
        if (parameter_index == 3) {
            self.map_variable(instruction.result_value, self.register_rcx, null)
            return
        }
        if (parameter_index == 4) {
            self.map_variable(instruction.result_value, self.register_r8, null)
            return
        }
        if (parameter_index == 5) {
            self.map_variable(instruction.result_value, self.register_r9, null)
            return
        }
        self.abort(clone("Invalid state"))
    }
    if (instruction.variable.is(IR_Global_Variable)) {
        ir_variable: @IR_Global_Variable = instruction.variable as @IR_Global_Variable
        if (ir_variable.is_external) {
            \ map external variable to global variable address
            self.map_variable(instruction.result_value, null, create_mc_global_variable_address(ir_variable))
            return
        }
        self.abort("Unsupported non-external variable")
    }
    self.abort(clone("Unsupported variable type: ").append(instruction.variable.object_type.name))
}

write_operand :: (file: @FILE, generator: @MC_Generator, ir_value: @IR_Value) -> @FILE {
    if (ir_value.is(IR_Constant_Value)) {
        ir_value: @IR_Constant_Value = ir_value as @IR_Constant_Value
        if (ir_value.literal.is(Integer_Token)) {
            return file.write((ir_value.literal as @Integer_Token).value)
        }
        generator.abort(clone("Unsupported constant literal: ").append(ir_value.literal.object_type.name))
    }
    if (ir_value.is(IR_Variable_Value)) {
        ir_value: @IR_Variable_Value = ir_value as @IR_Variable_Value
        mc_variable: @MC_Variable = generator.get_variable(ir_value.variable)
        if (mc_variable == null) {
            generator.abort("Invalid state")
        }
        if (mc_variable.register != null) {
            return file.write(mc_variable.register.name_q)
        }
        generator.abort("Not implemented!")
    }
    generator.abort(clone("Unsupported value: ").append(ir_value.object_type.name))
}

abort :: (self: @MC_Generator, message: @String) -> Nothing {
    self.output_file.fflush()
    abort(clone("[Generator] ").append(message))
}

MC_Generator :: struct {
    output_file_name: @String
    output_file: @FILE
    registers: @List
    register_rax: @MC_Register
    register_rcx: @MC_Register
    register_rdx: @MC_Register
    register_rbx: @MC_Register
    register_rsi: @MC_Register
    register_rdi: @MC_Register
    register_r8: @MC_Register
    register_r9: @MC_Register
    register_r10: @MC_Register
    register_r11: @MC_Register
    register_r12: @MC_Register
    register_r13: @MC_Register
    register_r14: @MC_Register
    register_r15: @MC_Register
    first_variable: @MC_Variable
    last_variable: @MC_Variable
}

create_mc_generator :: (output_file_name: @String) -> @MC_Generator {
    generator: @MC_Generator = new MC_Generator
    generator.output_file_name = output_file_name
    generator.output_file = fopen(output_file_name.data, "w".data)
    generator.register_rax = new MC_Register_RAX.init("rax", "eax", "ax", "al")
    generator.register_rcx = new MC_Register_RCX.init("rcx", "ecx", "cx", "cl")
    generator.register_rdx = new MC_Register_RDX.init("rdx", "edx", "dx", "dl")
    generator.register_rbx = new MC_Register_RBX.init("rbx", "ebx", "bx", "bl")
    generator.register_rsi = new MC_Register_RSI.init("rsi", "esi", "si", "sil")
    generator.register_rdi = new MC_Register_RDI.init("rdi", "edi", "di", "dil")
    generator.register_r8 = new MC_Register_R8.init("r8", "r8d", "r8w", "r8b")
    generator.register_r9 = new MC_Register_R9.init("r9", "r9d", "r9w", "r9b")
    generator.register_r10 = new MC_Register_R10.init("r10", "r10d", "r10w", "r10b")
    generator.register_r11 = new MC_Register_R11.init("r11", "r11d", "r11w", "r11b")
    generator.register_r12 = new MC_Register_R12.init("r12", "r12d", "r12w", "r12b")
    generator.register_r13 = new MC_Register_R13.init("r13", "r13d", "r13w", "r13b")
    generator.register_r14 = new MC_Register_R14.init("r14", "r14d", "r14w", "r14b")
    generator.register_r15 = new MC_Register_R15.init("r15", "r15d", "r15w", "r15b")
    generator.first_variable = null
    generator.last_variable = null
    return generator
}

find_unused_register :: (self: @MC_Generator) -> @MC_Register {
    if (self.register_r15.variable == null) {
        return self.register_r15
    }
    if (self.register_r14.variable == null) {
        return self.register_r14
    }
    if (self.register_r13.variable == null) {
        return self.register_r13
    }
    if (self.register_r12.variable == null) {
        return self.register_r12
    }
    if (self.register_r11.variable == null) {
        return self.register_r11
    }
    if (self.register_r10.variable == null) {
        return self.register_r10
    }
    self.abort("All registered are used")
}

map_variable :: (self: @MC_Generator, ir_variable_value: @IR_Variable_Value, register: @MC_Register) -> @MC_Variable {
    return self.map_variable(ir_variable_value, register, null)
}

map_variable :: (self: @MC_Generator, ir_variable_value: @IR_Variable_Value, address: @MC_Address) -> @MC_Variable {
    return self.map_variable(ir_variable_value, null, address)
}

map_variable :: (self: @MC_Generator, ir_variable_value: @IR_Variable_Value, register: @MC_Register, address: @MC_Address) -> @MC_Variable {
    ir_variable: @IR_Variable = ir_variable_value.variable
    variable: @MC_Variable = self.last_variable
    while (variable != null && variable.ir_variable != ir_variable) {
        variable = variable.prev_variable
    }
    if (variable == null) {
        variable = new MC_Variable
        variable.ir_variable = ir_variable
        variable.next_variable = null
        variable.prev_variable = self.last_variable
        if (self.last_variable == null) {
            self.first_variable = variable
        } else {
            self.last_variable.next_variable = variable
        }
        self.last_variable = variable
    }
    variable.ir_value = ir_variable_value
    variable.address = address
    variable.register = register
    if (register != null) {
        if (register.variable != null) {
            self.output_file.fflush()
            abort(clone("Register ").append(register.name_q).append(" already mapped to variable: ").append(register.variable.ir_variable.name))
        }
        register.variable = variable
    }
    return variable
}

get_variable :: (self: @MC_Generator, ir_variable: @IR_Variable) -> @MC_Variable {
    variable: @MC_Variable = self.first_variable
    while (variable != null && variable.ir_variable != ir_variable) {
        variable = variable.next_variable
    }
    return variable
}

spill_local_variable :: (self: @MC_Generator, variable: @MC_Variable) -> Nothing {
    ir_variable: @IR_Variable = variable.ir_variable
    if (variable.ir_variable.is(IR_Global_Variable)) {
        \ global variables are spilled after each instruction
        self.abort("Invalid state")
    }
    if (variable.address == null) {
        offset: Int = 0
        other_variable: @MC_Variable = self.first_variable
        while (other_variable != null) {
            other_variable_address: @MC_Address = other_variable.address
            if (other_variable_address != null && other_variable_address.is(MC_Local_Variable_Address)) {
                other_variable_address: @MC_Local_Variable_Address = other_variable_address as @MC_Local_Variable_Address
                if (offset < other_variable_address.offset) {
                    offset = other_variable_address.offset
                }
            }
            other_variable = other_variable.next_variable
        }
        offset = offset + self.get_type_size(variable)
        variable.address = create_mc_local_variable_address(offset)
    }
    self.output_file.write("  mov ").write(variable.address).write(", ").write(variable.register.name_q).end_line()
}

spill_global_variable :: (self: @MC_Generator, variable: @MC_Variable) -> Nothing {
    self.abort(clone("TODO: spill global variable ").append(variable.ir_variable.name))
}

release_all_registers :: (self: @MC_Generator) -> Nothing {
    self.release_register(self.register_rax)
    self.release_register(self.register_rcx)
    self.release_register(self.register_rdx)
    self.release_register(self.register_rbx)
    self.release_register(self.register_rsi)
    self.release_register(self.register_rdi)
    self.release_register(self.register_r8)
    self.release_register(self.register_r9)
    self.release_register(self.register_r10)
    self.release_register(self.register_r11)
    self.release_register(self.register_r12)
    self.release_register(self.register_r13)
    self.release_register(self.register_r14)
    self.release_register(self.register_r15)
}

release_register :: (self: @MC_Generator, register: @MC_Register) -> Nothing {
    variable: @MC_Variable = register.variable
    if (variable != null) {
        if (variable.is_still_needed()) {
            self.abort(clone("TODO: Release register ").append(register.name_q))
        } else {
            if (variable.prev_variable != null) {
                variable.prev_variable.next_variable = variable.next_variable
            } else {
                self.first_variable = variable.next_variable
            }
            if (variable.next_variable != null) {
                variable.next_variable.prev_variable = variable.prev_variable
            } else {
                self.last_variable = variable.prev_variable
            }
            register.variable = null
        }
    }
}

is_still_needed :: (variable: @MC_Variable) -> Boolean {
    ir_values_item: @List_Item = variable.ir_variable.values.first_item
    while (ir_values_item != null) {
        ir_value: @IR_Value = ir_values_item.data as @IR_Value
        user_instructions_item: @List_Item = ir_value.user_instructions.first_item
        while (user_instructions_item != null) {
            user_instruction: @IR_Instruction = user_instructions_item.data as @IR_Instruction
            if (user_instruction.is_generated == false) {
                return true
            }
            user_instructions_item = user_instructions_item.next_item
        }
        ir_values_item = ir_values_item.next_item
    }
    return false
}

MC_Variable :: struct {
    prev_variable: @MC_Variable
    next_variable: @MC_Variable
    ir_variable: @IR_Variable
    ir_value: @IR_Variable_Value
    register: @MC_Register
    address: @MC_Address
}

MC_Register :: struct : Object {
    name_q: @String
    name_d: @String
    name_w: @String
    name_b: @String
    variable: @MC_Variable
}

init :: (self: @MC_Register, name_q: @String, name_d: @String, name_w: @String, name_b: @String) -> @MC_Register {
    self.name_q = name_q
    self.name_d = name_d
    self.name_w = name_w
    self.name_b = name_b
    self.variable = null
    return self
}

MC_Register_RAX :: struct : MC_Register {
}

MC_Register_RCX :: struct : MC_Register {
}

MC_Register_RDX :: struct : MC_Register {
}

MC_Register_RBX :: struct : MC_Register {
}

MC_Register_RSI :: struct : MC_Register {
}

MC_Register_RDI :: struct : MC_Register {
}

MC_Register_R8 :: struct : MC_Register {
}

MC_Register_R9 :: struct : MC_Register {
}

MC_Register_R10 :: struct : MC_Register {
}

MC_Register_R11 :: struct : MC_Register {
}

MC_Register_R12 :: struct : MC_Register {
}

MC_Register_R13 :: struct : MC_Register {
}

MC_Register_R14 :: struct : MC_Register {
}

MC_Register_R15 :: struct : MC_Register {
}

MC_Address :: struct : Object {
}

write :: (file: @FILE, address: @MC_Address) -> @FILE {
    if (address.is(MC_Global_Variable_Address)) {
        address: @MC_Global_Variable_Address = address as @MC_Global_Variable_Address
        return file.write(address.ir_variable.name).write("[rip]")
    }
    if (address.is(MC_Local_Variable_Address)) {
        address: @MC_Local_Variable_Address = address as @MC_Local_Variable_Address
        return file.write("[rbp-").write(address.offset).write(']')
    }
    abort(clone("Unsupported type: ").append(address.object_type.name))
}

MC_Global_Variable_Address :: struct : MC_Address {
    ir_variable: @IR_Variable
}

create_mc_global_variable_address :: (ir_variable: @IR_Variable) -> @MC_Global_Variable_Address {
    address: @MC_Global_Variable_Address = new MC_Global_Variable_Address
    address.ir_variable = ir_variable
    return address
}

MC_Local_Variable_Address :: struct : MC_Address {
    offset: Int
}

create_mc_local_variable_address :: (offset: Int) -> @MC_Local_Variable_Address {
    address: @MC_Local_Variable_Address = new MC_Local_Variable_Address
    address.offset = offset
    return address
}

get_type_size :: (self: @MC_Generator, variable: @MC_Variable) -> Int {
    ir_type: @IR_Type = variable.ir_variable.type
    if (ir_type.is(IR_Int_Type)) {
        return 8
    }
    if (ir_type.is(IR_Pointer_Type)) {
        return 8
    }
    self.abort(clone("Unsupported type: ").append(ir_type.object_type.name))
}

\ -------------------------------------------------------------------------------------------------
\       IR_Builder
\ -------------------------------------------------------------------------------------------------

build :: (compilation_unit: @Compilation_Unit) -> @IR_Build {
    builder: @IR_Builder = create_ir_builder(compilation_unit)
    builder.build()
    build: @IR_Build = new IR_Build
    build.source = compilation_unit.source
    build.named_functions = builder.named_functions
    return build
}

IR_Build :: struct {
    source: @Source
    named_functions: @List
}

IR_Builder :: struct {
    context: @IR_Builder_Context
    compilation_unit: @Compilation_Unit
    named_types: @List
    named_functions: @List
    current_block: @IR_Block
    current_loop: @IR_Loop
    counter: @Counter
}

IR_Builder_Context :: struct {
    parent: @IR_Builder_Context
    variables: @List
    named_values: @List
}

IR_Loop :: struct {
    parent: @IR_Loop
    end_block: @IR_Block
}

create_ir_builder :: (compilation_unit: @Compilation_Unit) -> @IR_Builder {
    builder: @IR_Builder = new IR_Builder
    builder.compilation_unit = compilation_unit
    builder.context = create_ir_builder_context(null, false)
    builder.named_types = create_list()
    builder.named_types.append(new IR_Any_Type.init("Any"))
    builder.named_types.append(new IR_Boolean_Type.init("Boolean"))
    builder.named_types.append(new IR_Int_Type.init("Int"))
    builder.named_types.append(new IR_Int8_Type.init("Int8"))
    builder.named_types.append(new IR_Int16_Type.init("Int16"))
    builder.named_types.append(new IR_Int32_Type.init("Int32"))
    builder.named_types.append(new IR_Int64_Type.init("Int64"))
    builder.named_types.append(new IR_Nothing_Type.init("Nothing"))
    builder.named_types.append(new IR_Null_Type.init("Null"))
    builder.named_functions = create_list()
    builder.current_block = null
    builder.current_loop = null
    builder.counter = new Counter.init()
    return builder
}

create_ir_builder_context :: (parent: @IR_Builder_Context, reuse_named_values: Boolean) -> @IR_Builder_Context {
    context: @IR_Builder_Context = new IR_Builder_Context
    context.parent = parent
    context.variables = create_list()
    if (reuse_named_values) {
        context.named_values = parent.named_values
    } else {
        context.named_values = create_list()
    }
    return context
}

create_ir_loop :: (parent: @IR_Loop, end_block: @IR_Block) -> @IR_Loop {
    new_loop: @IR_Loop = new IR_Loop
    new_loop.parent = parent
    new_loop.end_block = end_block
    return new_loop
}

get_named_type :: (self: @IR_Builder, name: @String) -> @IR_Type {
    named_types: @List_Iterator = self.named_types.create_iterator()
    while (named_types.has_next()) {
        named_type: @IR_Type = named_types.next() as @IR_Type
        if (name.equals(named_type.name)) {
            return named_type
        }
    }
    return null
}

add_variable :: (self: @IR_Builder, variable: @IR_Variable) -> @IR_Variable {
    self.context.variables.prepend(variable)
    return variable
}

get_variable :: (self: @IR_Builder, name: @String) -> @IR_Variable {
    context: @IR_Builder_Context = self.context
    loop {
        variables: @List_Iterator = context.variables.create_iterator()
        while (variables.has_next()) {
            variable: @IR_Variable = variables.next() as @IR_Variable
            if (name.equals(variable.name)) {
                return variable
            }
        }
        context = context.parent
        if (context == null) {
            return null
        }
    }
}

get_variable_value :: (self: @IR_Builder, variable: @IR_Variable) -> @IR_Variable_Value {
    if (variable.is(IR_Global_Variable)) {
        return self.append(create_ir_load_variable_instruction(self.create_variable_value(variable))) as @IR_Variable_Value
    }
    current_block_instruction: @IR_Instruction = self.current_block.last_instruction
    while (current_block_instruction != null) {
        if (current_block_instruction.result_value != null && current_block_instruction.result_value.variable == variable) {
            return current_block_instruction.result_value
        }
        current_block_instruction = current_block_instruction.prev_instruction
    }
    instruction: @IR_Instruction = self.current_block.prepend(create_ir_phi_instruction(self.create_variable_value(variable)))
    return instruction.result_value
}

create_variable_value :: (self: @IR_Builder, variable: @IR_Variable) -> @IR_Variable_Value {
    return new IR_Variable_Value.init(variable)
}

get_named_function :: (self: @IR_Builder, name: @Identifier_Token, argument_types: @List) -> @IR_Function {
    function: @IR_Function = self.get_named_function(name.lexeme, argument_types)
    if (function == null) {
        message: @String = clone("Undefined function: ").append(name.lexeme).append(" :: (")
        argument_types: @List_Iterator = argument_types.create_iterator()
        while (argument_types.has_next()) {
            argument_type: @IR_Type = argument_types.next() as @IR_Type
            message.append(argument_type.name)
            if (argument_types.has_next()) {
                message.append(", ")
            }
        }
        message.append(")")
        abort(name.location, message)
    }
    return function
}

get_named_function :: (self: @IR_Builder, name: @String, argument_types: @List) -> @IR_Function {
    function: @IR_Function = null
    named_functions: @List_Iterator = self.named_functions.create_iterator()
    while (named_functions.has_next()) {
        named_function: @IR_Function = named_functions.next() as @IR_Function
        if (name.equals(named_function.name)) {
            is_match: Boolean = true
            argument_types: @List_Iterator = argument_types.create_iterator()
            named_function_parameters: @List_Iterator = named_function.parameters.create_iterator()
            while (argument_types.has_next() && named_function_parameters.has_next()) {
                argument_type: @IR_Type = argument_types.next() as @IR_Type
                named_function_parameter: @IR_Function_Parameter = named_function_parameters.next() as @IR_Function_Parameter
                if (named_function_parameter.type.accepts(argument_type) == false) {
                    is_match = false
                    break
                }
            }
            if (is_match && argument_types.has_next() == false && named_function_parameters.has_next() == false) {
                if (function != null) {
                    abort(name)
                }
                function = named_function
            }
        }
    }
    return function
}

accepts :: (self: @IR_Type, other: @IR_Type) -> Boolean {
    if (self == other) {
        return true
    }
    if (self.is(IR_Pointer_Type)) {
        self: @IR_Pointer_Type = self as @IR_Pointer_Type
        if (self.pointed_type.is(IR_Pointer_Type)) {
            stop: Boolean = true
        }
        if (other.is(IR_Pointer_Type)) {
            other: @IR_Pointer_Type = other as @IR_Pointer_Type
            if (self.pointed_type == other.pointed_type) {
                return true
            }
            if (self.pointed_type.is(IR_Any_Type)) {
                return true
            }
            if (self.pointed_type.is(IR_Struct_Type) && other.pointed_type.is(IR_Struct_Type)) {
                return (self.pointed_type as @IR_Struct_Type).is_base_type(other.pointed_type as @IR_Struct_Type)
            }
            return self.pointed_type.accepts(other.pointed_type)
        }
        if (other.is(IR_Null_Type)) {
            return true
        }
        return false
    }
    return false
}

create_temp_variable :: (self: @IR_Builder, type: @IR_Type) -> @IR_Variable {
    return new IR_Variable.init(clone("$").append(self.counter.next()), type)
}

create_temp_value :: (self: @IR_Builder, type: @IR_Type) -> @IR_Variable_Value {
    return self.create_variable_value(self.create_temp_variable(type))
}

append :: (self: @IR_Builder, instruction: @IR_Instruction) -> @IR_Variable_Value {
    self.current_block.append(instruction)
    return instruction.result_value
}

build :: (self: @IR_Builder) -> Nothing {
    types: @List_Iterator = self.compilation_unit.types.create_iterator()
    while (types.has_next()) {
        statement: @AST_Statement = types.next() as @AST_Statement
        self.convert_type_statement(statement)
    }

    global_variables: @List_Iterator = self.compilation_unit.global_variables.create_iterator()
    while (global_variables.has_next()) {
        variable_statement: @AST_Variable_Statement = global_variables.next() as @AST_Variable_Statement
        self.create_global_variable(variable_statement)
    }

    functions: @List_Iterator = self.compilation_unit.functions.create_iterator()
    while (functions.has_next()) {
        function_statement: @AST_Function_Statement = functions.next() as @AST_Function_Statement
        self.create_function(function_statement)
    }

    functions: @List_Iterator = self.compilation_unit.functions.create_iterator()
    while (functions.has_next()) {
        function_statement: @AST_Function_Statement = functions.next() as @AST_Function_Statement
        self.build_function(function_statement)
    }
}

convert_type_statement :: (self: @IR_Builder, statement: @AST_Statement) -> @IR_Type {
    if (statement.is(AST_Struct_Statement)) {
        return self.convert_struct_statement(statement as @AST_Struct_Statement)
    }
    abort(statement.location, statement.object_type)
}

convert_struct_statement :: (self: @IR_Builder, struct_statement: @AST_Struct_Statement) -> @IR_Type {
    struct_name: @String = struct_statement.name.lexeme
    type: @IR_Type = self.get_named_type(struct_name)
    if (type != null) {
        if (type.is(IR_Struct_Type) && (type as @IR_Struct_Type).statement == struct_statement) {
            return type
        }
        abort(struct_statement.location, clone("Duplicate type declaration: ").append(struct_name))
    }
    type: @IR_Struct_Type = create_ir_struct_type(struct_name, struct_statement)
    self.named_types.append(type)
    if (struct_statement.base_type != null) {
        base_type: @IR_Type = self.convert_value_type(struct_statement.base_type)
        if ((base_type.is(IR_Struct_Type)) == false) {
            abort(struct_statement.base_type.location, "Not a struct type.")
        }
        type.base_type = base_type as @IR_Struct_Type
    }
    if (struct_statement.members != null) {
        struct_members: @List_Iterator = struct_statement.members.create_iterator()
        while (struct_members.has_next()) {
            struct_member: @AST_Struct_Member = struct_members.next() as @AST_Struct_Member
            struct_member_name: @String = struct_member.name.lexeme
            struct_member_type: @IR_Type = self.convert_value_type(struct_member.type)
            type.add_member(struct_member_name, struct_member_type)
        }
    }
    if (type.is_object_type()) {
        self.create_global_variable(create_ast_variable_statement(struct_statement.name, create_ast_pointer_type(null, create_ast_named_type(create_identifier_token("Object_Type", null))), null, false))
    }
    return type
}

convert_value_type :: (self: @IR_Builder, type: @AST_Type) -> @IR_Type {
    if (type.is(AST_Array_Type)) {
        return self.convert_array_type(type as @AST_Array_Type)
    }
    if (type.is(AST_Named_Type)) {
        return self.convert_named_type(type as @AST_Named_Type)
    }
    if (type.is(AST_Pointer_Type)) {
        return self.convert_pointer_type(type as @AST_Pointer_Type)
    }
    abort(type.location, type.object_type)
}

convert_array_type :: (self: @IR_Builder, type: @AST_Array_Type) -> @IR_Type {
    return create_ir_array_type(self.convert_value_type(type.item_type), type.size_expression)
}

convert_named_type :: (self: @IR_Builder, type: @AST_Named_Type) -> @IR_Type {
    type_name: @Identifier_Token = type.name
    type: @IR_Type = self.get_named_type(type_name.lexeme)
    if (type == null) {
        types: @List_Iterator = self.compilation_unit.types.create_iterator()
        while (types.has_next()) {
            statement: @AST_Statement = types.next() as @AST_Statement
            if (statement.is(AST_Struct_Statement)) {
                statement: @AST_Struct_Statement = statement as @AST_Struct_Statement
                if (statement.name.lexeme.equals(type_name.lexeme)) {
                    return self.convert_struct_statement(statement)
                }
            } else {
                abort(statement.location, statement.object_type)
            }
        }
        abort(type_name.location, clone("Unknown type: ").append(type_name.lexeme))
    }
    return type
}

convert_pointer_type :: (self: @IR_Builder, type: @AST_Pointer_Type) -> @IR_Type {
    return create_ir_pointer_type(self.convert_value_type(type.pointed_type))
}

create_global_variable :: (self: @IR_Builder, variable_statement: @AST_Variable_Statement) -> Nothing {
    variable_name: @String = variable_statement.name.lexeme
    variable_type: @IR_Type
    if (variable_statement.type != null) {
        variable_type = self.convert_value_type(variable_statement.type)
    } else {
        abort(variable_statement.location, "Type inference is not supported yet.")
    }
    variable: @IR_Variable = create_ir_global_variable(variable_name, variable_type, variable_statement.is_external)
    if (variable_statement.value_expression != null) {
        abort(variable_statement.value_expression.location, "Initialized global variables are not supported yet.")
    }
    self.add_variable(variable)
    self.create_variable_value(variable)
}

create_function :: (self: @IR_Builder, function_statement: @AST_Function_Statement) -> @IR_Function {
    function: @IR_Function = new IR_Function
    function.id = self.named_functions.size + 1
    function.location = function_statement.location
    function.blocks = create_list()
    function.name = function_statement.name.lexeme
    function.parameters = create_list()
    function.return_type = self.convert_value_type(function_statement.return_type)

    parameters: @List_Iterator = function_statement.parameters.create_iterator()
    while (parameters.has_next()) {
        parameter: @AST_Function_Parameter = parameters.next() as @AST_Function_Parameter
        parameter_type: @IR_Type = self.convert_value_type(parameter.type)
        parameter_name: @String = parameter.name.lexeme
        function_parameter: @IR_Function_Parameter = new IR_Function_Parameter.init(parameter_name, parameter_type) as @IR_Function_Parameter
        function.parameters.append(function_parameter)
    }

    function_statement.ir_function = function
    self.named_functions.append(function)

    return function
}

build_function :: (self: @IR_Builder, function_statement: @AST_Function_Statement) -> Nothing {
    if (function_statement.body == null) {
        return
    }

    function: @IR_Function = function_statement.ir_function

    self.context = create_ir_builder_context(self.context, false)
    self.counter.reset()

    self.current_block = function.create_block()

    function_parameters: @List_Iterator = function.parameters.create_iterator()
    while (function_parameters.has_next()) {
        function_parameter: @IR_Function_Parameter = function_parameters.next() as @IR_Function_Parameter
        self.add_variable(function_parameter)
        self.current_block.append(create_ir_load_variable_instruction(self.create_variable_value(function_parameter)))
    }

    self.convert_block_statement(function_statement.body)
    if (self.current_block.last_instruction == null || self.current_block.last_instruction.is_exit_instruction() == false) {
        if (self.current_block.predecessors.size == 0) {
            \ this block is unreachable
            function.blocks.remove(self.current_block)
        } else {
            if (function.return_type.is(IR_Nothing_Type)) {
                self.append(create_ir_return_instruction(null))
            } else {
                abort(function_statement.location, "Missing return statement")
            }
        }
    }
    self.current_block = null

    self.remove_redundant_blocks(function)
    self.populate_phi_instructions(function)
    self.remove_trivial_phi_instructions(function)
    self.remove_redundant_set_instructions(function)

    self.context = self.context.parent
}

remove_redundant_blocks :: (self: @IR_Builder, function: @IR_Function) -> Nothing {
    loop {
        repeat: Boolean = false

        blocks: @List_Iterator = function.blocks.prune().create_iterator()

        \ skip entry block
        blocks.next()

        while (blocks.has_next()) {
            block: @IR_Block = blocks.next() as @IR_Block
            if (block.predecessors.size == 0) {
                \ found unreachable block
                if (block.last_instruction == null) {
                    blocks.remove_current()
                } else {
                    if (block.last_instruction == block.first_instruction && block.last_instruction.is(IR_Direct_Jump_Instruction)) {
                        block_instruction: @IR_Direct_Jump_Instruction = block.last_instruction as @IR_Direct_Jump_Instruction
                        block_instruction.block.predecessors.remove(block)
                        block_instruction.block.predecessors.prune()
                        blocks.remove_current()
                        repeat = true
                        break
                    } else {
                        abort(function.location, clone("Found non-empty unreachable block: block.").append(block.id))
                    }
                }
            }
            if (block.first_instruction == block.last_instruction && block.first_instruction.is(IR_Direct_Jump_Instruction)) {
                \ found jump block
                block_predecessor: @IR_Block = block.predecessors.last() as @IR_Block
                block_successor: @IR_Block = (block.first_instruction as @IR_Direct_Jump_Instruction).block
                if (block_predecessor.last_instruction.is(IR_Conditional_Jump_Instruction)) {
                    block.predecessors.remove(block_predecessor).prune()
                    block_predecessor_instruction: @IR_Conditional_Jump_Instruction = block_predecessor.last_instruction as @IR_Conditional_Jump_Instruction
                    if (block_predecessor_instruction.false_block == block) {
                        block_predecessor_instruction.false_block = block_successor
                    } else {
                        block_predecessor_instruction.true_block = block_successor
                    }
                    block_successor.predecessors.remove(block).prune().append(block_predecessor)
                    repeat = true
                    break
                }
                if (block_predecessor.last_instruction.is(IR_Direct_Jump_Instruction)) {
                    block.predecessors.remove(block_predecessor).prune()
                    block_predecessor_instruction: @IR_Direct_Jump_Instruction = block_predecessor.last_instruction as @IR_Direct_Jump_Instruction
                    block_predecessor_instruction.block = block_successor
                    block_successor.predecessors.remove(block).prune().append(block_predecessor)
                    repeat = true
                    break
                }
            }
        }

        if (repeat == false) {
            break
        }
    }
}

populate_phi_instructions :: (self: @IR_Builder, function: @IR_Function) -> Nothing {
    blocks: @List_Iterator = function.blocks.create_iterator()
    while (blocks.has_next()) {
        block: @IR_Block = blocks.next() as @IR_Block
        block_instruction: @IR_Instruction = block.first_instruction
        while (block_instruction != null && block_instruction.is(IR_Phi_Instruction)) {
            instruction: @IR_Phi_Instruction = block_instruction as @IR_Phi_Instruction
            if (instruction.values.size == 0) {
                block_predecessors: @List_Iterator = block.predecessors.create_iterator()
                while (block_predecessors.has_next()) {
                    block_predecessor: @IR_Block = block_predecessors.next() as @IR_Block
                    instruction.append(self.get_block_variable_value(block_predecessor, instruction.result_value.variable))
                }
            }
            block_instruction = block_instruction.next_instruction
        }
    }
}

get_block_variable_value :: (self: @IR_Builder, block: @IR_Block, variable: @IR_Variable) -> @IR_Value {
    block_instruction: @IR_Instruction = block.last_instruction
    while (block_instruction != null) {
        if (block_instruction.result_value != null && block_instruction.result_value.variable == variable) {
            return block_instruction.result_value
        }
        block_instruction = block_instruction.prev_instruction
    }
    if (block.predecessors.size == 1) {
        return self.get_block_variable_value(block.predecessors.last() as @IR_Block, variable)
    }
    instruction: @IR_Phi_Instruction = create_ir_phi_instruction(self.create_variable_value(variable))
    block.prepend(instruction)
    block_predecessors: @List_Iterator = block.predecessors.create_iterator()
    while (block_predecessors.has_next()) {
        block_predecessor: @IR_Block = block_predecessors.next() as @IR_Block
        instruction.append(self.get_block_variable_value(block_predecessor, variable))
    }
    return instruction.result_value
}

remove_trivial_phi_instructions :: (self: @IR_Builder, function: @IR_Function) -> Nothing {
    loop {
        repeat: Boolean = false

        blocks: @List_Iterator = function.blocks.prune().create_iterator()

        \ skip entry block
        blocks.next()

        while (blocks.has_next()) {
            block: @IR_Block = blocks.next() as @IR_Block
            block_instruction: @IR_Instruction = block.first_instruction
            while (block_instruction != null && block_instruction.is(IR_Phi_Instruction)) {
                instruction: @IR_Phi_Instruction = block_instruction as @IR_Phi_Instruction
                if (instruction.is_trivial()) {
                    \ found a trivial phi instruction
                    instruction.values.remove_all(instruction.result_value).prune()
                }
                if (instruction.is_redundant()) {
                    \ found redundant phi instruction
                    user_instructions: @List_Iterator = instruction.result_value.user_instructions.create_iterator()
                    while (user_instructions.has_next()) {
                        user_instruction: @IR_Instruction = user_instructions.next() as @IR_Instruction
                        user_instruction.replace_value(instruction.result_value, instruction.values.last() as @IR_Value)
                    }
                    block.remove(instruction)
                    repeat = true
                }
                block_instruction = block_instruction.next_instruction
            }
        }

        if (repeat == false) {
            break
        }
    }
}

remove_redundant_set_instructions :: (self: @IR_Builder, function: @IR_Function) -> Nothing {
    loop {
        repeat: Boolean = false

        blocks: @List_Iterator = function.blocks.prune().create_iterator()
        while (blocks.has_next()) {
            block: @IR_Block = blocks.next() as @IR_Block

            block_instruction: @IR_Instruction = block.first_instruction
            while (block_instruction != null) {
                if (block_instruction.is(IR_Set_Instruction)) {
                    instruction: @IR_Set_Instruction = block_instruction as @IR_Set_Instruction
                    instruction_value: @IR_Value = instruction.get_value()
                    if (instruction.prev_instruction != null && instruction_value.user_instructions.size == 1) {
                        instruction.prev_instruction.result_value = instruction.result_value
                        block.remove(instruction)
                        repeat = true
                        break
                    }
                }
                block_instruction = block_instruction.next_instruction
            }
        }

        if (repeat == false) {
            break
        }
    }
}

replace_value :: (instruction: @IR_Instruction, value: @IR_Value, new_value: @IR_Value) -> Nothing {
    value.user_instructions.remove(instruction).prune()
    new_value.user_instructions.append(instruction)
    if (instruction.is(IR_Phi_Instruction)) {
        instruction: @IR_Phi_Instruction = instruction as @IR_Phi_Instruction
        instruction_values: @List_Iterator = instruction.values.create_iterator()
        while (instruction_values.has_next()) {
            instruction_value: @IR_Value = instruction_values.next() as @IR_Value
            if (instruction_value == value) {
                instruction.values.remove_all(value).remove_all(new_value).prune().append(new_value)
            }
        }
        return
    }
    instruction.operand_values.replace(value, new_value)
}

convert_statement :: (self: @IR_Builder, statement: @AST_Statement) -> Nothing {
    if (self.current_block == null) {
        abort(statement.location, clone(statement.object_type.name).append(" requires a basic block."))
    }
    if (statement.is(AST_Assignment_Statement)) {
        self.convert_assignment_statement(statement as @AST_Assignment_Statement)
        return
    }
    if (statement.is(AST_Block_Statement)) {
        self.convert_block_statement(statement as @AST_Block_Statement)
        return
    }
    if (statement.is(AST_Break_Statement)) {
        self.convert_break_statement(statement as @AST_Break_Statement)
        return
    }
    if (statement.is(AST_Expression_Statement)) {
        self.convert_expression_statement(statement as @AST_Expression_Statement)
        return
    }
    if (statement.is(AST_If_Statement)) {
        self.convert_if_statement(statement as @AST_If_Statement)
        return
    }
    if (statement.is(AST_Loop_Statement)) {
        self.convert_loop_statement(statement as @AST_Loop_Statement)
        return
    }
    if (statement.is(AST_Return_Statement)) {
        self.convert_return_statement(statement as @AST_Return_Statement)
        return
    }
    if (statement.is(AST_Variable_Statement)) {
        self.convert_variable_statement(statement as @AST_Variable_Statement)
        return
    }
    if (statement.is(AST_While_Statement)) {
        self.convert_while_statement(statement as @AST_While_Statement)
        return
    }
    abort(statement.location, statement.object_type)
}

convert_assignment_statement :: (self: @IR_Builder, assignment_statement: @AST_Assignment_Statement) -> Nothing {
    if (assignment_statement.storage_expression.is(AST_Array_Access_Expression)) {
        array_access_expression: @AST_Array_Access_Expression = assignment_statement.storage_expression as @AST_Array_Access_Expression
        array_item_index_value: @IR_Value = self.convert_expression(array_access_expression.index_expression)
        value: @IR_Value = self.convert_expression(assignment_statement.value_expression)
        array_address: @IR_Value = self.convert_expression_address(array_access_expression.array_expression)
        if (array_address.type.is(IR_Pointer_Type) == false) {
            abort(assignment_statement.location, clone("Not an array pointer"))
        }
        array_item_type: @IR_Type = (array_address.type as @IR_Pointer_Type).pointed_type
        if (array_item_type.accepts(value.type) == false) {
            abort(assignment_statement.value_expression.location, "Invalid expression type")
        }
        self.append(create_ir_store_array_item_instruction(array_address, array_item_index_value, value))
        return
    }
    value: @IR_Value = self.convert_expression(assignment_statement.value_expression)
    if (assignment_statement.storage_expression.is(AST_Member_Access_Expression)) {
        member_access_expression: @AST_Member_Access_Expression = assignment_statement.storage_expression as @AST_Member_Access_Expression
        object_address_value: @IR_Value = self.convert_expression_address(member_access_expression.object_expression)
        if (object_address_value.type.is(IR_Pointer_Type) == false) {
            abort(assignment_statement.location, clone("Not a '").append(IR_Pointer_Type.name).append("' value"))
        }
        object_type: @IR_Type = (object_address_value.type as @IR_Pointer_Type).pointed_type
        if (object_type.is(IR_Struct_Type) == false) {
            abort(assignment_statement.location, clone("Not a '").append(IR_Struct_Type.name).append("' value"))
        }
        struct_type_member: @IR_Struct_Type_Member = (object_type as @IR_Struct_Type).get_member(member_access_expression.member_name.lexeme)
        if (struct_type_member == null) {
            abort(member_access_expression.member_name.location, clone(object_type.name).append(" doesn't have a '").append(member_access_expression.member_name.lexeme).append("' member"))
        }
        if (struct_type_member.type.accepts(value.type) == false) {
            abort(assignment_statement.value_expression.location, clone("Cannot assign a '").append(value.type.name).append("' value to a '").append(struct_type_member.type.name).append("' struct member"))
        }
        self.append(create_ir_store_struct_member_instruction(object_address_value, struct_type_member, value))
        return
    }
    if (assignment_statement.storage_expression.is(AST_Variable_Expression)) {
        variable_expression: @AST_Variable_Expression = assignment_statement.storage_expression as @AST_Variable_Expression
        variable_name: @String = variable_expression.name.lexeme
        variable: @IR_Variable = self.get_variable(variable_name)
        if (variable == null) {
            abort(variable_expression.location, clone("Undeclared variable: ").append(variable_name))
        }
        if (variable.type.accepts(value.type) == false) {
            abort(variable_expression.location, clone("Cannot assign a '").append(value.type.name).append("' value to a '").append(variable.type.name).append("' variable"))
        }
        self.append(create_ir_set_instruction(self.create_variable_value(variable), value))
        return
    }
    abort(assignment_statement.location, assignment_statement.storage_expression.object_type)
}

convert_block_statement :: (self: @IR_Builder, statement: @AST_Block_Statement) -> Nothing {
    self.context = create_ir_builder_context(self.context, true)
    block_statements: @List_Iterator = statement.statements.create_iterator()
    while (block_statements.has_next()) {
        block_statement: @AST_Statement = block_statements.next() as @AST_Statement
        self.convert_statement(block_statement)
    }
    self.context = self.context.parent
}

convert_break_statement :: (self: @IR_Builder, statement: @AST_Break_Statement) -> Nothing {
    if (self.current_loop == null) {
        abort(statement.location, "Break outside of a loop?")
    }
    self.current_block.append_jump(self.current_loop.end_block)
}

convert_expression_statement :: (self: @IR_Builder, statement: @AST_Expression_Statement) -> Nothing {
    self.convert_expression(statement.expression)
}

convert_if_statement :: (self: @IR_Builder, statement: @AST_If_Statement) -> Nothing {
    condition_value: @IR_Value = self.convert_expression(statement.condition_expression)
    true_block: @IR_Block = self.current_block.function.create_block()
    end_block: @IR_Block = self.current_block.function.create_block()
    if (statement.false_block != null) {
        false_block: @IR_Block = self.current_block.function.create_block()
        self.current_block.append_jump(condition_value, true_block, false_block)
        self.current_block = false_block
        self.convert_block_statement(statement.false_block)
        if (self.current_block.last_instruction.is_exit_instruction() == false) {
            self.current_block.append_jump(end_block)
        }
    } else {
        self.current_block.append_jump(condition_value, true_block, end_block)
    }
    self.current_block = true_block
    self.convert_block_statement(statement.true_block)
    if (self.current_block.last_instruction.is_exit_instruction() == false) {
        self.current_block.append_jump(end_block)
    }
    self.current_block = end_block
}

convert_loop_statement :: (self: @IR_Builder, statement: @AST_Loop_Statement) -> Nothing {
    loop_block: @IR_Block = self.current_block.function.create_block()
    end_block: @IR_Block = self.current_block.function.create_block()
    self.current_block.append_jump(loop_block)
    self.current_block = loop_block
    self.current_loop = create_ir_loop(self.current_loop, end_block)
    self.convert_block_statement(statement.block)
    self.current_block.append_jump(loop_block)
    self.current_block = end_block
    self.current_loop = self.current_loop.parent
}

convert_return_statement :: (self: @IR_Builder, statement: @AST_Return_Statement) -> Nothing {
    if (statement.value_expression != null) {
        return_value: @IR_Value = self.convert_expression(statement.value_expression)
        if (self.current_block.function.return_type.accepts(return_value.type) == false) {
            abort(statement.location, clone("Unexpected returned expression type: ").append(return_value.type.name))
        }
        self.append(create_ir_return_instruction(return_value))
    } else {
        self.append(create_ir_return_instruction(null))
    }
}

convert_variable_statement :: (self: @IR_Builder, variable_statement: @AST_Variable_Statement) -> Nothing {
    variable_name: @String = variable_statement.name.lexeme
    variable_type: @IR_Type
    if (variable_statement.type != null) {
        variable_type = self.convert_value_type(variable_statement.type)
    } else {
        abort(variable_statement.location, "Type inference is not supported yet.")
    }
    variable: @IR_Variable = new IR_Variable.init(variable_name, variable_type)
    if (variable_statement.value_expression != null) {
        variable_value: @IR_Value = self.convert_expression(variable_statement.value_expression)
        if (variable.type.accepts(variable_value.type) == false) {
            abort(variable_statement.value_expression.location, clone("Cannot assign a '").append(variable_value.type.name).append("' value to a '").append(variable.type.name).append("' variable"))
        }
        self.add_variable(variable)
        self.append(create_ir_set_instruction(self.create_variable_value(variable), variable_value))
    } else {
        self.add_variable(variable)
        self.append(create_ir_set_instruction(self.create_variable_value(variable), new IR_Undefined_Value.init(variable.type)))
    }
}

convert_while_statement :: (self: @IR_Builder, statement: @AST_While_Statement) -> Nothing {
    condition_block: @IR_Block = self.current_block.function.create_block()
    loop_block: @IR_Block = self.current_block.function.create_block()
    end_block: @IR_Block = self.current_block.function.create_block()
    self.current_block.append_jump(condition_block)
    self.current_block = condition_block
    condition_value: @IR_Value = self.convert_expression(statement.condition_expression)
    self.current_block.append_jump(condition_value, loop_block, end_block)
    self.current_block = loop_block
    self.current_loop = create_ir_loop(self.current_loop, end_block)
    self.convert_block_statement(statement.block)
    self.current_block.append_jump(condition_block)
    self.current_block = end_block
    self.current_loop = self.current_loop.parent
}

convert_expression :: (self: @IR_Builder, expression: @AST_Expression) -> @IR_Value {
    if (expression.is(AST_Add_Expression)) {
        return self.convert_add_expression(expression as @AST_Add_Expression)
    }
    if (expression.is(AST_Array_Access_Expression)) {
        return self.convert_array_access_expression(expression as @AST_Array_Access_Expression)
    }
    if (expression.is(AST_Call_Expression)) {
        return self.convert_call_expression(expression as @AST_Call_Expression)
    }
    if (expression.is(AST_Cast_Expression)) {
        return self.convert_cast_expression(expression as @AST_Cast_Expression)
    }
    if (expression.is(AST_Divide_Expression)) {
        return self.convert_divide_expression(expression as @AST_Divide_Expression)
    }
    if (expression.is(AST_Equals_Expression)) {
        return self.convert_equals_expression(expression as @AST_Equals_Expression)
    }
    if (expression.is(AST_Greater_Than_Expression)) {
        return self.convert_greater_than_expression(expression as @AST_Greater_Than_Expression)
    }
    if (expression.is(AST_Greater_Than_Or_Equals_Expression)) {
        return self.convert_greater_than_or_equals_expression(expression as @AST_Greater_Than_Or_Equals_Expression)
    }
    if (expression.is(AST_Less_Than_Expression)) {
        return self.convert_less_than_expression(expression as @AST_Less_Than_Expression)
    }
    if (expression.is(AST_Less_Than_Or_Equals_Expression)) {
        return self.convert_less_than_or_equals_expression(expression as @AST_Less_Than_Or_Equals_Expression)
    }
    if (expression.is(AST_Literal_Expression)) {
        return self.convert_literal_expression(expression as @AST_Literal_Expression)
    }
    if (expression.is(AST_Logic_And_Expression)) {
        return self.convert_logic_and_expression(expression as @AST_Logic_And_Expression)
    }
    if (expression.is(AST_Logic_Or_Expression)) {
        return self.convert_logic_or_expression(expression as @AST_Logic_Or_Expression)
    }
    if (expression.is(AST_Member_Access_Expression)) {
        return self.convert_member_access_expression(expression as @AST_Member_Access_Expression)
    }
    if (expression.is(AST_Modulo_Expression)) {
        return self.convert_modulo_expression(expression as @AST_Modulo_Expression)
    }
    if (expression.is(AST_Multiply_Expression)) {
        return self.convert_multiply_expression(expression as @AST_Multiply_Expression)
    }
    if (expression.is(AST_New_Expression)) {
        return self.convert_new_expression(expression as @AST_New_Expression)
    }
    if (expression.is(AST_Not_Equals_Expression)) {
        return self.convert_not_equals_expression(expression as @AST_Not_Equals_Expression)
    }
    if (expression.is(AST_Substract_Expression)) {
        return self.convert_substract_expression(expression as @AST_Substract_Expression)
    }
    if (expression.is(AST_Variable_Expression)) {
        return self.convert_variable_expression(expression as @AST_Variable_Expression)
    }
    abort(expression.location, expression.object_type)
}

convert_expression_address :: (self: @IR_Builder, expression: @AST_Expression) -> @IR_Value {
    if (expression.is(AST_Member_Access_Expression)) {
        return self.convert_member_access_expression_address(expression as @AST_Member_Access_Expression)
    }
    if (expression.is(AST_Variable_Expression)) {
        return self.convert_variable_expression_address(expression as @AST_Variable_Expression)
    }
    abort(expression.location, expression.object_type)
}

convert_add_expression :: (self: @IR_Builder, expression: @AST_Add_Expression) -> @IR_Value {
    left_value: @IR_Value = self.convert_expression(expression.left_expression)
    right_value: @IR_Value = self.convert_expression(expression.right_expression)
    if (left_value.type.is(IR_Int_Type) == false) {
        abort(expression.left_expression.location, "Not an Int expression")
    }
    if (right_value.type.is(IR_Int_Type) == false) {
        abort(expression.right_expression.location, "Not an Int expression")
    }
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Add_Instruction.init(self.create_temp_value(left_value.type), left_value, right_value))
}

convert_array_access_expression :: (self: @IR_Builder, array_access_expression: @AST_Array_Access_Expression) -> @IR_Value {
    index_value: @IR_Value = self.convert_expression(array_access_expression.index_expression)
    object_value: @IR_Value = self.convert_expression(array_access_expression.array_expression)
    object_value_type: @IR_Type = object_value.type
    if ((object_value_type.is(IR_Pointer_Type)) == false) {
        abort(array_access_expression.location, clone("Not an IR_Pointer_Type value: ").append(object_value_type.name))
    }
    object_value_type: @IR_Pointer_Type = object_value_type as @IR_Pointer_Type
    return self.append(create_ir_load_array_item_instruction(self.create_temp_value(object_value_type.pointed_type), object_value, index_value))
}

convert_call_expression :: (self: @IR_Builder, call_expression: @AST_Call_Expression) -> @IR_Value {
    if (call_expression.callee.is(AST_Member_Access_Expression)) {
        callee: @AST_Member_Access_Expression = call_expression.callee as @AST_Member_Access_Expression
        call_arguments: @List = create_list()
        call_argument_types: @List = create_list()
        first_argument: @IR_Value = self.convert_expression(callee.object_expression)
        call_arguments.append(first_argument)
        call_argument_types.append(first_argument.type)
        call_expression_arguments: @List_Iterator = call_expression.arguments.create_iterator()
        while (call_expression_arguments.has_next()) {
            call_expression_argument: @AST_Expression = call_expression_arguments.next() as @AST_Expression
            call_argument: @IR_Value = self.convert_expression(call_expression_argument)
            call_arguments.append(call_argument)
            call_argument_types.append(call_argument.type)
        }
        call_function: @IR_Function = self.get_named_function(callee.member_name, call_argument_types)
        if (call_function == null) {
            abort(callee.member_name.location, clone("No such function: ").append(callee.member_name.lexeme))
        }
        result_value: @IR_Variable_Value = null
        if (call_function.return_type.is(IR_Nothing_Type) == false) {
            result_value = self.create_temp_value(call_function.return_type)
        }
        return self.append(create_ir_call_instruction(result_value, call_function, call_arguments))
    }
    if (call_expression.callee.is(AST_Variable_Expression)) {
        callee: @AST_Variable_Expression = call_expression.callee as @AST_Variable_Expression
        call_arguments: @List = create_list()
        call_argument_types: @List = create_list()
        call_expression_arguments: @List_Iterator = call_expression.arguments.create_iterator()
        while (call_expression_arguments.has_next()) {
            call_expression_argument: @AST_Expression = call_expression_arguments.next() as @AST_Expression
            call_argument: @IR_Value = self.convert_expression(call_expression_argument)
            call_arguments.append(call_argument)
            call_argument_types.append(call_argument.type)
        }
        call_function: @IR_Function = self.get_named_function(callee.name, call_argument_types)
        if (call_function == null) {
            abort(callee.name.location, clone("No such function: ").append(callee.name.lexeme))
        }
        result_value: @IR_Variable_Value = null
        if (call_function.return_type.is(IR_Nothing_Type) == false) {
            result_value = self.create_temp_value(call_function.return_type)
        }
        return self.append(create_ir_call_instruction(result_value, call_function, call_arguments))
    }
    abort(call_expression.location, call_expression.callee.object_type)
}

convert_cast_expression :: (self: @IR_Builder, cast_expression: @AST_Cast_Expression) -> @IR_Value {
    value: @IR_Value = self.convert_expression(cast_expression.value_expression)
    result_value: @IR_Variable_Value = self.create_temp_value(self.convert_value_type(cast_expression.type))
    if (value.type.is(IR_Pointer_Type) && result_value.type.is(IR_Pointer_Type)) {
        return self.append(create_ir_set_instruction(result_value, value))
    }
    if (value.type.is(IR_Int_Type) && (result_value.type.is(IR_Int32_Type) || result_value.type.is(IR_Int8_Type))) {
        return self.append(create_ir_cast_instruction(result_value, value))
    }
    if (value.type.is(IR_Int32_Type) && (result_value.type.is(IR_Int_Type) || result_value.type.is(IR_Int8_Type))) {
        return self.append(create_ir_cast_instruction(result_value, value))
    }
    if (value.type.is(IR_Int8_Type) && (result_value.type.is(IR_Int_Type) || result_value.type.is(IR_Int32_Type))) {
        return self.append(create_ir_cast_instruction(result_value, value))
    }
    abort(cast_expression.location, clone("Cannot cast ").append(value.type.name).append(" to ").append(result_value.type.name))
}

convert_divide_expression :: (self: @IR_Builder, expression: @AST_Divide_Expression) -> @IR_Value {
    left_value: @IR_Value = self.convert_expression(expression.left_expression)
    right_value: @IR_Value = self.convert_expression(expression.right_expression)
    if (left_value.type.is(IR_Int_Type) == false) {
        abort(expression.left_expression.location, "Not an Int expression")
    }
    if (right_value.type.is(IR_Int_Type) == false) {
        abort(expression.right_expression.location, "Not an Int expression")
    }
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Divide_Instruction.init(self.create_temp_value(left_value.type), left_value, right_value))
}

convert_equals_expression :: (self: @IR_Builder, expression: @AST_Equals_Expression) -> @IR_Value {
    left_value: @IR_Value = self.convert_expression(expression.left_expression)
    right_value: @IR_Value = self.convert_expression(expression.right_expression)
    if (left_value.type.equals(right_value.type) == false && (left_value.type.is(IR_Pointer_Type) && right_value.type.is(IR_Null_Type) == false)) {
        abort(expression.location, "Operands are not the same type")
    }
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Equals_Comparison_Instruction.init(self.create_temp_value(self.get_named_type("Boolean")), left_value, right_value))
}

convert_greater_than_expression :: (self: @IR_Builder, expression: @AST_Greater_Than_Expression) -> @IR_Value {
    left_value: @IR_Value = self.convert_expression(expression.left_expression)
    right_value: @IR_Value = self.convert_expression(expression.right_expression)
    if (left_value.type.is(IR_Int_Type) == false) {
        abort(expression.left_expression.location, "Not an Int expression")
    }
    if (right_value.type.is(IR_Int_Type) == false) {
        abort(expression.right_expression.location, "Not an Int expression")
    }
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Greater_Than_Comparison_Instruction.init(self.create_temp_value(self.get_named_type("Boolean")), left_value, right_value))
}

convert_greater_than_or_equals_expression :: (self: @IR_Builder, expression: @AST_Greater_Than_Or_Equals_Expression) -> @IR_Value {
    left_value: @IR_Value = self.convert_expression(expression.left_expression)
    right_value: @IR_Value = self.convert_expression(expression.right_expression)
    if (left_value.type.is(IR_Int_Type) == false) {
        abort(expression.left_expression.location, "Not an Int expression")
    }
    if (right_value.type.is(IR_Int_Type) == false) {
        abort(expression.right_expression.location, "Not an Int expression")
    }
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Greater_Than_Or_Equals_Comparison_Instruction.init(self.create_temp_value(self.get_named_type("Boolean")), left_value, right_value))
}

convert_less_than_expression :: (self: @IR_Builder, expression: @AST_Less_Than_Expression) -> @IR_Value {
    left_value: @IR_Value = self.convert_expression(expression.left_expression)
    right_value: @IR_Value = self.convert_expression(expression.right_expression)
    if (left_value.type.is(IR_Int_Type) == false) {
        abort(expression.left_expression.location, "Not an Int expression")
    }
    if (right_value.type.is(IR_Int_Type) == false) {
        abort(expression.right_expression.location, "Not an Int expression")
    }
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Less_Than_Comparison_Instruction.init(self.create_temp_value(self.get_named_type("Boolean")), left_value, right_value))
}

convert_less_than_or_equals_expression :: (self: @IR_Builder, expression: @AST_Less_Than_Or_Equals_Expression) -> @IR_Value {
    left_value: @IR_Value = self.convert_expression(expression.left_expression)
    right_value: @IR_Value = self.convert_expression(expression.right_expression)
    if (left_value.type.is(IR_Int_Type) == false) {
        abort(expression.left_expression.location, "Not an Int expression")
    }
    if (right_value.type.is(IR_Int_Type) == false) {
        abort(expression.right_expression.location, "Not an Int expression")
    }
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Less_Than_Or_Equals_Comparison_Instruction.init(self.create_temp_value(self.get_named_type("Boolean")), left_value, right_value))
}

convert_literal_expression :: (self: @IR_Builder, expression: @AST_Literal_Expression) -> @IR_Value {
    if (expression.literal.is(Boolean_Token)) {
        return create_ir_constant_value(self.get_named_type("Boolean"), expression.literal)
    }
    if (expression.literal.is(Character_Token)) {
        return create_ir_constant_value(self.get_named_type("Int8"), expression.literal)
    }
    if (expression.literal.is(Integer_Token)) {
        return create_ir_constant_value(self.get_named_type("Int"), expression.literal)
    }
    if (expression.literal.is(Null_Token)) {
        return create_ir_constant_value(self.get_named_type("Null"), expression.literal)
    }
    if (expression.literal.is(String_Token)) {
        return create_ir_constant_value(create_ir_pointer_type(self.get_named_type("String")), expression.literal)
    }
    abort(expression.location, expression.literal.object_type)
}

convert_logic_and_expression :: (self: @IR_Builder, expression: @AST_Logic_And_Expression) -> @IR_Value {
    next_block: @IR_Block = self.current_block.function.create_block()
    end_block: @IR_Block = self.current_block.function.create_block()
    left_value: @IR_Value = self.convert_expression(expression.left_expression)
    if (left_value.type.is(IR_Boolean_Type) == false) {
        abort(expression.left_expression.location, "Must be a boolean expression")
    }
    result_variable: @IR_Variable = self.create_temp_variable(self.get_named_type("Boolean"))
    result_value_left: @IR_Variable_Value = self.create_variable_value(result_variable)
    self.append(create_ir_set_instruction(result_value_left, left_value))
    self.current_block.append_jump(result_value_left, next_block, end_block)
    self.current_block = next_block
    right_value: @IR_Value = self.convert_expression(expression.right_expression)
    if (right_value.type.is(IR_Boolean_Type) == false) {
        abort(expression.right_expression.location, "Must be a boolean expression")
    }
    self.append(create_ir_set_instruction(self.create_variable_value(result_variable), right_value))
    self.current_block.append_jump(end_block)
    self.current_block = end_block
    return self.append(create_ir_phi_instruction(self.create_variable_value(result_variable)))
}

convert_logic_or_expression :: (self: @IR_Builder, expression: @AST_Logic_Or_Expression) -> @IR_Value {
    next_block: @IR_Block = self.current_block.function.create_block()
    end_block: @IR_Block = self.current_block.function.create_block()
    left_value: @IR_Value = self.convert_expression(expression.left_expression)
    if (left_value.type.is(IR_Boolean_Type) == false) {
        abort(expression.left_expression.location, "Must be a boolean expression")
    }
    result_variable: @IR_Variable = self.create_temp_variable(self.get_named_type("Boolean"))
    result_value_left: @IR_Variable_Value = self.create_variable_value(result_variable)
    self.append(create_ir_set_instruction(result_value_left, left_value))
    self.current_block.append_jump(result_value_left, end_block, next_block)
    self.current_block = next_block
    right_value: @IR_Value = self.convert_expression(expression.right_expression)
    if (right_value.type.is(IR_Boolean_Type) == false) {
        abort(expression.right_expression.location, "Must be a boolean expression")
    }
    self.append(create_ir_set_instruction(self.create_variable_value(result_variable), right_value))
    self.current_block.append_jump(end_block)
    self.current_block = end_block
    return self.append(create_ir_phi_instruction(self.create_variable_value(result_variable)))
}

convert_member_access_expression :: (self: @IR_Builder, member_access_expression: @AST_Member_Access_Expression) -> @IR_Value {
    object_value: @IR_Value = self.convert_expression(member_access_expression.object_expression)
    object_value_type: @IR_Type = object_value.type
    if ((object_value_type.is(IR_Pointer_Type)) == false) {
        abort(member_access_expression.location, clone("Not an IR_Pointer_Type value: ").append(object_value_type.name))
    }
    object_value_type: @IR_Pointer_Type = object_value_type as @IR_Pointer_Type
    if ((object_value_type.pointed_type.is(IR_Struct_Type)) == false) {
        abort(member_access_expression.location, clone("Not a IR_Struct_Type pointer value: ").append(object_value_type.name))
    }
    struct_type: @IR_Struct_Type = object_value_type.pointed_type as @IR_Struct_Type
    struct_type_member: @IR_Struct_Type_Member = struct_type.get_member(member_access_expression.member_name.lexeme)
    if (struct_type_member == null) {
        abort(member_access_expression.member_name.location, clone(struct_type.name).append(" has no such member: ").append(member_access_expression.member_name.lexeme))
    }
    if (struct_type_member.type.is(IR_Struct_Type)) {
        return self.append(create_ir_load_struct_member_instruction(self.create_temp_value(create_ir_pointer_type(struct_type_member.type)), object_value, struct_type_member, true))
    }
    return self.append(create_ir_load_struct_member_instruction(self.create_temp_value(struct_type_member.type), object_value, struct_type_member, false))
}

convert_member_access_expression_address :: (self: @IR_Builder, member_access_expression: @AST_Member_Access_Expression) -> @IR_Value {
    result_type: @IR_Type = self.deduce_expression_type(member_access_expression)
    if (result_type.is(IR_Pointer_Type)) {
        return self.convert_member_access_expression(member_access_expression)
    }
    abort(member_access_expression.location, result_type.object_type)
}

convert_modulo_expression :: (self: @IR_Builder, expression: @AST_Modulo_Expression) -> @IR_Value {
    left_value: @IR_Value = self.convert_expression(expression.left_expression)
    right_value: @IR_Value = self.convert_expression(expression.right_expression)
    if (left_value.type.is(IR_Int_Type) == false) {
        abort(expression.left_expression.location, "Not an Int expression")
    }
    if (right_value.type.is(IR_Int_Type) == false) {
        abort(expression.right_expression.location, "Not an Int expression")
    }
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Modulo_Instruction.init(self.create_temp_value(left_value.type), left_value, right_value))
}

convert_multiply_expression :: (self: @IR_Builder, expression: @AST_Multiply_Expression) -> @IR_Value {
    left_value: @IR_Value = self.convert_expression(expression.left_expression)
    right_value: @IR_Value = self.convert_expression(expression.right_expression)
    if (left_value.type.is(IR_Int_Type) == false) {
        abort(expression.left_expression.location, "Not an Int expression")
    }
    if (right_value.type.is(IR_Int_Type) == false) {
        abort(expression.right_expression.location, "Not an Int expression")
    }
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Multiply_Instruction.init(self.create_temp_value(left_value.type), left_value, right_value))
}

convert_new_expression :: (self: @IR_Builder, expression: @AST_New_Expression) -> @IR_Value {
    type: @IR_Type = self.convert_value_type(expression.type)
    if (type.is(IR_Array_Type)) {
        type: @IR_Array_Type = type as @IR_Array_Type
        size_value: @IR_Value = self.convert_expression(type.size_expression)
        return self.append(create_ir_new_instruction(self.create_temp_value(create_ir_pointer_type(type.pointed_type)), type.pointed_type, size_value))
    }
    return self.append(create_ir_new_instruction(self.create_temp_value(create_ir_pointer_type(type)), type, null))
}

convert_not_equals_expression :: (self: @IR_Builder, expression: @AST_Not_Equals_Expression) -> @IR_Value {
    left_value: @IR_Value = self.convert_expression(expression.left_expression)
    right_value: @IR_Value = self.convert_expression(expression.right_expression)
    if (left_value.type.equals(right_value.type) == false && (left_value.type.is(IR_Pointer_Type) && right_value.type.is(IR_Null_Type) == false)) {
        abort(expression.location, "Operands are not the same type")
    }
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Not_Equals_Comparison_Instruction.init(self.create_temp_value(self.get_named_type("Boolean")), left_value, right_value))
}

convert_substract_expression :: (self: @IR_Builder, expression: @AST_Substract_Expression) -> @IR_Value {
    left_value: @IR_Value = self.convert_expression(expression.left_expression)
    right_value: @IR_Value = self.convert_expression(expression.right_expression)
    if (left_value.type.is(IR_Int_Type) == false) {
        abort(expression.left_expression.location, "Not an Int expression")
    }
    if (right_value.type.is(IR_Int_Type) == false) {
        abort(expression.right_expression.location, "Not an Int expression")
    }
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Substract_Instruction.init(self.create_temp_value(left_value.type), left_value, right_value))
}

convert_variable_expression :: (self: @IR_Builder, expression: @AST_Variable_Expression) -> @IR_Value {
    variable: @IR_Variable = self.get_variable(expression.name.lexeme)
    if (variable == null) {
        abort(expression.location, clone("Undeclared variable: ").append(expression.name.lexeme))
    }
    value: @IR_Value = self.get_variable_value(variable)
    if (value == null) {
        abort(expression.location, clone("Undeclared variable value: ").append(expression.name.lexeme))
    }
    return value
}

convert_variable_expression_address :: (self: @IR_Builder, expression: @AST_Variable_Expression) -> @IR_Value {
    variable: @IR_Variable = self.get_variable(expression.name.lexeme)
    if (variable == null) {
        abort(expression.location, clone("Undeclared variable: ").append(expression.name.lexeme))
    }
    if (variable.type.is(IR_Pointer_Type)) {
        return self.get_variable_value(variable)
    }
    abort(expression.location, clone("Variable type without address: ").append(variable.type.name))
}

deduce_expression_type :: (self: @IR_Builder, expression: @AST_Expression) -> @IR_Type {
    if (expression.is(AST_Call_Expression)) {
        return self.deduce_call_expression_type(expression as @AST_Call_Expression)
    }
    if (expression.is(AST_Literal_Expression)) {
        return self.deduce_literal_expression_type(expression as @AST_Literal_Expression)
    }
    if (expression.is(AST_Member_Access_Expression)) {
        return self.deduce_member_access_expression_type(expression as @AST_Member_Access_Expression)
    }
    if (expression.is(AST_Variable_Expression)) {
        return self.deduce_variable_expression_type(expression as @AST_Variable_Expression)
    }
    abort(expression.location, expression.object_type)
}

deduce_call_expression_type :: (self: @IR_Builder, expression: @AST_Call_Expression) -> @IR_Type {
    argument_types: @List = create_list()
    arguments: @List_Iterator = expression.arguments.create_iterator()
    while (arguments.has_next()) {
        argument: @AST_Expression = arguments.next() as @AST_Expression
        argument_type: @IR_Type = self.deduce_expression_type(argument)
        argument_types.append(argument_type)
    }
    if (expression.callee.is(AST_Member_Access_Expression)) {
        callee: @AST_Member_Access_Expression = expression.callee as @AST_Member_Access_Expression
        object_type: @IR_Type = self.deduce_expression_type(callee.object_expression)
        if (object_type.is(IR_Struct_Type)) {
            argument_types.prepend(create_ir_pointer_type(object_type))
        } else {
            argument_types.prepend(object_type)
        }
        function: @IR_Function = self.get_named_function(callee.member_name.lexeme, argument_types)
        if (function == null) {
            abort(callee.member_name.location, clone("Unknown function: ").append(callee.member_name.lexeme))
        }
        return function.return_type
    }
    abort(expression.location, expression.callee.object_type)
}

deduce_literal_expression_type :: (self: @IR_Builder, expression: @AST_Literal_Expression) -> @IR_Type {
    literal: @Literal_Token = expression.literal
    if (literal.is(String_Token)) {
        return create_ir_pointer_type(self.get_named_type("String"))
    }
    abort(literal.location, literal.object_type)
}

deduce_member_access_expression_type :: (self: @IR_Builder, expression: @AST_Member_Access_Expression) -> @IR_Type {
    object_type: @IR_Type = self.deduce_expression_type(expression.object_expression)
    if (object_type.is(IR_Pointer_Type) == false) {
        abort(expression.location, object_type.object_type)
    }
    object_type: @IR_Type = (object_type as @IR_Pointer_Type).pointed_type
    if (object_type.is(IR_Struct_Type) == false) {
        abort(expression.location, object_type.object_type)
    }
    object_type: @IR_Struct_Type = object_type as @IR_Struct_Type
    member: @IR_Struct_Type_Member = object_type.get_member(expression.member_name.lexeme)
    if (member == null) {
        abort(expression.member_name.location, clone(object_type.name).append(" has no such member: ").append(expression.member_name.lexeme))
    }
    if (member.type.is(IR_Struct_Type)) {
        return create_ir_pointer_type(member.type)
    }
    return member.type
}

deduce_variable_expression_type :: (self: @IR_Builder, expression: @AST_Variable_Expression) -> @IR_Type {
    variable: @IR_Variable = self.get_variable(expression.name.lexeme)
    if (variable == null) {
        abort(expression.location, clone("Unknown variable: ").append(expression.name.lexeme))
    }
    return variable.type
}

abort :: (location: @Source_Location, unexpected_type: @Object_Type) -> Nothing {
    stderr.end_line().end_line().write(location).write(": Unexpected type: ").write(unexpected_type.name).end_line()
    abort()
}

\ -------------------------------------------------------------------------------------------------
\       Counter
\ -------------------------------------------------------------------------------------------------

Counter :: struct {
    value: Int
}

init :: (self: @Counter) -> @Counter {
    self.value = 0
    return self
}

next :: (self: @Counter) -> Int {
    self.value = self.value + 1
    return self.value
}

reset :: (self: @Counter) -> @Counter {
    self.value = 0
    return self
}

\ -------------------------------------------------------------------------------------------------
\       IR
\ -------------------------------------------------------------------------------------------------

IR :: struct {
}

IR_Type :: struct : Object {
    name: @String
}

init :: (self: @IR_Type, name: @String) -> @IR_Type {
    self.name = name
    return self
}

IR_Any_Type :: struct : IR_Type {
}

IR_Boolean_Type :: struct : IR_Type {
}

IR_Int_Type :: struct : IR_Type {
}

IR_Int8_Type :: struct : IR_Type {
}

IR_Int16_Type :: struct : IR_Type {
}

IR_Int32_Type :: struct : IR_Type {
}

IR_Int64_Type :: struct : IR_Type {
}

IR_Nothing_Type :: struct : IR_Type {
}

IR_Null_Type :: struct : IR_Type {
}

IR_Pointer_Type :: struct : IR_Type {
    pointed_type: @IR_Type
}

equals :: (self: @IR_Type, other: @IR_Type) -> Boolean {
    if (self.is(IR_Pointer_Type) && other.is(IR_Pointer_Type)) {
        self: @IR_Pointer_Type = self as @IR_Pointer_Type
        other: @IR_Pointer_Type = other as @IR_Pointer_Type
        return self.pointed_type.equals(other.pointed_type)
    }
    return self == other
}

create_ir_pointer_type :: (pointed_type: @IR_Type) -> @IR_Pointer_Type {
    type: @IR_Pointer_Type = new IR_Pointer_Type
    type.init(clone("@").append(pointed_type.name))
    type.pointed_type = pointed_type
    return type
}

IR_Array_Type :: struct : IR_Pointer_Type {
    size_expression: @AST_Expression
}

create_ir_array_type :: (item_type: @IR_Type, size_expression: @AST_Expression) -> @IR_Type {
    type: @IR_Array_Type = new IR_Array_Type
    type.init(clone("[").append(item_type.name).append("]"))
    type.pointed_type = item_type
    type.size_expression = size_expression
    return type
}

IR_Struct_Type :: struct : IR_Type {
    base_type: @IR_Struct_Type
    members: @List
    statement: @AST_Struct_Statement
}

IR_Struct_Type_Member :: struct : Object {
    name: @String
    type: @IR_Type
}

create_ir_struct_type :: (name: @String, statement: @AST_Struct_Statement) -> @IR_Struct_Type {
    type: @IR_Struct_Type = new IR_Struct_Type
    type.init(name)
    type.members = create_list()
    type.statement = statement
    return type
}

add_member :: (self: @IR_Struct_Type, name: @String, type: @IR_Type) -> @IR_Struct_Type_Member {
    member: @IR_Struct_Type_Member = new IR_Struct_Type_Member
    member.name = name
    member.type = type
    self.members.append(member)
    return member
}

get_member :: (self: @IR_Struct_Type, name: @String) -> @IR_Struct_Type_Member {
    struct_type: @IR_Struct_Type = self
    loop {
        members: @List_Iterator = struct_type.members.create_iterator()
        while (members.has_next()) {
            member: @IR_Struct_Type_Member = members.next() as @IR_Struct_Type_Member
            if (member.name.equals(name)) {
                return member
            }
        }
        struct_type = struct_type.base_type
        if (struct_type == null) {
            return null
        }
    }
}

is_base_type :: (self: @IR_Struct_Type, other: @IR_Struct_Type) -> Boolean {
    struct_type: @IR_Struct_Type = other
    loop {
        if (self == struct_type.base_type) {
            return true
        }
        struct_type = struct_type.base_type
        if (struct_type == null) {
            return false
        }
    }
}

is_object_type :: (self: @IR_Struct_Type) -> Boolean {
    struct_type: @IR_Struct_Type = self
    loop {
        if (struct_type.name.equals("Object")) {
            return true
        }
        struct_type = struct_type.base_type
        if (struct_type == null) {
            return false
        }
    }
}

IR_Value :: struct : Object {
    type: @IR_Type
    user_instructions: @List
}

init :: (self: @IR_Value, type: @IR_Type) -> @IR_Value {
    self.type = type
    self.user_instructions = create_list()
    return self
}

IR_Undefined_Value :: struct : IR_Value {
}

IR_Constant_Value :: struct : IR_Value {
    literal: @Literal_Token
}

create_ir_constant_value :: (type: @IR_Type, literal: @Literal_Token) -> @IR_Constant_Value {
    value: @IR_Constant_Value = new IR_Constant_Value
    value.init(type)
    value.literal = literal
    return value
}

IR_Variable_Value :: struct : IR_Value {
    variable: @IR_Variable
    version: Int
}

init :: (self: @IR_Variable_Value, variable: @IR_Variable) -> @IR_Variable_Value {
    self.init(variable.type)
    self.variable = variable
    self.version = variable.values.size + 1
    variable.values.append(self)
    return self
}

IR_Block :: struct : Object {
    id: Int
    function: @IR_Function
    predecessors: @List
    first_instruction: @IR_Instruction
    last_instruction: @IR_Instruction
}

has_instructions :: (self: @IR_Block) -> Boolean {
    return self.first_instruction != null
}

prepend :: (self: @IR_Block, instruction: @IR_Instruction) -> @IR_Instruction {
    instruction.parent_block = self
    instruction.prev_instruction = null
    instruction.next_instruction = self.first_instruction
    if (self.first_instruction == null) {
        self.last_instruction = instruction
    } else {
        self.first_instruction.prev_instruction = instruction
    }
    self.first_instruction = instruction
    return instruction
}

append :: (self: @IR_Block, instruction: @IR_Instruction) -> @IR_Instruction {
    instruction.parent_block = self
    instruction.prev_instruction = self.last_instruction
    instruction.next_instruction = null
    if (self.last_instruction == null) {
        self.first_instruction = instruction
    } else {
        self.last_instruction.next_instruction = instruction
    }
    self.last_instruction = instruction
    return instruction
}

append_jump :: (self: @IR_Block, block: @IR_Block) -> @IR_Direct_Jump_Instruction {
    instruction: @IR_Direct_Jump_Instruction = new IR_Direct_Jump_Instruction
    instruction.init(null)
    instruction.block = block
    block.predecessors.append(self)
    self.append(instruction)
    return instruction
}

append_jump :: (self: @IR_Block, condition_value: @IR_Value, true_block: @IR_Block, false_block: @IR_Block) -> @IR_Conditional_Jump_Instruction {
    instruction: @IR_Conditional_Jump_Instruction = new IR_Conditional_Jump_Instruction
    instruction.init(null)
    instruction.operand_values.append(condition_value)
    instruction.true_block = true_block
    true_block.predecessors.append(self)
    instruction.false_block = false_block
    false_block.predecessors.append(self)
    condition_value.user_instructions.append(instruction)
    self.append(instruction)
    return instruction
}

remove :: (self: @IR_Block, instruction: @IR_Instruction) -> Nothing {
    if (instruction.parent_block != self) {
        abort()
    }
    if (instruction.prev_instruction != null) {
        instruction.prev_instruction.next_instruction = instruction.next_instruction
    }
    if (instruction.next_instruction != null) {
        instruction.next_instruction.prev_instruction = instruction.prev_instruction
    }
    if (self.first_instruction == instruction) {
        self.first_instruction = instruction.next_instruction
    }
    if (self.last_instruction == instruction) {
        self.last_instruction = instruction.prev_instruction
    }
    instruction.parent_block = null
    instruction.prev_instruction = null
    instruction.next_instruction = null
}

IR_Function :: struct : Object {
    id: Int
    location: @Source_Location
    name: @String
    parameters: @List
    return_type: @IR_Type
    blocks: @List
}

create_block :: (self: @IR_Function) -> @IR_Block {
    block: @IR_Block = new IR_Block
    block.id = self.blocks.size + 1
    block.function = self
    block.predecessors = create_list()
    block.first_instruction = null
    block.last_instruction = null
    self.blocks.append(block)
    return block
}

IR_Variable :: struct : Object {
    name: @String
    type: @IR_Type
    address_value: @IR_Value
    values: @List
}

init :: (self: @IR_Variable, name: @String, type: @IR_Type) -> @IR_Variable {
    self.name = name
    self.type = type
    self.address_value = null
    self.values = create_list()
    return self
}

IR_Global_Variable :: struct : IR_Variable {
    is_external: Boolean
}

create_ir_global_variable :: (name: @String, type: @IR_Type, is_external: Boolean) -> @IR_Global_Variable {
    variable: @IR_Global_Variable = new IR_Global_Variable
    variable.init(name, type)
    variable.is_external = is_external
    return variable
}

IR_Function_Parameter :: struct : IR_Variable {
}

IR_Instruction :: struct : Object {
    result_value: @IR_Variable_Value
    operand_values: @List
    parent_block: @IR_Block
    prev_instruction: @IR_Instruction
    next_instruction: @IR_Instruction
    is_generated: Boolean
}

init :: (self: @IR_Instruction, result_value: @IR_Variable_Value) -> @IR_Instruction {
    self.result_value = result_value
    self.operand_values = create_list()
    self.parent_block = null
    self.prev_instruction = null
    self.next_instruction = null
    self.is_generated = false
    return self
}

is_exit_instruction :: (self: @IR_Instruction) -> Boolean {
    if (self == null) {
        return false
    }
    if (self.is(IR_Jump_Instruction) || self.is(IR_Return_Instruction)) {
        return true
    }
    if (self.is(IR_Call_Instruction)) {
        self: @IR_Call_Instruction = self as @IR_Call_Instruction
        function: @IR_Function = self.function
        if (function.name.equals("abort")) {
            return true
        }
        if (function.name.equals("exit") && function.parameters.size == 1) {
            function_parameter: @IR_Function_Parameter = function.parameters.get(0) as @IR_Function_Parameter
            if (function_parameter.type.is(IR_Int_Type)) {
                return true
            }
        }
    }
    return false
}

IR_Call_Instruction :: struct : IR_Instruction {
    function: @IR_Function
    arguments: @List
}

create_ir_call_instruction :: (result_value: @IR_Variable_Value, function: @IR_Function, arguments: @List) -> @IR_Call_Instruction {
    instruction: @IR_Call_Instruction = new IR_Call_Instruction
    instruction.init(result_value)
    instruction.function = function
    instruction.arguments = instruction.operand_values
    arguments: @List_Iterator = arguments.create_iterator()
    while (arguments.has_next()) {
        value: @IR_Value = arguments.next() as @IR_Value
        instruction.operand_values.append(value)
        value.user_instructions.append(instruction)
    }
    return instruction
}

IR_Cast_Instruction :: struct : IR_Instruction {
}

create_ir_cast_instruction :: (result_value: @IR_Variable_Value, value: @IR_Value) -> @IR_Cast_Instruction {
    instruction: @IR_Cast_Instruction = new IR_Cast_Instruction
    instruction.init(result_value)
    instruction.operand_values.append(value)
    value.user_instructions.append(instruction)
    return instruction
}

get_value :: (self: @IR_Cast_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

IR_Jump_Instruction :: struct : IR_Instruction {
}

IR_Conditional_Jump_Instruction :: struct : IR_Jump_Instruction {
    true_block: @IR_Block
    false_block: @IR_Block
}

get_condition_value :: (self: @IR_Conditional_Jump_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

IR_Direct_Jump_Instruction :: struct : IR_Jump_Instruction {
    block: @IR_Block
}

IR_Load_Array_Item_Instruction :: struct : IR_Instruction {
}

create_ir_load_array_item_instruction :: (result_value: @IR_Variable_Value, array_value: @IR_Value, index_value: @IR_Value) -> @IR_Load_Array_Item_Instruction {
    instruction: @IR_Load_Array_Item_Instruction = new IR_Load_Array_Item_Instruction
    instruction.init(result_value)
    instruction.operand_values.append(array_value)
    instruction.operand_values.append(index_value)
    array_value.user_instructions.append(instruction)
    index_value.user_instructions.append(instruction)
    return instruction
}

get_array_value :: (self: @IR_Load_Array_Item_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

get_index_value :: (self: @IR_Load_Array_Item_Instruction) -> @IR_Value {
    return self.operand_values.last() as @IR_Value
}

IR_Load_Struct_Member_Instruction :: struct : IR_Instruction {
    struct_type_member: @IR_Struct_Type_Member
    load_address: Boolean
}

create_ir_load_struct_member_instruction :: (result_value: @IR_Variable_Value, struct_pointer_value: @IR_Value, struct_type_member: @IR_Struct_Type_Member, load_address: Boolean) -> @IR_Load_Struct_Member_Instruction {
    instruction: @IR_Load_Struct_Member_Instruction = new IR_Load_Struct_Member_Instruction
    instruction.init(result_value)
    instruction.operand_values.append(struct_pointer_value)
    instruction.struct_type_member = struct_type_member
    instruction.load_address = load_address
    struct_pointer_value.user_instructions.append(instruction)
    return instruction
}

get_struct_pointer_value :: (self: @IR_Load_Struct_Member_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

IR_Load_Variable_Instruction :: struct : IR_Instruction {
    variable: @IR_Variable
}

create_ir_load_variable_instruction :: (result_value: @IR_Variable_Value) -> @IR_Load_Variable_Instruction {
    instruction: @IR_Load_Variable_Instruction = new IR_Load_Variable_Instruction
    instruction.init(result_value)
    instruction.variable = result_value.variable
    return instruction
}

IR_New_Instruction :: struct : IR_Instruction {
    type: @IR_Type
}

create_ir_new_instruction :: (result_value: @IR_Variable_Value, type: @IR_Type, size_value: @IR_Value) -> @IR_New_Instruction {
    instruction: @IR_New_Instruction = new IR_New_Instruction
    instruction.init(result_value)
    instruction.type = type
    instruction.operand_values.append(size_value)
    if (size_value != null) {
        size_value.user_instructions.append(instruction)
    }
    return instruction
}

get_size_value :: (self: @IR_New_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

IR_Return_Instruction :: struct : IR_Instruction {
}

create_ir_return_instruction :: (return_value: @IR_Value) -> @IR_Return_Instruction {
    instruction: @IR_Return_Instruction = new IR_Return_Instruction
    instruction.init(null)
    instruction.operand_values.append(return_value)
    if (return_value != null) {
        return_value.user_instructions.append(instruction)
    }
    return instruction
}

get_return_value :: (self: @IR_Return_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

IR_Set_Instruction :: struct : IR_Instruction {
}

create_ir_set_instruction :: (result_value: @IR_Variable_Value, value: @IR_Value) -> @IR_Set_Instruction {
    instruction: @IR_Set_Instruction = new IR_Set_Instruction
    instruction.init(result_value)
    instruction.operand_values.append(value)
    value.user_instructions.append(instruction)
    return instruction
}

get_value :: (self: @IR_Set_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

IR_Store_Array_Item_Instruction :: struct : IR_Instruction {
}

create_ir_store_array_item_instruction :: (array_value: @IR_Value, index_value: @IR_Value, value: @IR_Value) -> @IR_Store_Array_Item_Instruction {
    instruction: @IR_Store_Array_Item_Instruction = new IR_Store_Array_Item_Instruction
    instruction.init(null)
    instruction.operand_values.append(array_value)
    instruction.operand_values.append(index_value)
    instruction.operand_values.append(value)
    array_value.user_instructions.append(instruction)
    index_value.user_instructions.append(instruction)
    value.user_instructions.append(instruction)
    return instruction
}

get_array_value :: (self: @IR_Store_Array_Item_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

get_index_value :: (self: @IR_Store_Array_Item_Instruction) -> @IR_Value {
    return self.operand_values.get(1) as @IR_Value
}

get_value :: (self: @IR_Store_Array_Item_Instruction) -> @IR_Value {
    return self.operand_values.last() as @IR_Value
}

IR_Store_Struct_Member_Instruction :: struct : IR_Instruction {
    struct_type_member: @IR_Struct_Type_Member
}

create_ir_store_struct_member_instruction :: (struct_pointer_value: @IR_Value, struct_type_member: @IR_Struct_Type_Member, value: @IR_Value) -> @IR_Store_Struct_Member_Instruction {
    instruction: @IR_Store_Struct_Member_Instruction = new IR_Store_Struct_Member_Instruction
    instruction.init(null)
    instruction.operand_values.append(struct_pointer_value)
    instruction.struct_type_member = struct_type_member
    instruction.operand_values.append(value)
    struct_pointer_value.user_instructions.append(instruction)
    value.user_instructions.append(instruction)
    return instruction
}

get_struct_pointer_value :: (self: @IR_Store_Struct_Member_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

get_value :: (self: @IR_Store_Struct_Member_Instruction) -> @IR_Value {
    return self.operand_values.last() as @IR_Value
}

IR_Binary_Instruction :: struct : IR_Instruction {
}

init :: (self: @IR_Binary_Instruction, result_value: @IR_Variable_Value, left_value: @IR_Value, right_value: @IR_Value) -> @IR_Binary_Instruction {
    self.init(result_value)
    self.operand_values.append(left_value)
    self.operand_values.append(right_value)
    left_value.user_instructions.append(self)
    right_value.user_instructions.append(self)
    return self
}

get_left_value :: (self: @IR_Binary_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

get_right_value :: (self: @IR_Binary_Instruction) -> @IR_Value {
    return self.operand_values.last() as @IR_Value
}

IR_Add_Instruction :: struct : IR_Binary_Instruction {
}

IR_Comparison_Instruction :: struct : IR_Binary_Instruction {
}

IR_Divide_Instruction :: struct : IR_Binary_Instruction {
}

IR_Equals_Comparison_Instruction :: struct : IR_Comparison_Instruction {
}

IR_Greater_Than_Comparison_Instruction :: struct : IR_Comparison_Instruction {
}

IR_Greater_Than_Or_Equals_Comparison_Instruction :: struct : IR_Comparison_Instruction {
}

IR_Less_Than_Comparison_Instruction :: struct : IR_Comparison_Instruction {
}

IR_Less_Than_Or_Equals_Comparison_Instruction :: struct : IR_Comparison_Instruction {
}

IR_Modulo_Instruction :: struct : IR_Binary_Instruction {
}

IR_Multiply_Instruction :: struct : IR_Binary_Instruction {
}

IR_Not_Equals_Comparison_Instruction :: struct : IR_Comparison_Instruction {
}

IR_Substract_Instruction :: struct : IR_Binary_Instruction {
}

IR_Phi_Instruction :: struct : IR_Instruction {
    values: @List
}

create_ir_phi_instruction :: (result_value: @IR_Variable_Value) -> @IR_Phi_Instruction {
    instruction: @IR_Phi_Instruction = new IR_Phi_Instruction
    instruction.init(result_value)
    instruction.values = instruction.operand_values
    return instruction
}

append :: (self: @IR_Phi_Instruction, value: @IR_Value) -> Nothing {
    self.values.remove_all(value).prune().append(value)
    value.user_instructions.append(self)
}

is_redundant :: (self: @IR_Phi_Instruction) -> Boolean {
    values: @List_Iterator = self.values.create_iterator()
    if (values.has_next() == false) {
        abort()
    }
    other: @IR_Value = values.next() as @IR_Value
    while (values.has_next()) {
        value: @IR_Value = values.next() as @IR_Value
        if (value != other) {
            return false
        }
    }
    return true
}

is_trivial :: (self: @IR_Phi_Instruction) -> Boolean {
    values: @List_Iterator = self.values.create_iterator()
    if (values.has_next() == false) {
        abort()
    }
    self_value: @IR_Value = self.result_value
    other: @IR_Value = null
    while (values.has_next()) {
        value: @IR_Value = values.next() as @IR_Value
        if (value != self_value) {
            if (value != other) {
                if (other != null) {
                    return false
                }
                other = value
            }
        }
    }
    return true
}

dump :: (build: @IR_Build, file: @FILE) -> Nothing {
    functions: @List_Iterator = build.named_functions.create_iterator()
    while (functions.has_next()) {
        function: @IR_Function = functions.next() as @IR_Function
        if (function.blocks.size > 0) {
            function.dump(file)
            file.end_line()
        }
    }
}

dump :: (function: @IR_Function, file: @FILE) -> Nothing {
    file.write(function.name).write('.').write(function.id).write(" :: (")
    function_parameters: @List_Iterator = function.parameters.create_iterator()
    while (function_parameters.has_next()) {
        function_parameter: @IR_Function_Parameter = function_parameters.next() as @IR_Function_Parameter
        file.write(function_parameter.name).write(": ").write(function_parameter.type.name)
        if (function_parameters.has_next()) {
            file.write(", ")
        }
    }
    file.write(") -> ").write(function.return_type.name).write(" {").end_line()
    dumped_blocks: @@IR_Block = new [@IR_Block; function.blocks.size]
    (function.blocks.first() as @IR_Block).dump(file, dumped_blocks)
    file.write('}').end_line()
}

dump :: (block: @IR_Block, file: @FILE, dumped_blocks: @@IR_Block) -> @FILE {
    if (dumped_blocks[block.id - 1] == block) {
        return file
    }
    dumped_blocks[block.id - 1] = block
    file.write("block.").write(block.id)
    block_predecessors: @List_Iterator = block.predecessors.create_iterator()
    if (block_predecessors.has_next()) {
        file.write('(')
        loop {
            block_predecessor: @IR_Block = block_predecessors.next() as @IR_Block
            file.write("block.").write(block_predecessor.id)
            if (block_predecessors.has_next()) {
                file.write(", ")
            } else {
                break
            }
        }
        file.write(')')
    }
    file.write(':').end_line()
    block_instruction: @IR_Instruction = block.first_instruction
    while (block_instruction != null) {
        block_instruction.dump(file)
        block_instruction = block_instruction.next_instruction
    }
    if (block.last_instruction.is(IR_Direct_Jump_Instruction)) {
        instruction: @IR_Direct_Jump_Instruction = block.last_instruction as @IR_Direct_Jump_Instruction
        instruction.block.dump(file, dumped_blocks)
    }
    if (block.last_instruction.is(IR_Conditional_Jump_Instruction)) {
        instruction: @IR_Conditional_Jump_Instruction = block.last_instruction as @IR_Conditional_Jump_Instruction
        instruction.true_block.dump(file, dumped_blocks)
        instruction.false_block.dump(file, dumped_blocks)
    }
    return file
}

dump :: (instruction: @IR_Instruction, file: @FILE) -> @FILE {
    file.write("   ")
    if (instruction.is(IR_Add_Instruction)) {
        instruction: @IR_Add_Instruction = instruction as @IR_Add_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" + ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_Call_Instruction)) {
        instruction: @IR_Call_Instruction = instruction as @IR_Call_Instruction
        if (instruction.result_value == null) {
            file.write("call").write('(').write(instruction.function.name).write('.').write(instruction.function.id)
        } else {
            file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write("call").write('(').write(instruction.function.name).write('.').write(instruction.function.id)
        }
        call_arguments: @List_Iterator = (instruction as @IR_Call_Instruction).arguments.create_iterator()
        while (call_arguments.has_next()) {
            file.write(", ")
            call_argument: @IR_Value = call_arguments.next() as @IR_Value
            file.write(call_argument, true)
        }
        return file.write(')').end_line()
    }
    if (instruction.is(IR_Cast_Instruction)) {
        instruction: @IR_Cast_Instruction = instruction as @IR_Cast_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write("cast").write('(').write(instruction.get_value(), true).write(')').end_line()
    }
    if (instruction.is(IR_Conditional_Jump_Instruction)) {
        instruction: @IR_Conditional_Jump_Instruction = instruction as @IR_Conditional_Jump_Instruction
        return file.write("jump").write('(').write(instruction.get_condition_value(), true).write(", block.").write(instruction.true_block.id).write(", block.").write(instruction.false_block.id).write(')').end_line()
    }
    if (instruction.is(IR_Direct_Jump_Instruction)) {
        instruction: @IR_Direct_Jump_Instruction = instruction as @IR_Direct_Jump_Instruction
        return file.write("jump").write('(').write("block.").write(instruction.block.id).write(')').end_line()
    }
    if (instruction.is(IR_Divide_Instruction)) {
        instruction: @IR_Binary_Instruction = instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" / ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_Equals_Comparison_Instruction)) {
        instruction: @IR_Binary_Instruction = instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" == ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_Greater_Than_Comparison_Instruction)) {
        instruction: @IR_Binary_Instruction = instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" > ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_Greater_Than_Or_Equals_Comparison_Instruction)) {
        instruction: @IR_Binary_Instruction = instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" >= ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_Less_Than_Comparison_Instruction)) {
        instruction: @IR_Binary_Instruction = instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" < ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_Less_Than_Or_Equals_Comparison_Instruction)) {
        instruction: @IR_Binary_Instruction = instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" <= ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_Load_Array_Item_Instruction)) {
        instruction: @IR_Load_Array_Item_Instruction = instruction as @IR_Load_Array_Item_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write("load_array_item").write('(').write(instruction.get_array_value(), true).write(", ").write(instruction.get_index_value(), true).write(')').end_line()
    }
    if (instruction.is(IR_Load_Struct_Member_Instruction)) {
        instruction: @IR_Load_Struct_Member_Instruction = instruction as @IR_Load_Struct_Member_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write("load_struct_member").write('(').write(instruction.get_struct_pointer_value(), true).write(", ").write(instruction.struct_type_member.name).write(')').end_line()
    }
    if (instruction.is(IR_Load_Variable_Instruction)) {
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write("load_variable").write('(').write((instruction as @IR_Load_Variable_Instruction).variable.name).write(')').end_line()
    }
    if (instruction.is(IR_Modulo_Instruction)) {
        instruction: @IR_Binary_Instruction = instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" // ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_Multiply_Instruction)) {
        instruction: @IR_Binary_Instruction = instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" * ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_New_Instruction)) {
        instruction: @IR_New_Instruction = instruction as @IR_New_Instruction
        file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write("new").write('(').write(instruction.type.name)
        if (instruction.get_size_value() != null) {
            file.write(", ").write(instruction.get_size_value(), true)
        }
        return file.write(')').end_line()
    }
    if (instruction.is(IR_Not_Equals_Comparison_Instruction)) {
        instruction: @IR_Binary_Instruction = instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" != ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_Phi_Instruction)) {
        instruction: @IR_Phi_Instruction = instruction as @IR_Phi_Instruction
        file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write("phi").write('(')
        values: @List_Iterator = instruction.values.create_iterator()
        if (values.has_next()) {
            loop {
                value: @IR_Value = values.next() as @IR_Value
                file.write(value, true)
                if (values.has_next()) {
                    file.write(", ")
                } else {
                    break
                }
            }
        }
        return file.write(')').end_line()
    }
    if (instruction.is(IR_Return_Instruction)) {
        instruction: @IR_Return_Instruction = instruction as @IR_Return_Instruction
        if (instruction.get_return_value() == null) {
            return file.write("return").write('(').write(')').end_line()
        }
        return file.write("return").write('(').write(instruction.get_return_value(), true).write(')').end_line()
    }
    if (instruction.is(IR_Set_Instruction)) {
        instruction: @IR_Set_Instruction = instruction as @IR_Set_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_value(), true).end_line()
    }
    if (instruction.is(IR_Store_Array_Item_Instruction)) {
        instruction: @IR_Store_Array_Item_Instruction = instruction as @IR_Store_Array_Item_Instruction
        return file.write("store_array_item").write('(').write(instruction.get_array_value(), true).write(", ").write(instruction.get_index_value(), true).write(", ").write(instruction.get_value(), true).write(')').end_line()
    }
    if (instruction.is(IR_Store_Struct_Member_Instruction)) {
        instruction: @IR_Store_Struct_Member_Instruction = instruction as @IR_Store_Struct_Member_Instruction
        return file.write("store_struct_member").write('(').write(instruction.get_struct_pointer_value(), true).write(", ").write(instruction.struct_type_member.name).write(", ").write(instruction.get_value(), true).write(')').end_line()
    }
    if (instruction.is(IR_Substract_Instruction)) {
        instruction: @IR_Binary_Instruction = instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" - ").write(instruction.get_right_value(), true).end_line()
    }
    abort(clone("Unsupported type: ").append(instruction.object_type.name))
}

write :: (file: @FILE, value: @IR_Value, check_users: Boolean) -> @FILE {
    if (check_users && value.user_instructions.size == 0) {
        file.fflush()
        if (value.is(IR_Variable_Value)) {
            value: @IR_Variable_Value = value as @IR_Variable_Value
            value_version: Int = value.version
            stderr.end_line().write(value.variable.name).write(".").write(value_version).end_line()
        }
        \ abort()
    }
    if (value.is(IR_Constant_Value)) {
        return file.write((value as @IR_Constant_Value).literal.lexeme)
    }
    if (value.is(IR_Variable_Value)) {
        return file.write((value as @IR_Variable_Value).variable.name).write('.').write((value as @IR_Variable_Value).version)
    }
    if (value.is(IR_Undefined_Value)) {
        return file.write("undefined")
    }
    abort(clone("Unsupported type: ").append(value.object_type.name))
}

\ -------------------------------------------------------------------------------------------------
\       Parser
\ -------------------------------------------------------------------------------------------------

Parser :: struct {
    tokens: @List_Iterator
    compilation_unit: @Compilation_Unit
    current_alignment: Int
    optional_comment: @Matcher
    optional_space: @Matcher
    required_ampersand: @Matcher
    required_as: @Matcher
    required_asterisk: @Matcher
    required_at: @Matcher
    required_break: @Matcher
    required_close_brace: @Matcher
    required_close_bracket: @Matcher
    required_close_paren: @Matcher
    required_colon: @Matcher
    required_column: @Matcher
    required_comma: @Matcher
    required_comment: @Matcher
    required_dot: @Matcher
    required_else: @Matcher
    required_end_of_file: @Matcher
    required_end_of_line: @Matcher
    required_equals: @Matcher
    required_exclamation_mark: @Matcher
    required_external: @Matcher
    required_greater_than: @Matcher
    required_hyphen: @Matcher
    required_identifier: @Matcher
    required_if: @Matcher
    required_is: @Matcher
    required_less_than: @Matcher
    required_literal: @Matcher
    required_loop: @Matcher
    required_new: @Matcher
    required_open_brace: @Matcher
    required_open_bracket: @Matcher
    required_open_paren: @Matcher
    required_plus: @Matcher
    required_return: @Matcher
    required_slash: @Matcher
    required_struct: @Matcher
    required_vertical_bar: @Matcher
    required_while: @Matcher
}

create_parser :: (tokens: @List) -> @Parser {
    parser: @Parser = new Parser
    parser.tokens = tokens.create_iterator()
    token: @Token = parser.tokens.next() as @Token
    parser.compilation_unit = create_compilation_unit(token.location.source)
    parser.current_alignment = 0

    parser.optional_comment = create_comment_matcher(false)
    parser.optional_space = create_space_matcher(false)

    parser.required_ampersand = create_other_matcher(true, "&")
    parser.required_as = create_keyword_matcher(true, "as")
    parser.required_asterisk = create_other_matcher(true, "*")
    parser.required_at = create_other_matcher(true, "@")
    parser.required_break = create_keyword_matcher(true, "break")
    parser.required_close_brace = create_other_matcher(true, "}")
    parser.required_close_bracket = create_other_matcher(true, "]")
    parser.required_close_paren = create_other_matcher(true, ")")
    parser.required_colon = create_other_matcher(true, ":")
    parser.required_column = create_other_matcher(true, ";")
    parser.required_comma = create_other_matcher(true, ",")
    parser.required_comment = create_comment_matcher(true)
    parser.required_dot = create_other_matcher(true, ".")
    parser.required_else = create_keyword_matcher(true, "else")
    parser.required_end_of_file = create_end_of_file_matcher(true)
    parser.required_end_of_line = create_end_of_line_matcher(true)
    parser.required_equals = create_other_matcher(true, "=")
    parser.required_exclamation_mark = create_other_matcher(true, "!")
    parser.required_external = create_keyword_matcher(true, "external")
    parser.required_greater_than = create_other_matcher(true, ">")
    parser.required_hyphen = create_other_matcher(true, "-")
    parser.required_identifier = create_identifier_matcher(true)
    parser.required_if = create_keyword_matcher(true, "if")
    parser.required_less_than = create_other_matcher(true, "<")
    parser.required_literal = create_literal_matcher(true)
    parser.required_loop = create_keyword_matcher(true, "loop")
    parser.required_new = create_keyword_matcher(true, "new")
    parser.required_open_brace = create_other_matcher(true, "{")
    parser.required_open_bracket = create_other_matcher(true, "[")
    parser.required_open_paren = create_other_matcher(true, "(")
    parser.required_plus = create_other_matcher(true, "+")
    parser.required_return = create_keyword_matcher(true, "return")
    parser.required_slash = create_other_matcher(true, "/")
    parser.required_struct = create_keyword_matcher(true, "struct")
    parser.required_vertical_bar = create_other_matcher(true, "|")
    parser.required_while = create_keyword_matcher(true, "while")

    return parser
}

parse :: (tokens: @List) -> @Compilation_Unit {
    parser: @Parser = create_parser(tokens)
    parser.compilation_unit.statements = parser.parse_statements()
    token: @Token = parser.tokens.current() as @Token
    if ((token.is(End_Of_File_Token)) == false) {
        abort(parser, token)
    }
    return parser.compilation_unit
}

\ statements
\   : ( statement <EOL> )*
parse_statements :: (self: @Parser) -> @List {
    statements: @List = create_list()

    loop {
        statement: @AST_Statement = self.parse_statement()
        if (statement == null) {
            break
        }
        self.consume_end_of_line()
        statements.append(statement)
    }

    return statements
}

\ statement
\   : if
\   | "return" expression?
\   | loop
\   | while
\   | "break"
\   | expression ( "::" ( struct | function ) | ":" type? ( "=" expression )? )?
parse_statement :: (self: @Parser) -> @AST_Statement {
    while (self.consume_empty_line()) {
    }

    if (self.matches(self.optional_space, self.required_close_brace) || self.matches(self.required_end_of_file)) {
        return null
    }

    self.consume_space(self.current_alignment * 4)

    if (self.matches(self.required_if)) {
        return self.parse_if()
    }
    if (self.matches(self.required_return)) {
        token: @Token = self.consume(self.required_return)
        value_expression: @AST_Expression = null
        if (self.matches_end_of_line() == false) {
            self.consume_space(1)
            value_expression = self.parse_expression()
        }
        return create_ast_return_statement(token.location, value_expression)
    }
    if (self.matches(self.required_loop)) {
        return self.parse_loop()
    }
    if (self.matches(self.required_while)) {
        return self.parse_while()
    }
    if (self.matches(self.required_break)) {
        token: @Token = self.consume(self.required_break)
        return create_ast_break_statement(token.location)
    }

    expression: @AST_Expression = self.parse_expression()

    if (self.matches(self.optional_space, self.optional_comment, self.required_end_of_line)) {
        return create_ast_expression_statement(expression)
    }

    if (self.matches(self.optional_space, self.required_colon, self.required_colon)) {
        self.consume_space(1)
        self.consume(self.required_colon, self.required_colon)
        self.consume_space(1)
        if (self.matches(self.required_struct)) {
            return self.parse_struct(expression)
        }
        return self.parse_function(expression)
    }

    if (self.matches(self.optional_space, self.required_colon)) {
        if (expression.is(AST_Variable_Expression)) {
            expression: @AST_Variable_Expression = expression as @AST_Variable_Expression
            variable_name: @Identifier_Token = expression.name
            variable_value_type: @AST_Type = null
            variable_value_expression: @AST_Expression = null
            variable_is_external: Boolean = false
            if (self.matches(self.optional_space, self.required_colon, self.required_equals)) {
                self.consume_space(1)
                self.consume(self.required_colon, self.required_equals)
                self.consume_space(1)
                variable_value_expression = self.parse_expression()
            } else {
                self.consume_space(0)
                self.consume(self.required_colon)
                self.consume_space(1)
                variable_value_type = self.parse_type()
                if (self.matches(self.optional_space, self.required_equals)) {
                    self.consume_space(1)
                    self.consume(self.required_equals)
                    self.consume_space(1)
                    if (self.matches(self.required_external)) {
                        self.consume(self.required_external)
                        variable_is_external = true
                    } else {
                        variable_value_expression = self.parse_expression()
                    }
                }
            }
            variable_statement: @AST_Variable_Statement = create_ast_variable_statement(variable_name, variable_value_type, variable_value_expression, variable_is_external)
            if (self.current_alignment == 0) {
                self.compilation_unit.global_variables.append(variable_statement)
            }
            return variable_statement
        }
        abort(expression.location, "Cannot use expression as variable name")
    }

    if (self.matches(self.optional_space, self.required_equals)) {
        self.consume_space(1)
        operator: @Other_Token = self.consume(self.required_equals) as @Other_Token
        self.consume_space(1)
        return create_ast_assignment_statement(expression, operator, self.parse_expression())
    }

    return null
}

\ struct
\   : "struct" ( ":" IDENTIFIER )? ( "{" <EOL> struct_members "}" )?
parse_struct :: (self: @Parser, name_expression: @AST_Expression) -> @AST_Statement {
    if (name_expression.is(AST_Variable_Expression)) {
        struct_name: @Identifier_Token = (name_expression as @AST_Variable_Expression).name
        self.consume(self.required_struct)
        base_type: @AST_Type
        if (self.matches(self.optional_space, self.required_colon)) {
            self.consume_space(1)
            self.consume(self.required_colon)
            self.consume_space(1)
            base_type = self.parse_type()
        } else {
            base_type = null
        }
        struct_members: @List
        if (self.matches(self.optional_space, self.required_open_brace)) {
            struct_members = create_list()
            self.consume_space(1)
            self.consume(self.required_open_brace)
            self.consume_end_of_line()
            self.current_alignment = self.current_alignment + 1
            self.parse_struct_members(struct_members)
            self.current_alignment = self.current_alignment - 1
            self.consume_space(self.current_alignment * 4)
            self.consume(self.required_close_brace)
        } else {
            struct_members = null
        }
        struct_statement: @AST_Struct_Statement = create_ast_struct_statement(struct_name, base_type, struct_members)
        self.compilation_unit.types.append(struct_statement)
        return struct_statement
    } else {
        abort(name_expression.location, "Cannot use expression as struct name")
    }
}

\ struct_members
\   : ( IDENTIFIER ":" type <EOL> )*
parse_struct_members :: (self: @Parser, struct_members: @List) -> Nothing {
    loop {
        while (self.consume_empty_line()) {
        }

        if (self.matches(self.optional_space, self.required_identifier)) {
            self.consume_space(self.current_alignment * 4)
            member_name: @Identifier_Token = self.consume(self.required_identifier) as @Identifier_Token
            self.consume_space(0)
            self.consume(self.required_colon)
            self.consume_space(1)
            member_value_type: @AST_Type = self.parse_type()
            struct_members.append(create_ast_struct_member(member_name, member_value_type))
        } else {
            break
        }
    }
}

\ function
\   : "(" function_parameters? ")" "->" type block?
parse_function :: (self: @Parser, name_expression: @AST_Expression) -> @AST_Statement {
    if (name_expression.is(AST_Variable_Expression)) {
        function_name: @Identifier_Token = (name_expression as @AST_Variable_Expression).name
        self.consume(self.required_open_paren)
        function_parameters: @List
        if (self.matches(self.optional_space, self.required_close_paren)) {
            function_parameters = create_list()
        } else {
            function_parameters = self.parse_function_parameters()
        }
        self.consume_space(0)
        self.consume(self.required_close_paren)
        self.consume_space(1)
        self.consume(self.required_hyphen, self.required_greater_than)
        self.consume_space(1)
        function_return_type: @AST_Type = self.parse_type()
        function_body: @AST_Block_Statement
        if (self.matches(self.optional_space, self.required_open_brace)) {
            self.consume_space(1)
            function_body = self.parse_block()
        } else {
            function_body = null
        }
        function_statement: @AST_Function_Statement = create_ast_function_statement(function_name, function_parameters, function_return_type, function_body)
        self.compilation_unit.functions.append(function_statement)
        return function_statement
    } else {
        abort(name_expression.location, "Cannot use expression as function name")
    }
}

\ function_parameters
\   : function_parameter ( "," function_parameter )*
parse_function_parameters :: (self: @Parser) -> @List {
    function_parameters: @List = create_list()
    expected_space: Int = 0
    loop {
        self.consume_space(expected_space)
        function_parameters.append(self.parse_function_parameter())
        if (self.matches(self.optional_space, self.required_comma)) {
            self.consume_space(0)
            self.consume(self.required_comma)
            expected_space = 1
        } else {
            break
        }
    }
    return function_parameters
}

\ function_parameter
\   : IDENTIFIER ":" type
parse_function_parameter :: (self: @Parser) -> @AST_Function_Parameter {
    parameter_name: @Identifier_Token = self.consume(self.required_identifier) as @Identifier_Token
    self.consume_space(0)
    self.consume(self.required_colon)
    self.consume_space(1)
    parameter_type: @AST_Type = self.parse_type()
    return create_ast_function_parameter(parameter_name, parameter_type)
}

\ block
\   : "{" statements "}"
parse_block :: (self: @Parser) -> @AST_Block_Statement {
    token: @Token = self.consume(self.required_open_brace)
    self.consume_end_of_line()
    self.current_alignment = self.current_alignment + 1
    statements: @List = self.parse_statements()
    self.current_alignment = self.current_alignment - 1
    self.consume_space(self.current_alignment * 4)
    self.consume(self.required_close_brace)
    return create_ast_block_statement(token, statements)
}

\ if
\   : "if" "(" expression ")" block ( "else" block )?
parse_if :: (self: @Parser) -> @AST_Statement {
    token: @Token = self.consume(self.required_if)
    self.consume_space(1)
    self.consume(self.required_open_paren)
    self.consume_space(0)
    condition_expression: @AST_Expression = self.parse_expression()
    self.consume_space(0)
    self.consume(self.required_close_paren)
    self.consume_space(1)
    true_block: @AST_Block_Statement = self.parse_block()
    false_block: @AST_Block_Statement = null
    if (self.matches(self.optional_space, self.required_else)) {
        self.consume_space(1)
        self.consume(self.required_else)
        self.consume_space(1)
        false_block = self.parse_block()
    }
    return create_ast_if_statement(token.location, condition_expression, true_block, false_block)
}

\ loop
\   : "loop" block
parse_loop :: (self: @Parser) -> @AST_Statement {
    token: @Token = self.consume(self.required_loop)
    self.consume_space(1)
    loop_block: @AST_Block_Statement = self.parse_block()
    return create_ast_loop_statement(token.location, loop_block)
}

\ while
\   : "while" "(" expression ")" block
parse_while :: (self: @Parser) -> @AST_Statement {
    token: @Token = self.consume(self.required_while)
    self.consume_space(1)
    self.consume(self.required_open_paren)
    self.consume_space(0)
    condition_expression: @AST_Expression = self.parse_expression()
    self.consume_space(0)
    self.consume(self.required_close_paren)
    self.consume_space(1)
    loop_block: @AST_Block_Statement = self.parse_block()
    return create_ast_while_statement(token.location, condition_expression, loop_block)
}

\ type
\   : "@" type
\   | IDENTIFIER
\   | "[" type ( ";" expression )? "]"
\   | "(" comma_separated_members? ")" "->" type
parse_type :: (self: @Parser) -> @AST_Type {
    if (self.matches(self.required_at)) {
        token: @Token = self.consume(self.required_at)
        self.consume_space(0)
        type: @AST_Type = self.parse_type()
        return create_ast_pointer_type(token.location, type)
    }
    if (self.matches(self.required_open_bracket)) {
        token: @Token = self.consume(self.required_open_bracket)
        array_item_type: @AST_Type = self.parse_type()
        if (self.matches(self.optional_space, self.required_column)) {
            self.consume_space(0)
            self.consume(self.required_column)
            self.consume_space(1)
            array_size_expression: @AST_Expression = self.parse_expression()
            self.consume_space(0)
            self.consume(self.required_close_bracket)
            return create_ast_array_type(token.location, array_item_type, array_size_expression)
        }
        return create_ast_array_type(token.location, array_item_type, null)
    }
    return create_ast_named_type(self.consume(self.required_identifier) as @Identifier_Token)
}

parse_expression :: (self: @Parser) -> @AST_Expression {
    return self.parse_logic_or_expression()
}

\ logic_or_expression
\   : logic_and_expression ( "||" logic_or_expression )?
parse_logic_or_expression :: (self: @Parser) -> @AST_Expression {
    expression: @AST_Expression = self.parse_logic_and_expression()
    if (self.matches(self.optional_space, self.required_vertical_bar, self.required_vertical_bar)) {
        self.consume_space(1)
        self.consume(self.required_vertical_bar, self.required_vertical_bar)
        self.consume_space(1)
        return new AST_Logic_Or_Expression.init(expression, self.parse_logic_or_expression())
    }
    return expression
}

\ logic_and_expression
\   : equality_expression ( "&&" logic_and_expression )?
parse_logic_and_expression :: (self: @Parser) -> @AST_Expression {
    expression: @AST_Expression = self.parse_equality_expression()
    if (self.matches(self.optional_space, self.required_ampersand, self.required_ampersand)) {
        self.consume_space(1)
        self.consume(self.required_ampersand, self.required_ampersand)
        self.consume_space(1)
        return new AST_Logic_And_Expression.init(expression, self.parse_logic_and_expression())
    }
    return expression
}

\ equality_expression
\   : comparison_expression ( ( "==" | "!=" ) equality_expression )?
parse_equality_expression :: (self: @Parser) -> @AST_Expression {
    expression: @AST_Expression = self.parse_comparison_expression()
    if (self.matches(self.optional_space, self.required_equals, self.required_equals) || self.matches(self.optional_space, self.required_exclamation_mark, self.required_equals)) {
        self.consume_space(1)
        binary_expression: @AST_Binary_Expression
        if (self.matches(self.required_equals)) {
            self.consume(self.required_equals)
            binary_expression = new AST_Equals_Expression
        } else {
            self.consume(self.required_exclamation_mark)
            binary_expression = new AST_Not_Equals_Expression
        }
        self.consume(self.required_equals)
        self.consume_space(1)
        return binary_expression.init(expression, self.parse_equality_expression())
    }
    return expression
}

\ comparison_expression
\   : addition_expression ( ( "<" | "<=" | ">" | ">=" ) comparison_expression )?
parse_comparison_expression :: (self: @Parser) -> @AST_Expression {
    expression: @AST_Expression = self.parse_addition_expression()
    if (self.matches(self.optional_space, self.required_less_than) || self.matches(self.optional_space, self.required_greater_than)) {
        self.consume_space(1)
        binary_expression: @AST_Binary_Expression
        if (self.matches(self.required_less_than)) {
            self.consume(self.required_less_than)
            if (self.matches(self.required_equals)) {
                self.consume(self.required_equals)
                binary_expression = new AST_Less_Than_Or_Equals_Expression
            } else {
                binary_expression = new AST_Less_Than_Expression
            }
        } else {
            self.consume(self.required_greater_than)
            if (self.matches(self.required_equals)) {
                self.consume(self.required_equals)
                binary_expression = new AST_Greater_Than_Or_Equals_Expression
            } else {
                binary_expression = new AST_Greater_Than_Expression
            }
        }
        self.consume_space(1)
        return binary_expression.init(expression, self.parse_comparison_expression())
    }
    return expression
}

\ addition_expression
\   : multiplication_expression ( ( "+" | "-" ) addition_expression )?
parse_addition_expression :: (self: @Parser) -> @AST_Expression {
    expression: @AST_Expression = self.parse_multiplication_expression()
    if (self.matches(self.optional_space, self.required_plus) || self.matches(self.optional_space, self.required_hyphen)) {
        self.consume_space(1)
        binary_expression: @AST_Binary_Expression
        if (self.matches(self.required_plus)) {
            self.consume(self.required_plus)
            binary_expression = new AST_Add_Expression
        } else {
            self.consume(self.required_hyphen)
            binary_expression = new AST_Substract_Expression
        }
        self.consume_space(1)
        return binary_expression.init(expression, self.parse_addition_expression())
    }
    return expression
}

\ multiplication_expression
\   : unary_expression ( ( "*" | "/" | "//" ) multiplication_expression )?
parse_multiplication_expression :: (self: @Parser) -> @AST_Expression {
    expression: @AST_Expression = self.parse_unary_expression()
    if (self.matches(self.optional_space, self.required_asterisk) || self.matches(self.optional_space, self.required_slash)) {
        self.consume_space(1)
        binary_expression: @AST_Binary_Expression
        if (self.matches(self.required_slash)) {
            self.consume(self.required_slash)
            if (self.matches(self.required_slash)) {
                self.consume(self.required_slash)
                binary_expression = new AST_Modulo_Expression
            } else {
                binary_expression = new AST_Divide_Expression
            }
        } else {
            self.consume(self.required_asterisk)
            binary_expression = new AST_Multiply_Expression
        }
        self.consume_space(1)
        return binary_expression.init(expression, self.parse_multiplication_expression())
    }
    return expression
}

parse_unary_expression :: (self: @Parser) -> @AST_Expression {
    return self.parse_cast_expression()
}

\ cast_expression
\   : access_expression ( "as" type )?
parse_cast_expression :: (self: @Parser) -> @AST_Expression {
    expression: @AST_Expression = self.parse_access_expression()
    if (self.matches(self.optional_space, self.required_as)) {
        self.consume_space(1)
        self.consume(self.required_as)
        self.consume_space(1)
        type: @AST_Type = self.parse_type()
        return create_ast_cast_expression(expression, type)
    }
    return expression
}

\ access_expression
\   : primary_expression ( "." IDENTIFIER | "(" call_arguments? ")" | "[" expression "]" )*
parse_access_expression :: (self: @Parser) -> @AST_Expression {
    expression: @AST_Expression = self.parse_primary_expression()
    loop {
        old_expression: @AST_Expression = expression
        if (self.matches(self.optional_space, self.required_dot)) {
            self.consume_space(0)
            self.consume(self.required_dot)
            self.consume_space(0)
            expression = create_ast_member_access_expression(expression, self.consume(self.required_identifier) as @Identifier_Token)
        }
        if (self.matches(self.optional_space, self.required_open_paren)) {
            self.consume_space(0)
            self.consume(self.required_open_paren)
            self.consume_space(0)
            call_arguments: @List = create_list()
            if (self.matches(self.optional_space, self.required_close_paren) == false) {
                self.parse_call_arguments(call_arguments)
            }
            self.consume_space(0)
            self.consume(self.required_close_paren)
            expression = create_ast_call_expression(expression, call_arguments)
        }
        if (self.matches(self.optional_space, self.required_open_bracket)) {
            self.consume_space(0)
            self.consume(self.required_open_bracket)
            self.consume_space(0)
            index_expression: @AST_Expression = self.parse_expression()
            self.consume_space(0)
            self.consume(self.required_close_bracket)
            expression = create_ast_array_access_expression(expression, index_expression)
        }
        if (expression == old_expression) {
            break
        }
    }
    return expression
}

\ call_arguments
\   : expression ( "," expression )*
parse_call_arguments :: (self: @Parser, call_arguments: @List) -> Nothing {
    call_arguments.append(self.parse_expression())
    while (self.matches(self.optional_space, self.required_comma)) {
        self.consume_space(0)
        self.consume(self.required_comma)
        self.consume_space(1)
        call_arguments.append(self.parse_expression())
    }
}

\ primary_expression
\   : IDENTIFIER
\   | INTEGER
\   | STRING
\   | CHARACTER
\   | "null"
\   | "false"
\   | "true"
\   | "(" expression ")"
\   | "new" type
parse_primary_expression :: (self: @Parser) -> @AST_Expression {
    if (self.matches(self.required_identifier)) {
        return create_ast_variable_expression(self.consume(self.required_identifier) as @Identifier_Token)
    }
    if (self.matches(self.required_literal)) {
        return create_ast_literal_expression(self.consume(self.required_literal) as @Literal_Token)
    }
    if (self.matches(self.required_open_paren)) {
        self.consume(self.required_open_paren)
        self.consume_space(0)
        expression: @AST_Expression = self.parse_expression()
        self.consume_space(0)
        self.consume(self.required_close_paren)
        return expression
    }
    if (self.matches(self.required_new)) {
        token: @Token = self.consume(self.required_new)
        self.consume_space(1)
        type: @AST_Type = self.parse_type()
        return create_ast_new_expression(token.location, type)
    }
    return null
}

abort :: (self: @Parser, unexpected_token: @Token) -> Nothing {
    stderr.write(unexpected_token.location).write(": Unexpected token: ").write(unexpected_token).end_line()
    abort()
}

consume_end_of_line :: (self: @Parser) -> Nothing {
    if (self.matches(self.optional_space, self.required_comment)) {
        self.consume_space(1)
        self.consume(self.required_comment)
    } else {
        self.consume_space(0)
    }
    self.consume(self.required_end_of_line)
}

consume_empty_line :: (self: @Parser) -> Boolean {
    if (self.matches(self.optional_space, self.optional_comment, self.required_end_of_line)) {
        if (self.matches(self.optional_space, self.required_comment)) {
            self.consume_space(self.current_alignment * 4)
            self.consume(self.required_comment)
        } else {
            self.consume_space(0)
        }
        self.consume(self.required_end_of_line)
        return true
    }
    return false
}

consume_space :: (self: @Parser, expected_space_count: Int) -> Nothing {
    space_count: Int
    token: @Token = self.tokens.current() as @Token
    if (token.is(Space_Token)) {
        self.tokens.next()
        space: @Space_Token = token as @Space_Token
        space_count = space.count
    } else {
        space_count = 0
    }
    if (space_count != expected_space_count) {
        stderr.write(token.location).write(": Consumed ").write(space_count).write(" spaces where ").write(expected_space_count).write(" are expected").end_line()
    }
}

consume :: (self: @Parser, first_matcher: @Matcher) -> @Token {
    return self.consume(first_matcher, null)
}

consume :: (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher) -> @Token {
    return self.consume(first_matcher, second_matcher, null)
}

consume :: (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher, third_matcher: @Matcher) -> @Token {
    token: @Token = self.tokens.current() as @Token
    first_token: @Token = token
    if (first_matcher.accepts(token)) {
        token = self.tokens.next() as @Token
    } else {
        if (first_matcher.is_required) {
            self.abort(token)
        }
    }
    if (second_matcher != null) {
        if (second_matcher.accepts(token)) {
            token = self.tokens.next() as @Token
        } else {
            if (second_matcher.is_required) {
                self.abort(token)
            }
        }
    }
    if (third_matcher != null) {
        if (third_matcher.accepts(token)) {
            token = self.tokens.next() as @Token
        } else {
            if (third_matcher.is_required) {
                self.abort(token)
            }
        }
    }
    return first_token
}

matches_end_of_line :: (self: @Parser) -> Boolean {
    return self.matches(self.optional_space, self.optional_comment, self.required_end_of_line)
}

matches :: (self: @Parser, first_matcher: @Matcher) -> Boolean {
    return self.matches(first_matcher, null)
}

matches :: (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher) -> Boolean {
    return self.matches(first_matcher, second_matcher, null)
}

matches :: (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher, third_matcher: @Matcher) -> Boolean {
    self.tokens.save_state()
    token: @Token = self.tokens.current() as @Token
    if (first_matcher.accepts(token)) {
        token = self.tokens.next() as @Token
    } else {
        if (first_matcher.is_required) {
            self.tokens.restore_state()
            return false
        }
    }
    if (second_matcher != null) {
        if (second_matcher.accepts(token)) {
            token = self.tokens.next() as @Token
        } else {
            if (second_matcher.is_required) {
                self.tokens.restore_state()
                return false
            }
        }
    }
    if (third_matcher != null) {
        if (third_matcher.accepts(token)) {
            token = self.tokens.next() as @Token
        } else {
            if (third_matcher.is_required) {
                self.tokens.restore_state()
                return false
            }
        }
    }
    self.tokens.restore_state()
    return true
}

Matcher :: struct : Object {
    is_required: Boolean
}

Comment_Matcher :: struct : Matcher {
}

create_comment_matcher :: (required: Boolean) -> @Comment_Matcher {
    matcher: @Comment_Matcher = new Comment_Matcher
    matcher.is_required = required
    return matcher
}

End_Of_File_Matcher :: struct : Matcher {
}

create_end_of_file_matcher :: (required: Boolean) -> @End_Of_File_Matcher {
    matcher: @End_Of_File_Matcher = new End_Of_File_Matcher
    matcher.is_required = required
    return matcher
}

End_Of_Line_Matcher :: struct : Matcher {
}

create_end_of_line_matcher :: (required: Boolean) -> @End_Of_Line_Matcher {
    matcher: @End_Of_Line_Matcher = new End_Of_Line_Matcher
    matcher.is_required = required
    return matcher
}

Identifier_Matcher :: struct : Matcher {
}

create_identifier_matcher :: (required: Boolean) -> @Identifier_Matcher {
    matcher: @Identifier_Matcher = new Identifier_Matcher
    matcher.is_required = required
    return matcher
}

Keyword_Matcher :: struct : Matcher {
    lexeme: @String
}

create_keyword_matcher :: (required: Boolean, lexeme: @String) -> @Keyword_Matcher {
    matcher: @Keyword_Matcher = new Keyword_Matcher
    matcher.is_required = required
    matcher.lexeme = lexeme
    return matcher
}

Literal_Matcher :: struct : Matcher {
}

create_literal_matcher :: (required: Boolean) -> @Literal_Matcher {
    matcher: @Literal_Matcher = new Literal_Matcher
    matcher.is_required = required
    return matcher
}

Other_Matcher :: struct : Matcher {
    lexeme: @String
}

create_other_matcher :: (required: Boolean, lexeme: @String) -> @Other_Matcher {
    matcher: @Other_Matcher = new Other_Matcher
    matcher.is_required = required
    matcher.lexeme = lexeme
    return matcher
}

Space_Matcher :: struct : Matcher {
}

create_space_matcher :: (required: Boolean) -> @Space_Matcher {
    matcher: @Space_Matcher = new Space_Matcher
    matcher.is_required = required
    return matcher
}

accepts :: (self: @Matcher, token: @Token) -> Boolean {
    if (self.is(Other_Matcher)) {
        self: @Other_Matcher = self as @Other_Matcher
        if (token.is(Other_Token)) {
            return token.lexeme.equals(self.lexeme)
        }
        return false
    }
    if (self.is(Space_Matcher)) {
        return token.is(Space_Token)
    }
    if (self.is(Identifier_Matcher)) {
        return token.is(Identifier_Token)
    }
    if (self.is(Keyword_Matcher)) {
        self: @Keyword_Matcher = self as @Keyword_Matcher
        if (token.is(Keyword_Token)) {
            return token.lexeme.equals(self.lexeme)
        }
        return false
    }
    if (self.is(Literal_Matcher)) {
        return token.is(Integer_Token) || token.is(String_Token) || token.is(Character_Token) || token.is(Boolean_Token) || token.is(Null_Token)
    }
    if (self.is(End_Of_Line_Matcher)) {
        return token.is(End_Of_Line_Token)
    }
    if (self.is(Comment_Matcher)) {
        return token.is(Comment_Token)
    }
    if (self.is(End_Of_File_Matcher)) {
        return token.is(End_Of_File_Token)
    }
    stderr.write("Unsupported token matcher").end_line()
    abort()
}

\ -------------------------------------------------------------------------------------------------
\       AST
\ -------------------------------------------------------------------------------------------------

Compilation_Unit :: struct {
    source: @Source
    types: @List
    global_variables: @List
    functions: @List
    statements: @List
}

create_compilation_unit :: (source: @Source) -> @Compilation_Unit {
    compilation_unit: @Compilation_Unit = new Compilation_Unit
    compilation_unit.source = source
    compilation_unit.types = create_list()
    compilation_unit.global_variables = create_list()
    compilation_unit.functions = create_list()
    compilation_unit.statements = null
    return compilation_unit
}

AST_Statement :: struct : Object {
    location: @Source_Location
}

AST_Function_Statement :: struct : AST_Statement {
    name: @Identifier_Token
    parameters: @List
    return_type: @AST_Type
    body: @AST_Block_Statement
    ir_function: @IR_Function
}

create_ast_function_statement :: (name: @Identifier_Token, parameters: @List, return_type: @AST_Type, body: @AST_Block_Statement) -> @AST_Function_Statement {
    function_statement: @AST_Function_Statement = new AST_Function_Statement
    function_statement.location = name.location
    function_statement.name = name
    function_statement.parameters = parameters
    function_statement.return_type = return_type
    function_statement.body = body
    function_statement.ir_function = null
    return function_statement
}

AST_Function_Parameter :: struct {
    location: @Source_Location
    name: @Identifier_Token
    type: @AST_Type
}

create_ast_function_parameter :: (name: @Identifier_Token, type: @AST_Type) -> @AST_Function_Parameter {
    function_parameter: @AST_Function_Parameter = new AST_Function_Parameter
    function_parameter.location = name.location
    function_parameter.name = name
    function_parameter.type = type
    return function_parameter
}

AST_Block_Statement :: struct : AST_Statement {
    statements: @List
}

create_ast_block_statement :: (open_brace: @Token, statements: @List) -> @AST_Block_Statement {
    block_statement: @AST_Block_Statement = new AST_Block_Statement
    block_statement.location = open_brace.location
    block_statement.statements = statements
    return block_statement
}

AST_Expression_Statement :: struct : AST_Statement {
    expression: @AST_Expression
}

create_ast_expression_statement :: (expression: @AST_Expression) -> @AST_Expression_Statement {
    statement: @AST_Expression_Statement = new AST_Expression_Statement
    statement.location = expression.location
    statement.expression = expression
    return statement
}

AST_If_Statement :: struct : AST_Statement {
    condition_expression: @AST_Expression
    true_block: @AST_Block_Statement
    false_block: @AST_Block_Statement
}

create_ast_if_statement :: (location: @Source_Location, condition_expression: @AST_Expression, true_block: @AST_Block_Statement, false_block: @AST_Block_Statement) -> @AST_If_Statement {
    statement: @AST_If_Statement = new AST_If_Statement
    statement.location = location
    statement.condition_expression = condition_expression
    statement.true_block = true_block
    statement.false_block = false_block
    return statement
}

AST_Loop_Statement :: struct : AST_Statement {
    block: @AST_Block_Statement
}

create_ast_loop_statement :: (location: @Source_Location, block: @AST_Block_Statement) -> @AST_Loop_Statement {
    statement: @AST_Loop_Statement = new AST_Loop_Statement
    statement.location = location
    statement.block = block
    return statement
}

AST_While_Statement :: struct : AST_Statement {
    condition_expression: @AST_Expression
    block: @AST_Block_Statement
}

create_ast_while_statement :: (location: @Source_Location, condition_expression: @AST_Expression, block: @AST_Block_Statement) -> @AST_While_Statement {
    statement: @AST_While_Statement = new AST_While_Statement
    statement.location = location
    statement.condition_expression = condition_expression
    statement.block = block
    return statement
}

AST_Break_Statement :: struct : AST_Statement {
}

create_ast_break_statement :: (location: @Source_Location) -> @AST_Break_Statement {
    statement: @AST_Break_Statement = new AST_Break_Statement
    statement.location = location
    return statement
}

AST_Return_Statement :: struct : AST_Statement {
    value_expression: @AST_Expression
}

create_ast_return_statement :: (location: @Source_Location, value_expression: @AST_Expression) -> @AST_Return_Statement {
    statement: @AST_Return_Statement = new AST_Return_Statement
    statement.location = location
    statement.value_expression = value_expression
    return statement
}

AST_Variable_Statement :: struct : AST_Statement {
    name: @Identifier_Token
    type: @AST_Type
    value_expression: @AST_Expression
    is_external: Boolean
}

create_ast_variable_statement :: (name: @Identifier_Token, type: @AST_Type, value_expression: @AST_Expression, is_external: Boolean) -> @AST_Variable_Statement {
    statement: @AST_Variable_Statement = new AST_Variable_Statement
    statement.location = name.location
    statement.name = name
    statement.type = type
    statement.value_expression = value_expression
    statement.is_external = is_external
    return statement
}

AST_Struct_Statement :: struct : AST_Statement {
    name: @Identifier_Token
    base_type: @AST_Type
    members: @List
}

create_ast_struct_statement :: (name: @Identifier_Token, base_type: @AST_Type, members: @List) -> @AST_Struct_Statement {
    statement: @AST_Struct_Statement = new AST_Struct_Statement
    statement.location = name.location
    statement.name = name
    statement.base_type = base_type
    statement.members = members
    return statement
}

AST_Struct_Member :: struct {
    location: @Source_Location
    name: @Identifier_Token
    type: @AST_Type
}

create_ast_struct_member :: (name: @Identifier_Token, type: @AST_Type) -> @AST_Struct_Member {
    struct_member: @AST_Struct_Member = new AST_Struct_Member
    struct_member.location = name.location
    struct_member.name = name
    struct_member.type = type
    return struct_member
}

AST_Assignment_Statement :: struct : AST_Statement {
    storage_expression: @AST_Expression
    operator: @Other_Token
    value_expression: @AST_Expression
}

create_ast_assignment_statement :: (storage_expression: @AST_Expression, operator: @Other_Token, value_expression: @AST_Expression) -> @AST_Assignment_Statement {
    statement: @AST_Assignment_Statement = new AST_Assignment_Statement
    statement.location = storage_expression.location
    statement.storage_expression = storage_expression
    statement.operator = operator
    statement.value_expression = value_expression
    return statement
}

AST_Type :: struct : Object {
    location: @Source_Location
}

AST_Named_Type :: struct : AST_Type {
    name: @Identifier_Token
}

create_ast_named_type :: (name: @Identifier_Token) -> @AST_Type {
    type: @AST_Named_Type = new AST_Named_Type
    type.location = name.location
    type.name = name
    return type
}

AST_Pointer_Type :: struct : AST_Type {
    pointed_type: @AST_Type
}

create_ast_pointer_type :: (location: @Source_Location, pointed_type: @AST_Type) -> @AST_Pointer_Type {
    type: @AST_Pointer_Type = new AST_Pointer_Type
    type.location = location
    type.pointed_type = pointed_type
    return type
}

AST_Array_Type :: struct : AST_Type {
    item_type: @AST_Type
    size_expression: @AST_Expression
}

create_ast_array_type :: (location: @Source_Location, item_type: @AST_Type, size_expression: @AST_Expression) -> @AST_Array_Type {
    type: @AST_Array_Type = new AST_Array_Type
    type.location = location
    type.item_type = item_type
    type.size_expression = size_expression
    return type
}

AST_Expression :: struct : Object {
    location: @Source_Location
}

AST_Literal_Expression :: struct : AST_Expression {
    literal: @Literal_Token
}

create_ast_literal_expression :: (literal: @Literal_Token) -> @AST_Literal_Expression {
    expression: @AST_Literal_Expression = new AST_Literal_Expression
    expression.location = literal.location
    expression.literal = literal
    return expression
}

AST_Variable_Expression :: struct : AST_Expression {
    name: @Identifier_Token
}

create_ast_variable_expression :: (name: @Identifier_Token) -> @AST_Variable_Expression {
    expression: @AST_Variable_Expression = new AST_Variable_Expression
    expression.location = name.location
    expression.name = name
    return expression
}

AST_Binary_Expression :: struct : AST_Expression {
    left_expression: @AST_Expression
    right_expression: @AST_Expression
}

init :: (self: @AST_Binary_Expression, left_expression: @AST_Expression, right_expression: @AST_Expression) -> @AST_Binary_Expression {
    self.location = left_expression.location
    self.left_expression = left_expression
    self.right_expression = right_expression
    return self
}

AST_Add_Expression :: struct : AST_Binary_Expression {
}

AST_Divide_Expression :: struct : AST_Binary_Expression {
}

AST_Equals_Expression :: struct : AST_Binary_Expression {
}

AST_Greater_Than_Expression :: struct : AST_Binary_Expression {
}

AST_Greater_Than_Or_Equals_Expression :: struct : AST_Binary_Expression {
}

AST_Less_Than_Expression :: struct : AST_Binary_Expression {
}

AST_Less_Than_Or_Equals_Expression :: struct : AST_Binary_Expression {
}

AST_Logic_And_Expression :: struct : AST_Binary_Expression {
}

AST_Logic_Or_Expression :: struct : AST_Binary_Expression {
}

AST_Modulo_Expression :: struct : AST_Binary_Expression {
}

AST_Multiply_Expression :: struct : AST_Binary_Expression {
}

AST_Not_Equals_Expression :: struct : AST_Binary_Expression {
}

AST_Substract_Expression :: struct : AST_Binary_Expression {
}

AST_Cast_Expression :: struct : AST_Expression {
    value_expression: @AST_Expression
    type: @AST_Type
}

create_ast_cast_expression :: (value_expression: @AST_Expression, type: @AST_Type) -> @AST_Cast_Expression {
    expression: @AST_Cast_Expression = new AST_Cast_Expression
    expression.location = value_expression.location
    expression.value_expression = value_expression
    expression.type = type
    return expression
}

AST_New_Expression :: struct : AST_Expression {
    type: @AST_Type
}

create_ast_new_expression :: (location: @Source_Location, type: @AST_Type) -> @AST_New_Expression {
    expression: @AST_New_Expression = new AST_New_Expression
    expression.location = location
    expression.type = type
    return expression
}

AST_Call_Expression :: struct : AST_Expression {
    callee: @AST_Expression
    arguments: @List
}

create_ast_call_expression :: (callee: @AST_Expression, arguments: @List) -> @AST_Call_Expression {
    expression: @AST_Call_Expression = new AST_Call_Expression
    expression.location = callee.location
    expression.callee = callee
    expression.arguments = arguments
    return expression
}

AST_Access_Expression :: struct : AST_Expression {
}

AST_Member_Access_Expression :: struct : AST_Access_Expression {
    object_expression: @AST_Expression
    member_name: @Identifier_Token
}

create_ast_member_access_expression :: (object_expression: @AST_Expression, member_name: @Identifier_Token) -> @AST_Member_Access_Expression {
    expression: @AST_Member_Access_Expression = new AST_Member_Access_Expression
    expression.location = object_expression.location
    expression.object_expression = object_expression
    expression.member_name = member_name
    return expression
}

AST_Array_Access_Expression :: struct : AST_Access_Expression {
    array_expression: @AST_Expression
    index_expression: @AST_Expression
}

create_ast_array_access_expression :: (array_expression: @AST_Expression, index_expression: @AST_Expression) -> @AST_Array_Access_Expression {
    expression: @AST_Array_Access_Expression = new AST_Array_Access_Expression
    expression.location = array_expression.location
    expression.array_expression = array_expression
    expression.index_expression = index_expression
    return expression
}

write :: (file: @FILE, compilation_unit: @Compilation_Unit) -> @FILE {
    statements: @List_Iterator = compilation_unit.statements.create_iterator()
    while (statements.has_next()) {
        statement: @AST_Statement = statements.next() as @AST_Statement
        file.write_source_line(statement.location, 0).write(statement, 0).end_line()
    }
    return file
}

write :: (file: @FILE, statement: @AST_Statement, alignment: Int) -> @FILE {
    if (statement.is(AST_Assignment_Statement)) {
        statement: @AST_Assignment_Statement = statement as @AST_Assignment_Statement
        return file.write(statement.storage_expression).write(' ').write(statement.operator).write(' ').write(statement.value_expression)
    }

    if (statement.is(AST_Block_Statement)) {
        file.write('{').end_line()
        block_statements: @List_Iterator = (statement as @AST_Block_Statement).statements.create_iterator()
        while (block_statements.has_next()) {
            block_statement: @AST_Statement = block_statements.next() as @AST_Statement
            file.write_source_line(block_statement.location, alignment + 1).write(block_statement, alignment + 1).end_line()
        }
        return file.write_source_line(statement.location, alignment).write('}')
    }

    if (statement.is(AST_Break_Statement)) {
        return file.write("break")
    }

    if (statement.is(AST_Expression_Statement)) {
        return file.write((statement as @AST_Expression_Statement).expression)
    }

    if (statement.is(AST_Function_Statement)) {
        statement: @AST_Function_Statement = statement as @AST_Function_Statement
        file.write(statement.name).write(" :: (")
        function_parameters: @List_Iterator = statement.parameters.create_iterator()
        if (function_parameters.has_next()) {
            loop {
                file.write(function_parameters.next() as @AST_Function_Parameter)
                if (function_parameters.has_next()) {
                    file.write(", ")
                } else {
                    break
                }
            }
        }
        file.write(") -> ").write(statement.return_type)
        if (statement.body == null) {
            return file
        }
        return file.write(" ").write(statement.body, alignment)
    }

    if (statement.is(AST_If_Statement)) {
        statement: @AST_If_Statement = statement as @AST_If_Statement
        file.write("if (").write(statement.condition_expression).write(") ").write(statement.true_block, alignment)
        if (statement.false_block != null) {
            file.write(" else ").write(statement.false_block, alignment)
        }
        return file
    }

    if (statement.is(AST_Loop_Statement)) {
        statement: @AST_Loop_Statement = statement as @AST_Loop_Statement
        return file.write("loop ").write(statement.block, alignment)
    }

    if (statement.is(AST_Return_Statement)) {
        statement: @AST_Return_Statement = statement as @AST_Return_Statement
        file.write("return")
        if (statement.value_expression != null) {
            file.write(" ").write(statement.value_expression)
        }
        return file
    }

    if (statement.is(AST_Struct_Statement)) {
        statement: @AST_Struct_Statement = statement as @AST_Struct_Statement
        file.write(statement.name).write(" :: struct")
        if (statement.base_type != null) {
            file.write(" : ").write(statement.base_type)
        }
        if (statement.members == null) {
            return file
        }
        file.write(" {").end_line()
        members: @List_Iterator = statement.members.create_iterator()
        while (members.has_next()) {
            member: @AST_Struct_Member = members.next() as @AST_Struct_Member
            file.write_source_line(member.location, alignment + 1).write(member.name).write(": ").write(member.type).end_line()
        }
        return file.write_source_line(statement.location, alignment).write('}')
    }

    if (statement.is(AST_Variable_Statement)) {
        statement: @AST_Variable_Statement = statement as @AST_Variable_Statement
        file.write((statement as @AST_Variable_Statement).name)
        if (statement.type != null) {
            file.write(": ").write(statement.type)
            if (statement.value_expression != null) {
                file.write(" = ").write(statement.value_expression)
            }
            if (statement.is_external) {
                file.write(" = external")
            }
        } else {
            file.write(" := ").write(statement.value_expression)
        }
        return file
    }

    if (statement.is(AST_While_Statement)) {
        statement: @AST_While_Statement = statement as @AST_While_Statement
        return file.write("while (").write(statement.condition_expression).write(") ").write(statement.block, alignment)
    }

    file.fflush()
    abort(statement.location, "Unsupported AST_Statement type: ".clone().append(statement.object_type.id))
}

write_source_line :: (file: @FILE, location: @Source_Location, alignment: Int) -> @FILE {
    file.write(location.source.file_name).write(':')
    line: Int = location.line
    if (line < 1000) {
        file.write('0')
    }
    if (line < 100) {
        file.write('0')
    }
    if (line < 10) {
        file.write('0')
    }
    file.write(line).write(": ")

    space_count: Int = alignment * 2
    while (space_count > 0) {
        file.write(' ')
        space_count = space_count - 1
    }

    return file
}

write :: (file: @FILE, parameter: @AST_Function_Parameter) -> @FILE {
    return file.write(parameter.name).write(": ").write(parameter.type)
}

write :: (file: @FILE, type: @AST_Type) -> @FILE {
    if (type.is(AST_Array_Type)) {
        type: @AST_Array_Type = type as @AST_Array_Type
        if (type.size_expression != null) {
            return file.write('[').write(type.item_type).write("; ").write(type.size_expression).write(']')
        }
        return file.write('[').write(type.item_type).write(']')
    }

    if (type.is(AST_Named_Type)) {
        return file.write((type as @AST_Named_Type).name)
    }

    if (type.is(AST_Pointer_Type)) {
        return file.write('@').write((type as @AST_Pointer_Type).pointed_type)
    }

    file.fflush()
    abort(type.location, "Unsupported AST_Type type: ".clone().append(type.object_type.id))
}

write :: (file: @FILE, expression: @AST_Expression) -> @FILE {
    if (expression.is(AST_Array_Access_Expression)) {
        return file.write((expression as @AST_Array_Access_Expression).array_expression).write('[').write((expression as @AST_Array_Access_Expression).index_expression).write(']')
    }

    if (expression.is(AST_Binary_Expression)) {
        file.write((expression as @AST_Binary_Expression).left_expression)
        if (expression.is(AST_Add_Expression)) {
            return file.write(" + ").write((expression as @AST_Binary_Expression).right_expression)
        }
        if (expression.is(AST_Divide_Expression)) {
            return file.write(" / ").write((expression as @AST_Binary_Expression).right_expression)
        }
        if (expression.is(AST_Equals_Expression)) {
            return file.write(" == ").write((expression as @AST_Binary_Expression).right_expression)
        }
        if (expression.is(AST_Greater_Than_Expression)) {
            return file.write(" > ").write((expression as @AST_Binary_Expression).right_expression)
        }
        if (expression.is(AST_Greater_Than_Or_Equals_Expression)) {
            return file.write(" >= ").write((expression as @AST_Binary_Expression).right_expression)
        }
        if (expression.is(AST_Less_Than_Expression)) {
            return file.write(" < ").write((expression as @AST_Binary_Expression).right_expression)
        }
        if (expression.is(AST_Less_Than_Or_Equals_Expression)) {
            return file.write(" <= ").write((expression as @AST_Binary_Expression).right_expression)
        }
        if (expression.is(AST_Logic_And_Expression)) {
            return file.write(" && ").write((expression as @AST_Binary_Expression).right_expression)
        }
        if (expression.is(AST_Logic_Or_Expression)) {
            return file.write(" || ").write((expression as @AST_Binary_Expression).right_expression)
        }
        if (expression.is(AST_Modulo_Expression)) {
            return file.write(" // ").write((expression as @AST_Binary_Expression).right_expression)
        }
        if (expression.is(AST_Multiply_Expression)) {
            return file.write(" * ").write((expression as @AST_Binary_Expression).right_expression)
        }
        if (expression.is(AST_Not_Equals_Expression)) {
            return file.write(" != ").write((expression as @AST_Binary_Expression).right_expression)
        }
        if (expression.is(AST_Substract_Expression)) {
            return file.write(" - ").write((expression as @AST_Binary_Expression).right_expression)
        }
    }

    if (expression.is(AST_Call_Expression)) {
        file.write((expression as @AST_Call_Expression).callee).write('(')
        call_arguments: @List_Iterator = (expression as @AST_Call_Expression).arguments.create_iterator()
        if (call_arguments.has_next()) {
            loop {
                file.write(call_arguments.next() as @AST_Expression)
                if (call_arguments.has_next()) {
                    file.write(", ")
                } else {
                    break
                }
            }
        }
        return file.write(')')
    }

    if (expression.is(AST_Cast_Expression)) {
        return file.write((expression as @AST_Cast_Expression).value_expression).write(" as ").write((expression as @AST_Cast_Expression).type)
    }

    if (expression.is(AST_Literal_Expression)) {
        return file.write((expression as @AST_Literal_Expression).literal)
    }

    if (expression.is(AST_New_Expression)) {
        return file.write("new ").write((expression as @AST_New_Expression).type)
    }

    if (expression.is(AST_Member_Access_Expression)) {
        return file.write((expression as @AST_Member_Access_Expression).object_expression).write('.').write((expression as @AST_Member_Access_Expression).member_name)
    }

    if (expression.is(AST_Variable_Expression)) {
        return file.write((expression as @AST_Variable_Expression).name)
    }

    file.fflush()
    abort(expression.location, "Unsupported AST_Expression type: ".clone().append(expression.object_type.id))
}

abort :: (location: @Source_Location, message: @String) -> Nothing {
    stderr.end_line().write(location).write(": ").write(message).end_line()
    abort()
}

\ -------------------------------------------------------------------------------------------------
\       Scanner
\ -------------------------------------------------------------------------------------------------

scan :: (file_name: @String) -> @List {
    scanner: @Scanner = create_scanner(create_source(file_name))
    tokens: @List = create_list()

    loop {
        token: @Token = scanner.next_token()
        tokens.append(token)
        if (token.is(End_Of_File_Token)) {
            break
        }
    }

    return tokens
}

Scanner :: struct {
    source: @Source
    current_char_index: Int
    current_line: Int
    current_column: Int
}

create_scanner :: (source: @Source) -> @Scanner {
    scanner: @Scanner = new Scanner
    scanner.source = source
    scanner.current_char_index = 0
    scanner.current_line = 1
    scanner.current_column = 1
    return scanner
}

peek_char :: (self: @Scanner) -> Int8 {
    return self.source.content[self.current_char_index]
}

next_char :: (self: @Scanner) -> Int8 {
    next_char: Int8 = self.source.content[self.current_char_index]
    if (next_char != '\0') {
        self.current_char_index = self.current_char_index + 1
        if (next_char == '\n') {
            self.current_line = self.current_line + 1
            self.current_column = 1
        } else {
            self.current_column = self.current_column + 1
        }
    }
    return next_char
}

next_token :: (self: @Scanner) -> @Token {
    token_lexeme: @String = new String
    token_lexeme.init()

    token_location: @Source_Location = new Source_Location
    token_location.source = self.source
    token_location.line = self.current_line
    token_location.column = self.current_column

    next_char: Int8 = self.peek_char()
    if (next_char.is_identifier_start()) {
        return self.scan_identifier_token(token_lexeme, token_location)
    }
    if (next_char.is_digit()) {
        return self.scan_integer_token(token_lexeme, token_location)
    }
    if (next_char == '\'') {
        return self.scan_character_token(token_lexeme, token_location)
    }
    if (next_char == '"') {
        return self.scan_string_token(token_lexeme, token_location)
    }
    if (next_char == '\\') {
        return self.scan_comment_token(token_lexeme, token_location)
    }
    if (next_char.is_space()) {
        return self.scan_space_token(token_lexeme, token_location)
    }
    if (next_char == '\n') {
        self.next_char()
        return create_end_of_line_token(token_lexeme, token_location)
    }
    if (next_char == '\0') {
        self.next_char()
        return create_end_of_file_token(token_lexeme, token_location)
    }
    token_lexeme.append(self.next_char())
    return create_other_token(token_lexeme, token_location)
}

is_digit :: (char: Int8) -> Boolean {
    return char as Int >= '0' as Int && char as Int <= '9' as Int
}

is_identifier_start :: (char: Int8) -> Boolean {
    return char.is_letter() || char == '_'
}

is_identifier_body :: (char: Int8) -> Boolean {
    if (char.is_identifier_start()) {
        return true
    }
    return char.is_digit()
}

is_letter :: (char: Int8) -> Boolean {
    return (char as Int >= 'a' as Int && char as Int <= 'z' as Int) || (char as Int >= 'A' as Int && char as Int <= 'Z' as Int)
}

is_space :: (char: Int8) -> Boolean {
    return char == ' '
}

scan_character_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    if (self.peek_char() == '\'') {
        token_lexeme.append(self.next_char())
        char: Int8 = self.next_char()
        token_lexeme.append(char)
        if (char == '\'') {
            return create_error_token(token_lexeme, token_location)
        }
        if (char == '\\') {
            char = self.next_char()
            token_lexeme.append(char)
            if (char.is_escape() == false) {
                return create_error_token(token_lexeme, token_location)
            }
            char = self.next_char()
            token_lexeme.append(char)
            if (char != '\'') {
                return create_error_token(token_lexeme, token_location)
            }
        } else {
            if (char == '\0' || char == '\n' || char == '\t') {
                return create_error_token(token_lexeme, token_location)
            }
            char = self.next_char()
            token_lexeme.append(char)
            if (char != '\'') {
                return create_error_token(token_lexeme, token_location)
            }
        }
    }
    return create_character_token(token_lexeme, token_location)
}

is_escape :: (char: Int8) -> Boolean {
    return char == 'n' || char == 't' || char == '\"' || char == '\'' || char == '\\' || char == '0'
}

scan_comment_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    while (self.peek_char() != '\n') {
        token_lexeme.append(self.next_char())
    }
    return create_comment_token(token_lexeme, token_location)
}

scan_identifier_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    while (self.peek_char().is_identifier_body()) {
        token_lexeme.append(self.next_char())
    }
    if (token_lexeme.equals("as")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("break")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("else")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("external")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("false")) {
        return create_boolean_token(token_lexeme, token_location, false)
    }
    if (token_lexeme.equals("if")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("loop")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("new")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("null")) {
        return create_null_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("return")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("struct")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    if (token_lexeme.equals("true")) {
        return create_boolean_token(token_lexeme, token_location, true)
    }
    if (token_lexeme.equals("while")) {
        return create_keyword_token(token_lexeme, token_location)
    }
    return create_identifier_token(token_lexeme, token_location)
}

scan_integer_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    value: Int = 0
    while (self.peek_char().is_digit()) {
        char: Int8 = self.next_char()
        value = value * 10 + (char as Int - '0' as Int)
        token_lexeme.append(char)
    }
    return create_integer_token(token_lexeme, token_location, value)
}

scan_space_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    count: Int = 0
    while (self.peek_char() == ' ') {
        char: Int8 = self.next_char()
        count = count + 1
        token_lexeme.append(char)
    }
    return create_space_token(token_lexeme, token_location, count)
}

scan_string_token :: (self: @Scanner, token_lexeme: @String, token_location: @Source_Location) -> @Token {
    if (self.peek_char() == '"') {
        value: @String = new String
        value.init()

        token_lexeme.append(self.next_char())
        loop {
            char: Int8 = self.peek_char()
            if (char == '\0' || char == '\n') {
                return create_error_token(token_lexeme, token_location)
            }
            char = self.next_char()
            token_lexeme.append(char)
            if (char == '"') {
                return create_string_token(token_lexeme, token_location, value)
            }
            if (char == '\\') {
                char = self.peek_char()
                if (char == '\0' || char == '\n') {
                    return create_error_token(token_lexeme, token_location)
                }
                char = self.next_char()
                token_lexeme.append(char)
                if (char.is_escape() == false) {
                    return create_error_token(token_lexeme, token_location)
                }
            }
        }
    }
    abort(token_location, "Unexpected state")
}

\ -------------------------------------------------------------------------------------------------
\       Token
\ -------------------------------------------------------------------------------------------------

Token :: struct : Object {
    lexeme: @String
    location: @Source_Location
}

init :: (self: @Token, lexeme: @String, location: @Source_Location) -> Nothing {
    self.location = location
    self.lexeme = lexeme
}

write :: (file: @FILE, token: @Token) -> @FILE {
    if (token.is(Other_Token) || token.is(Keyword_Token)) {
        file.write(27 as Int8).write("[2;37m")
    } else {
        if (token.is(Literal_Token)) {
            file.write(27 as Int8).write("[1;33m")
        } else {
            if (token.is(Comment_Token)) {
                file.write(27 as Int8).write("[2;33m")
            }
        }
    }
    file.write(token.lexeme)
    file.write(27 as Int8).write("[0m")
    return file
}

Literal_Token :: struct : Token {
}

Character_Token :: struct : Literal_Token {
}

create_character_token :: (lexeme: @String, location: @Source_Location) -> @Character_Token {
    token: @Character_Token = new Character_Token
    token.init(lexeme, location)
    return token
}

Boolean_Token :: struct : Literal_Token {
    value: Boolean
}

create_boolean_token :: (lexeme: @String, location: @Source_Location, value: Boolean) -> @Boolean_Token {
    token: @Boolean_Token = new Boolean_Token
    token.init(lexeme, location)
    token.value = value
    return token
}

Comment_Token :: struct : Token {
}

create_comment_token :: (lexeme: @String, location: @Source_Location) -> @Comment_Token {
    token: @Comment_Token = new Comment_Token
    token.init(lexeme, location)
    return token
}

End_Of_File_Token :: struct : Token {
}

create_end_of_file_token :: (lexeme: @String, location: @Source_Location) -> @End_Of_File_Token {
    token: @End_Of_File_Token = new End_Of_File_Token
    token.init(lexeme, location)
    return token
}

End_Of_Line_Token :: struct : Token {
}

create_end_of_line_token :: (lexeme: @String, location: @Source_Location) -> @End_Of_Line_Token {
    token: @End_Of_Line_Token = new End_Of_Line_Token
    token.init(lexeme, location)
    return token
}

Error_Token :: struct : Token {
}

create_error_token :: (lexeme: @String, location: @Source_Location) -> @Error_Token {
    token: @Error_Token = new Error_Token
    token.init(lexeme, location)
    return token
}

Identifier_Token :: struct : Token {
}

create_identifier_token :: (lexeme: @String, location: @Source_Location) -> @Identifier_Token {
    token: @Identifier_Token = new Identifier_Token
    token.init(lexeme, location)
    return token
}

Integer_Token :: struct : Literal_Token {
    value: Int
}

create_integer_token :: (lexeme: @String, location: @Source_Location, value: Int) -> @Integer_Token {
    token: @Integer_Token = new Integer_Token
    token.init(lexeme, location)
    token.value = value
    return token
}

Keyword_Token :: struct : Token {
}

create_keyword_token :: (lexeme: @String, location: @Source_Location) -> @Keyword_Token {
    token: @Keyword_Token = new Keyword_Token
    token.init(lexeme, location)
    return token
}

Null_Token :: struct : Literal_Token {
}

create_null_token :: (lexeme: @String, location: @Source_Location) -> @Null_Token {
    token: @Null_Token = new Null_Token
    token.init(lexeme, location)
    return token
}

Other_Token :: struct : Token {
}

create_other_token :: (lexeme: @String, location: @Source_Location) -> @Other_Token {
    token: @Other_Token = new Other_Token
    token.init(lexeme, location)
    return token
}

Space_Token :: struct : Token {
    count: Int
}

create_space_token :: (lexeme: @String, location: @Source_Location, count: Int) -> @Space_Token {
    token: @Space_Token = new Space_Token
    token.init(lexeme, location)
    token.count = count
    return token
}

String_Token :: struct : Literal_Token {
    value: @String
}

create_string_token :: (lexeme: @String, location: @Source_Location, value: @String) -> @String_Token {
    token: @String_Token = new String_Token
    token.init(lexeme, location)
    token.value = value
    return token
}

\ -------------------------------------------------------------------------------------------------
\       Source_Location
\ -------------------------------------------------------------------------------------------------

Source_Location :: struct {
    source: @Source
    line: Int
    column: Int
}

write :: (self: @FILE, location: @Source_Location) -> @FILE {
    return self.write(location.source.file_name).write(':').write(location.line).write(':').write(location.column)
}

\ -------------------------------------------------------------------------------------------------
\       Source
\ -------------------------------------------------------------------------------------------------

Source :: struct {
    file_name: @String
    content: @Int8
}

create_source :: (file_name: @String) -> @Source {
    source: @Source = new Source

    file: @FILE = fopen(file_name.data, "r".data)

    content_size: Int = 1024
    content: @Int8 = malloc(content_size) as @Int8
    content_length: Int = 0
    loop {
        char: Int32 = fgetc(file)
        if (feof(file) as Int != 0) {
            break
        }
        if (content_length + 1 > content_size - 1) {
            content_size = content_size + 1024
            content = realloc(content, content_size) as @Int8
        }
        content[content_length] = char as Int8
        content_length = content_length + 1
    }

    source.file_name = file_name
    source.content = content

    return source
}

\ -------------------------------------------------------------------------------------------------
\       List
\ -------------------------------------------------------------------------------------------------

List :: struct {
    first_item: @List_Item
    last_item: @List_Item
    size: Int
}

create_list :: () -> @List {
    list: @List = new List
    list.first_item = null
    list.last_item = null
    list.size = 0
    return list
}

append :: (self: @List, data: @Any) -> Nothing {
    item: @List_Item = new List_Item
    item.is_removed = false
    item.data = data
    item.prev_item = self.last_item
    item.next_item = null
    if (self.last_item == null) {
        self.first_item = item
    } else {
        self.last_item.next_item = item
    }
    self.last_item = item
    self.size = self.size + 1
}

prepend :: (self: @List, data: @Any) -> Nothing {
    item: @List_Item = new List_Item
    item.is_removed = false
    item.data = data
    item.prev_item = null
    item.next_item = self.first_item
    if (self.first_item == null) {
        self.last_item = item
    } else {
        self.first_item.prev_item = item
    }
    self.first_item = item
    self.size = self.size + 1
}

remove :: (self: @List, data: @Any) -> @List {
    item: @List_Item = self.first_item
    while (item != null) {
        if (item.data == data) {
            item.is_removed = true
            break
        }
        item = item.next_item
    }
    return self
}

remove_all :: (self: @List, data: @Any) -> @List {
    item: @List_Item = self.first_item
    while (item != null) {
        if (item.data == data) {
            item.is_removed = true
        }
        item = item.next_item
    }
    return self
}

prune :: (self: @List) -> @List {
    item: @List_Item = self.first_item
    while (item != null) {
        if (item.is_removed) {
            if (item.prev_item != null) {
                item.prev_item.next_item = item.next_item
            }
            if (item.next_item != null) {
                item.next_item.prev_item = item.prev_item
            }
            if (self.first_item == item) {
                self.first_item = item.next_item
            }
            if (self.last_item == item) {
                self.last_item = item.prev_item
            }
            self.size = self.size - 1
        }
        item = item.next_item
    }
    return self
}

replace :: (self: @List, data: @Any, new_data: @Any) -> Nothing {
    item: @List_Item = self.first_item
    while (item != null) {
        if (item.data == data) {
            item.data = new_data
        }
        item = item.next_item
    }
}

index_of :: (self: @List, data: @Any) -> Int {
    index: Int = 0
    item: @List_Item = self.first_item
    while (item != null) {
        if (item.data == data) {
            return index
        }
        item = item.next_item
        index = index + 1
    }
    return index * 0 - 1
}

get :: (self: @List, index: Int) -> @Any {
    if (index >= self.size || index < 0) {
        return null
    }
    item: @List_Item = self.first_item
    while (index > 0) {
        item = item.next_item
        index = index - 1
    }
    return item.data
}

first :: (self: @List) -> @Any {
    if (self.first_item == null) {
        return null
    }
    return self.first_item.data
}

last :: (self: @List) -> @Any {
    if (self.last_item == null) {
        return null
    }
    return self.last_item.data
}

List_Item :: struct {
    prev_item: @List_Item
    next_item: @List_Item
    data: @Any
    is_removed: Boolean
}

List_Iterator :: struct {
    current_item: @List_Item
    next_item: @List_Item
    saved_current_item: @List_Item
    saved_next_item: @List_Item
}

create_iterator :: (list: @List) -> @List_Iterator {
    iterator: @List_Iterator = new List_Iterator
    iterator.current_item = null
    iterator.next_item = list.first_item
    return iterator
}

current :: (self: @List_Iterator) -> @Any {
    if (self.current_item != null) {
        return self.current_item.data
    }
    return null
}

remove_current :: (self: @List_Iterator) -> Nothing {
    self.current_item.is_removed = true
}

has_next :: (self: @List_Iterator) -> Boolean {
    return self.next_item != null
}

next :: (self: @List_Iterator) -> @Any {
    if (self.next_item == null) {
        return null
    }
    self.current_item = self.next_item
    self.next_item = self.next_item.next_item
    return self.current_item.data
}

change :: (self: @List_Iterator, data: @Any) -> Nothing {
    if (self.current_item != null) {
        self.current_item.data = data
    }
}

save_state :: (self: @List_Iterator) -> Nothing {
    self.saved_current_item = self.current_item
    self.saved_next_item = self.next_item
}

restore_state :: (self: @List_Iterator) -> Nothing {
    self.current_item = self.saved_current_item
    self.next_item = self.saved_next_item
}

\ -------------------------------------------------------------------------------------------------
\       Object
\ -------------------------------------------------------------------------------------------------

Object :: struct {
    object_type: @Object_Type
}

Object_Type :: struct {
    id: Int
    name: String
    base_type: @Object_Type
}

is :: (self: @Object, object_type: @Object_Type) -> Boolean {
    self_type: @Object_Type = self.object_type
    loop {
        if (self_type == object_type) {
            return true
        }
        self_type = self_type.base_type
        if (self_type == null) {
            return false
        }
    }
}

\ -------------------------------------------------------------------------------------------------
\       String
\ -------------------------------------------------------------------------------------------------

String :: struct {
    data: @Int8
    data_size: Int
    length: Int
}

init :: (self: @String) -> @String {
    self.init(16)
    return self
}

init :: (self: @String, data_size: Int) -> @String {
    self.data_size = data_size
    self.data = malloc(data_size) as @Int8
    self.length = 0
    return self
}

init :: (self: @String, data: @Int8) -> @String {
    self.length = data.length()
    self.data_size = self.length + 1
    self.data = data
    return self
}

clone :: (self: @String) -> @String {
    clone: @String = new String
    clone.init(self.data_size)
    clone.append(self)
    return clone
}

append :: (self: @String, char: Int8) -> @String {
    if (self.length + 1 >= self.data_size) {
        self.data_size = self.data_size + 16
        self.data = realloc(self.data, self.data_size) as @Int8
    }
    self.data[self.length] = char
    self.length = self.length + 1
    self.data[self.length] = '\0'
    return self
}

append :: (self: @String, number: Int) -> @String {
    if (number >= 10) {
        self.append(number / 10)
    }
    return self.append((number // 10 + '0' as Int) as Int8)
}

append :: (self: @String, other: @String) -> @String {
    if (self.length + other.length >= self.data_size) {
        self.data_size = self.length + other.length + 1
        self.data = realloc(self.data, self.data_size) as @Int8
    }
    index: Int = 0
    other_data: @Int8 = other.data
    self_data: @Int8 = self.data
    self_length: Int = self.length
    loop {
        char: Int8 = other_data[index]
        self_data[self_length] = char
        if (char == '\0') {
            break
        }
        self_length = self_length + 1
        index = index + 1
    }
    self.length = self_length
    return self
}

ends_with :: (self: @String, suffix: @String) -> Boolean {
    index: Int = 0
    while (index < suffix.length) {
        if (self.data[self.length - suffix.length + index] != suffix.data[index]) {
            return false
        }
        index = index + 1
    }
    return true
}

equals :: (self: @String, other: @String) -> Boolean {
    if (self.length == other.length) {
        index: Int = 0
        while (index < self.length) {
            if (self.data[index] != other.data[index]) {
                return false
            }
            index = index + 1
        }
        return true
    }
    return false
}

length :: (string: @Int8) -> Int {
    length: Int = 0
    loop {
        char: Int8 = string[length]
        if (char == '\0') {
            return length
        }
        length = length + 1
    }
}

write_line :: (file: @FILE, string: @String) -> @FILE {
    return file.end_line().write(string)
}

write :: (self: @FILE, number: Int) -> @FILE {
    if (number >= 10) {
        self.write(number / 10)
    }
    fputc((number // 10 + '0' as Int) as Int32, self)
    return self
}

write :: (self: @FILE, string: @String) -> @FILE {
    return self.write(string.data)
}

write :: (self: @FILE, chars: @Int8) -> @FILE {
    index: Int = 0
    loop {
        char: Int8 = chars[index]
        if (char == '\0') {
            break
        }
        self.write(char)
        index = index + 1
    }
    return self
}

write :: (self: @FILE, char: Int8) -> @FILE {
    c: Int32 = char as Int32
    if (fputc(c, self) != c) {
        stderr.end_line().end_line().write("Failed to write character: ").write(c as Int).end_line()
        abort()
    }
    return self
}

end_line :: (self: @FILE) -> @FILE {
    return self.write('\n')
}

abort :: (message: @String) -> Nothing {
    stderr.end_line().end_line().write(message).end_line()
    abort()
}

\ -------------------------------------------------------------------------------------------------
\       LibC stuff
\ -------------------------------------------------------------------------------------------------

\ ----- stdio.h -----------------------------------------------------------------------------------

FILE :: struct

stdout: @FILE = external
stderr: @FILE = external

fclose :: (file: @FILE) -> Int32
feof :: (file: @FILE) -> Int32
fflush :: (file: @FILE) -> Int32
fgetc :: (file: @FILE) -> Int32
fopen :: (file: @Int8, mode: @Int8) -> @FILE
fputc :: (char: Int32, file: @FILE) -> Int32

\ ----- stdlib.h ----------------------------------------------------------------------------------

abort :: () -> Nothing
exit :: (code: Int) -> Nothing
free :: (block: @Any) -> Nothing
malloc :: (size: Int) -> @Any
realloc :: (block: @Int8, size: Int) -> @Any
