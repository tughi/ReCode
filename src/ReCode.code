\ TODO: change main to: program :: (arguments: @String) -> Nothing
main :: (argc: Int, argv: @@Int8) -> Nothing {
    if (argc != 3) {
        stdout.write("Usage:").new_line()
        stdout.write('\t').write(argv[0]).write(" <INPUT FILE> <OUTPUT FILE>").new_line()
        exit(1)
    }

    source_file_name: String
    @source_file_name.init(argv[1])
    if (@source_file_name.ends_with(".code") == false) {
        stdout.write("'").write(@source_file_name).write("' doesn't end with '.code'.").new_line()
        exit(1)
    }

    output_file_name: String
    @output_file_name.init(argv[2])
    if (@output_file_name.ends_with(".s") == false) {
        stdout.write("'").write(@output_file_name).write("' doesn't end with '.s'.").new_line()
        exit(1)
    }

    source: @Source = new Source
    source.load(@source_file_name)
    stdout.write(source.content)

    output_file: @FILE = fopen(argv[2], "w".data)
    output_file.write("  .file 1 \"").write(argv[1]).write("\"").new_line()
    output_file.write("  .intel_syntax noprefix").new_line()
    output_file.new_line()
    output_file.write("  .text").new_line()
    output_file.write("  .globl main").new_line()
    output_file.write("main:").new_line()
    output_file.write("  push rbp").new_line()
    output_file.write("  mov rbp, rsp").new_line()
    \ TODO: call program function
    output_file.write("main__end:").new_line()
    output_file.write("  xor rax, rax").new_line()
    output_file.write("  mov rsp, rbp").new_line()
    output_file.write("  pop rbp").new_line()
    output_file.write("  ret").new_line()
}

Source :: struct {
    file_name: @String
    content: @Int8
}

load :: (self: @Source, file_name: @String) -> Nothing {
    file: @FILE = fopen(file_name.data, "r".data)

    content_size: Int = 1024
    content: @Int8 = malloc(content_size)
    content_length: Int = 0
    loop {
        char: Int32 = fgetc(file)
        if (feof(file) as Int != 0) {
            break
        }
        if (content_length + 1 > content_size - 1) {
            content_size = content_size + 1024
            content = realloc(content, content_size)
        }
        content[content_length] = char as Int8
        content_length = content_length + 1
    }

    self.file_name = file_name
    self.content = content
}

String :: struct {
    length: Int
    data: @Int8
}

init :: (self: @String, data: @Int8) -> Nothing {
    self.length = data.length()
    self.data = data
}

ends_with :: (self: @String, suffix: @String) -> Boolean {
    index: Int = 0
    while (index < suffix.length) {
        if (self.data[self.length - suffix.length + index] != suffix.data[index]) {
            return false
        }
        index = index + 1
    }
    return true
}

length :: (string: @Int8) -> Int {
    length: Int = 0
    loop {
        char: Int8 = string[length]
        if (char == '\0') {
            return length
        }
        length = length + 1
    }
}

write :: (self: @FILE, number: Int) -> @FILE {
    if (number >= 10) {
        self.write(number / 10)
    }
    fputc((number // 10 + '0' as Int) as Int32, self)
    return self
}

write :: (self: @FILE, string: @String) -> @FILE {
    return self.write(string.data)
}

write :: (self: @FILE, string: @Int8) -> @FILE {
    index: Int = 0
    loop {
        char: Int8 = string[index]
        if (char == '\0') {
            break
        }
        self.write(char)
        index = index + 1
    }
    return self
}

write :: (self: @FILE, char: Int8) -> @FILE {
    c: Int32 = char as Int32
    if (fputc(c, self) != c) {
        stderr.write("Error: Failed to write character")
        abort()
    }
    return self
}

new_line :: (self: @FILE) -> @FILE {
    return self.write('\n')
}

\ --------------------------------------------------------------------------------------------------------
\       LibC stuff
\ --------------------------------------------------------------------------------------------------------

\ ----- stdio.h ------------------------------------------------------------------------------------------

FILE :: struct

stdout: @FILE = external
stderr: @FILE = external

fclose :: (file: @FILE) -> Int32
feof :: (file: @FILE) -> Int32
fflush :: (file: @FILE) -> Int32
fgetc :: (file: @FILE) -> Int32
fopen :: (file: @Int8, mode: @Int8) -> @FILE
fputc :: (char: Int32, file: @FILE) -> Int32

\ ----- stdlib.h -----------------------------------------------------------------------------------------

abort :: () -> Nothing
exit :: (code: Int) -> Nothing
free :: (block: @Int8) -> Nothing
malloc :: (size: Int) -> @Int8
realloc :: (block: @Int8, size: Int) -> @Int8
