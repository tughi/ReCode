\ TODO: change main to: program :: (arguments: @String) -> Nothing
main :: (argc: Int, argv: @@Int8) -> Nothing {
    if (argc != 3) {
        stdout.write("Usage:").new_line()
        stdout.write('\t').write(argv[0]).write(" <INPUT FILE> <OUTPUT FILE>").new_line()
        exit(1)
    }

    source_file_name: String
    source_file_name.init(argv[1])
    if (source_file_name.ends_with(".code") == false) {
        stdout.write("'").write(source_file_name).write("' doesn't end with '.code'.").new_line()
        exit(1)
    }

    output_file_name: String
    output_file_name.init(argv[2])
    if (output_file_name.ends_with(".s") == false) {
        stdout.write("'").write(output_file_name).write("' doesn't end with '.s'.").new_line()
        exit(1)
    }

    source: @Source = new Source
    source.load(source_file_name)
    stdout.write(source.content)

    output_file: @FILE = fopen(argv[2], "w".data)

    output_file.write("  .file 1 \"").write(source_file_name).write("\"")
    output_file.write_line("  .intel_syntax noprefix")
    output_file.write_line("")
    output_file.write_line("  .text")
    output_file.write_line("  .globl main")
    output_file.write_line("main:")
    output_file.write_line("  push rbp")
    output_file.write_line("  mov rbp, rsp")
    \ TODO: call program function
    output_file.write_line("main__end:")
    output_file.write_line("  xor rax, rax")
    output_file.write_line("  mov rsp, rbp")
    output_file.write_line("  pop rbp")
    output_file.write_line("  ret")
    output_file.write_line("")
}

Token :: struct {
    location: @Source_Location
    lexeme: @String
}

Source_Location :: struct {
    source: @Source
    line: Int
    column: Int
}

Source :: struct {
    file_name: @String
    content: @Int8
}

load :: (self: @Source, file_name: @String) -> Nothing {
    file: @FILE = fopen(file_name.data, "r".data)

    content_size: Int = 1024
    content: @Int8 = malloc(content_size)
    content_length: Int = 0
    loop {
        char: Int32 = fgetc(file)
        if (feof(file) as Int != 0) {
            break
        }
        if (content_length + 1 > content_size - 1) {
            content_size = content_size + 1024
            content = realloc(content, content_size)
        }
        content[content_length] = char as Int8
        content_length = content_length + 1
    }

    self.file_name = file_name
    self.content = content
}

String :: struct {
    length: Int
    data: @Int8
}

init :: (self: @String, data: @Int8) -> Nothing {
    self.length = data.length()
    self.data = data
}

ends_with :: (self: @String, suffix: @String) -> Boolean {
    index: Int = 0
    while (index < suffix.length) {
        if (self.data[self.length - suffix.length + index] != suffix.data[index]) {
            return false
        }
        index = index + 1
    }
    return true
}

length :: (string: @Int8) -> Int {
    length: Int = 0
    loop {
        char: Int8 = string[length]
        if (char == '\0') {
            return length
        }
        length = length + 1
    }
}

write_line :: (file: @FILE, string: @String) -> @FILE {
    return file.new_line().write(string)
}

write :: (self: @FILE, number: Int) -> @FILE {
    if (number >= 10) {
        self.write(number / 10)
    }
    fputc((number // 10 + '0' as Int) as Int32, self)
    return self
}

write :: (self: @FILE, string: @String) -> @FILE {
    return self.write(string.data)
}

write :: (self: @FILE, chars: @Int8) -> @FILE {
    index: Int = 0
    loop {
        char: Int8 = chars[index]
        if (char == '\0') {
            break
        }
        self.write(char)
        index = index + 1
    }
    return self
}

write :: (self: @FILE, char: Int8) -> @FILE {
    c: Int32 = char as Int32
    if (fputc(c, self) != c) {
        stderr.write("Error: Failed to write character")
        abort()
    }
    return self
}

new_line :: (self: @FILE) -> @FILE {
    return self.write('\n')
}

\ --------------------------------------------------------------------------------------------------------
\       LibC stuff
\ --------------------------------------------------------------------------------------------------------

\ ----- stdio.h ------------------------------------------------------------------------------------------

FILE :: struct

stdout: @FILE = external
stderr: @FILE = external

fclose :: (file: @FILE) -> Int32
feof :: (file: @FILE) -> Int32
fflush :: (file: @FILE) -> Int32
fgetc :: (file: @FILE) -> Int32
fopen :: (file: @Int8, mode: @Int8) -> @FILE
fputc :: (char: Int32, file: @FILE) -> Int32

\ ----- stdlib.h -----------------------------------------------------------------------------------------

abort :: () -> Nothing
exit :: (code: Int) -> Nothing
free :: (block: @Int8) -> Nothing
malloc :: (size: Int) -> @Int8
realloc :: (block: @Int8, size: Int) -> @Int8
