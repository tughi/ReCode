Token :: enum (line: int, column: int, lexeme: string) {
	Character(value: char)
	Comment(text: string)
	EndOfFile
	Error(message: string)
	Identifier(name: string)
	Integer(value: int)
	Other
	String(value: string)
}

Source :: struct {
	data: [char]
	current_index: int = 0
	current_line: int = 1
	current_column: int = 1
}

\ returns the character that is about to be consumed
peek :: (self: Source) -> char {
	if (self.current_index < self.data.length) {
		return self.data[self.current_index]
	}
	return 0
}

\ consume and return the current character if it's accepted by the provided function
consume :: (self: Source, accepted: (char) -> bool) -> char {
	if (self.current_index < self.data.length) {
		current := self.data[self.current_index]
		if (accepted(current)) {
			self.current_index += 1
			if (current == '\n') {
				self.current_line += 1
				self.current_column = 1
			} else {
				self.current_column += 1
			}
			return current
		}
	}
	return 0
}

main :: () {
	source := Source("Hello world!")

	is_valid :: (char) -> bool {
		return char > 0 && char < 128
	}

	loop {
		consumed := source.consume(is_valid)
		if (consumed == 0) {
			break
		}
		if (consumed == '!') {
			skip
		}
		echo(consumed)
	}
}
