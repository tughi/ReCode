func main(anon argc: i32, anon argv: [[u8; ?]; ?]) {
    if argc != 2 {
        exit(1)
    }

    let tokenizer = make Tokenizer(
        data: argv[1]
        index: 0
    )

    let stdout_writer = make Writer(stdout)
    while tokenizer.has_next_token() {
        let token = tokenizer.next_token()
        if token.kind == 0 {
            break
        }
        stdout_writer.write(token: token).end_line()
    }
}

\ ------------------------------------------------------------------------------ Tokenizer

struct Tokenizer {
    data: [u8; ?]
    index: i32

    func has_next_token(self) -> bool {
        return self.data[self.index] != 0
    }

    func next_token(self) -> @Token {
        let lexeme_builder = make StringBuilder(
            data: malloc(4).as([u8; ?])
            data_size: 4
            length: 0
        )
        let c = self.data[self.index]
        if c >= '0' and c <= '9' {
            return self.scan_number_token(@lexeme_builder)
        }
        self.index = self.index + 1
        return make @Token(
            kind: c
            lexeme: lexeme_builder.write(char: c).build()
            value: 0
        )
    }

    func scan_number_token(self, anon lexeme_builder: @StringBuilder) -> @Token {
        let value = 0
        loop {
            let c = self.data[self.index]
            if c < '0' or c > '9' {
                break
            }
            lexeme_builder.write(char: c)
            value = value * 10 + (c - '0').as(i32)
            self.index = self.index + 1
        }
        return make @Token(
            kind: 'n'
            lexeme: lexeme_builder.build()
            value: value
        )
    }
}

\ ------------------------------------------------------------------------------ Token

struct Token {
    kind: u8
    lexeme: [u8; ?]
    value: i32
}

func @Writer.write(self, token: @Token) -> @Writer {
    self.write(char: token.kind)
    if token.kind == 'n' {
        self.write(char: ':').write(char: ' ').write(signed: token.value)
    }
    return self
}

\ ------------------------------------------------------------------------------ StringBuilder

struct StringBuilder {
    data: [u8; ?]
    data_size: i32
    length: i32

    func write(self, char c: u8) -> @StringBuilder {
        if self.length == self.data_size {
            self.data_size = self.data_size + 8
            self.data = realloc(
                self.data.as(@Any)
                self.data_size.as(u64)
            ).as([u8; ?])
        }
        self.data[self.length] = c
        self.length = self.length + 1
        return self
    }

    func build(self) -> [u8; ?] {
        self.write(char: 0)
        return self.data
    }
}

func @StringBuilder.write_char(self, anon c: u8) {
    self.write(char: c)
}

\ ------------------------------------------------------------------------------ Writer

trait Writer {
    func write_char(self, anon c: u8)
}

func @Writer.write(self, char c: u8) -> @Writer {
    self.write_char(c)
    return self
}

func @Writer.write(self, signed value: i32) -> @Writer {
    \ TODO: Use a buffer to avoid recursion
    if value < 0 {
        self.write(char: '-')
        return self.write(signed: -value)
    }
    if value >= 10 {
        self.write(signed: value / 10)
    }
    return self.write(char: (value // 10).as(u8) + '0')
}

func @Writer.end_line(self) -> @Writer {
    self.write(char: '\n')
    return self
}

\ ------------------------------------------------------------------------------ LibC

external type FILE

external stdin: @FILE
external stdout: @FILE
external stderr: @FILE

external func fputc(anon c: i32, anon file: @FILE) -> i32

func @FILE.write_char(self, anon c: u8) {
    fputc(c.as(i32), stdout)
}

external func malloc(anon size: u64) -> @Any
external func realloc(anon block: @Any, anon size: u64) -> @Any

external func exit(anon code: i32)
