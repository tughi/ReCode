func main(anon argc: i32, anon argv: [@][@]u8) {
    if argc != 2 {
        exit(1)
    }

    let tokenizer = make Tokenizer(
        data: argv[1]
        index: 0
    )

    let stdout_writer = make Writer(stdout)

    stdout_writer.write("Tokens:").end_line()

    while tokenizer.has_next_token() {
        let token = tokenizer.next_token()
        stdout_writer.write(token: token).end_line()
    }

    let stop_token = tokenizer.next_token()
    if variant in stop_token is Stop {
        exit(0)
    }

    exit(2)
}

\ ------------------------------------------------------------------------------ Tokenizer

struct Tokenizer {
    data: [@]u8
    index: i32
}

func @Tokenizer.has_next_token(self) -> bool {
    return self.data[self.index] != 0
}

func @Tokenizer.next_token(self) -> Token {
    let lexeme_builder = make_string_builder()
    let c = self.data[self.index]
    if c == 0 {
        return make Token(make Stop(
            span: make Span(
                lexeme: lexeme_builder.build()
            )
        ))
    }
    if c >= '0' and c <= '9' {
        return self.scan_number_token(@lexeme_builder)
    }
    if c == ' ' {
        return self.scan_space_token(@lexeme_builder)
    }
    self.index = self.index + 1
    return make Token(make Other(
        span: make Span(
            lexeme: lexeme_builder.write(char: c).build()
        )
    ))
}

func @Tokenizer.scan_number_token(self, anon lexeme_builder: @String_Builder) -> Token {
    let value = 0
    loop {
        let c = self.data[self.index]
        if c < '0' or c > '9' {
            break
        }
        lexeme_builder.write(char: c)
        value = value * 10 + (c - '0').as(i32)
        self.index = self.index + 1
    }
    return make Token(make Number(
        span: make Span(
            lexeme: lexeme_builder.build()
        )
        value: value
    ))
}

func @Tokenizer.scan_space_token(self, anon lexeme_builder: @String_Builder) -> Token {
    let count = 0
    loop {
        let c = self.data[self.index]
        if c != ' ' {
            break
        }
        lexeme_builder.write(char: c)
        count = count + 1
        self.index = self.index + 1
    }
    return make Token(make Space(
        span: make Span(
            lexeme: lexeme_builder.build()
        )
        count: count
    ))
}

\ ------------------------------------------------------------------------------ String

struct String {
    data: [@]u8
    length: i32
}

func @Writer.write(self, anon string: str) -> @Writer {
    let string_copy = string
    let string_data = (@string_copy).as(@String).data
    let index = 0usize
    while index < string.length {
        self.write(char: string_data[index])
        index = index + 1
    }
    return self
}

\ ------------------------------------------------------------------------------ Token


struct Span {
    lexeme: str
}

struct Number {
    span: Span
    value: i32
}

struct Space {
    span: Span
    count: i32
}

struct Other {
    span: Span
}

struct Stop {
    span: Span
}

union Token {
    Number
    Space
    Other
    Stop
}

func @Writer.write(self, token: Token) -> @Writer {
    switch token_kind in token {
        case Number {
            return self.write("Number: ").write(signed: token_kind.value)
        }
        case Space {
            return self.write("Space: ").write(signed: token_kind.count)
        }
        case Other {
            return self.write("Other: ").write(token_kind.span.lexeme)
        }
        case Stop {
            return self.write("Stop")
        }
    }
    return self
}


\ ------------------------------------------------------------------------------ String_Builder

struct String_Builder {
    data: [@]u8
    data_size: i32
    length: i32
}

func @String_Builder.write(self, char c: u8) -> @String_Builder {
    if self.length == self.data_size {
        self.data_size = self.data_size + 8
        self.data = realloc(
            self.data.as(@Any)
            self.data_size.as(u64)
        ).as([@]u8)
    }
    self.data[self.length] = c
    self.length = self.length + 1
    return self
}

func @String_Builder.build(self) -> str {
    self.write(char: 0)
    let string = make String(
        data: self.data
        length: self.length - 1
    )
    return (@string).as(@str).@
}

func make_string_builder() -> String_Builder {
    return make_string_builder(initial_data_size: 4)
}

func make_string_builder(initial_data_size: i32) -> String_Builder {
    return make String_Builder(
        data: malloc(initial_data_size.as(u64)).as([@]u8)
        data_size: initial_data_size
        length: 0
    )
}

func @String_Builder.write_char(self, anon c: u8) {
    self.write(char: c)
}

\ ------------------------------------------------------------------------------ Writer

trait Writer {
    func write_char(self, anon c: u8)
}

func @Writer.write(self, char c: u8) -> @Writer {
    self.write_char(c)
    return self
}

func @Writer.write(self, signed value: i32) -> @Writer {
    \ TODO: Use a buffer to avoid recursion
    if value < 0 {
        self.write(char: '-')
        return self.write(signed: -value)
    }
    if value >= 10 {
        self.write(signed: value / 10)
    }
    return self.write(char: (value // 10).as(u8) + '0')
}

func @Writer.end_line(self) -> @Writer {
    self.write(char: '\n')
    return self
}

\ ------------------------------------------------------------------------------ LibC

external type FILE

external stdin: @FILE
external stdout: @FILE
external stderr: @FILE

external func fputc(anon c: i32, anon file: @FILE) -> i32

func @FILE.write_char(self, anon c: u8) {
    fputc(c.as(i32), stdout)
}

external func malloc(anon size: u64) -> @Any
external func realloc(anon block: @Any, anon size: u64) -> @Any

external func exit(anon code: i32)
