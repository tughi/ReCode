type FILE = opaque

type Tokenizer = struct {
  data: ptr<u8>
  index: i32
}

type Token = struct {
  kind: u8
  value: i32
}

external $stdin: ptr<FILE>

external $stdout: ptr<FILE>

external $stderr: ptr<FILE>

$main(%argc: i32, %argv: ptr<ptr<u8>>) {
@1:
  [ %argv %argc $stdout ]
  %argc.ptr: ptr<i32> = alloc i32
  [ %argc.ptr %argv %argc $stdout ]
  store %argc.ptr %argc
  [ %argc.ptr %argv $stdout ]
  %argv.ptr: ptr<ptr<ptr<u8>>> = alloc ptr<ptr<u8>>
  [ %argc.ptr %argv.ptr %argv $stdout ]
  store %argv.ptr %argv
  [ %argc.ptr %argv.ptr $stdout ]
  %argc.1: i32 = load %argc.ptr
  [ %argc.1 %argv.ptr $stdout ]
  %1: i32 = const 2
  [ %argc.1 %1 %argv.ptr $stdout ]
  %2: bool = cmp_ne %argc.1 %1
  [ %2 %argv.ptr $stdout ]
  br %2 @2 @3
  [ %argv.ptr $stdout ]
@2:
  [ ]
  %3: i32 = const 1
  [ %3 ]
  call $exit %3
  [ ]
@3:
  [ %argv.ptr $stdout ]
  %tokenizer.ptr: ptr<Tokenizer> = alloc Tokenizer
  [ %tokenizer.ptr %argv.ptr $stdout ]
  %4: i32 = const 1
  [ %tokenizer.ptr %argv.ptr %4 $stdout ]
  %5: ptr<ptr<u8>> = offset %argv.ptr %4
  [ %tokenizer.ptr %5 $stdout ]
  %6: ptr<u8> = load %5
  [ %tokenizer.ptr %6 $stdout ]
  %7: i32 = const 0
  [ %7 %tokenizer.ptr %6 $stdout ]
  %8: Tokenizer = struct { Tokenizer.data: %6, Tokenizer.index: %7 }
  [ %7 %tokenizer.ptr %6 $stdout ]
  %9: ptr<ptr<u8>> = offset %tokenizer.ptr Tokenizer.data
  [ %7 %tokenizer.ptr %9 %6 $stdout ]
  store %9 %6
  [ %7 %tokenizer.ptr $stdout ]
  %10: ptr<i32> = offset %tokenizer.ptr Tokenizer.index
  [ %10 %7 %tokenizer.ptr $stdout ]
  store %10 %7
  [ %tokenizer.ptr $stdout ]
  jmp @4
  [ %tokenizer.ptr $stdout ]
@4:
  [ %tokenizer.ptr $stdout ]
  %11: bool = call $pTokenizer__has_next_token %tokenizer.ptr
  [ %11 %tokenizer.ptr $stdout ]
  br %11 @5 @6
  [ %tokenizer.ptr $stdout ]
@5:
  [ %tokenizer.ptr $stdout ]
  %token.ptr: ptr<ptr<Token>> = alloc ptr<Token>
  [ %token.ptr %tokenizer.ptr $stdout ]
  %12: ptr<Token> = call $pTokenizer__next_token %tokenizer.ptr
  [ %token.ptr %12 %tokenizer.ptr $stdout ]
  store %token.ptr %12
  [ %token.ptr %tokenizer.ptr $stdout ]
  %13: ptr<Token> = load %token.ptr
  [ %13 %tokenizer.ptr %token.ptr $stdout ]
  %14: ptr<u8> = offset %13 Token.kind
  [ %14 %tokenizer.ptr %token.ptr $stdout ]
  %15: u8 = load %14
  [ %15 %tokenizer.ptr %token.ptr $stdout ]
  %16: u8 = const 0
  [ %15 %16 %tokenizer.ptr %token.ptr $stdout ]
  %17: bool = cmp_eq %15 %16
  [ %17 %tokenizer.ptr %token.ptr $stdout ]
  br %17 @7 @8
  [ %tokenizer.ptr %token.ptr $stdout ]
@6:
  [ ]
  ret
  [ ]
@7:
  [ ]
  jmp @6
  [ ]
@8:
  [ %tokenizer.ptr %token.ptr $stdout ]
  %18: ptr<FILE> = load $stdout
  [ %tokenizer.ptr %18 %token.ptr $stdout ]
  %token.1: ptr<Token> = load %token.ptr
  [ %tokenizer.ptr %18 %token.1 $stdout ]
  %19: ptr<FILE> = call $pFILE__write__token %18 %token.1
  [ %tokenizer.ptr %19 $stdout ]
  %20: ptr<FILE> = call $pFILE__end_line %19
  [ %tokenizer.ptr $stdout ]
  jmp @4
  [ %tokenizer.ptr $stdout ]
@9:
  [ %tokenizer.ptr %token.ptr $stdout ]
  jmp @8
  [ %tokenizer.ptr %token.ptr $stdout ]
}

$pTokenizer__has_next_token(%self: ptr<Tokenizer>): bool {
@1:
  [ %self ]
  %self.ptr: ptr<ptr<Tokenizer>> = alloc ptr<Tokenizer>
  [ %self.ptr %self ]
  store %self.ptr %self
  [ %self.ptr ]
  %1: ptr<Tokenizer> = load %self.ptr
  [ %self.ptr %1 ]
  %2: ptr<ptr<u8>> = offset %1 Tokenizer.data
  [ %2 %self.ptr ]
  %3: ptr<Tokenizer> = load %self.ptr
  [ %2 %3 ]
  %4: ptr<i32> = offset %3 Tokenizer.index
  [ %2 %4 ]
  %5: i32 = load %4
  [ %2 %5 ]
  %6: ptr<u8> = offset %2 %5
  [ %6 ]
  %7: u8 = load %6
  [ %7 ]
  %8: u8 = const 0
  [ %7 %8 ]
  %9: bool = cmp_ne %7 %8
  [ %9 ]
  ret %9
  [ ]
}

$pTokenizer__next_token(%self: ptr<Tokenizer>): ptr<Token> {
@1:
  [ %self ]
  %self.ptr: ptr<ptr<Tokenizer>> = alloc ptr<Tokenizer>
  [ %self.ptr %self ]
  store %self.ptr %self
  [ %self.ptr ]
  %char.ptr: ptr<u8> = alloc u8
  [ %char.ptr %self.ptr ]
  %1: ptr<Tokenizer> = load %self.ptr
  [ %char.ptr %self.ptr %1 ]
  %2: ptr<ptr<u8>> = offset %1 Tokenizer.data
  [ %char.ptr %2 %self.ptr ]
  %3: ptr<Tokenizer> = load %self.ptr
  [ %char.ptr %2 %3 %self.ptr ]
  %4: ptr<i32> = offset %3 Tokenizer.index
  [ %char.ptr %2 %4 %self.ptr ]
  %5: i32 = load %4
  [ %char.ptr %2 %5 %self.ptr ]
  %6: ptr<u8> = offset %2 %5
  [ %char.ptr %6 %self.ptr ]
  %7: u8 = load %6
  [ %char.ptr %7 %self.ptr ]
  store %char.ptr %7
  [ %char.ptr %self.ptr ]
  %char.1: u8 = load %char.ptr
  [ %char.1 %char.ptr %self.ptr ]
  %8: u8 = const '0'
  [ %char.1 %8 %char.ptr %self.ptr ]
  %9: bool = cmp_ge %char.1 %8
  [ %9 %char.ptr %self.ptr ]
  br %9 @4 @5
  [ %char.ptr %self.ptr %9 ]
@2:
  [ %self.ptr ]
  %self.1: ptr<Tokenizer> = load %self.ptr
  [ %self.1 ]
  %13: ptr<Token> = call $pTokenizer__scan_number_token %self.1
  [ %13 ]
  ret %13
  [ ]
@3:
  [ %char.ptr %self.ptr ]
  %14: ptr<Tokenizer> = load %self.ptr
  [ %char.ptr %self.ptr %14 ]
  %15: ptr<i32> = offset %14 Tokenizer.index
  [ %char.ptr %15 %self.ptr ]
  %16: ptr<Tokenizer> = load %self.ptr
  [ %char.ptr %15 %16 ]
  %17: ptr<i32> = offset %16 Tokenizer.index
  [ %char.ptr %15 %17 ]
  %18: i32 = load %17
  [ %char.ptr %15 %18 ]
  %19: i32 = const 1
  [ %char.ptr %15 %18 %19 ]
  %20: i32 = add %18 %19
  [ %char.ptr %15 %20 ]
  store %15 %20
  [ %char.ptr ]
  %21: u64 = const 5
  [ %char.ptr %21 ]
  %22: ptr<Token> = call $malloc %21
  [ %22 %char.ptr ]
  %char.3: u8 = load %char.ptr
  [ %22 %char.3 ]
  %23: i32 = const 0
  [ %22 %23 %char.3 ]
  %24: Token = struct { Token.kind: %char.3, Token.value: %23 }
  [ %22 %23 %char.3 ]
  %25: ptr<u8> = offset %22 Token.kind
  [ %22 %23 %25 %char.3 ]
  store %25 %char.3
  [ %22 %23 ]
  %26: ptr<i32> = offset %22 Token.value
  [ %22 %26 %23 ]
  store %26 %23
  [ %22 ]
  ret %22
  [ ]
@4:
  [ %char.ptr %self.ptr ]
  %char.2: u8 = load %char.ptr
  [ %char.2 %self.ptr %char.ptr ]
  %10: u8 = const '9'
  [ %char.2 %10 %self.ptr %char.ptr ]
  %11: bool = cmp_le %char.2 %10
  [ %11 %self.ptr %char.ptr ]
  jmp @5
  [ %self.ptr %char.ptr %11 ]
@5:
  [ %self.ptr %char.ptr ]
  %12: bool = phi @1 %9 @4 %11
  [ %self.ptr %char.ptr %12 ]
  br %12 @2 @3
  [ %self.ptr %char.ptr ]
}

$pTokenizer__scan_number_token(%self: ptr<Tokenizer>): ptr<Token> {
@1:
  [ %self ]
  %self.ptr: ptr<ptr<Tokenizer>> = alloc ptr<Tokenizer>
  [ %self.ptr %self ]
  store %self.ptr %self
  [ %self.ptr ]
  %value.ptr: ptr<i32> = alloc i32
  [ %value.ptr %self.ptr ]
  %1: i32 = const 0
  [ %value.ptr %1 %self.ptr ]
  store %value.ptr %1
  [ %self.ptr %value.ptr ]
  jmp @2
  [ %self.ptr %value.ptr ]
@2:
  [ %self.ptr %value.ptr ]
  %char.ptr: ptr<u8> = alloc u8
  [ %char.ptr %self.ptr %value.ptr ]
  %2: ptr<Tokenizer> = load %self.ptr
  [ %char.ptr %self.ptr %2 %value.ptr ]
  %3: ptr<ptr<u8>> = offset %2 Tokenizer.data
  [ %char.ptr %3 %self.ptr %value.ptr ]
  %4: ptr<Tokenizer> = load %self.ptr
  [ %char.ptr %3 %4 %value.ptr %self.ptr ]
  %5: ptr<i32> = offset %4 Tokenizer.index
  [ %char.ptr %3 %5 %value.ptr %self.ptr ]
  %6: i32 = load %5
  [ %char.ptr %3 %6 %value.ptr %self.ptr ]
  %7: ptr<u8> = offset %3 %6
  [ %char.ptr %7 %value.ptr %self.ptr ]
  %8: u8 = load %7
  [ %char.ptr %8 %value.ptr %self.ptr ]
  store %char.ptr %8
  [ %char.ptr %value.ptr %self.ptr ]
  %char.1: u8 = load %char.ptr
  [ %char.1 %char.ptr %value.ptr %self.ptr ]
  %9: u8 = const '0'
  [ %char.1 %9 %char.ptr %value.ptr %self.ptr ]
  %10: bool = cmp_lt %char.1 %9
  [ %10 %char.ptr %value.ptr %self.ptr ]
  br %10 @7 @6
  [ %value.ptr %self.ptr %char.ptr %10 ]
@3:
  [ %value.ptr ]
  %27: u64 = const 5
  [ %value.ptr %27 ]
  %28: ptr<Token> = call $malloc %27
  [ %28 %value.ptr ]
  %29: u8 = const 'n'
  [ %28 %29 %value.ptr ]
  %value.2: i32 = load %value.ptr
  [ %28 %value.2 %29 ]
  %30: Token = struct { Token.kind: %29, Token.value: %value.2 }
  [ %28 %value.2 %29 ]
  %31: ptr<u8> = offset %28 Token.kind
  [ %28 %value.2 %31 %29 ]
  store %31 %29
  [ %28 %value.2 ]
  %32: ptr<i32> = offset %28 Token.value
  [ %28 %32 %value.2 ]
  store %32 %value.2
  [ %28 ]
  ret %28
  [ ]
@4:
  [ %value.ptr ]
  jmp @3
  [ %value.ptr ]
@5:
  [ %self.ptr %value.ptr %char.ptr ]
  %value.1: i32 = load %value.ptr
  [ %self.ptr %value.ptr %char.ptr %value.1 ]
  %14: i32 = const 10
  [ %self.ptr %value.ptr %char.ptr %value.1 %14 ]
  %15: i32 = mul %value.1 %14
  [ %self.ptr %value.ptr %15 %char.ptr ]
  %char.3: u8 = load %char.ptr
  [ %self.ptr %value.ptr %15 %char.3 ]
  %16: u8 = const '0'
  [ %self.ptr %value.ptr %15 %char.3 %16 ]
  %17: u8 = sub %char.3 %16
  [ %self.ptr %value.ptr %15 %17 ]
  %18: i32 = cast %17
  [ %self.ptr %value.ptr %15 %18 ]
  %19: i32 = add %15 %18
  [ %self.ptr %value.ptr %19 ]
  store %value.ptr %19
  [ %self.ptr %value.ptr ]
  %20: ptr<Tokenizer> = load %self.ptr
  [ %self.ptr %20 %value.ptr ]
  %21: ptr<i32> = offset %20 Tokenizer.index
  [ %self.ptr %21 %value.ptr ]
  %22: ptr<Tokenizer> = load %self.ptr
  [ %self.ptr %21 %22 %value.ptr ]
  %23: ptr<i32> = offset %22 Tokenizer.index
  [ %self.ptr %21 %23 %value.ptr ]
  %24: i32 = load %23
  [ %self.ptr %21 %24 %value.ptr ]
  %25: i32 = const 1
  [ %self.ptr %21 %24 %25 %value.ptr ]
  %26: i32 = add %24 %25
  [ %self.ptr %21 %26 %value.ptr ]
  store %21 %26
  [ %self.ptr %value.ptr ]
  jmp @2
  [ %self.ptr %value.ptr ]
@6:
  [ %char.ptr %value.ptr %self.ptr ]
  %char.2: u8 = load %char.ptr
  [ %char.2 %value.ptr %self.ptr %char.ptr ]
  %11: u8 = const '9'
  [ %char.2 %11 %value.ptr %self.ptr %char.ptr ]
  %12: bool = cmp_gt %char.2 %11
  [ %12 %value.ptr %self.ptr %char.ptr ]
  jmp @7
  [ %value.ptr %self.ptr %char.ptr %12 ]
@7:
  [ %value.ptr %self.ptr %char.ptr ]
  %13: bool = phi @2 %10 @6 %12
  [ %value.ptr %self.ptr %char.ptr %13 ]
  br %13 @4 @5
  [ %value.ptr %self.ptr %char.ptr ]
@8:
  [ %self.ptr %value.ptr %char.ptr ]
  jmp @5
  [ %self.ptr %value.ptr %char.ptr ]
}

$pFILE__write__char(%self: ptr<FILE>, %char: u8): ptr<FILE> {
@1:
  [ $stdout %char %self ]
  %self.ptr: ptr<ptr<FILE>> = alloc ptr<FILE>
  [ %self.ptr $stdout %char %self ]
  store %self.ptr %self
  [ %self.ptr $stdout %char ]
  %char.ptr: ptr<u8> = alloc u8
  [ %self.ptr $stdout %char.ptr %char ]
  store %char.ptr %char
  [ %self.ptr $stdout %char.ptr ]
  %char.1: u8 = load %char.ptr
  [ %self.ptr %char.1 $stdout ]
  %1: ptr<FILE> = load $stdout
  [ %self.ptr %char.1 %1 ]
  %2: i32 = call $fputc %char.1 %1
  [ %self.ptr ]
  %self.1: ptr<FILE> = load %self.ptr
  [ %self.1 ]
  ret %self.1
  [ ]
}

$pFILE__write__signed(%self: ptr<FILE>, %value: i32): ptr<FILE> {
@1:
  [ %value %self ]
  %self.ptr: ptr<ptr<FILE>> = alloc ptr<FILE>
  [ %value %self.ptr %self ]
  store %self.ptr %self
  [ %value %self.ptr ]
  %value.ptr: ptr<i32> = alloc i32
  [ %value.ptr %value %self.ptr ]
  store %value.ptr %value
  [ %value.ptr %self.ptr ]
  %value.1: i32 = load %value.ptr
  [ %value.1 %value.ptr %self.ptr ]
  %1: i32 = const 0
  [ %value.1 %1 %value.ptr %self.ptr ]
  %2: bool = cmp_lt %value.1 %1
  [ %2 %value.ptr %self.ptr ]
  br %2 @2 @3
  [ %value.ptr %self.ptr ]
@2:
  [ %value.ptr %self.ptr ]
  %self.1: ptr<FILE> = load %self.ptr
  [ %value.ptr %self.ptr %self.1 ]
  %3: u8 = const '-'
  [ %value.ptr %self.ptr %self.1 %3 ]
  %4: ptr<FILE> = call $pFILE__write__char %self.1 %3
  [ %value.ptr %self.ptr ]
  %self.2: ptr<FILE> = load %self.ptr
  [ %self.2 %value.ptr ]
  %value.2: i32 = load %value.ptr
  [ %self.2 %value.2 ]
  %5: i32 = neg %value.2
  [ %self.2 %5 ]
  %6: ptr<FILE> = call $pFILE__write__signed %self.2 %5
  [ %6 ]
  ret %6
  [ ]
@3:
  [ %value.ptr %self.ptr ]
  %value.3: i32 = load %value.ptr
  [ %value.3 %value.ptr %self.ptr ]
  %7: i32 = const 10
  [ %value.3 %7 %value.ptr %self.ptr ]
  %8: bool = cmp_ge %value.3 %7
  [ %8 %value.ptr %self.ptr ]
  br %8 @4 @5
  [ %value.ptr %self.ptr ]
@4:
  [ %value.ptr %self.ptr ]
  %self.3: ptr<FILE> = load %self.ptr
  [ %self.3 %value.ptr %self.ptr ]
  %value.4: i32 = load %value.ptr
  [ %self.3 %value.4 %value.ptr %self.ptr ]
  %9: i32 = const 10
  [ %self.3 %value.4 %9 %value.ptr %self.ptr ]
  %10: i32 = div %value.4 %9
  [ %self.3 %10 %value.ptr %self.ptr ]
  %11: ptr<FILE> = call $pFILE__write__signed %self.3 %10
  [ %value.ptr %self.ptr ]
  jmp @5
  [ %value.ptr %self.ptr ]
@5:
  [ %value.ptr %self.ptr ]
  %self.4: ptr<FILE> = load %self.ptr
  [ %self.4 %value.ptr ]
  %value.5: i32 = load %value.ptr
  [ %self.4 %value.5 ]
  %12: i32 = const 10
  [ %self.4 %value.5 %12 ]
  %13: i32 = mod %value.5 %12
  [ %self.4 %13 ]
  %14: u8 = cast %13
  [ %self.4 %14 ]
  %15: u8 = const '0'
  [ %self.4 %14 %15 ]
  %16: u8 = add %14 %15
  [ %self.4 %16 ]
  %17: ptr<FILE> = call $pFILE__write__char %self.4 %16
  [ %17 ]
  ret %17
  [ ]
}

$pFILE__write__token(%self: ptr<FILE>, %token: ptr<Token>): ptr<FILE> {
@1:
  [ %token %self ]
  %self.ptr: ptr<ptr<FILE>> = alloc ptr<FILE>
  [ %self.ptr %token %self ]
  store %self.ptr %self
  [ %self.ptr %token ]
  %token.ptr: ptr<ptr<Token>> = alloc ptr<Token>
  [ %token.ptr %self.ptr %token ]
  store %token.ptr %token
  [ %token.ptr %self.ptr ]
  %self.1: ptr<FILE> = load %self.ptr
  [ %token.ptr %self.1 %self.ptr ]
  %1: ptr<Token> = load %token.ptr
  [ %token.ptr %self.1 %1 %self.ptr ]
  %2: ptr<u8> = offset %1 Token.kind
  [ %token.ptr %self.1 %2 %self.ptr ]
  %3: u8 = load %2
  [ %token.ptr %self.1 %3 %self.ptr ]
  %4: ptr<FILE> = call $pFILE__write__char %self.1 %3
  [ %token.ptr %self.ptr ]
  %5: ptr<Token> = load %token.ptr
  [ %5 %token.ptr %self.ptr ]
  %6: ptr<u8> = offset %5 Token.kind
  [ %6 %token.ptr %self.ptr ]
  %7: u8 = load %6
  [ %7 %token.ptr %self.ptr ]
  %8: u8 = const 'n'
  [ %7 %8 %token.ptr %self.ptr ]
  %9: bool = cmp_eq %7 %8
  [ %9 %token.ptr %self.ptr ]
  br %9 @2 @3
  [ %token.ptr %self.ptr ]
@2:
  [ %token.ptr %self.ptr ]
  %self.2: ptr<FILE> = load %self.ptr
  [ %token.ptr %self.2 %self.ptr ]
  %10: u8 = const ':'
  [ %token.ptr %self.2 %10 %self.ptr ]
  %11: ptr<FILE> = call $pFILE__write__char %self.2 %10
  [ %token.ptr %11 %self.ptr ]
  %12: u8 = const ' '
  [ %token.ptr %11 %12 %self.ptr ]
  %13: ptr<FILE> = call $pFILE__write__char %11 %12
  [ %13 %token.ptr %self.ptr ]
  %14: ptr<Token> = load %token.ptr
  [ %13 %14 %self.ptr ]
  %15: ptr<i32> = offset %14 Token.value
  [ %13 %15 %self.ptr ]
  %16: i32 = load %15
  [ %13 %16 %self.ptr ]
  %17: ptr<FILE> = call $pFILE__write__signed %13 %16
  [ %self.ptr ]
  jmp @3
  [ %self.ptr ]
@3:
  [ %self.ptr ]
  %self.3: ptr<FILE> = load %self.ptr
  [ %self.3 ]
  ret %self.3
  [ ]
}

$pFILE__end_line(%self: ptr<FILE>): ptr<FILE> {
@1:
  [ %self ]
  %self.ptr: ptr<ptr<FILE>> = alloc ptr<FILE>
  [ %self.ptr %self ]
  store %self.ptr %self
  [ %self.ptr ]
  %self.1: ptr<FILE> = load %self.ptr
  [ %self.ptr %self.1 ]
  %1: u8 = const '\n'
  [ %self.ptr %self.1 %1 ]
  %2: ptr<FILE> = call $pFILE__write__char %self.1 %1
  [ %self.ptr ]
  %self.2: ptr<FILE> = load %self.ptr
  [ %self.2 ]
  ret %self.2
  [ ]
}

$fputc(%c: u8, %file: ptr<FILE>): i32

$malloc(%size: u64): ptr<Any>

$exit(%code: i32)
