#!/usr/bin/env python3

import logging
import os
import re
import subprocess
import sys
from collections import OrderedDict
from datetime import datetime

logging.basicConfig(format='[%(asctime)s,%(msecs)03d][%(levelname).1s] %(message)s', datefmt='%H:%M:%S')

logger = logging.getLogger('ReCode')
logger.setLevel(logging.DEBUG)

COLOR_DEBUG = '\x1b[2;37m'
COLOR_ERROR = '\x1b[0;91m'
COLOR_RESET = '\x1b[0m'

def execute(command, exit_on_error=True, expected_code=0):
    logger.debug(f"{COLOR_DEBUG}{command}{COLOR_RESET}")
    return_code = subprocess.call(command.split(' '))
    if return_code != expected_code and exit_on_error:
        exit(return_code)
    return return_code

def cc(source_file, output_file):
    execute(f'cc -ansi -pedantic -Wno-declaration-after-statement -g -o {output_file} {source_file}')


def trace(program, args):
    logger.info(f"Tracing: {program} {args}")
    subprocess.run(f'''gdb {program} -batch -ex='set confirm off' -ex='set style enabled on' -ex='run {args}' -ex=backtrace -ex=quit''', shell=True)
    exit(1)


def clean():
    logger.info("Cleaning")

    execute('rm -fr build')


def bootstrap():
    logger.info("Bootstrapping")

    if not os.path.exists('build/stage0'):
        execute(f'mkdir -p build/stage0')

    bootstrap_compiler = 'build/stage0/ReCode'
    if not os.path.exists(bootstrap_compiler) or os.path.getmtime('bootstrap/ReCode.c') > os.path.getmtime(bootstrap_compiler):
        cc('bootstrap/ReCode.c', bootstrap_compiler)


def build_stage(n):
    logger.info(f"Building stage{n}")

    if not os.path.exists(f'build/stage{n}'):
        execute(f'mkdir build/stage{n}')

    compiler = f'build/stage{n - 1}/ReCode'
    source_file = f'compiler/ReCode.code'
    output_file = f'build/stage{n}/ReCode.c'
    compiler_args = f'{source_file} {output_file}'

    compiler_changed = not os.path.exists(output_file) or os.path.getmtime(output_file) < os.path.getmtime(compiler)
    if not compiler_changed:
        for root, dirs, files in os.walk(os.path.dirname(source_file)):
            for file in files:
                if os.path.getmtime(output_file) < os.path.getmtime(f'{root}/{file}'):
                    compiler_changed = True
                    break
            else:
                continue
            break

    if compiler_changed:
        if execute(f'{compiler} {compiler_args}', exit_on_error=False) != 0:
            trace(compiler, compiler_args)
        cc(output_file, f'build/stage{n}/ReCode')


def test():
    if not os.path.exists(f'build/tests'):
        execute(f'mkdir build/tests')

    for test_file_name in os.listdir('tests'):
        if not test_file_name.endswith('.code'):
            continue

        expected_error = None
        expected_output = None
        with open(f'tests/{test_file_name}') as test_file:
            line = next(test_file)
            if line == '// Expect:\n':
                line = next(test_file)
                line_match = re.match(r'// - (error|output): (\'.*\')\n', line)
                if line_match:
                    if line_match.group(1) == 'error':
                        expected_error = line_match.group(2)
                    else:
                        expected_output = line_match.group(2)
            if expected_error is None and expected_output is None:
                continue

        args = ['build/stage1/ReCode', f'tests/{test_file_name}', f'build/tests/{test_file_name[:-5]}.c']
        logger.info(f"Testing: {args[1]}")
        test_result = subprocess.run(args, capture_output=expected_error is not None, text=True)
        if expected_error:
            if test_result.returncode == 0:
                logger.error(f"{COLOR_ERROR}Unexpected exit code: {test_result.returncode}{COLOR_RESET}")
                exit(1)
            test_error = repr(re.sub(r'\x1b\[[0-9;]+m', '', test_result.stderr)) if test_result.stderr else None
            if test_error != expected_error:
                logger.error(f"{COLOR_ERROR}Unexpected error: {test_error}{COLOR_RESET}")
                trace(args[0], ' '.join(args[1:]))
                exit(test_result.returncode)
        if test_result.returncode == 0:
            cc(f'build/tests/{test_file_name[:-5]}.c', f'build/tests/{test_file_name[:-5]}')

            test_result = subprocess.run([f'build/tests/{test_file_name[:-5]}'], capture_output=expected_output is not None, text=True)
            if test_result.returncode != 0:
                logger.error(f"{COLOR_ERROR}Unexpected exit code: {test_result.returncode}{COLOR_RESET}")
                exit(test_result.returncode)
            if expected_output and repr(test_result.stdout) != expected_output:
                logger.error(f"{COLOR_ERROR}Unexpected output: {repr(test_result.stdout)}{COLOR_RESET}")
                exit(1)


def build():
    bootstrap()
    build_stage(1)
    test()
    build_stage(2)
    build_stage(3)


def stage():
    build()

    logger.info("Staging")
    execute('diff -q build/stage2/ReCode.c build/stage3/ReCode.c')
    execute('rm -fr bootstrap')
    execute('mkdir bootstrap')
    execute('cp -R compiler bootstrap/')
    execute('mv bootstrap/compiler bootstrap/stage0')
    execute('build/stage2/ReCode bootstrap/stage0/ReCode.code bootstrap/ReCode.c')

    bootstrap()

def time():
    build()

    count = 5
    start_time = datetime.now()
    for _ in range(count):
        execute('build/stage2/ReCode compiler/ReCode.code build/stage3/ReCode.c')
    finish_time = datetime.now()

    logger.info(f"Average time: {((finish_time - start_time) / count).total_seconds()}")

TASKS = OrderedDict(
    clean=clean,
    build=build,
    stage=stage,
    time=time,
)

if len(sys.argv) > 1:
    for task_name in sys.argv[1:]:
        if task_name in TASKS:
            TASKS[task_name]()
        else:
            print(f"Unrecognized task: {task_name}")
else:
    print(f"Usage: {sys.argv[0]} [ {' | '.join(TASKS.keys())} ]+ ")
