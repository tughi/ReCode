#!/usr/bin/env python3

import os
import re
import subprocess
import sys
from collections import OrderedDict


def execute(command, echo=True, exit_on_error=True):
    if echo:
        print(command)
    return_code = subprocess.call(command.split(' '))
    if return_code != 0 and exit_on_error:
        exit(return_code)
    return return_code


def clean():
    execute(f'''rm -fr build''')


def build():
    if not os.path.exists(os.path.join('build', 'bootstrap')):
        execute(f'''mkdir -p {os.path.join('build', 'bootstrap')}''')

    os.chdir('bootstrap')

    obj_files = []
    obj_files_changed = False

    loaded_includes = {}
    include_re = re.compile(r'#include\s+"\s*([^"]+)\s*"')

    def load_includes(source_file):
        source_file_includes = set()
        with open(source_file, 'r') as source_file_text:
            for source_line in source_file_text.readlines():
                match = include_re.search(source_line)
                if match:
                    source_file_include = match.group(1)
                    if not os.path.exists(source_file_include):
                        print(f'''File "{source_file}" includes non-existing file: {source_file_include}''')
                        exit(1)
                    if source_file_include not in source_file_includes:
                        source_file_includes.add(source_file_include)
                        if source_file_include not in loaded_includes:
                            loaded_includes[source_file_include] = set()  # avoids recursive loads
                            loaded_includes[source_file_include] = load_includes(source_file_include)
                        source_file_includes.update(loaded_includes[source_file_include])
        return source_file_includes

    c_files = [file for file in os.listdir('.') if file[0] != '.' and file.endswith('.c')]
    c_files.sort()
    for c_file in c_files:
        obj_file = os.path.join('..', 'build', 'bootstrap', c_file.replace('.c', '.o'))
        obj_files.append(obj_file)

        if os.path.exists(obj_file):
            obj_file_timestamp = os.path.getmtime(obj_file)

            obj_file_dependencies = set()
            obj_file_dependencies.add(c_file)
            obj_file_dependencies.update(load_includes(c_file))

            compile_file = False
            for obj_file_dependency in obj_file_dependencies:
                if os.path.getmtime(obj_file_dependency) > obj_file_timestamp:
                    compile_file = True
                    break
        else:
            compile_file = True

        if compile_file:
            execute(f'''gcc -g -c -o {obj_file} {c_file}''')
            obj_files_changed = True

    if obj_files_changed or not os.path.exists(os.path.join('..', 'build', 'ReCode')):
        execute(f'''gcc -g -rdynamic -o {os.path.join('..', 'build', 'ReCode')} {' '.join(obj_files)}''')

    os.chdir('..')


def run():
    build()

    os.chdir('build')
    execute('rm -f test_*', echo=False)
    os.chdir('..')

    os.chdir('build')
    test_dir = os.path.join('..', 'test')
    test_files = [file_name for file_name in os.listdir(test_dir) if file_name.startswith('test_') and file_name.endswith('.code')]
    test_files.sort()
    for test_file in test_files:
        test = test_file[:-5]
        print(f"Checking {test}")
        if execute(f'''./ReCode {os.path.join(test_dir, test_file)} {test}.s''', echo=False, exit_on_error=False) == 0:
            if execute(f'''gcc -g -o {test} {test}.s''', echo=False, exit_on_error=False) == 0:
                try:
                    with open(f'''{os.path.join(test_dir, test)}.exit''') as file:
                        for line in file:
                            expected_exit = int(line)
                            break
                except FileNotFoundError:
                    expected_exit = 0
                try:
                    with open(f'''{os.path.join(test_dir, test)}.output''', 'rb') as file:
                        expected_output = file.read()
                except FileNotFoundError:
                    expected_output = b''
                result = subprocess.run(f'''./{test}''', shell=True, capture_output=True)
                if result.returncode != expected_exit:
                    print(f"ERROR: exited with {result.returncode} instead of {expected_exit}")
                elif result.stdout != expected_output:
                    print(f"ERROR: wrong output")
                    print(f"captured: {result.stdout!r}")
                    print(f"expected: {expected_output!r}")
        else:
            subprocess.run(f'''gdb -batch -ex='set confirm off' -ex='set style enabled on' -ex='run {os.path.join(test_dir, test_file)} {test}.s &> /dev/null' -ex=bt -ex=quit --args ./ReCode''', shell=True)


TASKS = OrderedDict(
    clean=clean,
    build=build,
    run=run,
)

if len(sys.argv) > 1:
    for task_name in sys.argv[1:]:
        if task_name in TASKS:
            TASKS[task_name]()
        else:
            print(f"Unrecognized task: {task_name}")
else:
    print(f"Usage: {sys.argv[0]} [ {' | '.join(TASKS.keys())} ]+ ")
