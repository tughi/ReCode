\ Copyright (C) 2023 Stefan Selariu

\ ---------------------------------------------------------------------------------------------------------------------
\   LibC
\ ---------------------------------------------------------------------------------------------------------------------

external type File

external stdin: File*
external stdout: File*
external stderr: File*

external func fopen(file_name: char*, mode: char*) -> File*
external func fclose(stream: File*) -> i32
external func fgetc(stream: File*) -> i32
external func fputc(c: i32, stream: File*) -> i32
external func fputs(s: char*, stream: File*) -> i32

external func malloc(size: usize) -> void*
external func realloc(ptr: void*, size: usize) -> void*
external func free(ptr: void*) -> void

external func abort() -> void

\ ---------------------------------------------------------------------------------------------------------------------
\   String
\ ---------------------------------------------------------------------------------------------------------------------

struct String {
    data: char*
    data_size: usize
    length: usize
}

func String__create_empty(data_size: usize) -> String* {
    let string = malloc(sizeof(String)).as(String*)
    string.data = malloc(data_size).as(char*)
    string.data_size = data_size
    string.length = 0.as(usize)
    return string
}

func String__create() -> String* {
    return String__create_empty(16.as(usize))
}

func String__delete(self: String*) -> void {
    free(self.data.as(void*))
    free(self.as(void*))
}

func String__append_char(self: String*, ch: char) -> String* {
    if (self.length >= self.data_size) {
        self.data_size = self.data_size + 16.as(usize)
        self.data = realloc(self.data.as(void*), self.data_size).as(char*)
    }
    self.data[self.length] = ch
    self.length = self.length + 1.as(usize)
    return self
}

func String__append_cstring(self: String*, s: char*) -> String* {
    let index = 0.as(usize)
    while (true) {
        let c = s[index]
        if (c == '\0') {
            return self
        }
        String__append_char(self, c)
        index = index + 1.as(usize)
    }
}

func cstring_length(s: char*) -> usize {
    let length = 0.as(usize)
    while (true) {
        let c = s[length].as(u8)
        if (c == 0.as(u8)) {
            break
        }
        length = length + 1.as(usize)
    }
    return length
}

func String__create_from(data: char*) -> String* {
    let string_length = cstring_length(data)
    let string = String__create_empty(string_length)
    String__append_cstring(string, data)
    return string
}

func String__append_i16(self: String*, value: i16) -> String* {
    if (value < 0.as(i16)) {
        String__append_char(self, '-')
        String__append_i16(self, -value)
    } else {
        if (value >= 10.as(i16)) {
            String__append_i16(self, value / 10.as(i16))
        }
        String__append_char(self, (value % 10.as(i16)).as(char) + '0')
    }
    return self
}

func String__append_string(self: String*, other: String*) -> String* {
    let index = 0.as(usize)
    while (index < other.length) {
        String__append_char(self, other.data[index])
        index = index + 1.as(usize)
    }
    return self
}

func String__equals_cstring(self: String*, s: char*) -> bool {
    let length = cstring_length(s)
    if (self.length != length) {
        return false
    }

    let index = 0.as(usize)
    while (index < length) {
        if (self.data[index] != s[index]) {
            return false
        }
        index = index + 1.as(usize)
    }

    return true
}

func String__equals_string(self: String*, other: String*) -> bool {
    if (self.length != other.length) {
        return false
    }

    let index = 0.as(usize)
    while (index < self.length) {
        if (self.data[index] != other.data[index]) {
            return false
        }
        index = index + 1.as(usize)
    }

    return true
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Utils
\ ---------------------------------------------------------------------------------------------------------------------

func File__write_char(self: File*, c: char) -> void {
    fputc(c.as(i32), self)
}

func File__write_cstring(self: File*, s: char*) -> void {
    fputs(s, self)
}

func File__write_i32(self: File*, value: i32) -> void {
    if (value < 0) {
        File__write_char(self, '-')
        File__write_i32(self, -value)
    } else {
        if (value >= 10) {
            File__write_i32(self, value / 10)
        }
        File__write_char(self, (value % 10).as(char) + '0')
    }
}

func File__write_u64(self: File*, value: u64) -> void {
    if (value >= 10.as(u64)) {
        File__write_u64(self, value / 10.as(u64))
    }
    File__write_char(self, (value % 10.as(u64)).as(char) + '0')
}

func File__write_string(self: File*, string: String*) -> void {
    let index = 0.as(usize)
    while (index < string.length) {
        File__write_char(self, string.data[index])
        index = index + 1.as(usize)
    }
}

func error(message: String*) -> void {
    File__write_cstring(stderr, "\e[0;91m")
    File__write_string(stderr, message)
    File__write_cstring(stderr, "\e[0m\n")
}

func warning(message: String*) -> void {
    File__write_cstring(stderr, "\e[0;93m")
    File__write_string(stderr, message)
    File__write_cstring(stderr, "\e[0m\n")
}

func TODO(message: char*) -> void {
    File__write_cstring(stderr, "\e[0;95mTODO: ")
    File__write_cstring(stderr, message)
    File__write_cstring(stderr, "\e[0m\n")
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Source
\ ---------------------------------------------------------------------------------------------------------------------

struct Source {
    content: String*
    path: char*
}

func Source__create(file: File*, file_path: char*) -> Source* {
    let file_content = String__create()

    while (true) {
        let ch = fgetc(file)
        if (ch == -1) {
            break
        }
        String__append_char(file_content, ch.as(char))
    }

    String__append_char(file_content, '\0') \ simplifies EOF detection

    let source = malloc(sizeof(Source)).as(Source*)
    source.content = file_content
    source.path = file_path

    return source
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Source Location
\ ---------------------------------------------------------------------------------------------------------------------

struct Source_Location {
    source: Source*
    line: u16
    column: u16
}

func Source_Location__create(source: Source*, line: u16, column: u16) -> Source_Location* {
    let source_location = malloc(sizeof(Source_Location)).as(Source_Location*)
    source_location.source = source
    source_location.line = line
    source_location.column = column
    return source_location
}

func String__append_source_location(self: String*, location: Source_Location*) -> String* {
    String__append_cstring(self, location.source.path)
    String__append_char(self, ':')
    String__append_i16(self, location.line.as(i16))
    String__append_char(self, ':')
    String__append_i16(self, location.column.as(i16))
    return self
}

func File__write_source_location(self: File*, location: Source_Location*) -> void {
    if (location != null) {
        File__write_cstring(self, location.source.path)
        File__write_char(self, ':')
        File__write_i32(self, location.line.as(i32))
        File__write_char(self, ':')
        File__write_i32(self, location.column.as(i32))
        File__write_cstring(self, ": ")
    }
}

func Source_Location__error(self: Source_Location*, message: String*) -> void {
    File__write_source_location(stderr, self)
    error(message)
}

func Source_Location__warning(self: Source_Location*, message: String*) -> void {
    File__write_source_location(stderr, self)
    warning(message)
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Tokens
\ ---------------------------------------------------------------------------------------------------------------------

enum Token_Kind {
    CHARACTER
    COMMENT
    END_OF_FILE
    END_OF_LINE
    ERROR
    IDENTIFIER
    INTEGER
    KEYWORD
    OTHER
    SPACE
    STRING
}

struct Token {
    kind: Token_Kind
    location: Source_Location*
    lexeme: String*
    next_token: Token*
}

func Token__create_kind(kind: Token_Kind, kind_size: usize, location: Source_Location*, lexeme: String*) -> Token* {
    let token = malloc(kind_size).as(Token*)
    token.kind = kind
    token.location = location
    token.lexeme = lexeme
    token.next_token = null
    return token
}

func Token__error(self: Token*, message: String*) -> void {
    Source_Location__error(self.location, message)
}

func Token__warning(self: Token*, message: String*) -> void {
    Source_Location__warning(self.location, message)
}

struct Character_Token {
    super: Token
    value: char
}

func Character_Token__create(location: Source_Location*, lexeme: String*, value: char) -> Character_Token* {
    let token = Token__create_kind(Token_Kind.CHARACTER, sizeof(Character_Token), location, lexeme).as(Character_Token*)
    token.value = value
    return token
}

struct Comment_Token {
    super: Token
}

func Comment_Token__create(location: Source_Location*, lexeme: String*) -> Comment_Token* {
    return Token__create_kind(Token_Kind.COMMENT, sizeof(Comment_Token), location, lexeme).as(Comment_Token*)
}

struct End_Of_File_Token {
    super: Token
}

func End_Of_File_Token__create(location: Source_Location*, lexeme: String*) -> End_Of_File_Token* {
    return Token__create_kind(Token_Kind.END_OF_FILE, sizeof(End_Of_File_Token), location, lexeme).as(End_Of_File_Token*)
}

struct End_Of_Line_Token {
    super: Token
}

func End_Of_Line_Token__create(location: Source_Location*, lexeme: String*) -> End_Of_Line_Token* {
    return Token__create_kind(Token_Kind.END_OF_LINE, sizeof(End_Of_Line_Token), location, lexeme).as(End_Of_Line_Token*)
}

struct Error_Token {
    super: Token
}

func Error_Token__create(location: Source_Location*, lexeme: String*) -> Error_Token* {
    return Token__create_kind(Token_Kind.ERROR, sizeof(Error_Token), location, lexeme).as(Error_Token*)
}

struct Identifier_Token {
    super: Token
}

func Identifier_Token__create(location: Source_Location*, lexeme: String*) -> Identifier_Token* {
    return Token__create_kind(Token_Kind.IDENTIFIER, sizeof(Identifier_Token), location, lexeme).as(Identifier_Token*)
}

struct Integer_Token {
    super: Token
    value: u64
}

func Integer_Token__create(location: Source_Location*, lexeme: String*, value: u64) -> Integer_Token* {
    let token = Token__create_kind(Token_Kind.INTEGER, sizeof(Integer_Token), location, lexeme).as(Integer_Token*)
    token.value = value
    return token
}

struct Other_Token {
    super: Token
}

func Other_Token__create(location: Source_Location*, lexeme: String*) -> Other_Token* {
    return Token__create_kind(Token_Kind.OTHER, sizeof(Other_Token), location, lexeme).as(Other_Token*)
}

struct Space_Token {
    super: Token
    count: u16
}

func Space_Token__create(location: Source_Location*, lexeme: String*, count: u16) -> Space_Token* {
    let token = Token__create_kind(Token_Kind.SPACE, sizeof(Space_Token), location, lexeme).as(Space_Token*)
    token.count = count
    return token
}

struct String_Token {
    super: Token
    value: String*
}

func String_Token__create(location: Source_Location*, lexeme: String*, value: String*) -> String_Token* {
    let token = Token__create_kind(Token_Kind.STRING, sizeof(String_Token), location, lexeme).as(String_Token*)
    token.value = value
    return token
}

func Token__is_anything(self: Token*) -> bool {
    return self != null
}

func Token__is_character(self: Token*) -> bool {
    return self.kind == Token_Kind.CHARACTER
}

func Token__is_comment(self: Token*) -> bool {
    return self.kind == Token_Kind.COMMENT
}

func Token__is_end_of_file(self: Token*) -> bool {
    return self.kind == Token_Kind.END_OF_FILE
}

func Token__is_end_of_line(self: Token*) -> bool {
    return self.kind == Token_Kind.END_OF_LINE || self.kind == Token_Kind.END_OF_FILE
}

func Token__is_identifier(self: Token*) -> bool {
    return self.kind == Token_Kind.IDENTIFIER
}

func Token__is_integer(self: Token*) -> bool {
    return self.kind == Token_Kind.INTEGER
}

func Token__is_keyword(self: Token*, lexeme: char*) -> bool {
    return self.kind == Token_Kind.IDENTIFIER && String__equals_cstring(self.lexeme, lexeme)
}

func Token__is_break(self: Token*) -> bool {
    return Token__is_keyword(self, "break")
}

func Token__is_else(self: Token*) -> bool {
    return Token__is_keyword(self, "else")
}

func Token__is_enum(self: Token*) -> bool {
    return Token__is_keyword(self, "enum")
}

func Token__is_external(self: Token*) -> bool {
    return Token__is_keyword(self, "external")
}

func Token__is_false(self: Token*) -> bool {
    return Token__is_keyword(self, "false")
}

func Token__is_func(self: Token*) -> bool {
    return Token__is_keyword(self, "func")
}

func Token__is_if(self: Token*) -> bool {
    return Token__is_keyword(self, "if")
}

func Token__is_let(self: Token*) -> bool {
    return Token__is_keyword(self, "let")
}

func Token__is_null(self: Token*) -> bool {
    return Token__is_keyword(self, "null")
}

func Token__is_return(self: Token*) -> bool {
    return Token__is_keyword(self, "return")
}

func Token__is_sizeof(self: Token*) -> bool {
    return Token__is_keyword(self, "sizeof")
}

func Token__is_struct(self: Token*) -> bool {
    return Token__is_keyword(self, "struct")
}

func Token__is_true(self: Token*) -> bool {
    return Token__is_keyword(self, "true")
}

func Token__is_type(self: Token*) -> bool {
    return Token__is_keyword(self, "type")
}

func Token__is_undefined(self: Token*) -> bool {
    return Token__is_keyword(self, "undefined")
}

func Token__is_while(self: Token*) -> bool {
    return Token__is_keyword(self, "while")
}

func Token__is_other(self: Token*, lexeme: char*) -> bool {
    return self.kind == Token_Kind.OTHER && String__equals_cstring(self.lexeme, lexeme)
}

func Token__is_ampersand(self: Token*) -> bool {
    return Token__is_other(self, "&")
}

func Token__is_asterisk(self: Token*) -> bool {
    return Token__is_other(self, "*")
}

func Token__is_closing_brace(self: Token*) -> bool {
    return Token__is_other(self, "}")
}

func Token__is_closing_bracket(self: Token*) -> bool {
    return Token__is_other(self, "]")
}

func Token__is_closing_paren(self: Token*) -> bool {
    return Token__is_other(self, ")")
}

func Token__is_colon(self: Token*) -> bool {
    return Token__is_other(self, ":")
}

func Token__is_comma(self: Token*) -> bool {
    return Token__is_other(self, ",")
}

func Token__is_dot(self: Token*) -> bool {
    return Token__is_other(self, ".")
}

func Token__is_equals(self: Token*) -> bool {
    return Token__is_other(self, "=")
}

func Token__is_exclamation_mark(self: Token*) -> bool {
    return Token__is_other(self, "!")
}

func Token__is_greater_than(self: Token*) -> bool {
    return Token__is_other(self, ">")
}

func Token__is_less_than(self: Token*) -> bool {
    return Token__is_other(self, "<")
}

func Token__is_minus(self: Token*) -> bool {
    return Token__is_other(self, "-")
}

func Token__is_opening_brace(self: Token*) -> bool {
    return Token__is_other(self, "{")
}

func Token__is_opening_bracket(self: Token*) -> bool {
    return Token__is_other(self, "[")
}

func Token__is_opening_paren(self: Token*) -> bool {
    return Token__is_other(self, "(")
}

func Token__is_percent(self: Token*) -> bool {
    return Token__is_other(self, "%")
}

func Token__is_plus(self: Token*) -> bool {
    return Token__is_other(self, "+")
}

func Token__is_slash(self: Token*) -> bool {
    return Token__is_other(self, "/")
}

func Token__is_vertical_bar(self: Token*) -> bool {
    return Token__is_other(self, "|")
}

func Token__is_space(self: Token*) -> bool {
    return self.kind == Token_Kind.SPACE
}

func Token__is_string(self: Token*) -> bool {
    return self.kind == Token_Kind.STRING
}

func File__write_token(stream: File*, token: Token*) -> void {
    let colored = token.kind == Token_Kind.COMMENT || token.kind == Token_Kind.ERROR || token.kind == Token_Kind.OTHER
    if (colored) {
        if (token.kind == Token_Kind.OTHER) {
            File__write_cstring(stream, "\e[2;33m")
        } else if (token.kind == Token_Kind.COMMENT) {
            File__write_cstring(stream, "\e[2;37m")
        } else if (token.kind == Token_Kind.ERROR) {
            File__write_cstring(stream, "\e[2;31m")
        }
    }
    File__write_string(stream, token.lexeme)
    if (colored) {
        File__write_cstring(stream, "\e[0m")
    }
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Scanner
\ ---------------------------------------------------------------------------------------------------------------------

struct Scanner {
    source: Source*
    current_char_index: usize
    current_line: u16
    current_column: u16
    current_token: Token*
}

func Scanner__peek_char(self: Scanner*) -> char {
    return self.source.content.data[self.current_char_index]
}

func Scanner__next_char(self: Scanner*) -> char {
    let next_char = Scanner__peek_char(self)
    if (next_char != '\0') {
        self.current_char_index = self.current_char_index + 1.as(usize)
        if (next_char == '\n') {
            self.current_line = self.current_line + 1.as(u16)
            self.current_column = 1.as(u16)
        } else {
            self.current_column = self.current_column + 1.as(u16)
        }
    }
    return next_char
}

func escape_char_value(c: char) -> char {
    if (c == 'n') {
        return '\n'
    }
    if (c == '"') {
        return '\"'
    }
    if (c == '\'') {
        return '\''
    }
    if (c == '\\') {
        return '\\'
    }
    if (c == 't') {
        return '\t'
    }
    if (c == '0') {
        return '\0'
    }
    if (c == 'e') {
        return '\e'
    }
    return -1.as(char)
}

func char_is_end_of_line(c: char) -> bool {
    return c == '\n' || c == '\0'
}

func Scanner__scan_character_token(self: Scanner*, source_location: Source_Location*, token_lexeme: String*) -> Token* {
    if (Scanner__next_char(self) != '\'') {
        Source_Location__error(source_location, String__create_from("Unexpected char"))
        abort()
    }
    String__append_char(token_lexeme, '\'')

    let next_char = Scanner__peek_char(self)
    if (char_is_end_of_line(next_char) || next_char == '\t') {
        return Error_Token__create(source_location, token_lexeme).as(Token*)
    }

    String__append_char(token_lexeme, Scanner__next_char(self))
    let value = next_char

    if (value == '\'') {
        return Error_Token__create(source_location, token_lexeme).as(Token*)
    }

    if (value == '\\') {
        next_char = Scanner__peek_char(self)
        if (char_is_end_of_line(next_char) || next_char == '\t') {
            return Error_Token__create(source_location, token_lexeme).as(Token*)
        }

        String__append_char(token_lexeme, Scanner__next_char(self))

        value = escape_char_value(next_char)
        if (value == -1.as(char)) {
            return Error_Token__create(source_location, token_lexeme).as(Token*)
        }
    }

    if (Scanner__peek_char(self) != '\'') {
        return Error_Token__create(source_location, token_lexeme).as(Token*)
    }

    String__append_char(token_lexeme, Scanner__next_char(self))
    return Character_Token__create(source_location, token_lexeme, value).as(Token*)
}

func Scanner__scan_comment_token(self: Scanner*, source_location: Source_Location*, token_lexeme: String*) -> Token* {
    while (!char_is_end_of_line(Scanner__peek_char(self))) {
        String__append_char(token_lexeme, Scanner__next_char(self))
    }
    return Comment_Token__create(source_location, token_lexeme).as(Token*)
}

func char_is_identifier_start(c: char) -> bool {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_'
}

func char_is_identifier_letter(c: char) -> bool {
    return char_is_identifier_start(c) || (c >= '0' && c <= '9')
}

func Scanner__scan_identifier_token(self: Scanner*, source_location: Source_Location*, token_lexeme: String*) -> Token* {
    while (char_is_identifier_letter(Scanner__peek_char(self))) {
        String__append_char(token_lexeme, Scanner__next_char(self))
    }
    return Identifier_Token__create(source_location, token_lexeme).as(Token*)
}

func char_is_digit(c: char) -> bool {
    return c >= '0' && c <= '9'
}

func Scanner__scan_integer_token(self: Scanner*, source_location: Source_Location*, token_lexeme: String*) -> Token* {
    let value = 0.as(u64)
    while (char_is_digit(Scanner__peek_char(self))) {
        let c = Scanner__next_char(self)
        value = value * 10.as(u64) + (c - '0').as(u64)
        String__append_char(token_lexeme, c)
    }
    return Integer_Token__create(source_location, token_lexeme, value).as(Token*)
}

func char_is_space(c: char) -> bool {
    return c == ' '
}

func Scanner__scan_space_token(self: Scanner*, source_location: Source_Location*, token_lexeme: String*) -> Token* {
    let count = 0.as(u16)
    while (char_is_space(Scanner__peek_char(self))) {
        count = count + 1.as(u16)
        String__append_char(token_lexeme, Scanner__next_char(self))
    }
    return Space_Token__create(source_location, token_lexeme, count).as(Token*)
}

func Scanner__scan_string_token(self: Scanner*, source_location: Source_Location*, token_lexeme: String*) -> Token* {
    if (Scanner__next_char(self) != '"') {
        Source_Location__error(source_location, String__create_from("Unexpected char"))
        abort()
    }
    String__append_char(token_lexeme, '"')

    let value = String__create()

    while (true) {
        let next_char = Scanner__peek_char(self)
        if (char_is_end_of_line(next_char) || next_char == '\t') {
            return Error_Token__create(source_location, token_lexeme).as(Token*)
        }

        String__append_char(token_lexeme, Scanner__next_char(self))

        if (next_char == '"') {
            return String_Token__create(source_location, token_lexeme, value).as(Token*)
        }

        if (next_char == '\\') {
            next_char = Scanner__peek_char(self)
            if (char_is_end_of_line(next_char) || next_char == '\t') {
                return Error_Token__create(source_location, token_lexeme).as(Token*)
            }

            String__append_char(token_lexeme, Scanner__next_char(self))

            next_char = escape_char_value(next_char)
            if (next_char == -1.as(char)) {
                return Error_Token__create(source_location, token_lexeme).as(Token*)
            }
        }

        String__append_char(value, next_char)
    }
}

func Scanner__scan_token(self: Scanner*) -> Token* {
    let source_location = Source_Location__create(self.source, self.current_line, self.current_column)
    let token_lexeme = String__create()

    let next_char = Scanner__peek_char(self)

    if (char_is_identifier_start(next_char)) {
        return Scanner__scan_identifier_token(self, source_location, token_lexeme)
    }

    if (char_is_digit(next_char)) {
        return Scanner__scan_integer_token(self, source_location, token_lexeme)
    }

    if (char_is_space(next_char)) {
        return Scanner__scan_space_token(self, source_location, token_lexeme)
    }

    if (next_char == '\'') {
        return Scanner__scan_character_token(self, source_location, token_lexeme)
    }

    if (next_char == '\"') {
        return Scanner__scan_string_token(self, source_location, token_lexeme)
    }

    if (next_char == '\\') {
        return Scanner__scan_comment_token(self, source_location, token_lexeme)
    }

    if (next_char == '\n') {
        String__append_char(token_lexeme, Scanner__next_char(self))
        return End_Of_Line_Token__create(source_location, token_lexeme).as(Token*)
    }

    if (next_char == '\0') {
        return End_Of_File_Token__create(source_location, token_lexeme).as(Token*)
    }

    String__append_char(token_lexeme, Scanner__next_char(self))
    return Other_Token__create(source_location, token_lexeme).as(Token*)
}

func Scanner__next_token(self: Scanner*) -> Token* {
    if (self.current_token.next_token == null) {
        self.current_token.next_token = Scanner__scan_token(self)
    }
    self.current_token = self.current_token.next_token
    return self.current_token
}

func Scanner__peek_token(self: Scanner*, offset: u8) -> Token* {
    let token = self.current_token
    while (offset > 0.as(u8)) {
        if (token.next_token == null) {
            token.next_token = Scanner__scan_token(self)
        }
        token = token.next_token
        offset = offset - 1.as(u8)
    }
    return token
}

func Scanner__create(source: Source*) -> Scanner* {
    let scanner = malloc(sizeof(Scanner)).as(Scanner*)
    scanner.source = source
    scanner.current_char_index = 0.as(usize)
    scanner.current_line = 1.as(u16)
    scanner.current_column = 1.as(u16)

    scanner.current_token = Scanner__scan_token(scanner)

    return scanner
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Parsed Source
\ ---------------------------------------------------------------------------------------------------------------------

struct Parsed_Source {
    statements: Parsed_Statements*
}

enum Parsed_Type_Kind {
    FUNCTION
    NAMED
    POINTER
    STRUCT
}

struct Parsed_Type {
    kind: Parsed_Type_Kind
    location: Source_Location*
}

func Parsed_Type__create_kind(kind: Parsed_Type_Kind, kind_size: usize, location: Source_Location*) -> Parsed_Type* {
    let type = malloc(kind_size).as(Parsed_Type*)
    type.kind = kind
    type.location = location
    return type
}

struct Parsed_Function_Parameter {
    location: Source_Location*
    name: String*
    type: Parsed_Type*
    next_parameter: Parsed_Function_Parameter*
}

func Parsed_Function_Parameter__create(location: Source_Location*, name: String*, type: Parsed_Type*) -> Parsed_Function_Parameter* {
    let parameter = malloc(sizeof(Parsed_Function_Parameter)).as(Parsed_Function_Parameter*)
    parameter.location = location
    parameter.name = name
    parameter.type = type
    parameter.next_parameter = null
    return parameter
}

struct Parsed_Function_Type {
    super: Parsed_Type
    first_parameter: Parsed_Function_Parameter*
    return_type: Parsed_Type*
}

func Parsed_Function_Type__create(location: Source_Location*, first_parameter: Parsed_Function_Parameter*, return_type: Parsed_Type*) -> Parsed_Function_Type* {
    let type = Parsed_Type__create_kind(Parsed_Type_Kind.FUNCTION, sizeof(Parsed_Function_Type), location).as(Parsed_Function_Type*)
    type.first_parameter = first_parameter
    type.return_type = return_type
    return type
}

struct Parsed_Named_Type {
    super: Parsed_Type
    name: String*
}

func Parsed_Named_Type__create(name: Token*) -> Parsed_Named_Type* {
    let type = Parsed_Type__create_kind(Parsed_Type_Kind.NAMED, sizeof(Parsed_Named_Type), name.location).as(Parsed_Named_Type*)
    type.name = name.lexeme
    return type
}

struct Parsed_Pointer_Type {
    super: Parsed_Type
    other_type: Parsed_Type*
}

func Parsed_Pointer_Type__create(other_type: Parsed_Type*) -> Parsed_Pointer_Type* {
    let type = Parsed_Type__create_kind(Parsed_Type_Kind.POINTER, sizeof(Parsed_Pointer_Type), other_type.location).as(Parsed_Pointer_Type*)
    type.other_type = other_type
    return type
}

struct Parsed_Struct_Type {
    super: Parsed_Type
    other_type: Parsed_Type*
}

func Parsed_Struct_Type__create(location: Source_Location*, other_type: Parsed_Type*) -> Parsed_Struct_Type* {
    let type = Parsed_Type__create_kind(Parsed_Type_Kind.STRUCT, sizeof(Parsed_Struct_Type), location).as(Parsed_Struct_Type*)
    type.other_type = other_type
    return type
}

enum Parsed_Expression_Kind {
    ADD
    ADDRESS_OF
    ARRAY_ACCESS
    BOOL
    CALL
    CAST
    CHARACTER
    DEREFERENCE
    DIVIDE
    EQUALS
    GREATER
    GREATER_OR_EQUALS
    GROUP
    INTEGER
    LESS
    LESS_OR_EQUALS
    LOGIC_AND
    LOGIC_OR
    MEMBER_ACCESS
    MINUS
    MODULO
    MULTIPLY
    NOT
    NOT_EQUALS
    NULL
    SIZEOF
    STRING
    SUBSTRACT
    SYMBOL
}

struct Parsed_Expression {
    kind: Parsed_Expression_Kind
    location: Source_Location*
}

func Parsed_Expression__create_kind(kind: Parsed_Expression_Kind, kind_size: usize, location: Source_Location*) -> Parsed_Expression* {
    let expression = malloc(kind_size).as(Parsed_Expression*)
    expression.kind = kind
    expression.location = location
    return expression
}

struct Parsed_Binary_Expression {
    super: Parsed_Expression
    left_expression: Parsed_Expression*
    right_expression: Parsed_Expression*
}

func Parsed_Binary_Expression__create_kind(kind: Parsed_Expression_Kind, left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Binary_Expression* {
    let expression = Parsed_Expression__create_kind(kind, sizeof(Parsed_Binary_Expression), left_expression.location).as(Parsed_Binary_Expression*)
    expression.left_expression = left_expression
    expression.right_expression = right_expression
    return expression
}

struct Parsed_Unary_Expression {
    super: Parsed_Expression
    other_expression: Parsed_Expression*
}

func Parsed_Unary_Expression__create_kind(kind: Parsed_Expression_Kind, kind_size: usize, location: Source_Location*, other_expression: Parsed_Expression*) -> Parsed_Unary_Expression* {
    let expression = Parsed_Expression__create_kind(kind, kind_size, location).as(Parsed_Unary_Expression*)
    expression.other_expression = other_expression
    return expression
}

struct Parsed_Literal_Expression {
    super: Parsed_Expression
    literal: Token*
}

func Parsed_Literal_Expression__create_kind(kind: Parsed_Expression_Kind, kind_size: usize, literal: Token*) -> Parsed_Literal_Expression* {
    let expression = Parsed_Expression__create_kind(kind, kind_size, literal.location).as(Parsed_Literal_Expression*)
    expression.literal = literal
    return expression
}

struct Parsed_Add_Expression {
    super: Parsed_Binary_Expression
}

func Parsed_Add_Expression__create(left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Add_Expression* {
    return Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.ADD, left_expression, right_expression).as(Parsed_Add_Expression*)
}

struct Parsed_Address_Of_Expression {
    super: Parsed_Unary_Expression
}

func Parsed_Address_Of_Expression__create(location: Source_Location*, other_expression: Parsed_Expression*) -> Parsed_Address_Of_Expression* {
    return Parsed_Unary_Expression__create_kind(Parsed_Expression_Kind.ADDRESS_OF, sizeof(Parsed_Address_Of_Expression), location, other_expression).as(Parsed_Address_Of_Expression*)
}

struct Parsed_Array_Access_Expression {
    super: Parsed_Expression
    array_expression: Parsed_Expression*
    index_expression: Parsed_Expression*
}

func Parsed_Array_Access_Expression__create(array_expression: Parsed_Expression*, index_expression: Parsed_Expression*) -> Parsed_Array_Access_Expression* {
    let expression = Parsed_Expression__create_kind(Parsed_Expression_Kind.ARRAY_ACCESS, sizeof(Parsed_Array_Access_Expression), array_expression.location).as(Parsed_Array_Access_Expression*)
    expression.array_expression = array_expression
    expression.index_expression = index_expression
    return expression
}

struct Parsed_Bool_Expression {
    super: Parsed_Literal_Expression
    value: bool
}

func Parsed_Bool_Expression__create(literal: Token*, value: bool) -> Parsed_Bool_Expression* {
    let expression = Parsed_Literal_Expression__create_kind(Parsed_Expression_Kind.BOOL, sizeof(Parsed_Bool_Expression), literal).as(Parsed_Bool_Expression*)
    expression.value = value
    return expression
}

struct Parsed_Call_Argument {
    expression: Parsed_Expression*
    next_argument: Parsed_Call_Argument*
}

func Parsed_Call_Argument__create(expression: Parsed_Expression*) -> Parsed_Call_Argument* {
    let argument = malloc(sizeof(Parsed_Call_Argument)).as(Parsed_Call_Argument*)
    argument.expression = expression
    argument.next_argument = null
    return argument
}

struct Parsed_Call_Expression {
    super: Parsed_Expression
    callee_expression: Parsed_Expression*
    first_argument: Parsed_Call_Argument*
}

func Parsed_Call_Expression__create(callee_expression: Parsed_Expression*) -> Parsed_Call_Expression* {
    let expression = Parsed_Expression__create_kind(Parsed_Expression_Kind.CALL, sizeof(Parsed_Call_Expression), callee_expression.location).as(Parsed_Call_Expression*)
    expression.callee_expression = callee_expression
    expression.first_argument = null
    return expression
}

struct Parsed_Cast_Expression {
    super: Parsed_Unary_Expression
    type: Parsed_Type*
}

func Parsed_Cast_Expression__create(location: Source_Location*, other_expression: Parsed_Expression*, type: Parsed_Type*) -> Parsed_Cast_Expression* {
    let expression = Parsed_Unary_Expression__create_kind(Parsed_Expression_Kind.CAST, sizeof(Parsed_Cast_Expression), location, other_expression).as(Parsed_Cast_Expression*)
    expression.type = type
    return expression
}

struct Parsed_Character_Expression {
    super: Parsed_Literal_Expression
    value: char
}

func Parsed_Character_Expression__create(literal: Character_Token*) -> Parsed_Character_Expression* {
    let expression = Parsed_Literal_Expression__create_kind(Parsed_Expression_Kind.CHARACTER, sizeof(Parsed_Character_Expression), literal.as(Token*)).as(Parsed_Character_Expression*)
    expression.value = literal.value
    return expression
}

struct Parsed_Dereference_Expression {
    super: Parsed_Expression
    value_expression: Parsed_Expression*
}

func Parsed_Dereference_Expression__create(value_expression: Parsed_Expression*) -> Parsed_Dereference_Expression* {
    let expression = Parsed_Expression__create_kind(Parsed_Expression_Kind.DEREFERENCE, sizeof(Parsed_Dereference_Expression), value_expression.location).as(Parsed_Dereference_Expression*)
    expression.value_expression = value_expression
    return expression
}

struct Parsed_Divide_Expression {
    super: Parsed_Binary_Expression
}

func Parsed_Divide_Expression__create(left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Divide_Expression* {
    return Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.DIVIDE, left_expression, right_expression).as(Parsed_Divide_Expression*)
}

struct Parsed_Equals_Expression {
    super: Parsed_Binary_Expression
}

func Parsed_Equals_Expression__create(left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Equals_Expression* {
    return Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.EQUALS, left_expression, right_expression).as(Parsed_Equals_Expression*)
}

struct Parsed_Greater_Expression {
    super: Parsed_Binary_Expression
}

func Parsed_Greater_Expression__create(left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Greater_Expression* {
    return Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.GREATER, left_expression, right_expression).as(Parsed_Greater_Expression*)
}

struct Parsed_Greater_Or_Equals_Expression {
    super: Parsed_Binary_Expression
}

func Parsed_Greater_Or_Equals_Expression__create(left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Greater_Or_Equals_Expression* {
    return Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.GREATER_OR_EQUALS, left_expression, right_expression).as(Parsed_Greater_Or_Equals_Expression*)
}

struct Parsed_Group_Expression {
    super: Parsed_Expression
    other_expression: Parsed_Expression*
}

func Parsed_Group_Expression__create(location: Source_Location*, other_expression: Parsed_Expression*) -> Parsed_Group_Expression* {
    let expression = Parsed_Expression__create_kind(Parsed_Expression_Kind.GROUP, sizeof(Parsed_Group_Expression), location).as(Parsed_Group_Expression*)
    expression.other_expression = other_expression
    return expression
}

struct Parsed_Integer_Expression {
    super: Parsed_Literal_Expression
    value: u64
}

func Parsed_Integer_Expression__create(literal: Integer_Token*) -> Parsed_Integer_Expression* {
    let expression = Parsed_Literal_Expression__create_kind(Parsed_Expression_Kind.INTEGER, sizeof(Parsed_Integer_Expression), literal.as(Token*)).as(Parsed_Integer_Expression*)
    expression.value = literal.value
    return expression
}

struct Parsed_Less_Expression {
    super: Parsed_Binary_Expression
}

func Parsed_Less_Expression__create(left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Less_Expression* {
    return Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.LESS, left_expression, right_expression).as(Parsed_Less_Expression*)
}

struct Parsed_Less_Or_Equals_Expression {
    super: Parsed_Binary_Expression
}

func Parsed_Less_Or_Equals_Expression__create(left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Less_Or_Equals_Expression* {
    return Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.LESS_OR_EQUALS, left_expression, right_expression).as(Parsed_Less_Or_Equals_Expression*)
}

struct Parsed_Logic_And_Expression {
    super: Parsed_Binary_Expression
}

func Parsed_Logic_And_Expression__create(left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Logic_And_Expression* {
    return Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.LOGIC_AND, left_expression, right_expression).as(Parsed_Logic_And_Expression*)
}

struct Parsed_Logic_Or_Expression {
    super: Parsed_Binary_Expression
}

func Parsed_Logic_Or_Expression__create(left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Logic_Or_Expression* {
    return Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.LOGIC_OR, left_expression, right_expression).as(Parsed_Logic_Or_Expression*)
}

struct Parsed_Member_Access_Expression {
    super: Parsed_Expression
    object_expression: Parsed_Expression*
    member_name: Token*
}

func Parsed_Member_Access_Expression__create(object_expression: Parsed_Expression*, member_name: Token*) -> Parsed_Member_Access_Expression* {
    let expression = Parsed_Expression__create_kind(Parsed_Expression_Kind.MEMBER_ACCESS, sizeof(Parsed_Member_Access_Expression), object_expression.location).as(Parsed_Member_Access_Expression*)
    expression.object_expression = object_expression
    expression.member_name = member_name
    return expression
}

struct Parsed_Minus_Expression {
    super: Parsed_Unary_Expression
}

func Parsed_Minus_Expression__create(location: Source_Location*, other_expression: Parsed_Expression*) -> Parsed_Minus_Expression* {
    return Parsed_Unary_Expression__create_kind(Parsed_Expression_Kind.MINUS, sizeof(Parsed_Minus_Expression), location, other_expression).as(Parsed_Minus_Expression*)
}

struct Parsed_Modulo_Expression {
    super: Parsed_Binary_Expression
}

func Parsed_Modulo_Expression__create(left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Modulo_Expression* {
    return Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.MODULO, left_expression, right_expression).as(Parsed_Modulo_Expression*)
}

struct Parsed_Multiply_Expression {
    super: Parsed_Binary_Expression
}

func Parsed_Multiply_Expression__create(left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Multiply_Expression* {
    return Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.MULTIPLY, left_expression, right_expression).as(Parsed_Multiply_Expression*)
}

struct Parsed_Not_Expression {
    super: Parsed_Unary_Expression
}

func Parsed_Not_Expression__create(location: Source_Location*, other_expression: Parsed_Expression*) -> Parsed_Not_Expression* {
    return Parsed_Unary_Expression__create_kind(Parsed_Expression_Kind.NOT, sizeof(Parsed_Not_Expression), location, other_expression).as(Parsed_Not_Expression*)
}

struct Parsed_Not_Equals_Expression {
    super: Parsed_Binary_Expression
}

func Parsed_Not_Equals_Expression__create(left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Not_Equals_Expression* {
    return Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.NOT_EQUALS, left_expression, right_expression).as(Parsed_Not_Equals_Expression*)
}

struct Parsed_Null_Expression {
    super: Parsed_Literal_Expression
}

func Parsed_Null_Expression__create(literal: Token*) -> Parsed_Null_Expression* {
    return Parsed_Literal_Expression__create_kind(Parsed_Expression_Kind.NULL, sizeof(Parsed_Null_Expression), literal).as(Parsed_Null_Expression*)
}

struct Parsed_Sizeof_Expression {
    super: Parsed_Expression
    type: Parsed_Type*
}

func Parsed_Sizeof_Expression__create(location: Source_Location*, type: Parsed_Type*) -> Parsed_Sizeof_Expression* {
    let expression = Parsed_Expression__create_kind(Parsed_Expression_Kind.SIZEOF, sizeof(Parsed_Sizeof_Expression), location).as(Parsed_Sizeof_Expression*)
    expression.type = type
    return expression
}

struct Parsed_String_Expression {
    super: Parsed_Literal_Expression
    value: String*
}

func Parsed_String_Expression__create(literal: String_Token*) -> Parsed_String_Expression* {
    let expression = Parsed_Literal_Expression__create_kind(Parsed_Expression_Kind.STRING, sizeof(Parsed_String_Expression), literal.as(Token*)).as(Parsed_String_Expression*)
    expression.value = literal.value
    return expression
}

struct Parsed_Substract_Expression {
    super: Parsed_Binary_Expression
}

func Parsed_Substract_Expression__create(left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Substract_Expression* {
    return Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.SUBSTRACT, left_expression, right_expression).as(Parsed_Substract_Expression*)
}

struct Parsed_Symbol_Expression {
    super: Parsed_Expression
    name: Token*
}

func Parsed_Symbol_Expression__create(name: Token*) -> Parsed_Symbol_Expression* {
    let expression = Parsed_Expression__create_kind(Parsed_Expression_Kind.SYMBOL, sizeof(Parsed_Symbol_Expression), name.location).as(Parsed_Symbol_Expression*)
    expression.name = name
    return expression
}

enum Parsed_Statement_Kind {
    ASSIGNMENT
    BLOCK
    BREAK
    ENUM
    EXPRESSION
    FUNCTION
    IF
    OPAQUE_TYPE
    RETURN
    STRUCT
    VARIABLE
    WHILE
}

struct Parsed_Statement {
    kind: Parsed_Statement_Kind
    location: Source_Location*
    next_statement: Parsed_Statement*
}

func Parsed_Statement__create_kind(kind: Parsed_Statement_Kind, kind_size: usize, location: Source_Location*) -> Parsed_Statement* {
    let statement = malloc(kind_size).as(Parsed_Statement*)
    statement.kind = kind
    statement.location = location
    statement.next_statement = null
    return statement
}

struct Parsed_Named_Statement {
    super: Parsed_Statement
    name: Token*
}

func Parsed_Named_Statement__create_kind(kind: Parsed_Statement_Kind, kind_size: usize, location: Source_Location*, name: Token*) -> Parsed_Named_Statement* {
    let statement = Parsed_Statement__create_kind(kind, kind_size, location).as(Parsed_Named_Statement*)
    statement.name = name
    return statement
}

struct Parsed_Assignment_Statement {
    super: Parsed_Statement
    object_expression: Parsed_Expression*
    value_expression: Parsed_Expression*
}

func Parsed_Assignment_Statement__create(object_expression: Parsed_Expression*, value_expression: Parsed_Expression*) -> Parsed_Assignment_Statement* {
    let statement = Parsed_Statement__create_kind(Parsed_Statement_Kind.ASSIGNMENT, sizeof(Parsed_Assignment_Statement), object_expression.location).as(Parsed_Assignment_Statement*)
    statement.object_expression = object_expression
    statement.value_expression = value_expression
    return statement
}

struct Parsed_Block_Statement {
    super: Parsed_Statement
    statements: Parsed_Statements*
}

func Parsed_Block_Statement__create(location: Source_Location*, statements: Parsed_Statements*) -> Parsed_Block_Statement* {
    let statement = Parsed_Statement__create_kind(Parsed_Statement_Kind.BLOCK, sizeof(Parsed_Block_Statement), location).as(Parsed_Block_Statement*)
    statement.statements = statements
    return statement
}

struct Parsed_Break_Statement {
    super: Parsed_Statement
}

func Parsed_Break_Statement__create(location: Source_Location*) -> Parsed_Statement* {
    return Parsed_Statement__create_kind(Parsed_Statement_Kind.BREAK, sizeof(Parsed_Break_Statement), location)
}

struct Parsed_Enum_Member {
    name: Token*
    next_member: Parsed_Enum_Member*
}

func Parsed_Enum_Member__create(name: Token*) -> Parsed_Enum_Member* {
    let member = malloc(sizeof(Parsed_Enum_Member)).as(Parsed_Enum_Member*)
    member.name = name
    member.next_member = null
    return member
}

struct Parsed_Enum_Statement {
    super: Parsed_Named_Statement
    first_member: Parsed_Enum_Member*
}

func Parsed_Enum_Statement__create(location: Source_Location*, name: Token*) -> Parsed_Enum_Statement* {
    let statement = Parsed_Named_Statement__create_kind(Parsed_Statement_Kind.ENUM, sizeof(Parsed_Enum_Statement), location, name).as(Parsed_Enum_Statement*)
    statement.first_member = null
    return statement
}

struct Parsed_Expression_Statement {
    super: Parsed_Statement
    expression: Parsed_Expression*
}

func Parsed_Expression_Statement__create(expression: Parsed_Expression*) -> Parsed_Expression_Statement* {
    let statement = Parsed_Statement__create_kind(Parsed_Statement_Kind.EXPRESSION, sizeof(Parsed_Expression_Statement), expression.location).as(Parsed_Expression_Statement*)
    statement.expression = expression
    return statement
}

struct Parsed_Function_Statement {
    super: Parsed_Named_Statement
    first_parameter: Parsed_Function_Parameter*
    return_type: Parsed_Type*
    statements: Parsed_Statements*
    is_external: bool
}

func Parsed_Function_Statement__create(location: Source_Location*, name: Token*, first_parameter: Parsed_Function_Parameter*, resturn_type: Parsed_Type*, statements: Parsed_Statements*, is_external: bool) -> Parsed_Statement* {
    let statement = Parsed_Named_Statement__create_kind(Parsed_Statement_Kind.FUNCTION, sizeof(Parsed_Function_Statement), location, name).as(Parsed_Function_Statement*)
    statement.first_parameter = first_parameter
    statement.return_type = resturn_type
    statement.statements = statements
    statement.is_external = is_external
    return statement.as(Parsed_Statement*)
}

struct Parsed_If_Statement {
    super: Parsed_Statement
    condition_expression: Parsed_Expression*
    true_statement: Parsed_Statement*
    false_statement: Parsed_Statement*
}

func Parsed_If_Statement__create(location: Source_Location*, condition_expression: Parsed_Expression*, true_statement: Parsed_Statement*, false_statement: Parsed_Statement*) -> Parsed_Statement* {
    let statement = Parsed_Statement__create_kind(Parsed_Statement_Kind.IF, sizeof(Parsed_If_Statement), location).as(Parsed_If_Statement*)
    statement.condition_expression = condition_expression
    statement.true_statement = true_statement
    statement.false_statement = false_statement
    return statement.as(Parsed_Statement*)
}

struct Parsed_Opaque_Type_Statement {
    super: Parsed_Named_Statement
}

func Parsed_Opaque_Type_Statement__create(location: Source_Location*, name: Token*) -> Parsed_Opaque_Type_Statement* {
    return Parsed_Named_Statement__create_kind(Parsed_Statement_Kind.OPAQUE_TYPE, sizeof(Parsed_Opaque_Type_Statement), location, name).as(Parsed_Opaque_Type_Statement*)
}

struct Parsed_Return_Statement {
    super: Parsed_Statement
    expression: Parsed_Expression*
}

func Parsed_Return_Statement__create(location: Source_Location*, expression: Parsed_Expression*) -> Parsed_Statement* {
    let statement = Parsed_Statement__create_kind(Parsed_Statement_Kind.RETURN, sizeof(Parsed_Return_Statement), location).as(Parsed_Return_Statement*)
    statement.expression = expression
    return statement.as(Parsed_Statement*)
}

struct Parsed_Struct_Member {
    name: Token*
    type: Parsed_Type*
    next_member: Parsed_Struct_Member*
}

func Parsed_Struct_Member__create(name: Token*, type: Parsed_Type*) -> Parsed_Struct_Member* {
    let member = malloc(sizeof(Parsed_Struct_Member)).as(Parsed_Struct_Member*)
    member.name = name
    member.type = type
    member.next_member = null
    return member
}

struct Parsed_Struct_Statement {
    super: Parsed_Named_Statement
    first_member: Parsed_Struct_Member*
}

func Parsed_Struct_Statement__create(location: Source_Location*, name: Token*) -> Parsed_Struct_Statement* {
    let statement = Parsed_Named_Statement__create_kind(Parsed_Statement_Kind.STRUCT, sizeof(Parsed_Struct_Statement), location, name).as(Parsed_Struct_Statement*)
    statement.first_member = null
    return statement
}

struct Parsed_Variable_Statement {
    super: Parsed_Named_Statement
    type: Parsed_Type*
    expression: Parsed_Expression*
    is_external: bool
}

func Parsed_Variable_Statement__create(location: Source_Location*, name: Token*, type: Parsed_Type*, is_external: bool) -> Parsed_Variable_Statement* {
    let statement = Parsed_Named_Statement__create_kind(Parsed_Statement_Kind.VARIABLE, sizeof(Parsed_Variable_Statement), location, name).as(Parsed_Variable_Statement*)
    statement.type = type
    statement.is_external = is_external
    return statement
}

struct Parsed_While_Statement {
    super: Parsed_Statement
    condition_expression: Parsed_Expression*
    body_statement: Parsed_Statement*
}

func Parsed_While_Statement__create(location: Source_Location*, condition_expression: Parsed_Expression*, body_statement: Parsed_Statement*) -> Parsed_Statement* {
    let statement = Parsed_Statement__create_kind(Parsed_Statement_Kind.WHILE, sizeof(Parsed_While_Statement), location).as(Parsed_While_Statement*)
    statement.condition_expression = condition_expression
    statement.body_statement = body_statement
    return statement.as(Parsed_Statement*)
}

struct Parsed_Statements {
    first_statement: Parsed_Statement*
    last_statement: Parsed_Statement*
    has_globals: bool
}

func Parsed_Statements__create(has_globals: bool) -> Parsed_Statements* {
    let statements = malloc(sizeof(Parsed_Statements)).as(Parsed_Statements*)
    statements.first_statement = null
    statements.last_statement = null
    statements.has_globals = has_globals
    return statements
}

func Parsed_Statements__append(self: Parsed_Statements*, statement: Parsed_Statement*) -> void {
    if (self.first_statement == null) {
        self.first_statement = statement
    } else {
        self.last_statement.next_statement = statement
    }
    self.last_statement = statement
}

func Parsed_Compilation_Unit__create() -> Parsed_Source* {
    let compilation_unit = malloc(sizeof(Parsed_Source)).as(Parsed_Source*)
    compilation_unit.statements = Parsed_Statements__create(true)
    return compilation_unit
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Parser
\ ---------------------------------------------------------------------------------------------------------------------

struct Parser {
    scanner: Scanner*
    compilation_unit: Parsed_Source*
    current_identation: u16
}

func Parser__error(self: Parser*, message: String*) -> void {
    Token__error(self.scanner.current_token, message)
}

func Parser__warning(self: Parser*, message: String*) -> void {
    Token__warning(self.scanner.current_token, message)
}

func Parser__peek_token(self: Parser*, offset: u8) -> Token* {
    return Scanner__peek_token(self.scanner, offset)
}

func Parser__matches_three(self: Parser*, first_is: (func (Token*) -> bool), first_required: bool, second_is: (func (Token*) -> bool), second_required: bool, third_is: (func (Token*) -> bool)) -> bool {
    let peek_offset = 0.as(u8)
    if (first_is(Parser__peek_token(self, peek_offset))) {
        peek_offset = peek_offset + 1.as(u8)
    } else if (first_required) {
        return false
    }
    if (second_is != null) {
        if (second_is(Parser__peek_token(self, peek_offset))) {
            peek_offset = peek_offset + 1.as(u8)
        } else if (second_required) {
            return false
        }
    }
    if (third_is != null) {
        return third_is(Parser__peek_token(self, peek_offset))
    }
    return true
}

func Parser__matches_two(self: Parser*, first_is: (func (Token*) -> bool), first_required: bool, second_is: (func (Token*) -> bool)) -> bool {
    return Parser__matches_three(self, first_is, first_required, second_is, true, null)
}

func Parser__matches_one(self: Parser*, first_is: (func (Token*) -> bool)) -> bool {
    return Parser__matches_two(self, first_is, true, null)
}

func Parser__consume_token(self: Parser*, check: (func (Token*) -> bool)) -> Token* {
    if (Parser__matches_one(self, check)) {
        let token = self.scanner.current_token
        Scanner__next_token(self.scanner)
        return token
    }
    Parser__error(self, String__create_from("Unexpected token"))
    abort()
}

func Parser__consume_comment(self: Parser*) -> void {
    Parser__consume_token(self, Token__is_comment)
}

func Parser__consume_space(self: Parser*, count: u16) -> void {
    if (Parser__matches_one(self, Token__is_space)) {
        let token = Parser__consume_token(self, Token__is_space).as(Space_Token*)
        if (token.count != count) {
            let message = String__append_cstring(String__append_i16(String__append_cstring(String__append_i16(String__create_from("Consumed "), token.count.as(i16)), " spaces where "), count.as(i16)), " were expected")
            Token__warning(token.as(Token*), message)
            String__delete(message)
        }
    } else if (count > 0.as(u16)) {
        let message = String__append_cstring(String__append_i16(String__append_cstring(String__append_i16(String__create_from("Consumed "), 0.as(i16)), " spaces where "), count.as(i16)), " were expected")
        Parser__warning(self, message)
        String__delete(message)
    }
}

func Parser__consume_end_of_line(self: Parser*) -> void {
    if (Parser__matches_two(self, Token__is_space, false, Token__is_comment)) {
        Parser__consume_space(self, 1.as(u16))
        Parser__consume_comment(self)
    } else {
        Parser__consume_space(self, 0.as(u16))
    }
    let token = Parser__consume_token(self, Token__is_end_of_line)
    if (Token__is_end_of_file(token)) {
        Token__warning(token, String__create_from("Unexpected end of file"))
    }
}

func Parser__consume_empty_line(self: Parser*) -> bool {
    if (Parser__matches_one(self, Token__is_end_of_file)) {
        return false
    }
    if (Parser__matches_three(self, Token__is_space, false, Token__is_comment, false, Token__is_end_of_line)) {
        if (Parser__matches_two(self, Token__is_space, false, Token__is_comment)) {
            Parser__consume_space(self, self.current_identation * 4.as(u16))
            Parser__consume_comment(self)
        } else {
            Parser__consume_space(self, 0.as(u16))
        }
        Parser__consume_token(self, Token__is_end_of_line)
        return true
    }
    return false
}

\ primary_expression
\      | "false"
\      | "null"
\      | "true"
\      | CHARACTER
\      | IDENTIFIER
\      | INTEGER
\      | STRING
func Parser__parse_primary_expression(self: Parser*) -> Parsed_Expression* {
    if (Parser__matches_one(self, Token__is_true)) {
        return Parsed_Bool_Expression__create(Parser__consume_token(self, Token__is_true), true).as(Parsed_Expression*)
    }
    if (Parser__matches_one(self, Token__is_null)) {
        return Parsed_Null_Expression__create(Parser__consume_token(self, Token__is_null)).as(Parsed_Expression*)
    }
    if (Parser__matches_one(self, Token__is_false)) {
        return Parsed_Bool_Expression__create(Parser__consume_token(self, Token__is_false), false).as(Parsed_Expression*)
    }
    if (Parser__matches_one(self, Token__is_identifier)) {
        return Parsed_Symbol_Expression__create(Parser__consume_token(self, Token__is_identifier)).as(Parsed_Expression*)
    }
    if (Parser__matches_one(self, Token__is_integer)) {
        return Parsed_Integer_Expression__create(Parser__consume_token(self, Token__is_integer).as(Integer_Token*)).as(Parsed_Expression*)
    }
    if (Parser__matches_one(self, Token__is_character)) {
        return Parsed_Character_Expression__create(Parser__consume_token(self, Token__is_character).as(Character_Token*)).as(Parsed_Expression*)
    }
    if (Parser__matches_one(self, Token__is_string)) {
        return Parsed_String_Expression__create(Parser__consume_token(self, Token__is_string).as(String_Token*)).as(Parsed_Expression*)
    }
    if (Parser__matches_one(self, Token__is_opening_paren)) {
        let location = Parser__consume_token(self, Token__is_opening_paren).location
        Parser__consume_space(self, 0.as(u16))
        let expression = Parser__parse_expression(self)
        Parser__consume_space(self, 0.as(u16))
        Parser__consume_token(self, Token__is_closing_paren)
        return Parsed_Group_Expression__create(location, expression).as(Parsed_Expression*)
    }
    Parser__error(self, String__create_from("Unsupported primary expression"))
    abort()
}

\ access_expression
\      | primary_expression ( "." "*" | "." "as" "(" type ")" | "." IDENTIFIER | "(" ( expression ( "," expression )*)? ")" | "[" expression "]" )*
func Parser__parse_access_expression(self: Parser*) -> Parsed_Expression* {
    let expression = Parser__parse_primary_expression(self)
    while (true) {
        let old_expression = expression
        if (Parser__matches_two(self, Token__is_space, false, Token__is_dot)) {
            Parser__consume_space(self, 0.as(u16))
            Parser__consume_token(self, Token__is_dot)
            Parser__consume_space(self, 0.as(u16))
            if (Parser__matches_one(self, Token__is_asterisk)) {
                Parser__consume_token(self, Token__is_asterisk)
                expression = Parsed_Dereference_Expression__create(expression).as(Parsed_Expression*)
            } else {
                let name = Parser__consume_token(self, Token__is_identifier)
                if (String__equals_cstring(name.lexeme, "as")) {
                    Parser__consume_space(self, 0.as(u16))
                    Parser__consume_token(self, Token__is_opening_paren)
                    Parser__consume_space(self, 0.as(u16))
                    let type = Parser__parse_type(self)
                    Parser__consume_space(self, 0.as(u16))
                    Parser__consume_token(self, Token__is_closing_paren)
                    expression = Parsed_Cast_Expression__create(name.location, expression, type).as(Parsed_Expression*)
                } else {
                    expression = Parsed_Member_Access_Expression__create(expression, name).as(Parsed_Expression*)
                }
            }
        }
        if (Parser__matches_two(self, Token__is_space, false, Token__is_opening_paren)) {
            Parser__consume_space(self, 0.as(u16))
            Parser__consume_token(self, Token__is_opening_paren)
            Parser__consume_space(self, 0.as(u16))
            let call_expression = Parsed_Call_Expression__create(expression)
            if (!Parser__matches_one(self, Token__is_closing_paren)) {
                let last_argument = Parsed_Call_Argument__create(Parser__parse_expression(self))
                call_expression.first_argument = last_argument
                Parser__consume_space(self, 0.as(u16))
                while (Parser__matches_one(self, Token__is_comma)) {
                    Parser__consume_token(self, Token__is_comma)
                    Parser__consume_space(self, 1.as(u16))
                    let argument = Parsed_Call_Argument__create(Parser__parse_expression(self))
                    last_argument.next_argument = argument
                    last_argument = argument
                    Parser__consume_space(self, 0.as(u16))
                }
            }
            expression = call_expression.as(Parsed_Expression*)
            Parser__consume_token(self, Token__is_closing_paren)
        }
        if (Parser__matches_two(self, Token__is_space, false, Token__is_opening_bracket)) {
            Parser__consume_space(self, 0.as(u16))
            Parser__consume_token(self, Token__is_opening_bracket)
            Parser__consume_space(self, 0.as(u16))
            let index_expression = Parser__parse_expression(self)
            Parser__consume_space(self, 0.as(u16))
            Parser__consume_token(self, Token__is_closing_bracket)
            expression = Parsed_Array_Access_Expression__create(expression, index_expression).as(Parsed_Expression*)
        }
        if (old_expression == expression) {
            break
        }
    }
    return expression
}

\ unary_expression
\      | "-" unary_expression
\      | "!" unary_expression
\      | "&" unary_expression
\      | "sizeof" "(" type ")"
\      | access_expression
func Parser__parse_unary_expression(self: Parser*) -> Parsed_Expression* {
    if (Parser__matches_one(self, Token__is_minus)) {
        let location = Parser__consume_token(self, Token__is_minus).location
        Parser__consume_space(self, 0.as(u16))
        let expression = Parser__parse_unary_expression(self)
        return Parsed_Minus_Expression__create(location, expression).as(Parsed_Expression*)
    }
    if (Parser__matches_one(self, Token__is_exclamation_mark)) {
        let location = Parser__consume_token(self, Token__is_exclamation_mark).location
        Parser__consume_space(self, 0.as(u16))
        let expression = Parser__parse_unary_expression(self)
        return Parsed_Not_Expression__create(location, expression).as(Parsed_Expression*)
    }
    if (Parser__matches_one(self, Token__is_ampersand)) {
        let location = Parser__consume_token(self, Token__is_ampersand).location
        Parser__consume_space(self, 0.as(u16))
        let expression = Parser__parse_unary_expression(self)
        return Parsed_Address_Of_Expression__create(location, expression).as(Parsed_Expression*)
    }
    if (Parser__matches_one(self, Token__is_sizeof)) {
        let location = Parser__consume_token(self, Token__is_sizeof).location
        Parser__consume_space(self, 0.as(u16))
        Parser__consume_token(self, Token__is_opening_paren)
        Parser__consume_space(self, 0.as(u16))
        let type = Parser__parse_type(self)
        Parser__consume_space(self, 0.as(u16))
        Parser__consume_token(self, Token__is_closing_paren)
        return Parsed_Sizeof_Expression__create(location, type).as(Parsed_Expression*)
    }
    return Parser__parse_access_expression(self)
}

func Token__is_mutliplication(self: Token*) -> bool {
    return Token__is_asterisk(self) || Token__is_slash(self) || Token__is_percent(self)
}

\ multiplication
\      | unary_expression ( ( "*" | "/" | "%" ) unary_expression )*
func Parser__parse_multiplication_expression(self: Parser*) -> Parsed_Expression* {
    let expression = Parser__parse_unary_expression(self)
    while (Parser__matches_two(self, Token__is_space, false, Token__is_mutliplication)) {
        Parser__consume_space(self, 1.as(u16))
        if (Parser__matches_one(self, Token__is_asterisk)) {
            Parser__consume_token(self, Token__is_asterisk)
            Parser__consume_space(self, 1.as(u16))
            let right_expression = Parser__parse_unary_expression(self)
            expression = Parsed_Multiply_Expression__create(expression, right_expression).as(Parsed_Expression*)
        } else if (Parser__matches_one(self, Token__is_slash)) {
            Parser__consume_token(self, Token__is_slash)
            Parser__consume_space(self, 1.as(u16))
            let right_expression = Parser__parse_unary_expression(self)
            expression = Parsed_Divide_Expression__create(expression, right_expression).as(Parsed_Expression*)
        } else {
            Parser__consume_token(self, Token__is_percent)
            Parser__consume_space(self, 1.as(u16))
            let right_expression = Parser__parse_unary_expression(self)
            expression = Parsed_Modulo_Expression__create(expression, right_expression).as(Parsed_Expression*)
        }
    }
    return expression
}

func Token__is_addition(self: Token*) -> bool {
    return Token__is_plus(self) || Token__is_minus(self)
}

\ addition
\      | multiplication ( ( "+" | "-" ) multiplication )*
func Parser__parse_addition_expression(self: Parser*) -> Parsed_Expression* {
    let expression = Parser__parse_multiplication_expression(self)
    while (Parser__matches_two(self, Token__is_space, false, Token__is_addition)) {
        Parser__consume_space(self, 1.as(u16))
        if (Parser__matches_one(self, Token__is_plus)) {
            Parser__consume_token(self, Token__is_plus)
            Parser__consume_space(self, 1.as(u16))
            let right_expression = Parser__parse_multiplication_expression(self)
            expression = Parsed_Add_Expression__create(expression, right_expression).as(Parsed_Expression*)
        } else {
            Parser__consume_token(self, Token__is_minus)
            Parser__consume_space(self, 1.as(u16))
            let right_expression = Parser__parse_multiplication_expression(self)
            expression = Parsed_Substract_Expression__create(expression, right_expression).as(Parsed_Expression*)
        }
    }
    return expression
}

\ comparison
\      | addition ( ( "<=" | "<" | ">" | ">=") addition )*
func Parser__parse_comparison_expression(self: Parser*) -> Parsed_Expression* {
    let expression = Parser__parse_addition_expression(self)
    if (Parser__matches_two(self, Token__is_space, false, Token__is_less_than)) {
        Parser__consume_space(self, 1.as(u16))
        Parser__consume_token(self, Token__is_less_than)
        if (Parser__matches_one(self, Token__is_equals)) {
            Parser__consume_token(self, Token__is_equals)
            Parser__consume_space(self, 1.as(u16))
            let right_expression = Parser__parse_addition_expression(self)
            expression = Parsed_Less_Or_Equals_Expression__create(expression, right_expression).as(Parsed_Expression*)
        } else {
            Parser__consume_space(self, 1.as(u16))
            let right_expression = Parser__parse_addition_expression(self)
            expression = Parsed_Less_Expression__create(expression, right_expression).as(Parsed_Expression*)
        }
    } else if (Parser__matches_two(self, Token__is_space, false, Token__is_greater_than)) {
        Parser__consume_space(self, 1.as(u16))
        Parser__consume_token(self, Token__is_greater_than)
        if (Parser__matches_one(self, Token__is_equals)) {
            Parser__consume_token(self, Token__is_equals)
            Parser__consume_space(self, 1.as(u16))
            let right_expression = Parser__parse_addition_expression(self)
            expression = Parsed_Greater_Or_Equals_Expression__create(expression, right_expression).as(Parsed_Expression*)
        } else {
            Parser__consume_space(self, 1.as(u16))
            let right_expression = Parser__parse_addition_expression(self)
            expression = Parsed_Greater_Expression__create(expression, right_expression).as(Parsed_Expression*)
        }
    }
    return expression
}

\ equality
\      | comparison ( ( "==" | "!=" ) comparison )*
func Parser__parse_equality_expression(self: Parser*) -> Parsed_Expression* {
    let expression = Parser__parse_comparison_expression(self)
    if (Parser__matches_three(self, Token__is_space, false, Token__is_equals, true, Token__is_equals)) {
        Parser__consume_space(self, 1.as(u16))
        Parser__consume_token(self, Token__is_equals)
        Parser__consume_token(self, Token__is_equals)
        Parser__consume_space(self, 1.as(u16))
        let right_expression = Parser__parse_comparison_expression(self)
        expression = Parsed_Equals_Expression__create(expression, right_expression).as(Parsed_Expression*)
    } else if (Parser__matches_three(self, Token__is_space, false, Token__is_exclamation_mark, true, Token__is_equals)) {
        Parser__consume_space(self, 1.as(u16))
        Parser__consume_token(self, Token__is_exclamation_mark)
        Parser__consume_token(self, Token__is_equals)
        Parser__consume_space(self, 1.as(u16))
        let right_expression = Parser__parse_comparison_expression(self)
        expression = Parsed_Not_Equals_Expression__create(expression, right_expression).as(Parsed_Expression*)
    }
    return expression
}

\ logic_and
\      | equality ( "&&" equality )*
func Parser__parse_logic_and_expression(self: Parser*) -> Parsed_Expression* {
    let expression = Parser__parse_equality_expression(self)
    while (Parser__matches_three(self, Token__is_space, false, Token__is_ampersand, true, Token__is_ampersand)) {
        Parser__consume_space(self, 1.as(u16))
        Parser__consume_token(self, Token__is_ampersand)
        Parser__consume_token(self, Token__is_ampersand)
        Parser__consume_space(self, 1.as(u16))
        let right_expression = Parser__parse_equality_expression(self)
        expression = Parsed_Logic_And_Expression__create(expression, right_expression).as(Parsed_Expression*)
    }
    return expression
}

\ logic_or
\      | logic_and ( "||" logic_and )*
func Parser__parse_logic_or_expression(self: Parser*) -> Parsed_Expression* {
    let expression = Parser__parse_logic_and_expression(self)
    while (Parser__matches_three(self, Token__is_space, false, Token__is_vertical_bar, true, Token__is_vertical_bar)) {
        Parser__consume_space(self, 1.as(u16))
        Parser__consume_token(self, Token__is_vertical_bar)
        Parser__consume_token(self, Token__is_vertical_bar)
        Parser__consume_space(self, 1.as(u16))
        let right_expression = Parser__parse_logic_and_expression(self)
        expression = Parsed_Logic_Or_Expression__create(expression, right_expression).as(Parsed_Expression*)
    }
    return expression
}

\ expression
\      | logic_or
func Parser__parse_expression(self: Parser*) -> Parsed_Expression* {
    return Parser__parse_logic_or_expression(self)
}

\ struct
\   | "struct" IDENTIFIER "{" ( IDENTIFIER ":" type )* "}"
func Parser__parse_struct(self: Parser*) -> Parsed_Statement* {
    Parser__consume_token(self, Token__is_struct)
    Parser__consume_space(self, 1.as(u16))
    let name = Parser__consume_token(self, Token__is_identifier)
    Parser__consume_space(self, 1.as(u16))
    Parser__consume_token(self, Token__is_opening_brace)
    Parser__consume_end_of_line(self)
    let struct_statement = Parsed_Struct_Statement__create(name.location, name)
    let last_member: Parsed_Struct_Member* = null
    self.current_identation = self.current_identation + 1.as(u16)
    while (Parser__consume_empty_line(self)) {
        \ ignored
    }
    while (!Parser__matches_two(self, Token__is_space, false, Token__is_closing_brace)) {
        Parser__consume_space(self, self.current_identation * 4.as(u16))
        let name = Parser__consume_token(self, Token__is_identifier)
        Parser__consume_space(self, 0.as(u16))
        Parser__consume_token(self, Token__is_colon)
        Parser__consume_space(self, 1.as(u16))
        let type = Parser__parse_type(self)
        Parser__consume_end_of_line(self)
        let member = Parsed_Struct_Member__create(name, type)
        if (last_member == null) {
            struct_statement.first_member = member
            last_member = member
        } else {
            last_member.next_member = member
            last_member = member
        }
        while (Parser__consume_empty_line(self)) {
            \ ignored
        }
    }
    self.current_identation = self.current_identation - 1.as(u16)
    Parser__consume_space(self, self.current_identation * 4.as(u16))
    Parser__consume_token(self, Token__is_closing_brace)
    return struct_statement.as(Parsed_Statement*)
}

\ external_type
\   | "type" IDENTIFIER
func Parser__parse_external_type(self: Parser*) -> Parsed_Statement* {
    Parser__consume_token(self, Token__is_type)
    Parser__consume_space(self, 1.as(u16))
    let name = Parser__consume_token(self, Token__is_identifier)
    return Parsed_Opaque_Type_Statement__create(name.location, name).as(Parsed_Statement*)
}

\ enum
\      | "enum" IDENTIFIER "{" ( IDENTIFIER )* "}"
func Parser__parse_enum(self: Parser*) -> Parsed_Statement* {
    Parser__consume_token(self, Token__is_enum)
    Parser__consume_space(self, 1.as(u16))
    let name = Parser__consume_token(self, Token__is_identifier)
    Parser__consume_space(self, 1.as(u16))
    Parser__consume_token(self, Token__is_opening_brace)
    Parser__consume_end_of_line(self)
    let enum_statement = Parsed_Enum_Statement__create(name.location, name)
    let last_member: Parsed_Enum_Member* = null
    self.current_identation = self.current_identation + 1.as(u16)
    while (Parser__consume_empty_line(self)) {
        \ ignored
    }
    while (!Parser__matches_two(self, Token__is_space, false, Token__is_closing_brace)) {
        Parser__consume_space(self, self.current_identation * 4.as(u16))
        let name = Parser__consume_token(self, Token__is_identifier)
        Parser__consume_end_of_line(self)
        let member = Parsed_Enum_Member__create(name)
        if (last_member == null) {
            enum_statement.first_member = member
            last_member = member
        } else {
            last_member.next_member = member
            last_member = member
        }
        while (Parser__consume_empty_line(self)) {
            \ ignored
        }
    }
    self.current_identation = self.current_identation - 1.as(u16)
    Parser__consume_space(self, self.current_identation * 4.as(u16))
    Parser__consume_token(self, Token__is_closing_brace)
    return enum_statement.as(Parsed_Statement*)
}

\ type
\   | IDENTIFIER "*"*
\   | "(" "func" "(" ( type ( "," type )* )? ")" "->" type ")"
func Parser__parse_type(self: Parser*) -> Parsed_Type* {
    if (Parser__matches_three(self, Token__is_opening_paren, true, Token__is_space, false, Token__is_func)) {
        let location = Parser__consume_token(self, Token__is_opening_paren).location
        Parser__consume_space(self, 0.as(u16))
        Parser__consume_token(self, Token__is_func)
        Parser__consume_space(self, 1.as(u16))
        Parser__consume_token(self, Token__is_opening_paren)
        Parser__consume_space(self, 0.as(u16))
        let first_parameter: Parsed_Function_Parameter* = null
        if (!Parser__matches_one(self, Token__is_closing_paren)) {
            let type = Parser__parse_type(self)
            Parser__consume_space(self, 0.as(u16))
            first_parameter = Parsed_Function_Parameter__create(type.location, null, type)
            let last_parameter = first_parameter
            while (!Parser__matches_one(self, Token__is_closing_paren)) {
                Parser__consume_token(self, Token__is_comma)
                Parser__consume_space(self, 1.as(u16))
                let type = Parser__parse_type(self)
                Parser__consume_space(self, 0.as(u16))
                last_parameter.next_parameter = Parsed_Function_Parameter__create(type.location, null, type)
                last_parameter = last_parameter.next_parameter
            }
        }
        Parser__consume_token(self, Token__is_closing_paren)
        Parser__consume_space(self, 1.as(u16))
        Parser__consume_token(self, Token__is_minus)
        Parser__consume_space(self, 0.as(u16))
        Parser__consume_token(self, Token__is_greater_than)
        Parser__consume_space(self, 1.as(u16))
        let return_type = Parser__parse_type(self)
        Parser__consume_space(self, 0.as(u16))
        Parser__consume_token(self, Token__is_closing_paren)
        return Parsed_Function_Type__create(location, first_parameter, return_type).as(Parsed_Type*)
    } else {
        let name = Parser__consume_token(self, Token__is_identifier)
        let type = Parsed_Named_Type__create(name).as(Parsed_Type*)
        while (Parser__matches_two(self, Token__is_space, false, Token__is_asterisk)) {
            Parser__consume_space(self, 0.as(u16))
            Parser__consume_token(self, Token__is_asterisk)
            type = Parsed_Pointer_Type__create(type).as(Parsed_Type*)
        }
        return type
    }
}

\ variable
\      | "let" IDENTIFIER ( ":" type )? "=" ( "undefined" | expression )
func Parser__parse_variable(self: Parser*) -> Parsed_Statement* {
    Parser__consume_token(self, Token__is_let)
    Parser__consume_space(self, 1.as(u16))
    let name = Parser__consume_token(self, Token__is_identifier)
    let type: Parsed_Type* = null
    if (Parser__matches_two(self, Token__is_space, false, Token__is_colon)) {
        Parser__consume_space(self, 0.as(u16))
        Parser__consume_token(self, Token__is_colon)
        Parser__consume_space(self, 1.as(u16))
        type = Parser__parse_type(self)
    }
    Parser__consume_space(self, 1.as(u16))
    Parser__consume_token(self, Token__is_equals)
    Parser__consume_space(self, 1.as(u16))

    let value_expression: Parsed_Expression* = undefined
    if (Parser__matches_one(self, Token__is_undefined)) {
        Parser__consume_token(self, Token__is_undefined)
        value_expression = null
    } else {
        value_expression = Parser__parse_expression(self)
    }
    let variable_statement = Parsed_Variable_Statement__create(name.location, name, type, false)
    variable_statement.expression = value_expression
    return variable_statement.as(Parsed_Statement*)
}

\ external_variable
\      | IDENTIFIER ":" type
func Parser__parse_external_variable(self: Parser*) -> Parsed_Statement* {
    let name = Parser__consume_token(self, Token__is_identifier)
    Parser__consume_space(self, 0.as(u16))
    Parser__consume_token(self, Token__is_colon)
    Parser__consume_space(self, 1.as(u16))
    let type = Parser__parse_type(self)
    return Parsed_Variable_Statement__create(name.location, name, type, true).as(Parsed_Statement*)
}

\ block
\      | "{" statements "}"
func Parser__parse_block_statement(self: Parser*) -> Parsed_Block_Statement* {
    let location = Parser__consume_token(self, Token__is_opening_brace).location
    Parser__consume_end_of_line(self)
    let statements = Parsed_Statements__create(false)
    self.current_identation = self.current_identation + 1.as(u16)
    Parser__parse_statements(self, statements)
    self.current_identation = self.current_identation - 1.as(u16)
    Parser__consume_space(self, self.current_identation * 4.as(u16))
    Parser__consume_token(self, Token__is_closing_brace)
    return Parsed_Block_Statement__create(location, statements)
}

\ function_parameter
\   IDENTIFIER ":" type
func Parser__parse_function_parameter(self: Parser*) -> Parsed_Function_Parameter* {
    let name = Parser__consume_token(self, Token__is_identifier)
    Parser__consume_space(self, 0.as(u16))
    Parser__consume_token(self, Token__is_colon)
    Parser__consume_space(self, 1.as(u16))
    let type = Parser__parse_type(self)
    return Parsed_Function_Parameter__create(name.location, name.lexeme, type)
}

\ function
\   | "func" IDENTIFIER "(" function_parameter* ")" "->" type "{" statements "}"
func Parser__parse_function(self: Parser*) -> Parsed_Statement* {
    Parser__consume_token(self, Token__is_func)
    Parser__consume_space(self, 1.as(u16))
    let name = Parser__consume_token(self, Token__is_identifier)
    Parser__consume_space(self, 0.as(u16))
    Parser__consume_token(self, Token__is_opening_paren)
    let first_parameter: Parsed_Function_Parameter* = null
    if (!Parser__matches_two(self, Token__is_space, false, Token__is_closing_paren)) {
        Parser__consume_space(self, 0.as(u16))
        first_parameter = Parser__parse_function_parameter(self)
        let last_parameter = first_parameter
        while (Parser__matches_two(self, Token__is_space, false, Token__is_comma)) {
            Parser__consume_space(self, 0.as(u16))
            Parser__consume_token(self, Token__is_comma)
            Parser__consume_space(self, 1.as(u16))
            last_parameter.next_parameter = Parser__parse_function_parameter(self)
            last_parameter = last_parameter.next_parameter
        }
    }
    Parser__consume_space(self, 0.as(u16))
    Parser__consume_token(self, Token__is_closing_paren)
    Parser__consume_space(self, 1.as(u16))
    Parser__consume_token(self, Token__is_minus)
    Parser__consume_space(self, 0.as(u16))
    Parser__consume_token(self, Token__is_greater_than)
    Parser__consume_space(self, 1.as(u16))
    let return_type = Parser__parse_type(self)
    Parser__consume_space(self, 1.as(u16))
    Parser__consume_token(self, Token__is_opening_brace)
    Parser__consume_end_of_line(self)
    let statements = Parsed_Statements__create(false)
    self.current_identation = self.current_identation + 1.as(u16)
    Parser__parse_statements(self, statements)
    self.current_identation = self.current_identation - 1.as(u16)
    Parser__consume_space(self, self.current_identation * 4.as(u16))
    Parser__consume_token(self, Token__is_closing_brace)
    return Parsed_Function_Statement__create(name.location, name, first_parameter, return_type, statements, false)
}

\ external_function
\   | "func" IDENTIFIER "(" function_parameter* ")" ":" type
func Parser__parse_external_function(self: Parser*) -> Parsed_Statement* {
    Parser__consume_token(self, Token__is_func)
    Parser__consume_space(self, 1.as(u16))
    let name = Parser__consume_token(self, Token__is_identifier)
    Parser__consume_space(self, 0.as(u16))
    Parser__consume_token(self, Token__is_opening_paren)
    let first_parameter: Parsed_Function_Parameter* = null
    if (!Parser__matches_two(self, Token__is_space, false, Token__is_closing_paren)) {
        Parser__consume_space(self, 0.as(u16))
        first_parameter = Parser__parse_function_parameter(self)
        let last_parameter = first_parameter
        while (Parser__matches_two(self, Token__is_space, false, Token__is_comma)) {
            Parser__consume_space(self, 0.as(u16))
            Parser__consume_token(self, Token__is_comma)
            Parser__consume_space(self, 1.as(u16))
            last_parameter.next_parameter = Parser__parse_function_parameter(self)
            last_parameter = last_parameter.next_parameter
        }
    }
    Parser__consume_space(self, 0.as(u16))
    Parser__consume_token(self, Token__is_closing_paren)
    Parser__consume_space(self, 1.as(u16))
    Parser__consume_token(self, Token__is_minus)
    Parser__consume_space(self, 0.as(u16))
    Parser__consume_token(self, Token__is_greater_than)
    Parser__consume_space(self, 1.as(u16))
    let return_type = Parser__parse_type(self)
    return Parsed_Function_Statement__create(name.location, name, first_parameter, return_type, null, true)
}

\ return
\      | "return" expression?
func Parser__parse_return_statement(self: Parser*) -> Parsed_Statement* {
    let location = Parser__consume_token(self, Token__is_return).location
    let expression: Parsed_Expression* = null
    if (!Parser__matches_three(self, Token__is_space, false, Token__is_comment, false, Token__is_end_of_line)) {
        Parser__consume_space(self, 1.as(u16))
        expression = Parser__parse_expression(self)
    }
    return Parsed_Return_Statement__create(location, expression)
}

\ break
\      | "break"
func Parser__parse_break_statement(self: Parser*) -> Parsed_Statement* {
    let location = Parser__consume_token(self, Token__is_break).location
    return Parsed_Break_Statement__create(location)
}

\ if
\      | "if" "(" expression ")" block_statement ( "else" ( if | block_statement ) )?
func Parser__parse_if_statement(self: Parser*) -> Parsed_Statement* {
    let location = Parser__consume_token(self, Token__is_if).location
    Parser__consume_space(self, 1.as(u16))
    Parser__consume_token(self, Token__is_opening_paren)
    Parser__consume_space(self, 0.as(u16))
    let condition_expression = Parser__parse_expression(self)
    Parser__consume_space(self, 0.as(u16))
    Parser__consume_token(self, Token__is_closing_paren)
    Parser__consume_space(self, 1.as(u16))
    let true_statement = Parser__parse_block_statement(self).as(Parsed_Statement*)
    let false_statement: Parsed_Statement* = null
    if (Parser__matches_two(self, Token__is_space, false, Token__is_else)) {
        Parser__consume_space(self, 1.as(u16))
        Parser__consume_token(self, Token__is_else)
        Parser__consume_space(self, 1.as(u16))
        if (Parser__matches_one(self, Token__is_if)) {
            false_statement = Parser__parse_if_statement(self)
        } else {
            false_statement = Parser__parse_block_statement(self).as(Parsed_Statement*)
        }
    }
    return Parsed_If_Statement__create(location, condition_expression, true_statement, false_statement)
}

\ while
\      | "while" "(" expression ")" statement
func Parser__parse_while_statement(self: Parser*) -> Parsed_Statement* {
    let location = Parser__consume_token(self, Token__is_while).location
    Parser__consume_space(self, 1.as(u16))
    Parser__consume_token(self, Token__is_opening_paren)
    Parser__consume_space(self, 0.as(u16))
    let condition_expression = Parser__parse_expression(self)
    Parser__consume_space(self, 0.as(u16))
    Parser__consume_token(self, Token__is_closing_paren)
    Parser__consume_space(self, 1.as(u16))
    let body_statement = Parser__parse_block_statement(self).as(Parsed_Statement*)
    return Parsed_While_Statement__create(location, condition_expression, body_statement)
}

\ statement
\   | enum
\   | "external" ( external_function | external_type | external_variable )
\   | function
\   | if
\   | return
\   | struct
\   | variable
func Parser__parse_statement(self: Parser*) -> Parsed_Statement* {
    Parser__consume_space(self, self.current_identation * 4.as(u16))

    if (Parser__matches_one(self, Token__is_if)) {
        return Parser__parse_if_statement(self)
    }

    if (Parser__matches_one(self, Token__is_while)) {
        return Parser__parse_while_statement(self)
    }

    if (Parser__matches_one(self, Token__is_return)) {
        return Parser__parse_return_statement(self)
    }

    if (Parser__matches_one(self, Token__is_break)) {
        return Parser__parse_break_statement(self)
    }

    if (Parser__matches_one(self, Token__is_let)) {
        return Parser__parse_variable(self)
    }

    if (Parser__matches_one(self, Token__is_func)) {
        return Parser__parse_function(self)
    }

    if (Parser__matches_one(self, Token__is_struct)) {
        return Parser__parse_struct(self)
    }

    if (Parser__matches_one(self, Token__is_enum)) {
        return Parser__parse_enum(self)
    }

    if (Parser__matches_one(self, Token__is_external)) {
        let location = Parser__consume_token(self, Token__is_external).location
        Parser__consume_space(self, 1.as(u16))
        if (Parser__matches_one(self, Token__is_func)) {
            return Parser__parse_external_function(self)
        }
        if (Parser__matches_one(self, Token__is_type)) {
            return Parser__parse_external_type(self)
        }
        return Parser__parse_external_variable(self)
    }

    let expression = Parser__parse_access_expression(self)
    if (Parser__matches_two(self, Token__is_space, false, Token__is_equals)) {
        Parser__consume_space(self, 1.as(u16))
        Parser__consume_token(self, Token__is_equals)
        Parser__consume_space(self, 1.as(u16))
        let value_expression = Parser__parse_expression(self)
        return Parsed_Assignment_Statement__create(expression, value_expression).as(Parsed_Statement*)
    }
    return Parsed_Expression_Statement__create(expression).as(Parsed_Statement*)
}

\ statements
\      | ( statement )*
func Parser__parse_statements(self: Parser*, statements: Parsed_Statements*) -> void {
    while (true) {
        while (Parser__consume_empty_line(self)) {
            \ ignored
        }

        if (statements.has_globals) {
            if (Parser__matches_three(self, Token__is_space, false, Token__is_comment, false, Token__is_end_of_line)) {
                return
            }
        } else {
            if (Parser__matches_two(self, Token__is_space, false, Token__is_closing_brace)) {
                return
            }
        }

        let statement = Parser__parse_statement(self)

        Parser__consume_end_of_line(self)

        Parsed_Statements__append(statements, statement)
    }
}

func Parser__parse_source(self: Parser*, source: Source*) -> void {
    let other_scanner = self.scanner

    self.scanner = Scanner__create(source)

    Parser__parse_statements(self, self.compilation_unit.statements)

    let last_token = Parser__peek_token(self, 0.as(u8))
    if (!Token__is_end_of_file(last_token)) {
        Parser__error(self, String__create_from("Scanner didn't reach end of file"))
        abort()
    } else if (last_token.location.column != 1.as(u16)) {
        Parser__warning(self, String__create_from("No new line at the end of file"))
    }

    self.scanner = other_scanner
}

func parse(source: Source*) -> Parsed_Source* {
    let parser: Parser = undefined
    parser.scanner = null
    parser.compilation_unit = Parsed_Compilation_Unit__create()
    parser.current_identation = 0.as(u16)

    Parser__parse_source(&parser, source)

    return parser.compilation_unit
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Checked Types
\ ---------------------------------------------------------------------------------------------------------------------

enum Checked_Type_Kind {
    \ Builtins
    BOOL
    CHAR
    I16
    I32
    I64
    I8
    USIZE
    U16
    U32
    U64
    U8
    VOID
    NULL \ Pseudo type
    \ Defined
    DEFINED
    ENUM
    OPAQUE
    STRUCT
    \ Dynamic
    FUNCTION
    POINTER
}

struct Checked_Type {
    kind: Checked_Type_Kind
    location: Source_Location*
    next_type: Checked_Type*
}

func Checked_Type__create_kind(kind: Checked_Type_Kind, kind_size: usize, location: Source_Location*) -> Checked_Type* {
    let type = malloc(kind_size).as(Checked_Type*)
    type.kind = kind
    type.location = location
    type.next_type = null
    return type
}

func Checked_Type__expect_same_type(self: Checked_Type*, other_type: Checked_Type*, location: Source_Location*) -> void {
    if (self.kind == Checked_Type_Kind.POINTER && other_type.kind == Checked_Type_Kind.NULL) {
        return
    }
    if (self.kind == Checked_Type_Kind.FUNCTION && other_type.kind == Checked_Type_Kind.NULL) {
        return
    }
    if (!Checked_Type__equals(self, other_type)) {
        let message = String__create_from("Unexpected type. Got \"")
        String__append_checked_type(message, other_type)
        String__append_cstring(message, "\" instead of \"")
        String__append_checked_type(message, self)
        String__append_char(message, '"')
        Source_Location__error(location, message)
        abort()
    }
}

func Checked_Type__is_scalar_type(self: Checked_Type*) -> bool {
    if (self.kind == Checked_Type_Kind.CHAR) {
        return true
    } else if (self.kind == Checked_Type_Kind.I16) {
        return true
    } else if (self.kind == Checked_Type_Kind.I32) {
        return true
    } else if (self.kind == Checked_Type_Kind.I64) {
        return true
    } else if (self.kind == Checked_Type_Kind.I8) {
        return true
    } else if (self.kind == Checked_Type_Kind.U16) {
        return true
    } else if (self.kind == Checked_Type_Kind.U32) {
        return true
    } else if (self.kind == Checked_Type_Kind.U64) {
        return true
    } else if (self.kind == Checked_Type_Kind.U8) {
        return true
    } else if (self.kind == Checked_Type_Kind.USIZE) {
        return true
    } else if (self.kind == Checked_Type_Kind.ENUM) {
        return true
    }
    return false
}

func Checked_Type__expect_scalar_type(self: Checked_Type*, location: Source_Location*) -> void {
    if (!Checked_Type__is_scalar_type(self)) {
        let message = String__create_from("Type \"")
        String__append_checked_type(message, self)
        String__append_cstring(message, "\" is not a scalar type")
        Source_Location__error(location, message)
        abort()
    }
}

struct Checked_Named_Type {
    super: Checked_Type
    name: String*
}

func Checked_Named_Type__create_kind(kind: Checked_Type_Kind, kind_size: usize, location: Source_Location*, name: String*) -> Checked_Named_Type* {
    let type = Checked_Type__create_kind(kind, kind_size, location).as(Checked_Named_Type*)
    type.name = name
    return type
}

struct Checked_Enum_Member {
    location: Source_Location*
    name: String*
    symbol: Checked_Symbol*
    next_member: Checked_Enum_Member*
}

func Checked_Enum_Member__create(location: Source_Location*, name: String*) -> Checked_Enum_Member* {
    let member = malloc(sizeof(Checked_Enum_Member)).as(Checked_Enum_Member*)
    member.location = location
    member.name = name
    member.symbol = null
    member.next_member = null
    return member
}

struct Checked_Enum_Type {
    super: Checked_Named_Type
    first_member: Checked_Enum_Member*
}

func Checked_Enum_Type__create(location: Source_Location*, name: String*) -> Checked_Enum_Type* {
    let type = Checked_Named_Type__create_kind(Checked_Type_Kind.ENUM, sizeof(Checked_Enum_Type), location, name).as(Checked_Enum_Type*)
    type.first_member = null
    return type
}

func Checked_Enum_Type__find_member(self: Checked_Enum_Type*, name: String*) -> Checked_Enum_Member* {
    let member = self.first_member
    while (member != null) {
        if (String__equals_string(name, member.name)) {
            break
        }
        member = member.next_member
    }
    return member
}

struct Checked_Function_Parameter {
    location: Source_Location*
    name: String*
    type: Checked_Type*
    next_parameter: Checked_Function_Parameter*
}

func Checked_Function_Parameter__create(location: Source_Location*, name: String*, type: Checked_Type*) -> Checked_Function_Parameter* {
    let parameter = malloc(sizeof(Checked_Function_Parameter)).as(Checked_Function_Parameter*)
    parameter.location = location
    parameter.name = name
    parameter.type = type
    parameter.next_parameter = null
    return parameter
}

struct Checked_Function_Type {
    super: Checked_Type
    first_parameter: Checked_Function_Parameter*
    return_type: Checked_Type*
}

func Checked_Function_Type__create(location: Source_Location*, first_parameter: Checked_Function_Parameter*, return_type: Checked_Type*) -> Checked_Function_Type* {
    let type = Checked_Type__create_kind(Checked_Type_Kind.FUNCTION, sizeof(Checked_Function_Type), location).as(Checked_Function_Type*)
    type.first_parameter = first_parameter
    type.return_type = return_type
    return type
}

func Checked_Function_Type__equals(self: Checked_Function_Type*, other_type: Checked_Type*) -> bool {
    if (other_type.kind != self.kind) {
        return false
    }
    let function_type = other_type.as(Checked_Function_Type*)
    if (!Checked_Type__equals(self.return_type, function_type.return_type)) {
        return false
    }
    let self_parameter = self.first_parameter
    let function_parameter = function_type.first_parameter
    while (self_parameter != null && function_parameter != null) {
        if (!Checked_Type__equals(self_parameter.type, function_parameter.type)) {
            return false
        }
        self_parameter = self_parameter.next_parameter
        function_parameter = function_parameter.next_parameter
    }
    if (self_parameter != null || function_parameter != null) {
        return false
    }
    return true
}

struct Checked_Opaque_Type {
    super: Checked_Named_Type
}

func Checked_Opaque_Type__create(location: Source_Location*, name: String*) -> Checked_Opaque_Type* {
    return Checked_Named_Type__create_kind(Checked_Type_Kind.OPAQUE, sizeof(Checked_Opaque_Type), location, name).as(Checked_Opaque_Type*)
}

struct Checked_Pointer_Type {
    super: Checked_Type
    other_type: Checked_Type*
}

func Checked_Pointer_Type__create(location: Source_Location*, other_type: Checked_Type*) -> Checked_Pointer_Type* {
    let type = Checked_Type__create_kind(Checked_Type_Kind.POINTER, sizeof(Checked_Pointer_Type), location).as(Checked_Pointer_Type*)
    type.other_type = other_type
    return type
}

func Checked_Pointer_Type__equals(self: Checked_Pointer_Type*, other_type: Checked_Type*) -> bool {
    if (other_type.kind != self.kind) {
        return false
    }
    return Checked_Type__equals(self.other_type, other_type.as(Checked_Pointer_Type*).other_type)
}

struct Checked_Defined_Type {
    super: Checked_Type
    defined_type: Checked_Named_Type*
}

func Checked_Defined_Type__create(defined_type: Checked_Named_Type*) -> Checked_Defined_Type* {
    let type = Checked_Type__create_kind(Checked_Type_Kind.DEFINED, sizeof(Checked_Defined_Type), defined_type.location).as(Checked_Defined_Type*)
    type.defined_type = defined_type
    return type
}

struct Checked_Struct_Member {
    location: Source_Location*
    name: String*
    type: Checked_Type*
    next_member: Checked_Struct_Member*
}

func Checked_Struct_Member__create(location: Source_Location*, name: String*, type: Checked_Type*) -> Checked_Struct_Member* {
    let member = malloc(sizeof(Checked_Struct_Member)).as(Checked_Struct_Member*)
    member.location = location
    member.name = name
    member.type = type
    member.next_member = null
    return member
}

struct Checked_Struct_Type {
    super: Checked_Named_Type
    super_type: Checked_Struct_Type*
    first_member: Checked_Struct_Member*
}

func Checked_Struct_Type__create(location: Source_Location*, name: String*) -> Checked_Struct_Type* {
    let type = Checked_Named_Type__create_kind(Checked_Type_Kind.STRUCT, sizeof(Checked_Struct_Type), location, name).as(Checked_Struct_Type*)
    type.super_type = null
    type.first_member = null
    return type
}

func Checked_Struct_Type__find_member(self: Checked_Struct_Type*, name: String*) -> Checked_Struct_Member* {
    let member = self.first_member
    while (member != null) {
        if (String__equals_string(name, member.name)) {
            break
        }
        member = member.next_member
    }
    return member
}

func Checked_Struct_Type__equals(self: Checked_Struct_Type*, other_type: Checked_Type*) -> bool {
    if (self.kind != other_type.kind) {
        return false
    }
    return String__equals_string(self.name, other_type.as(Checked_Struct_Type*).name)
}

func Checked_Type__equals(self: Checked_Type*, other_type: Checked_Type*) -> bool {
    if (self == other_type) {
        return true
    }
    if (self.kind != other_type.kind) {
        return false
    }
    if (self.kind == Checked_Type_Kind.FUNCTION) {
        return Checked_Function_Type__equals(self.as(Checked_Function_Type*), other_type)
    }
    if (self.kind == Checked_Type_Kind.POINTER) {
        return Checked_Pointer_Type__equals(self.as(Checked_Pointer_Type*), other_type)
    }
    if (self.kind == Checked_Type_Kind.STRUCT) {
        return Checked_Struct_Type__equals(self.as(Checked_Struct_Type*), other_type)
    }
    Source_Location__error(self.location, String__create_from("Unsupported type"))
    abort()
}

func String__append_checked_type(self: String*, type: Checked_Type*) -> String* {
    if (type.kind <= Checked_Type_Kind.NULL) {
        let named_type = type.as(Checked_Named_Type*)
        String__append_string(self, named_type.name)
    } else if (type.kind == Checked_Type_Kind.STRUCT) {
        let struct_type = type.as(Checked_Struct_Type*)
        String__append_cstring(self, "struct ")
        String__append_string(self, struct_type.name)
    } else if (type.kind == Checked_Type_Kind.FUNCTION) {
        let function_type = type.as(Checked_Function_Type*)
        String__append_cstring(self, "(func (")
        let function_parameter = function_type.first_parameter
        while (function_parameter != null) {
            String__append_checked_type(self, function_parameter.type)
            function_parameter = function_parameter.next_parameter
            if (function_parameter != null) {
                String__append_cstring(self, ", ")
            }
        }
        String__append_cstring(self, ") -> ")
        String__append_checked_type(self, function_type.return_type)
        String__append_char(self, ')')
    } else if (type.kind == Checked_Type_Kind.ENUM) {
        let enum_type = type.as(Checked_Enum_Type*)
        String__append_cstring(self, "enum ")
        String__append_string(self, enum_type.name)
    } else if (type.kind == Checked_Type_Kind.POINTER) {
        let pointer_type = type.as(Checked_Pointer_Type*)
        String__append_checked_type(self, pointer_type.other_type)
        String__append_char(self, '*')
    } else {
        Source_Location__error(type.location, String__create_from("Unsupported type"))
        abort()
    }
    return self
}

func File__write_checked_function_symbol(self: File*, function_symbol: Checked_Function_Symbol*) -> void {
    let function_type = function_symbol.function_type
    File__write_checked_type(self, function_type.return_type)
    File__write_char(self, ' ')
    File__write_string(self, function_symbol.name)
    File__write_char(self, '(')
    let function_parameter = function_type.first_parameter
    while (function_parameter != null) {
        File__write_checked_function_parameter(self, function_parameter)
        function_parameter = function_parameter.next_parameter
        if (function_parameter != null) {
            File__write_cstring(self, ", ")
        }
    }
    File__write_char(self, ')')
}

func File__write_checked_function_parameter(self: File*, parameter: Checked_Function_Parameter*) -> void {
    if (parameter.type.kind == Checked_Type_Kind.FUNCTION) {
        let function_type = parameter.type.as(Checked_Function_Type*)
        File__write_checked_type(self, function_type.return_type)
        File__write_cstring(self, " (*")
        File__write_string(self, parameter.name)
        File__write_cstring(self, ")(")
        let function_parameter = function_type.first_parameter
        while (function_parameter != null) {
            File__write_checked_function_parameter(self, function_parameter)
            function_parameter = function_parameter.next_parameter
            if (function_parameter != null) {
                File__write_cstring(self, ", ")
            }
        }
        File__write_char(self, ')')
    } else {
        File__write_checked_type(self, parameter.type)
        if (parameter.name != null) {
            File__write_char(self, ' ')
            File__write_string(self, parameter.name)
        }
    }
}

func File__write_checked_type(self: File*, type: Checked_Type*) -> void {
    if (type == null) {
        File__write_cstring(self, "null")
    } else if (type.kind == Checked_Type_Kind.I16) {
        File__write_cstring(self, "int16_t")
    } else if (type.kind == Checked_Type_Kind.I32) {
        File__write_cstring(self, "int32_t")
    } else if (type.kind == Checked_Type_Kind.I64) {
        File__write_cstring(self, "int64_t")
    } else if (type.kind == Checked_Type_Kind.I8) {
        File__write_cstring(self, "int8_t")
    } else if (type.kind == Checked_Type_Kind.U16) {
        File__write_cstring(self, "uint16_t")
    } else if (type.kind == Checked_Type_Kind.U32) {
        File__write_cstring(self, "uint32_t")
    } else if (type.kind == Checked_Type_Kind.U64) {
        File__write_cstring(self, "uint64_t")
    } else if (type.kind == Checked_Type_Kind.U8) {
        File__write_cstring(self, "uint8_t")
    } else if (type.kind == Checked_Type_Kind.USIZE) {
        File__write_cstring(self, "size_t")
    } else if (type.kind <= Checked_Type_Kind.NULL) {
        let named_type = type.as(Checked_Named_Type*)
        File__write_string(self, named_type.name)
    } else if (type.kind == Checked_Type_Kind.STRUCT) {
        let struct_type = type.as(Checked_Struct_Type*)
        File__write_cstring(self, "struct ")
        File__write_string(self, struct_type.name)
    } else if (type.kind == Checked_Type_Kind.OPAQUE) {
        let opaque_type = type.as(Checked_Opaque_Type*)
        File__write_cstring(self, "struct ")
        File__write_string(self, opaque_type.name)
    } else if (type.kind == Checked_Type_Kind.ENUM) {
        let enum_type = type.as(Checked_Enum_Type*)
        File__write_cstring(self, "enum ")
        File__write_string(self, enum_type.name)
    } else if (type.kind == Checked_Type_Kind.POINTER) {
        let pointer_type = type.as(Checked_Pointer_Type*)
        File__write_checked_type(self, pointer_type.other_type)
        File__write_char(self, '*')
    } else {
        Source_Location__error(type.location, String__create_from("Unsupported type"))
        abort()
    }
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Checked Symbols
\ ---------------------------------------------------------------------------------------------------------------------

enum Checked_Symbol_Kind {
    ENUM_MEMBER
    FUNCTION
    FUNCTION_PARAMETER
    TYPE
    VARIABLE
}

struct Checked_Symbol {
    kind: Checked_Symbol_Kind
    location: Source_Location*
    name: String*
    type: Checked_Type*
    prev_symbol: Checked_Symbol*
    next_symbol: Checked_Symbol*
}

func Checked_Symbol__create_kind(kind: Checked_Symbol_Kind, kind_size: usize, location: Source_Location*, name: String*, type: Checked_Type*) -> Checked_Symbol* {
    let symbol = malloc(kind_size).as(Checked_Symbol*)
    symbol.kind = kind
    symbol.location = location
    symbol.name = name
    symbol.type = type
    symbol.prev_symbol = null
    symbol.next_symbol = null
    return symbol
}

struct Checked_Enum_Member_Symbol {
    super: Checked_Symbol
}

func Checked_Enum_Member_Symbol__create(location: Source_Location*, name: String*, type: Checked_Type*) -> Checked_Enum_Member_Symbol* {
    return Checked_Symbol__create_kind(Checked_Symbol_Kind.ENUM_MEMBER, sizeof(Checked_Enum_Member_Symbol), location, name, type).as(Checked_Enum_Member_Symbol*)
}

struct Checked_Function_Symbol {
    super: Checked_Symbol
    function_type: Checked_Function_Type*
    checked_statements: Checked_Statements*
}

func Checked_Function_Symbol__create(location: Source_Location*, name: String*, function_type: Checked_Function_Type*) -> Checked_Function_Symbol* {
    let symbol = Checked_Symbol__create_kind(Checked_Symbol_Kind.FUNCTION, sizeof(Checked_Function_Symbol), location, name, function_type.as(Checked_Type*)).as(Checked_Function_Symbol*)
    symbol.function_type = function_type
    symbol.checked_statements = null
    return symbol
}

struct Checked_Function_Parameter_Symbol {
    super: Checked_Symbol
}

func Checked_Function_Parameter_Symbol__create(location: Source_Location*, name: String*, type: Checked_Type*) -> Checked_Function_Parameter_Symbol* {
    return Checked_Symbol__create_kind(Checked_Symbol_Kind.FUNCTION_PARAMETER, sizeof(Checked_Function_Parameter_Symbol), location, name, type).as(Checked_Function_Parameter_Symbol*)
}

struct Checked_Type_Symbol {
    super: Checked_Symbol
    named_type: Checked_Named_Type*
}

func Checked_Type_Symbol__create(location: Source_Location*, name: String*, named_type: Checked_Named_Type*) -> Checked_Type_Symbol* {
    let symbol = Checked_Symbol__create_kind(Checked_Symbol_Kind.TYPE, sizeof(Checked_Type_Symbol), location, name, Checked_Defined_Type__create(named_type).as(Checked_Type*)).as(Checked_Type_Symbol*)
    symbol.named_type = named_type
    return symbol
}

struct Checked_Variable_Symbol {
    super: Checked_Symbol
}

func Checked_Variable__create(location: Source_Location*, name: String*, type: Checked_Type*) -> Checked_Variable_Symbol* {
    return Checked_Symbol__create_kind(Checked_Symbol_Kind.VARIABLE, sizeof(Checked_Variable_Symbol), location, name, type).as(Checked_Variable_Symbol*)
}

struct Checked_Symbols {
    parent: Checked_Symbols*
    first_symbol: Checked_Symbol*
    last_symbol: Checked_Symbol*
}

func Checked_Symbols__create(parent: Checked_Symbols*) -> Checked_Symbols* {
    let symbols = malloc(sizeof(Checked_Symbols)).as(Checked_Symbols*)
    symbols.parent = parent
    symbols.first_symbol = null
    symbols.last_symbol = null
    return symbols
}

func Checked_Symbols__find_sibling_symbol(self: Checked_Symbols*, name: String*) -> Checked_Symbol* {
    let symbol = self.first_symbol
    while (symbol != null) {
        if (String__equals_string(name, symbol.name)) {
            return symbol
        }
        symbol = symbol.next_symbol
    }
    return null
}

func Checked_Symbols__append_symbol(self: Checked_Symbols*, symbol: Checked_Symbol*) -> void {
    let other_symbol = Checked_Symbols__find_sibling_symbol(self, symbol.name)
    if (other_symbol != null) {
        Source_Location__error(symbol.location, String__append_source_location(String__create_from("Symbol declared first here: "), other_symbol.location))
        abort()
    }

    if (self.last_symbol == null) {
        self.first_symbol = symbol
    } else {
        self.last_symbol.next_symbol = symbol
        symbol.prev_symbol = self.last_symbol
    }
    self.last_symbol = symbol
}

func Checked_Symbols__find_symbol(self: Checked_Symbols*, name: String*) -> Checked_Symbol* {
    let symbol = self.last_symbol
    while (symbol != null) {
        if (String__equals_string(name, symbol.name)) {
            return symbol
        }
        symbol = symbol.prev_symbol
    }
    if (self.parent != null) {
        return Checked_Symbols__find_symbol(self.parent, name)
    }
    return null
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Checked Expressions
\ ---------------------------------------------------------------------------------------------------------------------

enum Checked_Expression_Kind {
    ADD
    ADDRESS_OF
    ARRAY_ACCESS
    BOOL
    CALL
    CAST
    CHARACTER
    DEREFERENCE
    DIVIDE
    EQUALS
    GREATER
    GREATER_OR_EQUALS
    GROUP
    INTEGER
    LESS
    LESS_OR_EQUALS
    LOGIC_AND
    LOGIC_OR
    MEMBER_ACCESS
    MINUS
    MODULO
    MULTIPLY
    NOT
    NOT_EQUALS
    NULL
    SIZEOF
    STRING
    SUBSTRACT
    SYMBOL
}

struct Checked_Expression {
    kind: Checked_Expression_Kind
    location: Source_Location*
    type: Checked_Type*
}

func Checked_Expression__create_kind(kind: Checked_Expression_Kind, kind_size: usize, location: Source_Location*, type: Checked_Type*) -> Checked_Expression* {
    let expression = malloc(kind_size).as(Checked_Expression*)
    expression.kind = kind
    expression.location = location
    expression.type = type
    return expression
}

struct Checked_Binary_Expression {
    super: Checked_Expression
    left_expression: Checked_Expression*
    right_expression: Checked_Expression*
}

func Checked_Binary_Expression__create_kind(kind: Checked_Expression_Kind, location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Binary_Expression* {
    let expression = Checked_Expression__create_kind(kind, sizeof(Checked_Binary_Expression), location, type).as(Checked_Binary_Expression*)
    expression.left_expression = left_expression
    expression.right_expression = right_expression
    return expression
}

struct Checked_Unary_Expression {
    super: Checked_Expression
    other_expression: Checked_Expression*
}

func Checked_Unary_Expression__create_kind(kind: Checked_Expression_Kind, kind_size: usize, location: Source_Location*, type: Checked_Type*, other_expression: Checked_Expression*) -> Checked_Unary_Expression* {
    let expression = Checked_Expression__create_kind(kind, kind_size, location, type).as(Checked_Unary_Expression*)
    expression.other_expression = other_expression
    return expression
}

struct Checked_Add_Expression {
    super: Checked_Binary_Expression
}

func Checked_Add_Expression__create(location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Add_Expression* {
    return Checked_Binary_Expression__create_kind(Checked_Expression_Kind.ADD, location, type, left_expression, right_expression).as(Checked_Add_Expression*)
}

struct Checked_Address_Of_Expression {
    super: Checked_Unary_Expression
}

func Checked_Address_Of_Expression__create(location: Source_Location*, type: Checked_Type*, other_expression: Checked_Expression*) -> Checked_Address_Of_Expression* {
    return Checked_Unary_Expression__create_kind(Checked_Expression_Kind.ADDRESS_OF, sizeof(Checked_Address_Of_Expression), location, type, other_expression).as(Checked_Address_Of_Expression*)
}

struct Checked_Array_Access_Expression {
    super: Checked_Expression
    array_expression: Checked_Expression*
    index_expression: Checked_Expression*
}

func Checked_Array_Access_Expression__create(location: Source_Location*, type: Checked_Type*, array_expression: Checked_Expression*, index_expression: Checked_Expression*) -> Checked_Array_Access_Expression* {
    let expression = Checked_Expression__create_kind(Checked_Expression_Kind.ARRAY_ACCESS, sizeof(Checked_Array_Access_Expression), location, type).as(Checked_Array_Access_Expression*)
    expression.array_expression = array_expression
    expression.index_expression = index_expression
    return expression
}

struct Checked_Bool_Expression {
    super: Checked_Expression
    value: bool
}

func Checked_Bool_Expression__create(location: Source_Location*, type: Checked_Type*, value: bool) -> Checked_Bool_Expression* {
    let expression = Checked_Expression__create_kind(Checked_Expression_Kind.BOOL, sizeof(Checked_Bool_Expression), location, type).as(Checked_Bool_Expression*)
    expression.value = value
    return expression
}

struct Checked_Call_Argument {
    expression: Checked_Expression*
    next_argument: Checked_Call_Argument*
}

func Checked_Call_Argument__create(expression: Checked_Expression*) -> Checked_Call_Argument* {
    let argument = malloc(sizeof(Checked_Call_Argument)).as(Checked_Call_Argument*)
    argument.expression = expression
    argument.next_argument = null
    return argument
}

struct Checked_Call_Expression {
    super: Checked_Expression
    callee_expression: Checked_Expression*
    first_argument: Checked_Call_Argument*
}

func Checked_Call_Expression__create(location: Source_Location*, type: Checked_Type*, callee_expression: Checked_Expression*, first_argument: Checked_Call_Argument*) -> Checked_Call_Expression* {
    let expression = Checked_Expression__create_kind(Checked_Expression_Kind.CALL, sizeof(Checked_Call_Expression), location, type).as(Checked_Call_Expression*)
    expression.callee_expression = callee_expression
    expression.first_argument = first_argument
    return expression
}

struct Checked_Cast_Expression {
    super: Checked_Expression
    other_expression: Checked_Expression*
}

func Checked_Cast_Expression__create(location: Source_Location*, type: Checked_Type*, other_expression: Checked_Expression*) -> Checked_Cast_Expression* {
    let expression = Checked_Expression__create_kind(Checked_Expression_Kind.CAST, sizeof(Checked_Cast_Expression), location, type).as(Checked_Cast_Expression*)
    expression.other_expression = other_expression
    return expression
}

struct Checked_Character_Expression {
    super: Checked_Expression
    value: char
}

func Checked_Character_Expression__create(location: Source_Location*, type: Checked_Type*, value: char) -> Checked_Character_Expression* {
    let expression = Checked_Expression__create_kind(Checked_Expression_Kind.CHARACTER, sizeof(Checked_Character_Expression), location, type).as(Checked_Character_Expression*)
    expression.value = value
    return expression
}

struct Checked_Dereference_Expression {
    super: Checked_Expression
    value_expression: Checked_Expression*
}

func Checked_Dereference_Expression__create(location: Source_Location*, type: Checked_Type*, value_expression: Checked_Expression*) -> Checked_Dereference_Expression* {
    let expression = Checked_Expression__create_kind(Checked_Expression_Kind.DEREFERENCE, sizeof(Checked_Dereference_Expression), location, type).as(Checked_Dereference_Expression*)
    expression.value_expression = value_expression
    return expression
}

struct Checked_Divide_Expression {
    super: Checked_Binary_Expression
}

func Checked_Divide_Expression__create(location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Divide_Expression* {
    return Checked_Binary_Expression__create_kind(Checked_Expression_Kind.DIVIDE, location, type, left_expression, right_expression).as(Checked_Divide_Expression*)
}

struct Checked_Equals_Expression {
    super: Checked_Binary_Expression
}

func Checked_Equals_Expression__create(location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Equals_Expression* {
    return Checked_Binary_Expression__create_kind(Checked_Expression_Kind.EQUALS, location, type, left_expression, right_expression).as(Checked_Equals_Expression*)
}

struct Checked_Greater_Expression {
    super: Checked_Binary_Expression
}

func Checked_Greater_Expression__create(location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Greater_Expression* {
    return Checked_Binary_Expression__create_kind(Checked_Expression_Kind.GREATER, location, type, left_expression, right_expression).as(Checked_Greater_Expression*)
}

struct Checked_Greater_Or_Equals_Expression {
    super: Checked_Binary_Expression
}

func Checked_Greater_Or_Equals_Expression__create(location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Greater_Or_Equals_Expression* {
    return Checked_Binary_Expression__create_kind(Checked_Expression_Kind.GREATER_OR_EQUALS, location, type, left_expression, right_expression).as(Checked_Greater_Or_Equals_Expression*)
}

struct Checked_Group_Expression {
    super: Checked_Expression
    other_expression: Checked_Expression*
}

func Checked_Group_Expression__create(location: Source_Location*, type: Checked_Type*, other_expression: Checked_Expression*) -> Checked_Group_Expression* {
    let expression = Checked_Expression__create_kind(Checked_Expression_Kind.GROUP, sizeof(Checked_Group_Expression), location, type).as(Checked_Group_Expression*)
    expression.other_expression = other_expression
    return expression
}

struct Checked_Integer_Expression {
    super: Checked_Expression
    value: u64
}

func Checked_Integer_Expression__create(location: Source_Location*, type: Checked_Type*, value: u64) -> Checked_Integer_Expression* {
    let expression = Checked_Expression__create_kind(Checked_Expression_Kind.INTEGER, sizeof(Checked_Integer_Expression), location, type).as(Checked_Integer_Expression*)
    expression.value = value
    return expression
}

struct Checked_Less_Expression {
    super: Checked_Binary_Expression
}

func Checked_Less_Expression__create(location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Less_Expression* {
    return Checked_Binary_Expression__create_kind(Checked_Expression_Kind.LESS, location, type, left_expression, right_expression).as(Checked_Less_Expression*)
}

struct Checked_Less_Or_Equals_Expression {
    super: Checked_Binary_Expression
}

func Checked_Less_Or_Equals_Expression__create(location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Less_Or_Equals_Expression* {
    return Checked_Binary_Expression__create_kind(Checked_Expression_Kind.LESS_OR_EQUALS, location, type, left_expression, right_expression).as(Checked_Less_Or_Equals_Expression*)
}

struct Checked_Logic_And_Expression {
    super: Checked_Binary_Expression
}

func Checked_Logic_And_Expression__create(location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Logic_And_Expression* {
    return Checked_Binary_Expression__create_kind(Checked_Expression_Kind.LOGIC_AND, location, type, left_expression, right_expression).as(Checked_Logic_And_Expression*)
}

struct Checked_Logic_Or_Expression {
    super: Checked_Binary_Expression
}

func Checked_Logic_Or_Expression__create(location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Logic_Or_Expression* {
    return Checked_Binary_Expression__create_kind(Checked_Expression_Kind.LOGIC_OR, location, type, left_expression, right_expression).as(Checked_Logic_Or_Expression*)
}

struct Checked_Member_Access_Expression {
    super: Checked_Expression
    object_expression: Checked_Expression*
    member: Checked_Struct_Member*
}

func Checked_Member_Access_Expression__create(location: Source_Location*, type: Checked_Type*, object_expression: Checked_Expression*, member: Checked_Struct_Member*) -> Checked_Member_Access_Expression* {
    let expression = Checked_Expression__create_kind(Checked_Expression_Kind.MEMBER_ACCESS, sizeof(Checked_Member_Access_Expression), location, type).as(Checked_Member_Access_Expression*)
    expression.object_expression = object_expression
    expression.member = member
    return expression
}

struct Checked_Minus_Expression {
    super: Checked_Unary_Expression
}

func Checked_Minus_Expression__create(location: Source_Location*, type: Checked_Type*, other_expression: Checked_Expression*) -> Checked_Minus_Expression* {
    return Checked_Unary_Expression__create_kind(Checked_Expression_Kind.MINUS, sizeof(Checked_Minus_Expression), location, type, other_expression).as(Checked_Minus_Expression*)
}

struct Checked_Modulo_Expression {
    super: Checked_Binary_Expression
}

func Checked_Modulo_Expression__create(location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Modulo_Expression* {
    return Checked_Binary_Expression__create_kind(Checked_Expression_Kind.MODULO, location, type, left_expression, right_expression).as(Checked_Modulo_Expression*)
}

struct Checked_Multiply_Expression {
    super: Checked_Binary_Expression
}

func Checked_Multiply_Expression__create(location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Multiply_Expression* {
    return Checked_Binary_Expression__create_kind(Checked_Expression_Kind.MULTIPLY, location, type, left_expression, right_expression).as(Checked_Multiply_Expression*)
}

struct Checked_Not_Expression {
    super: Checked_Unary_Expression
}

func Checked_Not_Expression__create(location: Source_Location*, type: Checked_Type*, other_expression: Checked_Expression*) -> Checked_Not_Expression* {
    return Checked_Unary_Expression__create_kind(Checked_Expression_Kind.NOT, sizeof(Checked_Not_Expression), location, type, other_expression).as(Checked_Not_Expression*)
}

struct Checked_Not_Equals_Expression {
    super: Checked_Binary_Expression
}

func Checked_Not_Equals_Expression__create(location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Not_Equals_Expression* {
    return Checked_Binary_Expression__create_kind(Checked_Expression_Kind.NOT_EQUALS, location, type, left_expression, right_expression).as(Checked_Not_Equals_Expression*)
}

struct Checked_Null_Expression {
    super: Checked_Expression
}

func Checked_Null_Expression__create(location: Source_Location*, type: Checked_Type*) -> Checked_Null_Expression* {
    return Checked_Expression__create_kind(Checked_Expression_Kind.NULL, sizeof(Checked_Null_Expression), location, type).as(Checked_Null_Expression*)
}

struct Checked_Sizeof_Expression {
    super: Checked_Expression
    sized_type: Checked_Type*
}

func Checked_Sizeof_Expression__create(location: Source_Location*, type: Checked_Type*, sized_type: Checked_Type*) -> Checked_Sizeof_Expression* {
    let expression = Checked_Expression__create_kind(Checked_Expression_Kind.SIZEOF, sizeof(Checked_Sizeof_Expression), location, type).as(Checked_Sizeof_Expression*)
    expression.sized_type = sized_type
    return expression
}

struct Checked_String_Expression {
    super: Checked_Expression
    value: String*
}

func Checked_String_Expression__create(location: Source_Location*, type: Checked_Type*, value: String*) -> Checked_String_Expression* {
    let expression = Checked_Expression__create_kind(Checked_Expression_Kind.STRING, sizeof(Checked_String_Expression), location, type).as(Checked_String_Expression*)
    expression.value = value
    return expression
}

struct Checked_Substract_Expression {
    super: Checked_Binary_Expression
}

func Checked_Substract_Expression__create(location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Substract_Expression* {
    return Checked_Binary_Expression__create_kind(Checked_Expression_Kind.SUBSTRACT, location, type, left_expression, right_expression).as(Checked_Substract_Expression*)
}

struct Checked_Symbol_Expression {
    super: Checked_Expression
    symbol: Checked_Symbol*
}

func Checked_Symbol_Expression__create(location: Source_Location*, type: Checked_Type*, symbol: Checked_Symbol*) -> Checked_Symbol_Expression* {
    let expression = Checked_Expression__create_kind(Checked_Expression_Kind.SYMBOL, sizeof(Checked_Symbol_Expression), location, type).as(Checked_Symbol_Expression*)
    expression.symbol = symbol
    return expression
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Checked Statements
\ ---------------------------------------------------------------------------------------------------------------------

enum Checked_Statement_Kind {
    ASSIGNMENT
    BLOCK
    BREAK
    EXPRESSION
    GOTO
    IF
    LABEL
    RETURN
    VARIABLE
    WHILE
}

struct Checked_Statement {
    kind: Checked_Statement_Kind
    location: Source_Location*
    next_statement: Checked_Statement*
}

func Checked_Statement__create_kind(kind: Checked_Statement_Kind, kind_size: usize, location: Source_Location*) -> Checked_Statement* {
    let statement = malloc(kind_size).as(Checked_Statement*)
    statement.kind = kind
    statement.location = location
    statement.next_statement = null
    return statement
}

struct Checked_Assignment_Statement {
    super: Checked_Statement
    object_expression: Checked_Expression*
    value_expression: Checked_Expression*
}

func Checked_Assignment_Statement__create(location: Source_Location*, object_expression: Checked_Expression*, value_expression: Checked_Expression*) -> Checked_Assignment_Statement* {
    let statement = Checked_Statement__create_kind(Checked_Statement_Kind.ASSIGNMENT, sizeof(Checked_Assignment_Statement), location).as(Checked_Assignment_Statement*)
    statement.object_expression = object_expression
    statement.value_expression = value_expression
    return statement
}

struct Checked_Block_Statement {
    super: Checked_Statement
    context: Checker_Context*
    label: String*
}

func Checked_Block_Statement__create(location: Source_Location*, context: Checker_Context*, label: String*) -> Checked_Block_Statement* {
    let statement = Checked_Statement__create_kind(Checked_Statement_Kind.BLOCK, sizeof(Checked_Block_Statement), location).as(Checked_Block_Statement*)
    statement.context = context
    statement.label = label
    return statement
}

struct Checked_Break_Statement {
    super: Checked_Statement
}

func Checked_Break_Statement__create(location: Source_Location*) -> Checked_Break_Statement* {
    return Checked_Statement__create_kind(Checked_Statement_Kind.BREAK, sizeof(Checked_Break_Statement), location).as(Checked_Break_Statement*)
}

struct Checked_Expression_Statement {
    super: Checked_Statement
    expression: Checked_Expression*
}

func Checked_Expression_Statement__create(location: Source_Location*, expression: Checked_Expression*) -> Checked_Expression_Statement* {
    let statement = Checked_Statement__create_kind(Checked_Statement_Kind.EXPRESSION, sizeof(Checked_Expression_Statement), location).as(Checked_Expression_Statement*)
    statement.expression = expression
    return statement
}

struct Checked_Goto_Statement {
    super: Checked_Statement
    label: String*
}

func Checked_Goto_Statement__create(location: Source_Location*, label: String*) -> Checked_Goto_Statement* {
    let statement = Checked_Statement__create_kind(Checked_Statement_Kind.GOTO, sizeof(Checked_Goto_Statement), location).as(Checked_Goto_Statement*)
    statement.label = label
    return statement
}

struct Checked_If_Statement {
    super: Checked_Statement
    condition_expression: Checked_Expression*
    true_statement: Checked_Statement*
    false_statement: Checked_Statement*
}

func Checked_If_Statement__create(location: Source_Location*, condition_expression: Checked_Expression*, true_statement: Checked_Statement*, false_statement: Checked_Statement*) -> Checked_If_Statement* {
    let statement = Checked_Statement__create_kind(Checked_Statement_Kind.IF, sizeof(Checked_If_Statement), location).as(Checked_If_Statement*)
    statement.condition_expression = condition_expression
    statement.true_statement = true_statement
    statement.false_statement = false_statement
    return statement
}

struct Checked_Label_Statement {
    super: Checked_Statement
    label: String*
}

func Checked_Label_Statement__create(location: Source_Location*, label: String*) -> Checked_Label_Statement* {
    let statement = Checked_Statement__create_kind(Checked_Statement_Kind.LABEL, sizeof(Checked_Label_Statement), location).as(Checked_Label_Statement*)
    statement.label = label
    return statement
}

struct Checked_Return_Statement {
    super: Checked_Statement
    expression: Checked_Expression*
}

func Checked_Return_Statement__create(location: Source_Location*, expression: Checked_Expression*) -> Checked_Return_Statement* {
    let statement = Checked_Statement__create_kind(Checked_Statement_Kind.RETURN, sizeof(Checked_Return_Statement), location).as(Checked_Return_Statement*)
    statement.expression = expression
    return statement
}

struct Checked_Variable_Statement {
    super: Checked_Statement
    variable: Checked_Variable_Symbol*
    expression: Checked_Expression*
    is_external: bool
}

func Checked_Variable_Statement__create(location: Source_Location*, variable: Checked_Variable_Symbol*, expression: Checked_Expression*, is_external: bool) -> Checked_Variable_Statement* {
    let statement = Checked_Statement__create_kind(Checked_Statement_Kind.VARIABLE, sizeof(Checked_Variable_Statement), location).as(Checked_Variable_Statement*)
    statement.variable = variable
    statement.expression = expression
    statement.is_external = is_external
    return statement
}

struct Checked_While_Statement {
    super: Checked_Statement
    condition_expression: Checked_Expression*
    body_statement: Checked_Statement*
}

func Checked_While_Statement__create(location: Source_Location*, condition_expression: Checked_Expression*, body_statement: Checked_Statement*) -> Checked_While_Statement* {
    let statement = Checked_Statement__create_kind(Checked_Statement_Kind.WHILE, sizeof(Checked_While_Statement), location).as(Checked_While_Statement*)
    statement.condition_expression = condition_expression
    statement.body_statement = body_statement
    return statement
}

struct Checked_Statements {
    symbols: Checked_Symbols*
    first_statement: Checked_Statement*
    last_statement: Checked_Statement*
}

func Checked_Statements__create(symbols: Checked_Symbols*) -> Checked_Statements* {
    let statements = malloc(sizeof(Checked_Statements)).as(Checked_Statements*)
    statements.symbols = symbols
    statements.first_statement = null
    statements.last_statement = null
    return statements
}

func Checked_Statements__append(self: Checked_Statements*, statement: Checked_Statement*) -> void {
    if (self.first_statement == null) {
        self.first_statement = statement
    } else {
        self.last_statement.next_statement = statement
    }
    self.last_statement = statement
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Checked Source
\ ---------------------------------------------------------------------------------------------------------------------

struct Checked_Source {
    first_symbol: Checked_Symbol*
    statements: Checked_Statements*
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Checker
\ ---------------------------------------------------------------------------------------------------------------------

struct Checker_Context {
    parent: Checker_Context*
    symbols: Checked_Symbols*
    statements: Checked_Statements*

    function_counter: Counter*
    function_return_type: Checked_Type*
}

func Checker_Context__create(parent: Checker_Context*) -> Checker_Context* {
    let context = malloc(sizeof(Checker_Context)).as(Checker_Context*)
    context.parent = parent
    if (parent == null) {
        context.symbols = Checked_Symbols__create(null)
        context.function_counter = Counter__create()
        context.function_return_type = null
    } else {
        context.symbols = Checked_Symbols__create(parent.symbols)
        context.function_counter = parent.function_counter
        context.function_return_type = parent.function_return_type
    }
    context.statements = Checked_Statements__create(context.symbols)
    return context
}

struct Checker {
    first_type: Checked_Named_Type*
    last_type: Checked_Named_Type*
    last_builting_type: Checked_Named_Type*

    root_context: Checker_Context*
    current_context: Checker_Context*
}

func Checker__create() -> Checker* {
    let checker = malloc(sizeof(Checker)).as(Checker*)
    checker.first_type = null
    checker.last_type = null
    checker.root_context = Checker_Context__create(null)
    checker.current_context = checker.root_context

    let location = Source_Location__create(null, 0.as(u16), 1.as(u16))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.BOOL, sizeof(Checked_Named_Type), location, String__create_from("bool")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.CHAR, sizeof(Checked_Named_Type), location, String__create_from("char")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.I16, sizeof(Checked_Named_Type), location, String__create_from("i16")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.I32, sizeof(Checked_Named_Type), location, String__create_from("i32")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.I64, sizeof(Checked_Named_Type), location, String__create_from("i64")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.I8, sizeof(Checked_Named_Type), location, String__create_from("i8")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.U16, sizeof(Checked_Named_Type), location, String__create_from("u16")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.U32, sizeof(Checked_Named_Type), location, String__create_from("u32")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.U64, sizeof(Checked_Named_Type), location, String__create_from("u64")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.U8, sizeof(Checked_Named_Type), location, String__create_from("u8")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.USIZE, sizeof(Checked_Named_Type), location, String__create_from("usize")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.VOID, sizeof(Checked_Named_Type), location, String__create_from("void")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.NULL, sizeof(Checked_Named_Type), location, String__create_from("null")))
    checker.last_builting_type = checker.last_type

    return checker
}

func Checker__append_type(self: Checker*, type: Checked_Named_Type*) -> void {
    if (self.first_type == null) {
        self.first_type = type
    } else {
        self.last_type.next_type = type.as(Checked_Type*)
    }
    self.last_type = type

    Checked_Symbols__append_symbol(self.root_context.symbols, Checked_Type_Symbol__create(type.location, type.name, type).as(Checked_Symbol*))
}

func Checker__find_type(self: Checker*, name: String*) -> Checked_Named_Type* {
    let type = self.first_type
    while (type != null) {
        if (String__equals_string(name, type.name)) {
            break
        }
        type = type.next_type.as(Checked_Named_Type*)
    }
    return type
}

func Checker__get_builtin_type(self: Checker*, kind: Checked_Type_Kind) -> Checked_Named_Type* {
    let type = self.first_type
    let custom_type = self.last_builting_type.next_type.as(Checked_Named_Type*)
    while (type != custom_type) {
        if (type.kind == kind) {
            return type
        }
        type = type.next_type.as(Checked_Named_Type*)
    }
    error(String__create_from("No such builtin type"))
    abort()
}

func Checker__resolve_type(self: Checker*, parsed_type: Parsed_Type*) -> Checked_Type* {
    if (parsed_type.kind == Parsed_Type_Kind.NAMED) {
        let type = Checker__find_type(self, parsed_type.as(Parsed_Named_Type*).name)
        if (type != null) {
            return type.as(Checked_Type*)
        }
    }
    if (parsed_type.kind == Parsed_Type_Kind.POINTER) {
        return Checked_Pointer_Type__create(parsed_type.location, Checker__resolve_type(self, parsed_type.as(Parsed_Pointer_Type*).other_type)).as(Checked_Type*)
    }
    if (parsed_type.kind == Parsed_Type_Kind.STRUCT) {
        let type = Checker__resolve_type(self, parsed_type.as(Parsed_Struct_Type*).other_type)
        if (type.kind != Checked_Type_Kind.STRUCT) {
            TODO("Report unexpected type")
            abort()
        }
        return type
    }
    if (parsed_type.kind == Parsed_Type_Kind.FUNCTION) {
        let parsed_function_type = parsed_type.as(Parsed_Function_Type*)
        let first_parameter: Checked_Function_Parameter* = null
        let parsed_parameter = parsed_function_type.first_parameter
        if (parsed_parameter != null) {
            first_parameter = Checked_Function_Parameter__create(parsed_parameter.location, null, Checker__resolve_type(self, parsed_parameter.type))
            let last_parameter = first_parameter
            parsed_parameter = parsed_parameter.next_parameter
            while (parsed_parameter != null) {
                let parameter = Checked_Function_Parameter__create(parsed_parameter.location, null, Checker__resolve_type(self, parsed_parameter.type))
                last_parameter.next_parameter = parameter
                last_parameter = parameter
                parsed_parameter = parsed_parameter.next_parameter
            }
        }
        let return_type = Checker__resolve_type(self, parsed_function_type.return_type)
        return Checked_Function_Type__create(parsed_type.location, first_parameter, return_type).as(Checked_Type*)
    }
    Source_Location__error(parsed_type.location, String__create_from("Undefined type"))
    abort()
}

func Checker__check_add_expression(self: Checker*, parsed_expression: Parsed_Add_Expression*) -> Checked_Expression* {
    let left_expression = Checker__check_expression(self, parsed_expression.left_expression)
    Checked_Type__expect_scalar_type(left_expression.type, left_expression.location)
    let right_expression = Checker__check_expression(self, parsed_expression.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return Checked_Add_Expression__create(parsed_expression.location, left_expression.type, left_expression, right_expression).as(Checked_Expression*)
}

func Checker__check_address_of_expression(self: Checker*, parsed_expression: Parsed_Address_Of_Expression*) -> Checked_Expression* {
    let other_expression = Checker__check_expression(self, parsed_expression.other_expression)
    if (other_expression.kind != Checked_Expression_Kind.SYMBOL) {
        Source_Location__error(parsed_expression.location, String__create_from("Not a symbol"))
        abort()
    }
    return Checked_Address_Of_Expression__create(parsed_expression.location, Checked_Pointer_Type__create(other_expression.location, other_expression.type).as(Checked_Type*), other_expression).as(Checked_Expression*)
}

func Checker__check_array_access_expression(self: Checker*, parsed_expression: Parsed_Array_Access_Expression*) -> Checked_Expression* {
    let array_expression = Checker__check_expression(self, parsed_expression.array_expression)
    let array_type = array_expression.type
    if (array_type.kind != Checked_Type_Kind.POINTER) {
        let message = String__create()
        String__append_char(message, '"')
        String__append_checked_type(message, array_type)
        String__append_cstring(message, "\" is not a pointer type.")
        Source_Location__error(parsed_expression.array_expression.location, message)
        abort()
    }
    let type = array_type.as(Checked_Pointer_Type*).other_type
    let index_expression = Checker__check_expression(self, parsed_expression.index_expression)
    Checked_Type__expect_same_type(Checker__get_builtin_type(self, Checked_Type_Kind.USIZE).as(Checked_Type*), index_expression.type, index_expression.location)
    return Checked_Array_Access_Expression__create(parsed_expression.location, type, array_expression, index_expression).as(Checked_Expression*)
}

func Checker__check_bool_expression(self: Checker*, parsed_expression: Parsed_Bool_Expression*) -> Checked_Expression* {
    let expression_type = Checker__get_builtin_type(self, Checked_Type_Kind.BOOL).as(Checked_Type*)
    let value = parsed_expression.value
    return Checked_Bool_Expression__create(parsed_expression.location, expression_type, value).as(Checked_Expression*)
}

func Checker__check_call_expression(self: Checker*, parsed_expression: Parsed_Call_Expression*) -> Checked_Expression* {
    let callee_expression = Checker__check_expression(self, parsed_expression.callee_expression)
    let callee_type = callee_expression.type
    if (callee_type.kind != Checked_Type_Kind.FUNCTION) {
        Source_Location__error(parsed_expression.location, String__create_from("Not a function"))
        abort()
    }
    let function_type = callee_type.as(Checked_Function_Type*)
    let first_argument: Checked_Call_Argument* = null
    if (parsed_expression.first_argument != null || function_type.first_parameter != null) {
        let last_argument: Checked_Call_Argument* = null
        let function_parameter = function_type.first_parameter
        let parsed_argument = parsed_expression.first_argument
        while (function_parameter != null && parsed_argument != null) {
            let argument_expression = Checker__check_expression(self, parsed_argument.expression)
            Checked_Type__expect_same_type(function_parameter.type, argument_expression.type, argument_expression.location)
            if (argument_expression.kind == Checked_Expression_Kind.SYMBOL && argument_expression.as(Checked_Symbol_Expression*).symbol.kind == Checked_Symbol_Kind.FUNCTION) {
                TODO("Create callable expression stored in a temp variable")
            }
            let argument = Checked_Call_Argument__create(argument_expression)
            if (last_argument == null) {
                first_argument = argument
            } else {
                last_argument.next_argument = argument
            }
            last_argument = argument
            function_parameter = function_parameter.next_parameter
            parsed_argument = parsed_argument.next_argument
        }
        if (function_parameter != null) {
            Source_Location__error(parsed_expression.location, String__create_from("Report too few arguments"))
            abort()
        }
        if (parsed_argument != null) {
            Source_Location__error(parsed_expression.location, String__create_from("Report too many arguments"))
            abort()
        }
    }
    return Checked_Call_Expression__create(parsed_expression.location, function_type.return_type, callee_expression, first_argument).as(Checked_Expression*)
}

func Checker__check_cast_expression(self: Checker*, parsed_expression: Parsed_Cast_Expression*) -> Checked_Expression* {
    let type = Checker__resolve_type(self, parsed_expression.type)
    let other_expression = Checker__check_expression(self, parsed_expression.other_expression)
    let other_type = other_expression.type
    let can_cast = false
    if (type.kind == Checked_Type_Kind.POINTER) {
        if (other_type.kind == Checked_Type_Kind.POINTER) {
            can_cast = true
        }
    } else if (Checked_Type__is_scalar_type(type)) {
        if (Checked_Type__is_scalar_type(type)) {
            can_cast = true
        }
    }
    if (Checked_Type__equals(type, other_type)) {
        Source_Location__warning(parsed_expression.location, String__create_from("Redundant cast"))
    }
    if (!can_cast) {
        let message = String__create_from("Cannot cast \"")
        String__append_checked_type(message, other_expression.type)
        String__append_cstring(message, "\" to \"")
        String__append_checked_type(message, type)
        String__append_cstring(message, "\".")
        Source_Location__error(parsed_expression.location, message)
        abort()
    }
    return Checked_Cast_Expression__create(parsed_expression.location, type, other_expression).as(Checked_Expression*)
}

func Checker__check_character_expression(self: Checker*, parsed_expression: Parsed_Character_Expression*) -> Checked_Expression* {
    let expression_type = Checker__get_builtin_type(self, Checked_Type_Kind.CHAR).as(Checked_Type*)
    let value = parsed_expression.value
    return Checked_Character_Expression__create(parsed_expression.location, expression_type, value).as(Checked_Expression*)
}

func Checker__check_dereference_expression(self: Checker*, parsed_expression: Parsed_Dereference_Expression*) -> Checked_Expression* {
    let value_expression = Checker__check_expression(self, parsed_expression.value_expression)
    let value_type = value_expression.type
    if (value_type.kind != Checked_Type_Kind.POINTER) {
        Source_Location__error(parsed_expression.location, String__create_from("Not a pointer value"))
        abort()
    }
    return Checked_Dereference_Expression__create(parsed_expression.location, value_type.as(Checked_Pointer_Type*).other_type, value_expression).as(Checked_Expression*)
}

func Checker__check_divide_expression(self: Checker*, parsed_expression: Parsed_Divide_Expression*) -> Checked_Expression* {
    let left_expression = Checker__check_expression(self, parsed_expression.left_expression)
    Checked_Type__expect_scalar_type(left_expression.type, left_expression.location)
    let right_expression = Checker__check_expression(self, parsed_expression.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return Checked_Divide_Expression__create(parsed_expression.location, left_expression.type, left_expression, right_expression).as(Checked_Expression*)
}

func Checker__check_equals_expression(self: Checker*, parsed_expression: Parsed_Equals_Expression*) -> Checked_Expression* {
    let left_expression = Checker__check_expression(self, parsed_expression.left_expression)
    let right_expression = Checker__check_expression(self, parsed_expression.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return Checked_Equals_Expression__create(parsed_expression.location, Checker__get_builtin_type(self, Checked_Type_Kind.BOOL).as(Checked_Type*), left_expression, right_expression).as(Checked_Expression*)
}

func Checker__check_greater_expression(self: Checker*, parsed_expression: Parsed_Greater_Expression*) -> Checked_Expression* {
    let left_expression = Checker__check_expression(self, parsed_expression.left_expression)
    Checked_Type__expect_scalar_type(left_expression.type, left_expression.location)
    let right_expression = Checker__check_expression(self, parsed_expression.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return Checked_Greater_Expression__create(parsed_expression.location, Checker__get_builtin_type(self, Checked_Type_Kind.BOOL).as(Checked_Type*), left_expression, right_expression).as(Checked_Expression*)
}

func Checker__check_greater_or_equals_expression(self: Checker*, parsed_expression: Parsed_Greater_Or_Equals_Expression*) -> Checked_Expression* {
    let left_expression = Checker__check_expression(self, parsed_expression.left_expression)
    Checked_Type__expect_scalar_type(left_expression.type, left_expression.location)
    let right_expression = Checker__check_expression(self, parsed_expression.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return Checked_Greater_Or_Equals_Expression__create(parsed_expression.location, Checker__get_builtin_type(self, Checked_Type_Kind.BOOL).as(Checked_Type*), left_expression, right_expression).as(Checked_Expression*)
}

func Checker__check_group_expression(self: Checker*, parsed_expression: Parsed_Group_Expression*) -> Checked_Expression* {
    let other_expression = Checker__check_expression(self, parsed_expression.other_expression)
    return Checked_Group_Expression__create(parsed_expression.location, other_expression.type, other_expression).as(Checked_Expression*)
}

func Checker__check_integer_expression(self: Checker*, parsed_expression: Parsed_Integer_Expression*) -> Checked_Expression* {
    let expression_type = Checker__get_builtin_type(self, Checked_Type_Kind.I32).as(Checked_Type*)
    let value = parsed_expression.value
    return Checked_Integer_Expression__create(parsed_expression.location, expression_type, value).as(Checked_Expression*)
}

func Checker__check_less_expression(self: Checker*, parsed_expression: Parsed_Less_Expression*) -> Checked_Expression* {
    let left_expression = Checker__check_expression(self, parsed_expression.left_expression)
    Checked_Type__expect_scalar_type(left_expression.type, left_expression.location)
    let right_expression = Checker__check_expression(self, parsed_expression.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return Checked_Less_Expression__create(parsed_expression.location, Checker__get_builtin_type(self, Checked_Type_Kind.BOOL).as(Checked_Type*), left_expression, right_expression).as(Checked_Expression*)
}

func Checker__check_less_or_equals_expression(self: Checker*, parsed_expression: Parsed_Less_Or_Equals_Expression*) -> Checked_Expression* {
    let left_expression = Checker__check_expression(self, parsed_expression.left_expression)
    Checked_Type__expect_scalar_type(left_expression.type, left_expression.location)
    let right_expression = Checker__check_expression(self, parsed_expression.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return Checked_Less_Or_Equals_Expression__create(parsed_expression.location, Checker__get_builtin_type(self, Checked_Type_Kind.BOOL).as(Checked_Type*), left_expression, right_expression).as(Checked_Expression*)
}

func Checker__check_logic_and_expression(self: Checker*, parsed_expression: Parsed_Logic_And_Expression*) -> Checked_Expression* {
    let left_expression = Checker__check_expression(self, parsed_expression.left_expression)
    Checked_Type__expect_same_type(Checker__get_builtin_type(self, Checked_Type_Kind.BOOL).as(Checked_Type*), left_expression.type, left_expression.location)
    let right_expression = Checker__check_expression(self, parsed_expression.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return Checked_Logic_And_Expression__create(parsed_expression.location, left_expression.type, left_expression, right_expression).as(Checked_Expression*)
}

func Checker__check_logic_or_expression(self: Checker*, parsed_expression: Parsed_Logic_Or_Expression*) -> Checked_Expression* {
    let left_expression = Checker__check_expression(self, parsed_expression.left_expression)
    Checked_Type__expect_same_type(Checker__get_builtin_type(self, Checked_Type_Kind.BOOL).as(Checked_Type*), left_expression.type, left_expression.location)
    let right_expression = Checker__check_expression(self, parsed_expression.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return Checked_Logic_Or_Expression__create(parsed_expression.location, left_expression.type, left_expression, right_expression).as(Checked_Expression*)
}

func Checker__check_member_access_expression(self: Checker*, parsed_expression: Parsed_Member_Access_Expression*) -> Checked_Expression* {
    let object_expression = Checker__check_expression(self, parsed_expression.object_expression)
    let object_type = object_expression.type
    if (object_type.kind == Checked_Type_Kind.POINTER) {
        object_type = object_type.as(Checked_Pointer_Type*).other_type
        if (object_type.kind == Checked_Type_Kind.STRUCT) {
            return Checker__check_struct_member_access_expression(self, object_expression, object_type.as(Checked_Struct_Type*), parsed_expression.member_name)
        }
    } else if (object_type.kind == Checked_Type_Kind.STRUCT) {
        return Checker__check_struct_member_access_expression(self, object_expression, object_type.as(Checked_Struct_Type*), parsed_expression.member_name)
    } else if (object_type.kind == Checked_Type_Kind.DEFINED) {
        let defined_type = object_type.as(Checked_Defined_Type*).defined_type
        if (defined_type.kind == Checked_Type_Kind.ENUM) {
            let enum_type = defined_type.as(Checked_Enum_Type*)
            let enum_member = Checked_Enum_Type__find_member(enum_type, parsed_expression.member_name.lexeme)
            if (enum_member == null) {
                Source_Location__error(object_expression.location, String__create_from("No such enum members"))
                abort()
            }
            return Checked_Symbol_Expression__create(object_expression.location, enum_type.as(Checked_Type*), enum_member.symbol).as(Checked_Expression*)
        }
        Source_Location__error(object_expression.location, String__create_from("Type has no members"))
        abort()
    }
    Source_Location__error(object_expression.location, String__create_from("Unsupported type"))
    abort()
}

func Checker__check_struct_member_access_expression(self: Checker*, object_expression: Checked_Expression*, struct_type: Checked_Struct_Type*, member_name: Token*) -> Checked_Expression* {
    let member = Checked_Struct_Type__find_member(struct_type, member_name.lexeme)
    if (member == null) {
        if (struct_type.super_type != null) {
            object_expression = Checked_Member_Access_Expression__create(object_expression.location, struct_type.first_member.type, object_expression, struct_type.first_member).as(Checked_Expression*)
            return Checker__check_struct_member_access_expression(self, object_expression, struct_type.super_type, member_name)
        }
        Source_Location__error(member_name.location, String__create_from("No such struct member"))
        abort()
    }
    return Checked_Member_Access_Expression__create(object_expression.location, member.type, object_expression, member).as(Checked_Expression*)
}

func Checker__check_minus_expression(self: Checker*, parsed_expression: Parsed_Minus_Expression*) -> Checked_Expression* {
    let other_expression = Checker__check_expression(self, parsed_expression.other_expression)
    let other_expression_type = other_expression.type
    Checked_Type__expect_scalar_type(other_expression_type, other_expression.location)
    return Checked_Minus_Expression__create(parsed_expression.location, other_expression_type, other_expression).as(Checked_Expression*)
}

func Checker__check_modulo_expression(self: Checker*, parsed_expression: Parsed_Modulo_Expression*) -> Checked_Expression* {
    let left_expression = Checker__check_expression(self, parsed_expression.left_expression)
    Checked_Type__expect_scalar_type(left_expression.type, left_expression.location)
    let right_expression = Checker__check_expression(self, parsed_expression.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return Checked_Modulo_Expression__create(parsed_expression.location, left_expression.type, left_expression, right_expression).as(Checked_Expression*)
}

func Checker__check_multiply_expression(self: Checker*, parsed_expression: Parsed_Multiply_Expression*) -> Checked_Expression* {
    let left_expression = Checker__check_expression(self, parsed_expression.left_expression)
    Checked_Type__expect_scalar_type(left_expression.type, left_expression.location)
    let right_expression = Checker__check_expression(self, parsed_expression.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return Checked_Multiply_Expression__create(parsed_expression.location, left_expression.type, left_expression, right_expression).as(Checked_Expression*)
}

func Checker__check_not_expression(self: Checker*, parsed_expression: Parsed_Not_Expression*) -> Checked_Expression* {
    let other_expression = Checker__check_expression(self, parsed_expression.other_expression)
    let other_expression_type = other_expression.type
    Checked_Type__expect_same_type(Checker__get_builtin_type(self, Checked_Type_Kind.BOOL).as(Checked_Type*), other_expression_type, other_expression.location)
    return Checked_Not_Expression__create(parsed_expression.location, other_expression_type, other_expression).as(Checked_Expression*)
}

func Checker__check_not_equals_expression(self: Checker*, parsed_expression: Parsed_Not_Equals_Expression*) -> Checked_Expression* {
    let left_expression = Checker__check_expression(self, parsed_expression.left_expression)
    let right_expression = Checker__check_expression(self, parsed_expression.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return Checked_Not_Equals_Expression__create(parsed_expression.location, Checker__get_builtin_type(self, Checked_Type_Kind.BOOL).as(Checked_Type*), left_expression, right_expression).as(Checked_Expression*)
}

func Checker__check_null_expression(self: Checker*, parsed_expression: Parsed_Null_Expression*) -> Checked_Expression* {
    let expression_type = Checker__get_builtin_type(self, Checked_Type_Kind.NULL).as(Checked_Type*)
    return Checked_Null_Expression__create(parsed_expression.literal.location, expression_type).as(Checked_Expression*)
}

func Checker__check_sizeof_expression(self: Checker*, parsed_expression: Parsed_Sizeof_Expression*) -> Checked_Expression* {
    let expression_type = Checker__get_builtin_type(self, Checked_Type_Kind.USIZE).as(Checked_Type*)
    let sized_type = Checker__resolve_type(self, parsed_expression.type)
    return Checked_Sizeof_Expression__create(parsed_expression.location, expression_type, sized_type).as(Checked_Expression*)
}

func Checker__check_string_expression(self: Checker*, parsed_expression: Parsed_String_Expression*) -> Checked_Expression* {
    let char_type = Checker__get_builtin_type(self, Checked_Type_Kind.CHAR).as(Checked_Type*)
    let expression_type = Checked_Pointer_Type__create(parsed_expression.literal.location, char_type).as(Checked_Type*)
    let value = parsed_expression.value
    return Checked_String_Expression__create(parsed_expression.location, expression_type, value).as(Checked_Expression*)
}

func Checker__check_substract_expression(self: Checker*, parsed_expression: Parsed_Substract_Expression*) -> Checked_Expression* {
    let left_expression = Checker__check_expression(self, parsed_expression.left_expression)
    Checked_Type__expect_scalar_type(left_expression.type, left_expression.location)
    let right_expression = Checker__check_expression(self, parsed_expression.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return Checked_Substract_Expression__create(parsed_expression.location, left_expression.type, left_expression, right_expression).as(Checked_Expression*)
}

func Checker__check_symbol_expression(self: Checker*, parsed_expression: Parsed_Symbol_Expression*) -> Checked_Expression* {
    let symbol = Checked_Symbols__find_symbol(self.current_context.symbols, parsed_expression.name.lexeme)
    if (symbol == null) {
        Token__error(parsed_expression.name, String__create_from("Undefined symbol"))
        abort()
    }
    if (symbol.type == null) {
        Token__error(parsed_expression.name, String__create_from("Symbol without type"))
        abort()
    }
    return Checked_Symbol_Expression__create(parsed_expression.location, symbol.type, symbol).as(Checked_Expression*)
}

func Checker__check_expression(self: Checker*, parsed_expression: Parsed_Expression*) -> Checked_Expression* {
    if (parsed_expression.kind == Parsed_Expression_Kind.ADD) {
        return Checker__check_add_expression(self, parsed_expression.as(Parsed_Add_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.ADDRESS_OF) {
        return Checker__check_address_of_expression(self, parsed_expression.as(Parsed_Address_Of_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.ARRAY_ACCESS) {
        return Checker__check_array_access_expression(self, parsed_expression.as(Parsed_Array_Access_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.BOOL) {
        return Checker__check_bool_expression(self, parsed_expression.as(Parsed_Bool_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.CALL) {
        return Checker__check_call_expression(self, parsed_expression.as(Parsed_Call_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.CAST) {
        return Checker__check_cast_expression(self, parsed_expression.as(Parsed_Cast_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.CHARACTER) {
        return Checker__check_character_expression(self, parsed_expression.as(Parsed_Character_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.DEREFERENCE) {
        return Checker__check_dereference_expression(self, parsed_expression.as(Parsed_Dereference_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.DIVIDE) {
        return Checker__check_divide_expression(self, parsed_expression.as(Parsed_Divide_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.EQUALS) {
        return Checker__check_equals_expression(self, parsed_expression.as(Parsed_Equals_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.GREATER) {
        return Checker__check_greater_expression(self, parsed_expression.as(Parsed_Greater_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.GREATER_OR_EQUALS) {
        return Checker__check_greater_or_equals_expression(self, parsed_expression.as(Parsed_Greater_Or_Equals_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.GROUP) {
        return Checker__check_group_expression(self, parsed_expression.as(Parsed_Group_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.INTEGER) {
        return Checker__check_integer_expression(self, parsed_expression.as(Parsed_Integer_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.LESS) {
        return Checker__check_less_expression(self, parsed_expression.as(Parsed_Less_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.LESS_OR_EQUALS) {
        return Checker__check_less_or_equals_expression(self, parsed_expression.as(Parsed_Less_Or_Equals_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.LOGIC_AND) {
        return Checker__check_logic_and_expression(self, parsed_expression.as(Parsed_Logic_And_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.LOGIC_OR) {
        return Checker__check_logic_or_expression(self, parsed_expression.as(Parsed_Logic_Or_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.MEMBER_ACCESS) {
        return Checker__check_member_access_expression(self, parsed_expression.as(Parsed_Member_Access_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.MINUS) {
        return Checker__check_minus_expression(self, parsed_expression.as(Parsed_Minus_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.MODULO) {
        return Checker__check_modulo_expression(self, parsed_expression.as(Parsed_Modulo_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.MULTIPLY) {
        return Checker__check_multiply_expression(self, parsed_expression.as(Parsed_Multiply_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.NOT) {
        return Checker__check_not_expression(self, parsed_expression.as(Parsed_Not_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.NOT_EQUALS) {
        return Checker__check_not_equals_expression(self, parsed_expression.as(Parsed_Not_Equals_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.NULL) {
        return Checker__check_null_expression(self, parsed_expression.as(Parsed_Null_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.SIZEOF) {
        return Checker__check_sizeof_expression(self, parsed_expression.as(Parsed_Sizeof_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.STRING) {
        return Checker__check_string_expression(self, parsed_expression.as(Parsed_String_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.SUBSTRACT) {
        return Checker__check_substract_expression(self, parsed_expression.as(Parsed_Substract_Expression*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.SYMBOL) {
        return Checker__check_symbol_expression(self, parsed_expression.as(Parsed_Symbol_Expression*))
    }
    Source_Location__error(parsed_expression.location, String__append_i16(String__create_from("Unsupported expression kind: "), parsed_expression.kind.as(i16)))
    abort()
}

func Checker__check_enum_statement(self: Checker*, parsed_statement: Parsed_Enum_Statement*) -> void {
    let enum_type = Checked_Enum_Type__create(parsed_statement.name.location, parsed_statement.name.lexeme)
    Checker__append_type(self, enum_type.as(Checked_Named_Type*))

    let last_enum_member: Checked_Enum_Member* = null
    let parsed_enum_member = parsed_statement.first_member
    while (parsed_enum_member != null) {
        let enum_member = Checked_Enum_Member__create(parsed_enum_member.name.location, parsed_enum_member.name.lexeme)
        let enum_member_symbol_name = String__append_string(String__append_cstring(String__append_string(String__create(), enum_type.name), "__"), enum_member.name)
        enum_member.symbol = Checked_Enum_Member_Symbol__create(enum_member.location, enum_member_symbol_name, enum_type.as(Checked_Type*)).as(Checked_Symbol*)
        Checked_Symbols__append_symbol(self.root_context.symbols, enum_member.symbol)
        if (last_enum_member == null) {
            enum_type.first_member = enum_member
        } else {
            last_enum_member.next_member = enum_member
        }
        last_enum_member = enum_member
        parsed_enum_member = parsed_enum_member.next_member
    }
}

func Checker__create_opaque_type(self: Checker*, parsed_statement: Parsed_Opaque_Type_Statement*) -> void {
    let other_type = Checker__find_type(self, parsed_statement.name.lexeme)
    if (other_type != null) {
        Source_Location__error(parsed_statement.name.location, String__append_source_location(String__create_from("Type declared first here: "), other_type.location))
        abort()
    } else {
        let opaque_type = Checked_Opaque_Type__create(parsed_statement.name.location, parsed_statement.name.lexeme)
        Checker__append_type(self, opaque_type.as(Checked_Named_Type*))
    }
}

func Checker__create_struct_type(self: Checker*, parsed_statement: Parsed_Struct_Statement*) -> void {
    let other_type = Checker__find_type(self, parsed_statement.name.lexeme)
    if (other_type != null) {
        Source_Location__error(parsed_statement.name.location, String__append_source_location(String__create_from("Type declared first here: "), other_type.location))
        abort()
    } else {
        let struct_type = Checked_Struct_Type__create(parsed_statement.name.location, parsed_statement.name.lexeme)
        Checker__append_type(self, struct_type.as(Checked_Named_Type*))
    }
}

func Checker__check_struct_statement(self: Checker*, parsed_statement: Parsed_Struct_Statement*) -> void {
    let struct_type = Checker__find_type(self, parsed_statement.name.lexeme).as(Checked_Struct_Type*)
    if (parsed_statement.first_member != null) {
        let last_struct_member: Checked_Struct_Member* = null
        let parsed_member = parsed_statement.first_member
        while (parsed_member != null) {
            let struct_member = Checked_Struct_Type__find_member(struct_type, parsed_member.name.lexeme)
            if (struct_member != null) {
                Source_Location__error(parsed_member.name.location, String__append_source_location(String__create_from("Struct member declared first here: "), struct_member.location))
                abort()
            }
            let struct_member_type = Checker__resolve_type(self, parsed_member.type)
            struct_member = Checked_Struct_Member__create(parsed_member.name.location, parsed_member.name.lexeme, struct_member_type)
            if (String__equals_cstring(struct_member.name, "super")) {
                if (struct_type.first_member != null) {
                    Source_Location__error(parsed_member.name.location, String__create_from("Must be the first struct member"))
                    abort()
                }
                if (struct_member.type.kind != Checked_Type_Kind.STRUCT) {
                    Source_Location__error(parsed_member.type.location, String__create_from("Must be a struct"))
                    abort()
                }
                let struct_super_type = struct_member.type.as(Checked_Struct_Type*)
                let other_struct_type = struct_super_type
                while (other_struct_type != null) {
                    if (other_struct_type == struct_type) {
                        Source_Location__error(parsed_member.type.location, String__create_from("Type recursivity"))
                        abort()
                    }
                    other_struct_type = other_struct_type.super_type
                }
                struct_type.super_type = struct_super_type
            }
            if (last_struct_member == null) {
                struct_type.first_member = struct_member
            } else {
                last_struct_member.next_member = struct_member
            }
            last_struct_member = struct_member
            parsed_member = parsed_member.next_member
        }
    }
}

func Checker__check_assignment_statement(self: Checker*, parsed_statement: Parsed_Assignment_Statement*) -> Checked_Assignment_Statement* {
    let object_expression = Checker__check_expression(self, parsed_statement.object_expression)
    let value_expression = Checker__check_expression(self, parsed_statement.value_expression)
    Checked_Type__expect_same_type(object_expression.type, value_expression.type, value_expression.location)
    return Checked_Assignment_Statement__create(parsed_statement.location, object_expression, value_expression)
}

func Checker__check_block_statement(self: Checker*, parsed_statement: Parsed_Block_Statement*) -> Checked_Block_Statement* {
    let context = Checker_Context__create(self.current_context)
    self.current_context = context
    Checker__check_statements(self, parsed_statement.statements)
    self.current_context = context.parent
    return Checked_Block_Statement__create(parsed_statement.location, context, null)
}

func Checker__check_break_statement(self: Checker*, parsed_statement: Parsed_Break_Statement*) -> Checked_Break_Statement* {
    return Checked_Break_Statement__create(parsed_statement.location)
}

func Checker__check_expression_statement(self: Checker*, parsed_statement: Parsed_Expression_Statement*) -> Checked_Expression_Statement* {
    let expression = Checker__check_expression(self, parsed_statement.expression)
    if (!Checked_Type__equals(Checker__get_builtin_type(self, Checked_Type_Kind.VOID).as(Checked_Type*), expression.type)) {
        \ TODO: Source_Location__warning(expression.location, String__create_from("Unused result value"))
    }
    return Checked_Expression_Statement__create(parsed_statement.location, expression)
}

func Checker__check_if_statement(self: Checker*, parsed_statement: Parsed_If_Statement*) -> Checked_Statement* {
    let labels_count = Counter__next(self.current_context.function_counter)
    let wrapper_label = String__append_i16(String__create_from("if__start__"), labels_count)
    let wrapper_end_label = String__append_i16(String__create_from("if__end__"), labels_count)
    let then_label = String__append_i16(String__create_from("if__then__"), labels_count)
    let else_label = wrapper_end_label
    if (parsed_statement.false_statement != null) {
        else_label = String__append_i16(String__create_from("if__else__"), labels_count)
    }

    let wrapper_context = Checker_Context__create(self.current_context)
    self.current_context = wrapper_context

    let wrapper_block = Checked_Block_Statement__create(parsed_statement.location, wrapper_context, wrapper_label)

    let then_block = Checker__check_if_condition(self, parsed_statement.condition_expression, then_label, else_label)

    let current_context = self.current_context
    self.current_context = then_block.context
    Checked_Statements__append(then_block.context.statements, Checker__check_statement(self, parsed_statement.true_statement))
    Checked_Statements__append(then_block.context.statements, Checked_Goto_Statement__create(null, wrapper_end_label).as(Checked_Statement*))
    self.current_context = current_context

    if (parsed_statement.false_statement != null) {
        Checked_Statements__append(wrapper_block.context.statements, Checked_Label_Statement__create(null, else_label).as(Checked_Statement*))
        Checked_Statements__append(wrapper_block.context.statements, Checker__check_statement(self, parsed_statement.false_statement))
    }

    Checked_Statements__append(wrapper_block.context.statements, Checked_Label_Statement__create(null, wrapper_end_label).as(Checked_Statement*))

    self.current_context = wrapper_context.parent

    return wrapper_block.as(Checked_Statement*)
}

\ This function appends ifs and gotos in the current block and returns a block for the true statement
func Checker__check_if_condition(self: Checker*, parsed_expression: Parsed_Expression*, then_label: String*, else_label: String*) -> Checked_Block_Statement* {
    let initial_context = self.current_context
    let then_block: Checked_Block_Statement* = undefined
    if (parsed_expression.kind == Parsed_Expression_Kind.LOGIC_AND) {
        let parsed_binary_expression = parsed_expression.as(Parsed_Logic_And_Expression*)
        let first_expression_block = Checker__check_if_condition(self, parsed_binary_expression.left_expression, then_label, else_label)
        self.current_context = first_expression_block.context
        then_block = Checker__check_if_condition(self, parsed_binary_expression.right_expression, then_label, else_label)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.LOGIC_OR) {
        let parsed_binary_expression = parsed_expression.as(Parsed_Logic_Or_Expression*)
        let new_then_label = String__append_i16(String__append_cstring(String__append_string(String__create(), then_label), "__"), Counter__next(self.current_context.function_counter))
        let first_expression_block = Checker__check_if_condition(self, Parsed_Not_Expression__create(null, parsed_binary_expression.left_expression).as(Parsed_Expression*), else_label, new_then_label)
        self.current_context = first_expression_block.context
        let second_expression_block = Checker__check_if_condition(self, Parsed_Not_Expression__create(null, parsed_binary_expression.right_expression).as(Parsed_Expression*), else_label, new_then_label)
        Checked_Statements__append(second_expression_block.context.statements, Checked_Goto_Statement__create(null, else_label).as(Checked_Statement*))
        then_block = Checked_Block_Statement__create(null, Checker_Context__create(initial_context), new_then_label)
        Checked_Statements__append(initial_context.statements, then_block.as(Checked_Statement*))
    } else if (parsed_expression.kind == Parsed_Expression_Kind.GROUP) {
        then_block = Checker__check_if_condition(self, parsed_expression.as(Parsed_Group_Expression*).other_expression, then_label, else_label)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.NOT && parsed_expression.as(Parsed_Not_Expression*).other_expression.kind == Parsed_Expression_Kind.GROUP) {
        then_block = Checker__check_if_condition(self, Parsed_Not_Expression__create(null, parsed_expression.as(Parsed_Not_Expression*).other_expression.as(Parsed_Group_Expression*).other_expression).as(Parsed_Expression*), then_label, else_label)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.NOT && parsed_expression.as(Parsed_Not_Expression*).other_expression.kind == Parsed_Expression_Kind.NOT) {
        then_block = Checker__check_if_condition(self, parsed_expression.as(Parsed_Not_Expression*).other_expression.as(Parsed_Not_Expression*).other_expression, then_label, else_label)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.NOT && parsed_expression.as(Parsed_Not_Expression*).other_expression.kind == Parsed_Expression_Kind.LOGIC_OR) {
        let parsed_binary_expression = parsed_expression.as(Parsed_Not_Expression*).other_expression.as(Parsed_Logic_Or_Expression*)
        then_block = Checker__check_if_condition(self, Parsed_Logic_And_Expression__create(Parsed_Not_Expression__create(null, parsed_binary_expression.left_expression).as(Parsed_Expression*), Parsed_Not_Expression__create(null, parsed_binary_expression.right_expression).as(Parsed_Expression*)).as(Parsed_Expression*), then_label, else_label)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.NOT && parsed_expression.as(Parsed_Not_Expression*).other_expression.kind == Parsed_Expression_Kind.LOGIC_AND) {
        let parsed_binary_expression = parsed_expression.as(Parsed_Not_Expression*).other_expression.as(Parsed_Logic_And_Expression*)
        then_block = Checker__check_if_condition(self, Parsed_Logic_Or_Expression__create(Parsed_Not_Expression__create(null, parsed_binary_expression.left_expression).as(Parsed_Expression*), Parsed_Not_Expression__create(null, parsed_binary_expression.right_expression).as(Parsed_Expression*)).as(Parsed_Expression*), then_label, else_label)
    } else {
        let checked_expression = Checker__check_expression(self, parsed_expression)
        Checked_Type__expect_same_type(Checker__get_builtin_type(self, Checked_Type_Kind.BOOL).as(Checked_Type*), checked_expression.type, checked_expression.location)
        then_block = Checked_Block_Statement__create(null, Checker_Context__create(self.current_context), null)
        Checked_Statements__append(self.current_context.statements, Checked_If_Statement__create(null, checked_expression, then_block.as(Checked_Statement*), null).as(Checked_Statement*))
    }
    self.current_context = initial_context
    return then_block
}

func Checker__check_return_statement(self: Checker*, parsed_statement: Parsed_Return_Statement*) -> Checked_Return_Statement* {
    let expression: Checked_Expression* = null
    if (parsed_statement.expression != null) {
        expression = Checker__check_expression(self, parsed_statement.expression)
        Checked_Type__expect_same_type(self.current_context.function_return_type, expression.type, expression.location)
    } else if (self.current_context.function_return_type.kind != Checked_Type_Kind.VOID) {
        Source_Location__error(parsed_statement.location, String__create_from("Missing expression"))
        abort()
    }
    return Checked_Return_Statement__create(parsed_statement.location, expression)
}

func Checker__check_variable_statement(self: Checker*, parsed_statement: Parsed_Variable_Statement*) -> Checked_Variable_Statement* {
    let type: Checked_Type* = null
    if (parsed_statement.type != null) {
        type = Checker__resolve_type(self, parsed_statement.type)
        if (type.kind == Checked_Type_Kind.OPAQUE) {
            Source_Location__error(parsed_statement.location, String__create_from("Variable cannot have an opaque type"))
            abort()
        }
    }
    let expression: Checked_Expression* = null
    if (parsed_statement.expression != null) {
        expression = Checker__check_expression(self, parsed_statement.expression)
        if (type != null) {
            Checked_Type__expect_same_type(type, expression.type, expression.location)
            if (expression.type.kind != Checked_Type_Kind.NULL) {
                Source_Location__warning(parsed_statement.type.location, String__create_from("Redundant type declaration"))
            }
        } else {
            type = expression.type
        }
    }
    if (type == null || type.kind == Checked_Type_Kind.NULL) {
        Source_Location__error(parsed_statement.location, String__create_from("Unknown variable type"))
        abort()
    }
    let variable = Checked_Variable__create(parsed_statement.name.location, parsed_statement.name.lexeme, type)
    Checked_Symbols__append_symbol(self.current_context.symbols, variable.as(Checked_Symbol*))
    return Checked_Variable_Statement__create(parsed_statement.location, variable, expression, parsed_statement.is_external)
}

func Checker__check_while_statement(self: Checker*, parsed_statement: Parsed_While_Statement*) -> Checked_While_Statement* {
    let condition_expression = Checker__check_expression(self, parsed_statement.condition_expression)
    Checked_Type__expect_same_type(Checker__get_builtin_type(self, Checked_Type_Kind.BOOL).as(Checked_Type*), condition_expression.type, condition_expression.location)
    let body_statement = Checker__check_statement(self, parsed_statement.body_statement)
    return Checked_While_Statement__create(parsed_statement.location, condition_expression, body_statement)
}

func Checker__check_function_declaration(self: Checker*, parsed_statement: Parsed_Function_Statement*) -> void {
    let function_name = parsed_statement.name.lexeme
    let function_return_type = Checker__resolve_type(self, parsed_statement.return_type)
    let function_first_parameter: Checked_Function_Parameter* = null
    let parsed_parameter = parsed_statement.first_parameter
    if (parsed_parameter != null) {
        function_first_parameter = Checked_Function_Parameter__create(parsed_parameter.location, parsed_parameter.name, Checker__resolve_type(self, parsed_parameter.type))
        let function_last_parameter = function_first_parameter
        parsed_parameter = parsed_parameter.next_parameter
        while (parsed_parameter != null) {
            let function_parameter = Checked_Function_Parameter__create(parsed_parameter.location, parsed_parameter.name, Checker__resolve_type(self, parsed_parameter.type))
            function_last_parameter.next_parameter = function_parameter
            function_last_parameter = function_parameter
            parsed_parameter = parsed_parameter.next_parameter
        }
    }
    let function_type = Checked_Function_Type__create(parsed_statement.location, function_first_parameter, function_return_type)

    let other_symbol = Checked_Symbols__find_sibling_symbol(self.root_context.symbols, function_name)
    if (other_symbol != null) {
        if (other_symbol.kind != Checked_Symbol_Kind.FUNCTION || !Checked_Type__equals(function_type.as(Checked_Type*), other_symbol.as(Checked_Function_Symbol*).function_type.as(Checked_Type*))) {
            TODO("Report overloaded function")
            abort()
        } else {
            Source_Location__error(parsed_statement.name.location, String__append_source_location(String__create_from("Function declared first here: "), other_symbol.location))
            abort()
        }
    } else {
        Checked_Symbols__append_symbol(self.root_context.symbols, Checked_Function_Symbol__create(parsed_statement.name.location, function_name, function_type).as(Checked_Symbol*))
    }
}

func Checker__check_statement(self: Checker*, parsed_statement: Parsed_Statement*) -> Checked_Statement* {
    if (parsed_statement.kind == Parsed_Statement_Kind.ASSIGNMENT) {
        return Checker__check_assignment_statement(self, parsed_statement.as(Parsed_Assignment_Statement*)).as(Checked_Statement*)
    } else if (parsed_statement.kind == Parsed_Statement_Kind.BLOCK) {
        return Checker__check_block_statement(self, parsed_statement.as(Parsed_Block_Statement*)).as(Checked_Statement*)
    } else if (parsed_statement.kind == Parsed_Statement_Kind.BREAK) {
        return Checker__check_break_statement(self, parsed_statement.as(Parsed_Break_Statement*)).as(Checked_Statement*)
    } else if (parsed_statement.kind == Parsed_Statement_Kind.EXPRESSION) {
        return Checker__check_expression_statement(self, parsed_statement.as(Parsed_Expression_Statement*)).as(Checked_Statement*)
    } else if (parsed_statement.kind == Parsed_Statement_Kind.IF) {
        return Checker__check_if_statement(self, parsed_statement.as(Parsed_If_Statement*))
    } else if (parsed_statement.kind == Parsed_Statement_Kind.RETURN) {
        return Checker__check_return_statement(self, parsed_statement.as(Parsed_Return_Statement*)).as(Checked_Statement*)
    } else if (parsed_statement.kind == Parsed_Statement_Kind.VARIABLE) {
        return Checker__check_variable_statement(self, parsed_statement.as(Parsed_Variable_Statement*)).as(Checked_Statement*)
    } else if (parsed_statement.kind == Parsed_Statement_Kind.WHILE) {
        return Checker__check_while_statement(self, parsed_statement.as(Parsed_While_Statement*)).as(Checked_Statement*)
    }
    Source_Location__error(parsed_statement.location, String__create_from("Unsupported statement"))
    abort()
}

func Checker__check_statements(self: Checker*, parsed_statements: Parsed_Statements*) -> void {
    let parsed_statement = parsed_statements.first_statement
    while (parsed_statement != null) {
        let checked_statement = Checker__check_statement(self, parsed_statement)
        Checked_Statements__append(self.current_context.statements, checked_statement)
        parsed_statement = parsed_statement.next_statement
    }
}

func Checker__check_function_definition(self: Checker*, parsed_statement: Parsed_Function_Statement*) -> void {
    let symbol = Checked_Symbols__find_sibling_symbol(self.root_context.symbols, parsed_statement.name.lexeme)
    if (symbol == null || symbol.kind != Checked_Symbol_Kind.FUNCTION) {
        TODO("Report missing function symbol")
        abort()
    }
    let function_symbol = symbol.as(Checked_Function_Symbol*)
    let function_type = function_symbol.function_type

    let function_context = Checker_Context__create(self.current_context)
    function_context.function_return_type = function_type.return_type
    Counter__reset(function_context.function_counter)

    if (function_type.first_parameter != null) {
        \ Create a symbol for each function parameter
        let parameter = function_type.first_parameter
        while (parameter != null) {
            Checked_Symbols__append_symbol(function_context.symbols, Checked_Function_Parameter_Symbol__create(parameter.location, parameter.name, parameter.type).as(Checked_Symbol*))
            parameter = parameter.next_parameter
        }
    }

    let context = Checker_Context__create(function_context)
    self.current_context = context
    Checker__check_statements(self, parsed_statement.statements)
    self.current_context = function_context.parent

    function_symbol.checked_statements = context.statements \ TODO: use context instead
}

func Checker__check_source(self: Checker*, parsed_source: Parsed_Source*) -> Checked_Source* {
    let parsed_statement: Parsed_Statement* = undefined

    \ Collect all type definitions
    parsed_statement = parsed_source.statements.first_statement
    while (parsed_statement != null) {
        let checked_statement: Checked_Statement* = null
        if (parsed_statement.kind == Parsed_Statement_Kind.FUNCTION) {
            \ ignored
        } else if (parsed_statement.kind == Parsed_Statement_Kind.VARIABLE) {
            \ ignored
        } else if (parsed_statement.kind == Parsed_Statement_Kind.STRUCT) {
            Checker__create_struct_type(self, parsed_statement.as(Parsed_Struct_Statement*))
        } else if (parsed_statement.kind == Parsed_Statement_Kind.OPAQUE_TYPE) {
            Checker__create_opaque_type(self, parsed_statement.as(Parsed_Opaque_Type_Statement*))
        } else if (parsed_statement.kind == Parsed_Statement_Kind.ENUM) {
            Checker__check_enum_statement(self, parsed_statement.as(Parsed_Enum_Statement*))
        } else {
            Source_Location__error(parsed_statement.location, String__create_from("Unsupported statement"))
            abort()
        }
        if (checked_statement != null) {
            Checked_Statements__append(self.current_context.statements, checked_statement)
        }
        parsed_statement = parsed_statement.next_statement
    }

    \ Check all defined types
    parsed_statement = parsed_source.statements.first_statement
    while (parsed_statement != null) {
        if (parsed_statement.kind == Parsed_Statement_Kind.STRUCT) {
            Checker__check_struct_statement(self, parsed_statement.as(Parsed_Struct_Statement*))
        }
        parsed_statement = parsed_statement.next_statement
    }

    \ Collect other declarations
    parsed_statement = parsed_source.statements.first_statement
    while (parsed_statement != null) {
        let checked_statement: Checked_Statement* = null
        if (parsed_statement.kind == Parsed_Statement_Kind.FUNCTION) {
            Checker__check_function_declaration(self, parsed_statement.as(Parsed_Function_Statement*))
        } else if (parsed_statement.kind == Parsed_Statement_Kind.VARIABLE) {
            checked_statement = Checker__check_variable_statement(self, parsed_statement.as(Parsed_Variable_Statement*)).as(Checked_Statement*)
        } else if (parsed_statement.kind == Parsed_Statement_Kind.STRUCT) {
            \ ignored
        } else if (parsed_statement.kind == Parsed_Statement_Kind.OPAQUE_TYPE) {
            \ ignored
        } else if (parsed_statement.kind == Parsed_Statement_Kind.ENUM) {
            \ ignored
        } else {
            Source_Location__error(parsed_statement.location, String__create_from("Unsupported statement"))
            abort()
        }
        if (checked_statement != null) {
            Checked_Statements__append(self.current_context.statements, checked_statement)
        }
        parsed_statement = parsed_statement.next_statement
    }

    \ Check function definitions
    parsed_statement = parsed_source.statements.first_statement
    while (parsed_statement != null) {
        if (parsed_statement.kind == Parsed_Statement_Kind.FUNCTION) {
            let function_statement = parsed_statement.as(Parsed_Function_Statement*)
            if (function_statement.statements != null) {
                Checker__check_function_definition(self, function_statement)
            }
        } else if (parsed_statement.kind == Parsed_Statement_Kind.VARIABLE) {
            \ ignored
        } else if (parsed_statement.kind == Parsed_Statement_Kind.STRUCT) {
            \ ignored
        } else if (parsed_statement.kind == Parsed_Statement_Kind.OPAQUE_TYPE) {
            \ ignored
        } else if (parsed_statement.kind == Parsed_Statement_Kind.ENUM) {
            \ ignored
        } else {
            Source_Location__error(parsed_statement.location, String__create_from("Unsupported statement"))
            abort()
        }
        parsed_statement = parsed_statement.next_statement
    }

    let checked_source = malloc(sizeof(Checked_Source)).as(Checked_Source*)
    checked_source.first_symbol = self.current_context.symbols.first_symbol
    checked_source.statements = self.current_context.statements
    return checked_source
}

func check(parsed_source: Parsed_Source*) -> Checked_Source* {
    let type_checker = Checker__create()

    return Checker__check_source(type_checker, parsed_source)
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Generator
\ ---------------------------------------------------------------------------------------------------------------------

struct Generator {
    file: File*
    identation: u16
}

func Generator__write_source_location(self: Generator*, location: Source_Location*) -> void {
    if (location != null) {
        File__write_cstring(self.file, "#line ")
        File__write_i32(self.file, location.line.as(i32))
        File__write_cstring(self.file, " \"")
        File__write_cstring(self.file, location.source.path)
        File__write_cstring(self.file, "\"\n")
    }
}

func Generator__generate_add_expression(self: Generator*, expression: Checked_Add_Expression*) -> void {
    Generator__generate_expression(self, expression.left_expression)
    File__write_cstring(self.file, " + ")
    Generator__generate_expression(self, expression.right_expression)
}

func Generator__generate_address_of_expression(self: Generator*, expression: Checked_Address_Of_Expression*) -> void {
    File__write_cstring(self.file, "&")
    Generator__generate_expression(self, expression.other_expression)
}

func Generator__generate_array_access_expression(self: Generator*, expression: Checked_Array_Access_Expression*) -> void {
    Generator__generate_expression(self, expression.array_expression)
    File__write_cstring(self.file, "[")
    Generator__generate_expression(self, expression.index_expression)
    File__write_cstring(self.file, "]")
}

func Generator__generate_bool_expression(self: Generator*, expression: Checked_Bool_Expression*) -> void {
    if (expression.value) {
        File__write_cstring(self.file, "true")
    } else {
        File__write_cstring(self.file, "false")
    }
}

func Generator__generate_call_expression(self: Generator*, expression: Checked_Call_Expression*) -> void {
    Generator__generate_expression(self, expression.callee_expression)
    File__write_cstring(self.file, "(")
    let argument = expression.first_argument
    while (argument != null) {
        Generator__generate_expression(self, argument.expression)
        argument = argument.next_argument
        if (argument != null) {
            File__write_cstring(self.file, ", ")
        }
    }
    File__write_cstring(self.file, ")")
}

func Generator__generate_cast_expression(self: Generator*, expression: Checked_Cast_Expression*) -> void {
    File__write_cstring(self.file, "((")
    File__write_checked_type(self.file, expression.type)
    File__write_cstring(self.file, ") ")
    Generator__generate_expression(self, expression.other_expression)
    File__write_char(self.file, ')')
}

func File__write_octal_escaped_char(stream: File*, value: char) -> void {
    File__write_char(stream, '\\')
    if (value > 64.as(char)) {
        File__write_char(stream, value / 64.as(char) % 8.as(char) + '0')
    }
    if (value > 8.as(char)) {
        File__write_char(stream, value / 8.as(char) % 8.as(char) + '0')
    }
    File__write_char(stream, value % 8.as(char) + '0')
}

func File__write_escaped_char(stream: File*, ch: char) -> void {
    if (ch < 32.as(char)) {
        if (ch == '\n') {
            File__write_cstring(stream, "\\n")
        } else if (ch == '\t') {
            File__write_cstring(stream, "\\t")
        } else {
            File__write_octal_escaped_char(stream, ch)
        }
    } else if (ch < 127.as(char)) {
        if (ch == '\"') {
            File__write_cstring(stream, "\\\"")
        } else if (ch == '\'') {
            File__write_cstring(stream, "\\'")
        } else if (ch == '\\') {
            File__write_cstring(stream, "\\\\")
        } else {
            File__write_char(stream, ch)
        }
    } else {
        File__write_octal_escaped_char(stream, ch)
    }
}

func Generator__generate_character_expression(self: Generator*, expression: Checked_Character_Expression*) -> void {
    File__write_char(self.file, '\'')
    File__write_escaped_char(self.file, expression.value)
    File__write_char(self.file, '\'')
}

func Generator__generate_dereference_expression(self: Generator*, expression: Checked_Dereference_Expression*) -> void {
    File__write_cstring(self.file, "*(")
    Generator__generate_expression(self, expression.value_expression)
    File__write_char(self.file, ')')
}

func Generator__generate_divide_expression(self: Generator*, expression: Checked_Divide_Expression*) -> void {
    Generator__generate_expression(self, expression.left_expression)
    File__write_cstring(self.file, " / ")
    Generator__generate_expression(self, expression.right_expression)
}

func Generator__generate_equals_expression(self: Generator*, expression: Checked_Equals_Expression*) -> void {
    Generator__generate_expression(self, expression.left_expression)
    File__write_cstring(self.file, " == ")
    Generator__generate_expression(self, expression.right_expression)
}

func Generator__generate_greater_expression(self: Generator*, expression: Checked_Greater_Expression*) -> void {
    Generator__generate_expression(self, expression.left_expression)
    File__write_cstring(self.file, " > ")
    Generator__generate_expression(self, expression.right_expression)
}

func Generator__generate_greater_or_equals_expression(self: Generator*, expression: Checked_Greater_Or_Equals_Expression*) -> void {
    Generator__generate_expression(self, expression.left_expression)
    File__write_cstring(self.file, " >= ")
    Generator__generate_expression(self, expression.right_expression)
}

func Generator__generate_group_expression(self: Generator*, expression: Checked_Group_Expression*) -> void {
    File__write_cstring(self.file, "(")
    Generator__generate_expression(self, expression.other_expression)
    File__write_cstring(self.file, ")")
}

func Generator__generate_integer_expression(self: Generator*, expression: Checked_Integer_Expression*) -> void {
    File__write_u64(self.file, expression.value)
}

func Generator__generate_less_expression(self: Generator*, expression: Checked_Less_Expression*) -> void {
    Generator__generate_expression(self, expression.left_expression)
    File__write_cstring(self.file, " < ")
    Generator__generate_expression(self, expression.right_expression)
}

func Generator__generate_less_or_equals_expression(self: Generator*, expression: Checked_Less_Or_Equals_Expression*) -> void {
    Generator__generate_expression(self, expression.left_expression)
    File__write_cstring(self.file, " <= ")
    Generator__generate_expression(self, expression.right_expression)
}

func Generator__generate_logic_and_expression(self: Generator*, expression: Checked_Logic_And_Expression*) -> void {
    Generator__generate_expression(self, expression.left_expression)
    File__write_cstring(self.file, " && ")
    Generator__generate_expression(self, expression.right_expression)
}

func Generator__generate_logic_or_expression(self: Generator*, expression: Checked_Logic_Or_Expression*) -> void {
    Generator__generate_expression(self, expression.left_expression)
    File__write_cstring(self.file, " || ")
    Generator__generate_expression(self, expression.right_expression)
}

func Generator__generate_member_access_expression(self: Generator*, expression: Checked_Member_Access_Expression*) -> void {
    Generator__generate_expression(self, expression.object_expression)
    if (expression.object_expression.type.kind == Checked_Type_Kind.POINTER) {
        File__write_cstring(self.file, "->")
    } else {
        File__write_cstring(self.file, ".")
    }
    File__write_string(self.file, expression.member.name)
}

func Generator__generate_minus_expression(self: Generator*, expression: Checked_Minus_Expression*) -> void {
    File__write_cstring(self.file, "-")
    Generator__generate_expression(self, expression.other_expression)
}

func Generator__generate_modulo_expression(self: Generator*, expression: Checked_Modulo_Expression*) -> void {
    Generator__generate_expression(self, expression.left_expression)
    File__write_cstring(self.file, " % ")
    Generator__generate_expression(self, expression.right_expression)
}

func Generator__generate_multiply_expression(self: Generator*, expression: Checked_Multiply_Expression*) -> void {
    Generator__generate_expression(self, expression.left_expression)
    File__write_cstring(self.file, " * ")
    Generator__generate_expression(self, expression.right_expression)
}

func Generator__generate_not_expression(self: Generator*, expression: Checked_Not_Expression*) -> void {
    File__write_cstring(self.file, "!(")
    Generator__generate_expression(self, expression.other_expression)
    File__write_char(self.file, ')')
}

func Generator__generate_not_equals_expression(self: Generator*, expression: Checked_Not_Equals_Expression*) -> void {
    Generator__generate_expression(self, expression.left_expression)
    File__write_cstring(self.file, " != ")
    Generator__generate_expression(self, expression.right_expression)
}

func Generator__generate_null_expression(self: Generator*, expression: Checked_Null_Expression*) -> void {
    File__write_cstring(self.file, "NULL")
}

func Generator__generate_sizeof_expression(self: Generator*, expression: Checked_Sizeof_Expression*) -> void {
    File__write_cstring(self.file, "sizeof(")
    File__write_checked_type(self.file, expression.sized_type)
    File__write_cstring(self.file, ")")
}

func Generator__generate_string_expression(self: Generator*, expression: Checked_String_Expression*) -> void {
    File__write_char(self.file, '"')
    let index = 0.as(usize)
    while (index < expression.value.length) {
        File__write_escaped_char(self.file, expression.value.data[index])
        index = index + 1.as(usize)
    }
    File__write_char(self.file, '"')
}

func Generator__generate_substract_expression(self: Generator*, expression: Checked_Substract_Expression*) -> void {
    Generator__generate_expression(self, expression.left_expression)
    File__write_cstring(self.file, " - ")
    Generator__generate_expression(self, expression.right_expression)
}

func Generator__generate_symbol_expression(self: Generator*, expression: Checked_Symbol_Expression*) -> void {
    File__write_string(self.file, expression.symbol.name)
}

func Generator__generate_expression(self: Generator*, expression: Checked_Expression*) -> void {
    if (expression.kind == Checked_Expression_Kind.ADD) {
        Generator__generate_add_expression(self, expression.as(Checked_Add_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.ADDRESS_OF) {
        Generator__generate_address_of_expression(self, expression.as(Checked_Address_Of_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.ARRAY_ACCESS) {
        Generator__generate_array_access_expression(self, expression.as(Checked_Array_Access_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.BOOL) {
        Generator__generate_bool_expression(self, expression.as(Checked_Bool_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.CALL) {
        Generator__generate_call_expression(self, expression.as(Checked_Call_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.CAST) {
        Generator__generate_cast_expression(self, expression.as(Checked_Cast_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.CHARACTER) {
        Generator__generate_character_expression(self, expression.as(Checked_Character_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.DEREFERENCE) {
        Generator__generate_dereference_expression(self, expression.as(Checked_Dereference_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.DIVIDE) {
        Generator__generate_divide_expression(self, expression.as(Checked_Divide_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.EQUALS) {
        Generator__generate_equals_expression(self, expression.as(Checked_Equals_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.GREATER) {
        Generator__generate_greater_expression(self, expression.as(Checked_Greater_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.GREATER_OR_EQUALS) {
        Generator__generate_greater_or_equals_expression(self, expression.as(Checked_Greater_Or_Equals_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.GROUP) {
        Generator__generate_group_expression(self, expression.as(Checked_Group_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.INTEGER) {
        Generator__generate_integer_expression(self, expression.as(Checked_Integer_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.LESS) {
        Generator__generate_less_expression(self, expression.as(Checked_Less_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.LESS_OR_EQUALS) {
        Generator__generate_less_or_equals_expression(self, expression.as(Checked_Less_Or_Equals_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.LOGIC_AND) {
        Generator__generate_logic_and_expression(self, expression.as(Checked_Logic_And_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.LOGIC_OR) {
        Generator__generate_logic_or_expression(self, expression.as(Checked_Logic_Or_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.MEMBER_ACCESS) {
        Generator__generate_member_access_expression(self, expression.as(Checked_Member_Access_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.MINUS) {
        Generator__generate_minus_expression(self, expression.as(Checked_Minus_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.MODULO) {
        Generator__generate_modulo_expression(self, expression.as(Checked_Modulo_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.MULTIPLY) {
        Generator__generate_multiply_expression(self, expression.as(Checked_Multiply_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.NOT) {
        Generator__generate_not_expression(self, expression.as(Checked_Not_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.NOT_EQUALS) {
        Generator__generate_not_equals_expression(self, expression.as(Checked_Not_Equals_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.NULL) {
        Generator__generate_null_expression(self, expression.as(Checked_Null_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.SIZEOF) {
        Generator__generate_sizeof_expression(self, expression.as(Checked_Sizeof_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.STRING) {
        Generator__generate_string_expression(self, expression.as(Checked_String_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.SUBSTRACT) {
        Generator__generate_substract_expression(self, expression.as(Checked_Substract_Expression*))
    } else if (expression.kind == Checked_Expression_Kind.SYMBOL) {
        Generator__generate_symbol_expression(self, expression.as(Checked_Symbol_Expression*))
    } else {
        Source_Location__error(expression.location, String__create_from("Unsupported expression"))
        abort()
    }
}

func Generator__write_identation(self: Generator*) -> void {
    let identation = self.identation
    while (identation > 0.as(u16)) {
        File__write_cstring(self.file, "    ")
        identation = identation - 1.as(u16)
    }
}

func Generator__generate_assignment_statement(self: Generator*, statement: Checked_Assignment_Statement*) -> void {
    Generator__generate_expression(self, statement.object_expression)
    File__write_cstring(self.file, " = ")
    Generator__generate_expression(self, statement.value_expression)
    File__write_cstring(self.file, ";")
}

func Generator__generate_block_statement(self: Generator*, statement: Checked_Block_Statement*) -> void {
    if (statement.label != null) {
        File__write_string(self.file, statement.label)
        File__write_cstring(self.file, ": ")
    }
    File__write_char(self.file, '{')
    Generator__generate_statements(self, statement.context.statements)
    if (statement.location != null) {
        File__write_char(self.file, '\n')
        Generator__write_identation(self)
        File__write_char(self.file, '}')
    } else {
        File__write_cstring(self.file, " }")
    }
}

func Generator__generate_break_statement(self: Generator*, statement: Checked_Break_Statement*) -> void {
    File__write_cstring(self.file, "break;")
}

func Generator__generate_expression_statement(self: Generator*, statement: Checked_Expression_Statement*) -> void {
    Generator__generate_expression(self, statement.expression)
    File__write_cstring(self.file, ";")
}

func Generator__generate_goto_statement(self: Generator*, statement: Checked_Goto_Statement*) -> void {
    File__write_cstring(self.file, "goto ")
    File__write_string(self.file, statement.label)
    File__write_char(self.file, ';')
}

func Generator__generate_if_statement(self: Generator*, statement: Checked_If_Statement*) -> void {
    File__write_cstring(self.file, "if (")
    Generator__generate_expression(self, statement.condition_expression)
    File__write_cstring(self.file, ") ")
    Generator__generate_statement(self, statement.true_statement)
    if (statement.false_statement != null) {
        File__write_cstring(self.file, " else ")
        Generator__generate_statement(self, statement.false_statement)
    }
}

func Generator__generate_label_statement(self: Generator*, statement: Checked_Label_Statement*) -> void {
    File__write_string(self.file, statement.label)
    File__write_cstring(self.file, ": ;")
}

func Generator__generate_return_statement(self: Generator*, statement: Checked_Return_Statement*) -> void {
    File__write_cstring(self.file, "return")
    if (statement.expression != null) {
        File__write_cstring(self.file, " ")
        Generator__generate_expression(self, statement.expression)
    }
    File__write_cstring(self.file, ";")
}

func Generator__generate_variable_statement(self: Generator*, statement: Checked_Variable_Statement*) -> void {
    if (statement.is_external) {
        File__write_cstring(self.file, "extern ")
        File__write_checked_type(self.file, statement.variable.type)
        File__write_char(self.file, ' ')
        File__write_string(self.file, statement.variable.name)
    } else if (statement.expression != null) {
        File__write_string(self.file, statement.variable.name)
        File__write_cstring(self.file, " = ")
        Generator__generate_expression(self, statement.expression)
    }
    File__write_cstring(self.file, ";")
}

func Generator__generate_while_statement(self: Generator*, statement: Checked_While_Statement*) -> void {
    File__write_cstring(self.file, "while (")
    Generator__generate_expression(self, statement.condition_expression)
    File__write_cstring(self.file, ") ")
    Generator__generate_statement(self, statement.body_statement)
}

func Generator__generate_statement(self: Generator*, statement: Checked_Statement*) -> void {
    if (statement.kind == Checked_Statement_Kind.ASSIGNMENT) {
        Generator__generate_assignment_statement(self, statement.as(Checked_Assignment_Statement*))
    } else if (statement.kind == Checked_Statement_Kind.BLOCK) {
        Generator__generate_block_statement(self, statement.as(Checked_Block_Statement*))
    } else if (statement.kind == Checked_Statement_Kind.BREAK) {
        Generator__generate_break_statement(self, statement.as(Checked_Break_Statement*))
    } else if (statement.kind == Checked_Statement_Kind.EXPRESSION) {
        Generator__generate_expression_statement(self, statement.as(Checked_Expression_Statement*))
    } else if (statement.kind == Checked_Statement_Kind.GOTO) {
        Generator__generate_goto_statement(self, statement.as(Checked_Goto_Statement*))
    } else if (statement.kind == Checked_Statement_Kind.IF) {
        Generator__generate_if_statement(self, statement.as(Checked_If_Statement*))
    } else if (statement.kind == Checked_Statement_Kind.LABEL) {
        Generator__generate_label_statement(self, statement.as(Checked_Label_Statement*))
    } else if (statement.kind == Checked_Statement_Kind.RETURN) {
        Generator__generate_return_statement(self, statement.as(Checked_Return_Statement*))
    } else if (statement.kind == Checked_Statement_Kind.VARIABLE) {
        Generator__generate_variable_statement(self, statement.as(Checked_Variable_Statement*))
    } else if (statement.kind == Checked_Statement_Kind.WHILE) {
        Generator__generate_while_statement(self, statement.as(Checked_While_Statement*))
    } else {
        Source_Location__error(statement.location, String__create_from("Unsupported statement"))
        abort()
    }
}

func Generator__generate_statements(self: Generator*, statements: Checked_Statements*) -> void {
    self.identation = self.identation + 1.as(u16)

    let symbol = statements.symbols.first_symbol
    while (symbol != null) {
        File__write_char(self.file, ' ')
        File__write_checked_type(self.file, symbol.type)
        File__write_char(self.file, ' ')
        File__write_string(self.file, symbol.name)
        File__write_cstring(self.file, ";")
        symbol = symbol.next_symbol
    }

    let statement = statements.first_statement
    while (statement != null) {
        if (statement.location != null) {
            File__write_char(self.file, '\n')
            Generator__write_source_location(self, statement.location)
            Generator__write_identation(self)
        } else {
            File__write_char(self.file, ' ')
        }

        Generator__generate_statement(self, statement)

        statement = statement.next_statement
    }

    self.identation = self.identation - 1.as(u16)
}

func Generator__generate_enum(self: Generator*, enum_type: Checked_Enum_Type*) -> void {
    File__write_checked_type(self.file, enum_type.as(Checked_Type*))
    File__write_cstring(self.file, " {\n")
    let enum_member = enum_type.first_member
    while (enum_member != null) {
        File__write_char(self.file, '\t')
        File__write_string(self.file, enum_member.symbol.name)
        enum_member = enum_member.next_member
        if (enum_member != null) {
            File__write_cstring(self.file, ",\n")
        } else {
            File__write_char(self.file, '\n')
        }
    }
    File__write_cstring(self.file, "};\n")
}

func Generator__declare_function(self: Generator*, function_symbol: Checked_Function_Symbol*) -> void {
    File__write_checked_function_symbol(self.file, function_symbol)
    File__write_cstring(self.file, ";\n")
}

func Generator__generate_function(self: Generator*, function_symbol: Checked_Function_Symbol*) -> void {
    if (function_symbol.checked_statements == null) {
        return
    }
    Generator__write_source_location(self, function_symbol.location)
    File__write_checked_function_symbol(self.file, function_symbol)
    File__write_cstring(self.file, " {")
    Generator__generate_statements(self, function_symbol.checked_statements)
    File__write_cstring(self.file, "}\n\n")
}

func Generator__declare_opaque_type(self: Generator*, opaque_type: Checked_Opaque_Type*) -> void {
    File__write_checked_type(self.file, opaque_type.as(Checked_Type*))
    File__write_cstring(self.file, ";\n")
}

func Generator__declare_struct(self: Generator*, struct_type: Checked_Struct_Type*) -> void {
    File__write_checked_type(self.file, struct_type.as(Checked_Type*))
    File__write_cstring(self.file, ";\n")
}

func Generator__generate_struct(self: Generator*, struct_type: Checked_Struct_Type*) -> void {
    let struct_member = struct_type.first_member
    if (struct_member == null) {
        return
    }
    File__write_checked_type(self.file, struct_type.as(Checked_Type*))
    File__write_cstring(self.file, " {\n")
    while (struct_member != null) {
        File__write_char(self.file, '\t')
        File__write_checked_type(self.file, struct_member.type)
        File__write_char(self.file, ' ')
        File__write_string(self.file, struct_member.name)
        File__write_cstring(self.file, ";\n")
        struct_member = struct_member.next_member
    }
    File__write_cstring(self.file, "};\n\n")
}

func generate(file: File*, checked_source: Checked_Source*) -> void {
    let generator: Generator = undefined
    generator.file = file
    generator.identation = 0.as(u16)

    let checked_symbol: Checked_Symbol* = undefined

    File__write_cstring(generator.file, "/* Copyright (C) 2023 Stefan Selariu */\n")
    File__write_cstring(generator.file, "\n")
    File__write_cstring(generator.file, "#include <inttypes.h>\n")
    File__write_cstring(generator.file, "#include <stdbool.h>\n")
    File__write_cstring(generator.file, "#include <stddef.h>\n")
    File__write_cstring(generator.file, "\n")

    \ Declare all defined types
    checked_symbol = checked_source.first_symbol
    while (checked_symbol != null) {
        if (checked_symbol.kind == Checked_Symbol_Kind.TYPE) {
            let named_type = checked_symbol.as(Checked_Type_Symbol*).named_type
            if (named_type.kind == Checked_Type_Kind.STRUCT) {
                Generator__declare_struct(&generator, named_type.as(Checked_Struct_Type*))
            } else if (named_type.kind == Checked_Type_Kind.OPAQUE) {
                Generator__declare_opaque_type(&generator, named_type.as(Checked_Opaque_Type*))
            } else if (named_type.kind == Checked_Type_Kind.ENUM) {
                Generator__generate_enum(&generator, named_type.as(Checked_Enum_Type*))
            }
        }
        checked_symbol = checked_symbol.next_symbol
    }
    File__write_cstring(generator.file, "\n")

    \ Generate all defined types
    checked_symbol = checked_source.first_symbol
    while (checked_symbol != null) {
        if (checked_symbol.kind == Checked_Symbol_Kind.TYPE) {
            let named_type = checked_symbol.as(Checked_Type_Symbol*).named_type
            if (named_type.kind == Checked_Type_Kind.STRUCT) {
                Generator__generate_struct(&generator, named_type.as(Checked_Struct_Type*))
            }
        }
        checked_symbol = checked_symbol.next_symbol
    }

    \ Declare all global variables
    let checked_statement = checked_source.statements.first_statement
    while (checked_statement != null) {
        if (checked_statement.kind == Checked_Statement_Kind.VARIABLE) {
            Generator__generate_variable_statement(&generator, checked_statement.as(Checked_Variable_Statement*))
            File__write_cstring(generator.file, "\n")
        } else {
            Source_Location__error(checked_statement.location, String__create_from("Unsupported statement"))
            abort()
        }
        checked_statement = checked_statement.next_statement
    }
    File__write_cstring(generator.file, "\n")

    \ Declare all defined functions
    checked_symbol = checked_source.first_symbol
    while (checked_symbol != null) {
        if (checked_symbol.kind == Checked_Symbol_Kind.FUNCTION) {
            Generator__declare_function(&generator, checked_symbol.as(Checked_Function_Symbol*))
        }
        checked_symbol = checked_symbol.next_symbol
    }
    File__write_cstring(generator.file, "\n")

    \ Generate all defined functions
    checked_symbol = checked_source.first_symbol
    while (checked_symbol != null) {
        if (checked_symbol.kind == Checked_Symbol_Kind.FUNCTION) {
            Generator__generate_function(&generator, checked_symbol.as(Checked_Function_Symbol*))
        }
        checked_symbol = checked_symbol.next_symbol
    }
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Counter
\ ---------------------------------------------------------------------------------------------------------------------

struct Counter {
    value: i16
}

func Counter__create() -> Counter* {
    let counter = malloc(sizeof(Counter)).as(Counter*)
    counter.value = 0.as(i16)
    return counter
}

func Counter__next(self: Counter*) -> i16 {
    self.value = self.value + 1.as(i16)
    return self.value
}

func Counter__reset(self: Counter*) -> Counter* {
    self.value = 0.as(i16)
    return self
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Main
\ ---------------------------------------------------------------------------------------------------------------------

func main(argc: i32, argv: char**) -> i32 {
    if (argc < 3) {
        error(String__append_cstring(String__append_cstring(String__create_from("Usage: "), argv[0.as(usize)]), " SOURCE OUTPUT"))
        return 1
    }

    let source_file_path = argv[1.as(usize)]
    let source_file = fopen(source_file_path, "r")
    if (source_file == null) {
        error(String__append_cstring(String__create_from("Cannot open file: "), source_file_path))
        return 1
    }

    let output_file_path = argv[2.as(usize)]
    let output_file: File* = undefined
    if (String__equals_cstring(String__create_from(output_file_path), "-")) {
        output_file = stdout
    } else {
        output_file = fopen(output_file_path, "w")
        if (output_file == null) {
            error(String__append_cstring(String__create_from("Cannot open file: "), output_file_path))
            return 1
        }
    }

    let source = Source__create(source_file, source_file_path)
    let parsed_source = parse(source)
    let checked_source = check(parsed_source)
    generate(output_file, checked_source)

    fclose(source_file)
    return fclose(output_file)
}
