\ Copyright (C) 2023 Stefan Selariu

\ ---------------------------------------------------------------------------------------------------------------------
\   LibC
\ ---------------------------------------------------------------------------------------------------------------------

define File = opaque type

let stdin: File* = external
let stdout: File* = external
let stderr: File* = external

define fopen = external func (file_name: char*, mode: char*) -> File*
define fclose = external func (stream: File*) -> i32
define fgetc = external func (stream: File*) -> i32
define fputc = external func (c: i32, stream: File*) -> i32
define fputs = external func (s: char*, stream: File*) -> i32

define malloc = external func (size: usize) -> void*
define realloc = external func (ptr: void*, size: usize) -> void*
define free = external func (ptr: void*) -> void

define abort = external func () -> void

\ ---------------------------------------------------------------------------------------------------------------------
\   String
\ ---------------------------------------------------------------------------------------------------------------------

define String = struct {
    data: char*
    data_size: usize
    length: usize
}

define String__create_empty = func (data_size: usize) -> String* {
    let string: String* = (String*) malloc(sizeof(String))
    string.data = (char*) malloc(data_size)
    string.data_size = data_size
    string.length = (usize) 0
    return string
}

define String__create = func () -> String* {
    return String__create_empty((usize) 16)
}

define String__delete = func (self: String*) -> void {
    free((void*) self.data)
    free((void*) self)
}

define String__append_char = func (self: String*, ch: char) -> String* {
    if (self.length >= self.data_size) {
        self.data_size = self.data_size + (usize) 16
        self.data = (char*) realloc((void*) self.data, self.data_size)
    }
    self.data[self.length] = ch
    self.length = self.length + (usize) 1
    return self
}

define String__append_cstring = func (self: String*, s: char*) -> String* {
    let index: usize = (usize) 0
    while (true) {
        let c: char = s[index]
        if (c == '\0') {
            return self
        }
        String__append_char(self, c)
        index = index + (usize) 1
    }
}

define cstring_length = func (s: char*) -> usize {
    let length: usize = (usize) 0
    while (true) {
        let c: u8 = (u8) s[length]
        if (c == (u8) 0) {
            break
        }
        length = length + (usize) 1
    }
    return length
}

define String__create_from = func (data: char*) -> String* {
    let string_length: usize = cstring_length(data)
    let string: String* = String__create_empty(string_length)
    String__append_cstring(string, data)
    return string
}

define String__append_i16 = func (self: String*, value: i16) -> String* {
    if (value < (i16) 0) {
        String__append_char(self, '-')
        String__append_i16(self, -value)
    } else {
        if (value >= (i16) 10) {
            String__append_i16(self, value / (i16) 10)
        }
        String__append_char(self, (char) (value % (i16) 10) + '0')
    }
    return self
}

define String__append_string = func (self: String*, other: String*) -> String* {
    let index: usize = (usize) 0
    while (index < other.length) {
        String__append_char(self, other.data[index])
        index = index + (usize) 1
    }
    return self
}

define String__equals_cstring = func (self: String*, s: char*) -> bool {
    let length: usize = cstring_length(s)
    if (self.length != length) {
        return false
    }

    let index: usize = (usize) 0
    while (index < length) {
        if (self.data[index] != s[index]) {
            return false
        }
        index = index + (usize) 1
    }

    return true
}

define String__equals_string = func (self: String*, other: String*) -> bool {
    if (self.length != other.length) {
        return false
    }

    let index: usize = (usize) 0
    while (index < self.length) {
        if (self.data[index] != other.data[index]) {
            return false
        }
        index = index + (usize) 1
    }

    return true
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Utils
\ ---------------------------------------------------------------------------------------------------------------------

define pass = func () -> void {
}

define File__write_char = func (self: File*, c: char) -> void {
    fputc((i32) c, self)
}

define File__write_cstring = func (self: File*, s: char*) -> void {
    fputs(s, self)
}

define File__write_i32 = func (self: File*, value: i32) -> void {
    if (value < 0) {
        File__write_char(self, '-')
        File__write_i32(self, -value)
    } else {
        if (value >= 10) {
            File__write_i32(self, value / 10)
        }
        File__write_char(self, (char) (value % 10) + '0')
    }
}

define File__write_u64 = func (self: File*, value: u64) -> void {
    if (value >= (u64) 10) {
        File__write_u64(self, value / (u64) 10)
    }
    File__write_char(self, (char) (value % (u64) 10) + '0')
}

define File__write_string = func (self: File*, string: String*) -> void {
    let index: usize = (usize) 0
    while (index < string.length) {
        File__write_char(self, string.data[index])
        index = index + (usize) 1
    }
}

define error = func (message: String*) -> void {
    File__write_cstring(stderr, "\e[0;91m")
    File__write_string(stderr, message)
    File__write_cstring(stderr, "\e[0m\n")
}

define warning = func (message: String*) -> void {
    File__write_cstring(stderr, "\e[0;93m")
    File__write_string(stderr, message)
    File__write_cstring(stderr, "\e[0m\n")
}

define TODO = func (message: char*) -> void {
    File__write_cstring(stderr, "\e[0;95mTODO: ")
    File__write_cstring(stderr, message)
    File__write_cstring(stderr, "\e[0m\n")
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Source
\ ---------------------------------------------------------------------------------------------------------------------

define Source = struct {
    content: String*
    path: char*
}

define Source__create = func (file: File*, file_path: char*) -> Source* {
    let file_content: String* = String__create()

    while (true) {
        let ch: i32 = fgetc(file)
        if (ch == -1) {
            break
        }
        String__append_char(file_content, (char) ch)
    }

    String__append_char(file_content, '\0') \ simplifies EOF detection

    let source: Source* = (Source*) malloc(sizeof(Source))
    source.content = file_content
    source.path = file_path

    return source
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Source Location
\ ---------------------------------------------------------------------------------------------------------------------

define Source_Location = struct {
    source: Source*
    line: u16
    column: u16
}

define Source_Location__create = func (source: Source*, line: u16, column: u16) -> Source_Location* {
    let source_location: Source_Location* = (Source_Location*) malloc(sizeof(Source_Location))
    source_location.source = source
    source_location.line = line
    source_location.column = column
    return source_location
}

define String__append_source_location = func (self: String*, location: Source_Location*) -> String* {
    String__append_cstring(self, location.source.path)
    String__append_char(self, ':')
    String__append_i16(self, (i16) location.line)
    String__append_char(self, ':')
    String__append_i16(self, (i16) location.column)
    return self
}

define File__write_source_location = func (self: File*, location: Source_Location*) -> void {
    File__write_cstring(self, location.source.path)
    File__write_char(self, ':')
    File__write_i32(self, (i32) location.line)
    File__write_char(self, ':')
    File__write_i32(self, (i32) location.column)
    File__write_cstring(self, ": ")
}

define Source_Location__error = func (self: Source_Location*, message: String*) -> void {
    File__write_source_location(stderr, self)
    error(message)
}

define Source_Location__warning = func (self: Source_Location*, message: String*) -> void {
    File__write_source_location(stderr, self)
    warning(message)
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Tokens
\ ---------------------------------------------------------------------------------------------------------------------

define Token_Kind = enum {
    CHARACTER
    COMMENT
    END_OF_FILE
    END_OF_LINE
    ERROR
    IDENTIFIER
    INTEGER
    KEYWORD
    OTHER
    SPACE
    STRING
}

define Token = struct {
    kind: Token_Kind
    location: Source_Location*
    lexeme: String*
    next_token: Token*
}

define Token__create_kind = func (kind: Token_Kind, kind_size: usize, location: Source_Location*, lexeme: String*) -> Token* {
    let token: Token* = (Token*) malloc(kind_size)
    token.kind = kind
    token.location = location
    token.lexeme = lexeme
    token.next_token = null
    return token
}

define Token__error = func (self: Token*, message: String*) -> void {
    Source_Location__error(self.location, message)
}

define Token__warning = func (self: Token*, message: String*) -> void {
    Source_Location__warning(self.location, message)
}

define Character_Token = struct {
    super: Token
    value: char
}

define Character_Token__create = func (location: Source_Location*, lexeme: String*, value: char) -> Character_Token* {
    let token: Character_Token* = (Character_Token*) Token__create_kind(Token_Kind.CHARACTER, sizeof(Character_Token), location, lexeme)
    token.value = value
    return token
}

define Comment_Token = struct {
    super: Token
}

define Comment_Token__create = func (location: Source_Location*, lexeme: String*) -> Comment_Token* {
    return (Comment_Token*) Token__create_kind(Token_Kind.COMMENT, sizeof(Comment_Token), location, lexeme)
}

define End_Of_File_Token = struct {
    super: Token
}

define End_Of_File_Token__create = func (location: Source_Location*, lexeme: String*) -> End_Of_File_Token* {
    return (End_Of_File_Token*) Token__create_kind(Token_Kind.END_OF_FILE, sizeof(End_Of_File_Token), location, lexeme)
}

define End_Of_Line_Token = struct {
    super: Token
}

define End_Of_Line_Token__create = func (location: Source_Location*, lexeme: String*) -> End_Of_Line_Token* {
    return (End_Of_Line_Token*) Token__create_kind(Token_Kind.END_OF_LINE, sizeof(End_Of_Line_Token), location, lexeme)
}

define Error_Token = struct {
    super: Token
}

define Error_Token__create = func (location: Source_Location*, lexeme: String*) -> Error_Token* {
    return (Error_Token*) Token__create_kind(Token_Kind.ERROR, sizeof(Error_Token), location, lexeme)
}

define Identifier_Token = struct {
    super: Token
}

define Identifier_Token__create = func (location: Source_Location*, lexeme: String*) -> Identifier_Token* {
    return (Identifier_Token*) Token__create_kind(Token_Kind.IDENTIFIER, sizeof(Identifier_Token), location, lexeme)
}

define Integer_Token = struct {
    super: Token
    value: u64
}

define Integer_Token__create = func (location: Source_Location*, lexeme: String*, value: u64) -> Integer_Token* {
    let token: Integer_Token* = (Integer_Token*) Token__create_kind(Token_Kind.INTEGER, sizeof(Integer_Token), location, lexeme)
    token.value = value
    return token
}

define Other_Token = struct {
    super: Token
}

define Other_Token__create = func (location: Source_Location*, lexeme: String*) -> Other_Token* {
    return (Other_Token*) Token__create_kind(Token_Kind.OTHER, sizeof(Other_Token), location, lexeme)
}

define Space_Token = struct {
    super: Token
    count: u16
}

define Space_Token__create = func (location: Source_Location*, lexeme: String*, count: u16) -> Space_Token* {
    let token: Space_Token* = (Space_Token*) Token__create_kind(Token_Kind.SPACE, sizeof(Space_Token), location, lexeme)
    token.count = count
    return token
}

define String_Token = struct {
    super: Token
    value: String*
}

define String_Token__create = func (location: Source_Location*, lexeme: String*, value: String*) -> String_Token* {
    let token: String_Token* = (String_Token*) Token__create_kind(Token_Kind.STRING, sizeof(String_Token), location, lexeme)
    token.value = value
    return token
}

define Token__is_anything = func (self: Token*) -> bool {
    return self != null
}

define Token__is_character = func (self: Token*) -> bool {
    return self.kind == Token_Kind.CHARACTER
}

define Token__is_comment = func (self: Token*) -> bool {
    return self.kind == Token_Kind.COMMENT
}

define Token__is_end_of_file = func (self: Token*) -> bool {
    return self.kind == Token_Kind.END_OF_FILE
}

define Token__is_end_of_line = func (self: Token*) -> bool {
    return self.kind == Token_Kind.END_OF_LINE || self.kind == Token_Kind.END_OF_FILE
}

define Token__is_identifier = func (self: Token*) -> bool {
    return self.kind == Token_Kind.IDENTIFIER
}

define Token__is_integer = func (self: Token*) -> bool {
    return self.kind == Token_Kind.INTEGER
}

define Token__is_keyword = func (self: Token*, lexeme: char*) -> bool {
    return self.kind == Token_Kind.IDENTIFIER && String__equals_cstring(self.lexeme, lexeme)
}

define Token__is_break = func (self: Token*) -> bool {
    return Token__is_keyword(self, "break")
}

define Token__is_define = func (self: Token*) -> bool {
    return Token__is_keyword(self, "define")
}

define Token__is_else = func (self: Token*) -> bool {
    return Token__is_keyword(self, "else")
}

define Token__is_enum = func (self: Token*) -> bool {
    return Token__is_keyword(self, "enum")
}

define Token__is_external = func (self: Token*) -> bool {
    return Token__is_keyword(self, "external")
}

define Token__is_false = func (self: Token*) -> bool {
    return Token__is_keyword(self, "false")
}

define Token__is_func = func (self: Token*) -> bool {
    return Token__is_keyword(self, "func")
}

define Token__is_if = func (self: Token*) -> bool {
    return Token__is_keyword(self, "if")
}

define Token__is_let = func (self: Token*) -> bool {
    return Token__is_keyword(self, "let")
}

define Token__is_null = func (self: Token*) -> bool {
    return Token__is_keyword(self, "null")
}

define Token__is_opaque = func (self: Token*) -> bool {
    return Token__is_keyword(self, "opaque")
}

define Token__is_return = func (self: Token*) -> bool {
    return Token__is_keyword(self, "return")
}

define Token__is_sizeof = func (self: Token*) -> bool {
    return Token__is_keyword(self, "sizeof")
}

define Token__is_struct = func (self: Token*) -> bool {
    return Token__is_keyword(self, "struct")
}

define Token__is_true = func (self: Token*) -> bool {
    return Token__is_keyword(self, "true")
}

define Token__is_type = func (self: Token*) -> bool {
    return Token__is_keyword(self, "type")
}

define Token__is_typedef = func (self: Token*) -> bool {
    return Token__is_keyword(self, "typedef")
}

define Token__is_undefined = func (self: Token*) -> bool {
    return Token__is_keyword(self, "undefined")
}

define Token__is_while = func (self: Token*) -> bool {
    return Token__is_keyword(self, "while")
}

define Token__is_other = func (self: Token*, lexeme: char*) -> bool {
    return self.kind == Token_Kind.OTHER && String__equals_cstring(self.lexeme, lexeme)
}

define Token__is_ampersand = func (self: Token*) -> bool {
    return Token__is_other(self, "&")
}

define Token__is_asterisk = func (self: Token*) -> bool {
    return Token__is_other(self, "*")
}

define Token__is_closing_brace = func (self: Token*) -> bool {
    return Token__is_other(self, "}")
}

define Token__is_closing_bracket = func (self: Token*) -> bool {
    return Token__is_other(self, "]")
}

define Token__is_closing_paren = func (self: Token*) -> bool {
    return Token__is_other(self, ")")
}

define Token__is_colon = func (self: Token*) -> bool {
    return Token__is_other(self, ":")
}

define Token__is_comma = func (self: Token*) -> bool {
    return Token__is_other(self, ",")
}

define Token__is_dot = func (self: Token*) -> bool {
    return Token__is_other(self, ".")
}

define Token__is_equals = func (self: Token*) -> bool {
    return Token__is_other(self, "=")
}

define Token__is_exclamation_mark = func (self: Token*) -> bool {
    return Token__is_other(self, "!")
}

define Token__is_greater_than = func (self: Token*) -> bool {
    return Token__is_other(self, ">")
}

define Token__is_less_than = func (self: Token*) -> bool {
    return Token__is_other(self, "<")
}

define Token__is_minus = func (self: Token*) -> bool {
    return Token__is_other(self, "-")
}

define Token__is_opening_brace = func (self: Token*) -> bool {
    return Token__is_other(self, "{")
}

define Token__is_opening_bracket = func (self: Token*) -> bool {
    return Token__is_other(self, "[")
}

define Token__is_opening_paren = func (self: Token*) -> bool {
    return Token__is_other(self, "(")
}

define Token__is_percent = func (self: Token*) -> bool {
    return Token__is_other(self, "%")
}

define Token__is_plus = func (self: Token*) -> bool {
    return Token__is_other(self, "+")
}

define Token__is_slash = func (self: Token*) -> bool {
    return Token__is_other(self, "/")
}

define Token__is_vertical_bar = func (self: Token*) -> bool {
    return Token__is_other(self, "|")
}

define Token__is_space = func (self: Token*) -> bool {
    return self.kind == Token_Kind.SPACE
}

define Token__is_string = func (self: Token*) -> bool {
    return self.kind == Token_Kind.STRING
}

define File__write_token = func (stream: File*, token: Token*) -> void {
    let colored: bool = token.kind == Token_Kind.COMMENT || token.kind == Token_Kind.ERROR || token.kind == Token_Kind.OTHER
    if (colored) {
        if (token.kind == Token_Kind.OTHER) {
            File__write_cstring(stream, "\e[2;33m")
        } else if (token.kind == Token_Kind.COMMENT) {
            File__write_cstring(stream, "\e[2;37m")
        } else if (token.kind == Token_Kind.ERROR) {
            File__write_cstring(stream, "\e[2;31m")
        }
    }
    File__write_string(stream, token.lexeme)
    if (colored) {
        File__write_cstring(stream, "\e[0m")
    }
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Scanner
\ ---------------------------------------------------------------------------------------------------------------------

define Scanner = struct {
    source: Source*
    current_char_index: usize
    current_line: u16
    current_column: u16
    current_token: Token*
}

define Scanner__peek_char = func (self: Scanner*) -> char {
    return self.source.content.data[self.current_char_index]
}

define Scanner__next_char = func (self: Scanner*) -> char {
    let next_char: char = Scanner__peek_char(self)
    if (next_char != '\0') {
        self.current_char_index = self.current_char_index + (usize) 1
        if (next_char == '\n') {
            self.current_line = self.current_line + (u16) 1
            self.current_column = (u16) 1
        } else {
            self.current_column = self.current_column + (u16) 1
        }
    }
    return next_char
}

define escape_char_value = func (c: char) -> char {
    if (c == 'n') {
        return '\n'
    }
    if (c == '"') {
        return '\"'
    }
    if (c == '\'') {
        return '\''
    }
    if (c == '\\') {
        return '\\'
    }
    if (c == 't') {
        return '\t'
    }
    if (c == '0') {
        return '\0'
    }
    if (c == 'e') {
        return '\e'
    }
    return (char) -1
}

define char_is_end_of_line = func (c: char) -> bool {
    return c == '\n' || c == '\0'
}

define Scanner__scan_character_token = func (self: Scanner*, source_location: Source_Location*, token_lexeme: String*) -> Token* {
    if (Scanner__next_char(self) != '\'') {
        Source_Location__error(source_location, String__create_from("Unexpected char"))
        abort()
    }
    String__append_char(token_lexeme, '\'')

    let next_char: char = Scanner__peek_char(self)
    if (char_is_end_of_line(next_char) || next_char == '\t') {
        return (Token*) Error_Token__create(source_location, token_lexeme)
    }

    String__append_char(token_lexeme, Scanner__next_char(self))
    let value: char = next_char

    if (value == '\'') {
        return (Token*) Error_Token__create(source_location, token_lexeme)
    }

    if (value == '\\') {
        next_char = Scanner__peek_char(self)
        if (char_is_end_of_line(next_char) || next_char == '\t') {
            return (Token*) Error_Token__create(source_location, token_lexeme)
        }

        String__append_char(token_lexeme, Scanner__next_char(self))

        value = escape_char_value(next_char)
        if (value == (char) -1) {
            return (Token*) Error_Token__create(source_location, token_lexeme)
        }
    }

    if (Scanner__peek_char(self) != '\'') {
        return (Token*) Error_Token__create(source_location, token_lexeme)
    }

    String__append_char(token_lexeme, Scanner__next_char(self))
    return (Token*) Character_Token__create(source_location, token_lexeme, value)
}

define Scanner__scan_comment_token = func (self: Scanner*, source_location: Source_Location*, token_lexeme: String*) -> Token* {
    while (!char_is_end_of_line(Scanner__peek_char(self))) {
        String__append_char(token_lexeme, Scanner__next_char(self))
    }
    return (Token*) Comment_Token__create(source_location, token_lexeme)
}

define char_is_identifier_start = func (c: char) -> bool {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_'
}

define char_is_identifier_letter = func (c: char) -> bool {
    return char_is_identifier_start(c) || (c >= '0' && c <= '9')
}

define Scanner__scan_identifier_token = func (self: Scanner*, source_location: Source_Location*, token_lexeme: String*) -> Token* {
    while (char_is_identifier_letter(Scanner__peek_char(self))) {
        String__append_char(token_lexeme, Scanner__next_char(self))
    }
    return (Token*) Identifier_Token__create(source_location, token_lexeme)
}

define char_is_digit = func (c: char) -> bool {
    return c >= '0' && c <= '9'
}

define Scanner__scan_integer_token = func (self: Scanner*, source_location: Source_Location*, token_lexeme: String*) -> Token* {
    let value: u64 = (u64) 0
    while (char_is_digit(Scanner__peek_char(self))) {
        let c: char = Scanner__next_char(self)
        value = value * (u64) 10 + (u64) (c - '0')
        String__append_char(token_lexeme, c)
    }
    return (Token*) Integer_Token__create(source_location, token_lexeme, value)
}

define char_is_space = func (c: char) -> bool {
    return c == ' '
}

define Scanner__scan_space_token = func (self: Scanner*, source_location: Source_Location*, token_lexeme: String*) -> Token* {
    let count: u16 = (u16) 0
    while (char_is_space(Scanner__peek_char(self))) {
        count = count + (u16) 1
        String__append_char(token_lexeme, Scanner__next_char(self))
    }
    return (Token*) Space_Token__create(source_location, token_lexeme, count)
}

define Scanner__scan_string_token = func (self: Scanner*, source_location: Source_Location*, token_lexeme: String*) -> Token* {
    if (Scanner__next_char(self) != '"') {
        Source_Location__error(source_location, String__create_from("Unexpected char"))
        abort()
    }
    String__append_char(token_lexeme, '"')

    let value: String* = String__create()

    while (true) {
        let next_char: char = Scanner__peek_char(self)
        if (char_is_end_of_line(next_char) || next_char == '\t') {
            return (Token*) Error_Token__create(source_location, token_lexeme)
        }

        String__append_char(token_lexeme, Scanner__next_char(self))

        if (next_char == '"') {
            return (Token*) String_Token__create(source_location, token_lexeme, value)
        }

        if (next_char == '\\') {
            next_char = Scanner__peek_char(self)
            if (char_is_end_of_line(next_char) || next_char == '\t') {
                return (Token*) Error_Token__create(source_location, token_lexeme)
            }

            String__append_char(token_lexeme, Scanner__next_char(self))

            next_char = escape_char_value(next_char)
            if (next_char == ((char) -1)) {
                return (Token*) Error_Token__create(source_location, token_lexeme)
            }
        }

        String__append_char(value, next_char)
    }
}

define Scanner__scan_token = func (self: Scanner*) -> Token* {
    let source_location: Source_Location* = Source_Location__create(self.source, self.current_line, self.current_column)
    let token_lexeme: String* = String__create()

    let next_char: char = Scanner__peek_char(self)

    if (char_is_identifier_start(next_char)) {
        return Scanner__scan_identifier_token(self, source_location, token_lexeme)
    }

    if (char_is_digit(next_char)) {
        return Scanner__scan_integer_token(self, source_location, token_lexeme)
    }

    if (char_is_space(next_char)) {
        return Scanner__scan_space_token(self, source_location, token_lexeme)
    }

    if (next_char == '\'') {
        return Scanner__scan_character_token(self, source_location, token_lexeme)
    }

    if (next_char == '\"') {
        return Scanner__scan_string_token(self, source_location, token_lexeme)
    }

    if (next_char == '\\') {
        return Scanner__scan_comment_token(self, source_location, token_lexeme)
    }

    if (next_char == '\n') {
        String__append_char(token_lexeme, Scanner__next_char(self))
        return (Token*) End_Of_Line_Token__create(source_location, token_lexeme)
    }

    if (next_char == '\0') {
        return (Token*) End_Of_File_Token__create(source_location, token_lexeme)
    }

    String__append_char(token_lexeme, Scanner__next_char(self))
    return (Token*) Other_Token__create(source_location, token_lexeme)
}

define Scanner__next_token = func (self: Scanner*) -> Token* {
    if (self.current_token.next_token == null) {
        self.current_token.next_token = Scanner__scan_token(self)
    }
    self.current_token = self.current_token.next_token
    return self.current_token
}

define Scanner__peek_token = func (self: Scanner*, offset: u8) -> Token* {
    let token: Token* = self.current_token
    while (offset > (u8) 0) {
        if (token.next_token == null) {
            token.next_token = Scanner__scan_token(self)
        }
        token = token.next_token
        offset = offset - (u8) 1
    }
    return token
}

define Scanner__create = func (source: Source*) -> Scanner* {
    let scanner: Scanner* = (Scanner*) malloc(sizeof(Scanner))
    scanner.source = source
    scanner.current_char_index = (usize) 0
    scanner.current_line = (u16) 1
    scanner.current_column = (u16) 1

    scanner.current_token = Scanner__scan_token(scanner)

    return scanner
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Parsed Source
\ ---------------------------------------------------------------------------------------------------------------------

define Parsed_Source = struct {
    statements: Parsed_Statements*
}

define Parsed_Type_Kind = enum {
    NAMED
    POINTER
    STRUCT
}

define Parsed_Type = struct {
    kind: Parsed_Type_Kind
    location: Source_Location*
}

define Parsed_Type__create_kind = func (kind: Parsed_Type_Kind, kind_size: usize, location: Source_Location*) -> Parsed_Type* {
    let type: Parsed_Type* = (Parsed_Type*) malloc(kind_size)
    type.kind = kind
    type.location = location
    return type
}

define Parsed_Named_Type = struct {
    super: Parsed_Type
    name: String*
}

define Parsed_Named_Type__create = func (name: Token*) -> Parsed_Type* {
    let type: Parsed_Named_Type* = (Parsed_Named_Type*) Parsed_Type__create_kind(Parsed_Type_Kind.NAMED, sizeof(Parsed_Named_Type), name.location)
    type.name = name.lexeme
    return (Parsed_Type*) type
}

define Parsed_Pointer_Type = struct {
    super: Parsed_Type
    other_type: Parsed_Type*
}

define Parsed_Pointer_Type__create = func (other_type: Parsed_Type*) -> Parsed_Type* {
    let type: Parsed_Pointer_Type* = (Parsed_Pointer_Type*) Parsed_Type__create_kind(Parsed_Type_Kind.POINTER, sizeof(Parsed_Pointer_Type), other_type.location)
    type.other_type = other_type
    return (Parsed_Type*) type
}

define Parsed_Struct_Type = struct {
    super: Parsed_Type
    other_type: Parsed_Type*
}

define Parsed_Struct_Type__create = func (location: Source_Location*, other_type: Parsed_Type*) -> Parsed_Type* {
    let type: Parsed_Struct_Type* = (Parsed_Struct_Type*) Parsed_Type__create_kind(Parsed_Type_Kind.STRUCT, sizeof(Parsed_Struct_Type), location)
    type.other_type = other_type
    return (Parsed_Type*) type
}

define Parsed_Expression_Kind = enum {
    ADD
    ADDRESS_OF
    ARRAY_ACCESS
    BOOL
    CALL
    CAST
    CHARACTER
    DEREFERENCE
    DIVIDE
    EQUALS
    GREATER
    GREATER_OR_EQUALS
    GROUP
    INTEGER
    LESS
    LESS_OR_EQUALS
    LOGIC_AND
    LOGIC_OR
    MEMBER_ACCESS
    MINUS
    MODULO
    MULTIPLY
    NOT
    NOT_EQUALS
    NULL
    SIZEOF
    STRING
    SUBSTRACT
    SYMBOL
}

define Parsed_Expression = struct {
    kind: Parsed_Expression_Kind
    location: Source_Location*
}

define Parsed_Expression__create_kind = func (kind: Parsed_Expression_Kind, kind_size: usize, location: Source_Location*) -> Parsed_Expression* {
    let expression: Parsed_Expression* = (Parsed_Expression*) malloc(kind_size)
    expression.kind = kind
    expression.location = location
    return expression
}

define Parsed_Binary_Expression = struct {
    super: Parsed_Expression
    left_expression: Parsed_Expression*
    right_expression: Parsed_Expression*
}

define Parsed_Binary_Expression__create_kind = func (kind: Parsed_Expression_Kind, left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Binary_Expression* {
    let expression: Parsed_Binary_Expression* = (Parsed_Binary_Expression*) Parsed_Expression__create_kind(kind, sizeof(Parsed_Binary_Expression), left_expression.location)
    expression.left_expression = left_expression
    expression.right_expression = right_expression
    return expression
}

define Parsed_Unary_Expression = struct {
    super: Parsed_Expression
    other_expression: Parsed_Expression*
}

define Parsed_Unary_Expression__create_kind = func (kind: Parsed_Expression_Kind, kind_size: usize, location: Source_Location*, other_expression: Parsed_Expression*) -> Parsed_Unary_Expression* {
    let expression: Parsed_Unary_Expression* = (Parsed_Unary_Expression*) Parsed_Expression__create_kind(kind, kind_size, location)
    expression.other_expression = other_expression
    return expression
}

define Parsed_Literal_Expression = struct {
    super: Parsed_Expression
    literal: Token*
}

define Parsed_Literal_Expression__create_kind = func (kind: Parsed_Expression_Kind, kind_size: usize, literal: Token*) -> Parsed_Literal_Expression* {
    let expression: Parsed_Literal_Expression* = (Parsed_Literal_Expression*) Parsed_Expression__create_kind(kind, kind_size, literal.location)
    expression.literal = literal
    return expression
}

define Parsed_Add_Expression = struct {
    super: Parsed_Binary_Expression
}

define Parsed_Add_Expression__create = func (left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Add_Expression* {
    return (Parsed_Add_Expression*) Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.ADD, left_expression, right_expression)
}

define Parsed_Address_Of_Expression = struct {
    super: Parsed_Unary_Expression
}

define Parsed_Address_Of_Expression__create = func (location: Source_Location*, other_expression: Parsed_Expression*) -> Parsed_Address_Of_Expression* {
    return (Parsed_Address_Of_Expression*) Parsed_Unary_Expression__create_kind(Parsed_Expression_Kind.ADDRESS_OF, sizeof(Parsed_Address_Of_Expression), location, other_expression)
}

define Parsed_Array_Access_Expression = struct {
    super: Parsed_Expression
    array_expression: Parsed_Expression*
    index_expression: Parsed_Expression*
}

define Parsed_Array_Access_Expression__create = func (array_expression: Parsed_Expression*, index_expression: Parsed_Expression*) -> Parsed_Array_Access_Expression* {
    let expression: Parsed_Array_Access_Expression* = (Parsed_Array_Access_Expression*) Parsed_Expression__create_kind(Parsed_Expression_Kind.ARRAY_ACCESS, sizeof(Parsed_Array_Access_Expression), array_expression.location)
    expression.array_expression = array_expression
    expression.index_expression = index_expression
    return expression
}

define Parsed_Bool_Expression = struct {
    super: Parsed_Literal_Expression
    value: bool
}

define Parsed_Bool_Expression__create = func (literal: Token*, value: bool) -> Parsed_Bool_Expression* {
    let expression: Parsed_Bool_Expression* = (Parsed_Bool_Expression*) Parsed_Literal_Expression__create_kind(Parsed_Expression_Kind.BOOL, sizeof(Parsed_Bool_Expression), literal)
    expression.value = value
    return expression
}

define Parsed_Call_Argument = struct {
    expression: Parsed_Expression*
    next_argument: Parsed_Call_Argument*
}

define Parsed_Call_Argument__create = func (expression: Parsed_Expression*) -> Parsed_Call_Argument* {
    let argument: Parsed_Call_Argument* = (Parsed_Call_Argument*) malloc(sizeof(Parsed_Call_Argument))
    argument.expression = expression
    argument.next_argument = null
    return argument
}

define Parsed_Call_Expression = struct {
    super: Parsed_Expression
    callee_expression: Parsed_Expression*
    first_argument: Parsed_Call_Argument*
}

define Parsed_Call_Expression__create = func (callee_expression: Parsed_Expression*) -> Parsed_Call_Expression* {
    let expression: Parsed_Call_Expression* = (Parsed_Call_Expression*) Parsed_Expression__create_kind(Parsed_Expression_Kind.CALL, sizeof(Parsed_Call_Expression), callee_expression.location)
    expression.callee_expression = callee_expression
    expression.first_argument = null
    return expression
}

define Parsed_Cast_Expression = struct {
    super: Parsed_Unary_Expression
    type: Parsed_Type*
}

define Parsed_Cast_Expression__create = func (location: Source_Location*, other_expression: Parsed_Expression*, type: Parsed_Type*) -> Parsed_Cast_Expression* {
    let expression: Parsed_Cast_Expression* = (Parsed_Cast_Expression*) Parsed_Unary_Expression__create_kind(Parsed_Expression_Kind.CAST, sizeof(Parsed_Cast_Expression), location, other_expression)
    expression.type = type
    return expression
}

define Parsed_Character_Expression = struct {
    super: Parsed_Literal_Expression
    value: char
}

define Parsed_Character_Expression__create = func (literal: Character_Token*) -> Parsed_Character_Expression* {
    let expression: Parsed_Character_Expression* = (Parsed_Character_Expression*) Parsed_Literal_Expression__create_kind(Parsed_Expression_Kind.CHARACTER, sizeof(Parsed_Character_Expression), (Token*) literal)
    expression.value = literal.value
    return expression
}

define Parsed_Dereference_Expression = struct {
    super: Parsed_Expression
    value_expression: Parsed_Expression*
}

define Parsed_Dereference_Expression__create = func (value_expression: Parsed_Expression*) -> Parsed_Dereference_Expression* {
    let expression: Parsed_Dereference_Expression* = (Parsed_Dereference_Expression*) Parsed_Expression__create_kind(Parsed_Expression_Kind.DEREFERENCE, sizeof(Parsed_Dereference_Expression), value_expression.location)
    expression.value_expression = value_expression
    return expression
}

define Parsed_Divide_Expression = struct {
    super: Parsed_Binary_Expression
}

define Parsed_Divide_Expression__create = func (left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Divide_Expression* {
    return (Parsed_Divide_Expression*) Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.DIVIDE, left_expression, right_expression)
}

define Parsed_Equals_Expression = struct {
    super: Parsed_Binary_Expression
}

define Parsed_Equals_Expression__create = func (left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Equals_Expression* {
    return (Parsed_Equals_Expression*) Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.EQUALS, left_expression, right_expression)
}

define Parsed_Greater_Expression = struct {
    super: Parsed_Binary_Expression
}

define Parsed_Greater_Expression__create = func (left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Greater_Expression* {
    return (Parsed_Greater_Expression*) Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.GREATER, left_expression, right_expression)
}

define Parsed_Greater_Or_Equals_Expression = struct {
    super: Parsed_Binary_Expression
}

define Parsed_Greater_Or_Equals_Expression__create = func (left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Greater_Or_Equals_Expression* {
    return (Parsed_Greater_Or_Equals_Expression*) Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.GREATER_OR_EQUALS, left_expression, right_expression)
}

define Parsed_Group_Expression = struct {
    super: Parsed_Expression
    other_expression: Parsed_Expression*
}

define Parsed_Group_Expression__create = func (location: Source_Location*, other_expression: Parsed_Expression*) -> Parsed_Group_Expression* {
    let expression: Parsed_Group_Expression* = (Parsed_Group_Expression*) Parsed_Expression__create_kind(Parsed_Expression_Kind.GROUP, sizeof(Parsed_Group_Expression), location)
    expression.other_expression = other_expression
    return expression
}

define Parsed_Integer_Expression = struct {
    super: Parsed_Literal_Expression
    value: u64
}

define Parsed_Integer_Expression__create = func (literal: Integer_Token*) -> Parsed_Integer_Expression* {
    let expression: Parsed_Integer_Expression* = (Parsed_Integer_Expression*) Parsed_Literal_Expression__create_kind(Parsed_Expression_Kind.INTEGER, sizeof(Parsed_Integer_Expression), (Token*) literal)
    expression.value = literal.value
    return expression
}

define Parsed_Less_Expression = struct {
    super: Parsed_Binary_Expression
}

define Parsed_Less_Expression__create = func (left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Less_Expression* {
    return (Parsed_Less_Expression*) Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.LESS, left_expression, right_expression)
}

define Parsed_Less_Or_Equals_Expression = struct {
    super: Parsed_Binary_Expression
}

define Parsed_Less_Or_Equals_Expression__create = func (left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Less_Or_Equals_Expression* {
    return (Parsed_Less_Or_Equals_Expression*) Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.LESS_OR_EQUALS, left_expression, right_expression)
}

define Parsed_Logic_And_Expression = struct {
    super: Parsed_Binary_Expression
}

define Parsed_Logic_And_Expression__create = func (left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Logic_And_Expression* {
    return (Parsed_Logic_And_Expression*) Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.LOGIC_AND, left_expression, right_expression)
}

define Parsed_Logic_Or_Expression = struct {
    super: Parsed_Binary_Expression
}

define Parsed_Logic_Or_Expression__create = func (left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Logic_Or_Expression* {
    return (Parsed_Logic_Or_Expression*) Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.LOGIC_OR, left_expression, right_expression)
}

define Parsed_Member_Access_Expression = struct {
    super: Parsed_Expression
    object_expression: Parsed_Expression*
    member_name: Token*
}

define Parsed_Member_Access_Expression__create = func (object_expression: Parsed_Expression*, member_name: Token*) -> Parsed_Member_Access_Expression* {
    let expression: Parsed_Member_Access_Expression* = (Parsed_Member_Access_Expression*) Parsed_Expression__create_kind(Parsed_Expression_Kind.MEMBER_ACCESS, sizeof(Parsed_Member_Access_Expression), object_expression.location)
    expression.object_expression = object_expression
    expression.member_name = member_name
    return expression
}

define Parsed_Minus_Expression = struct {
    super: Parsed_Unary_Expression
}

define Parsed_Minus_Expression__create = func (location: Source_Location*, other_expression: Parsed_Expression*) -> Parsed_Minus_Expression* {
    return (Parsed_Minus_Expression*) Parsed_Unary_Expression__create_kind(Parsed_Expression_Kind.MINUS, sizeof(Parsed_Minus_Expression), location, other_expression)
}

define Parsed_Modulo_Expression = struct {
    super: Parsed_Binary_Expression
}

define Parsed_Modulo_Expression__create = func (left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Modulo_Expression* {
    return (Parsed_Modulo_Expression*) Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.MODULO, left_expression, right_expression)
}

define Parsed_Multiply_Expression = struct {
    super: Parsed_Binary_Expression
}

define Parsed_Multiply_Expression__create = func (left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Multiply_Expression* {
    return (Parsed_Multiply_Expression*) Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.MULTIPLY, left_expression, right_expression)
}

define Parsed_Not_Expression = struct {
    super: Parsed_Unary_Expression
}

define Parsed_Not_Expression__create = func (location: Source_Location*, other_expression: Parsed_Expression*) -> Parsed_Not_Expression* {
    return (Parsed_Not_Expression*) Parsed_Unary_Expression__create_kind(Parsed_Expression_Kind.NOT, sizeof(Parsed_Not_Expression), location, other_expression)
}

define Parsed_Not_Equals_Expression = struct {
    super: Parsed_Binary_Expression
}

define Parsed_Not_Equals_Expression__create = func (left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Not_Equals_Expression* {
    return (Parsed_Not_Equals_Expression*) Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.NOT_EQUALS, left_expression, right_expression)
}

define Parsed_Null_Expression = struct {
    super: Parsed_Literal_Expression
}

define Parsed_Null_Expression__create = func (literal: Token*) -> Parsed_Null_Expression* {
    return (Parsed_Null_Expression*) Parsed_Literal_Expression__create_kind(Parsed_Expression_Kind.NULL, sizeof(Parsed_Null_Expression), literal)
}

define Parsed_Sizeof_Expression = struct {
    super: Parsed_Expression
    type: Parsed_Type*
}

define Parsed_Sizeof_Expression__create = func (location: Source_Location*, type: Parsed_Type*) -> Parsed_Sizeof_Expression* {
    let expression: Parsed_Sizeof_Expression* = (Parsed_Sizeof_Expression*) Parsed_Expression__create_kind(Parsed_Expression_Kind.SIZEOF, sizeof(Parsed_Sizeof_Expression), location)
    expression.type = type
    return expression
}

define Parsed_String_Expression = struct {
    super: Parsed_Literal_Expression
    value: String*
}

define Parsed_String_Expression__create = func (literal: String_Token*) -> Parsed_String_Expression* {
    let expression: Parsed_String_Expression* = (Parsed_String_Expression*) Parsed_Literal_Expression__create_kind(Parsed_Expression_Kind.STRING, sizeof(Parsed_String_Expression), (Token*) literal)
    expression.value = literal.value
    return expression
}

define Parsed_Substract_Expression = struct {
    super: Parsed_Binary_Expression
}

define Parsed_Substract_Expression__create = func (left_expression: Parsed_Expression*, right_expression: Parsed_Expression*) -> Parsed_Substract_Expression* {
    return (Parsed_Substract_Expression*) Parsed_Binary_Expression__create_kind(Parsed_Expression_Kind.SUBSTRACT, left_expression, right_expression)
}

define Parsed_Symbol_Expression = struct {
    super: Parsed_Expression
    name: Token*
}

define Parsed_Symbol_Expression__create = func (name: Token*) -> Parsed_Symbol_Expression* {
    let expression: Parsed_Symbol_Expression* = (Parsed_Symbol_Expression*) Parsed_Expression__create_kind(Parsed_Expression_Kind.SYMBOL, sizeof(Parsed_Symbol_Expression), name.location)
    expression.name = name
    return expression
}

define Parsed_Statement_Kind = enum {
    ASSIGNMENT
    BLOCK
    BREAK
    ENUM
    EXPRESSION
    FUNCTION
    FUNCTION_TYPE
    IF
    OPAQUE_TYPE
    RETURN
    STRUCT
    VARIABLE
    WHILE
}

define Parsed_Statement = struct {
    kind: Parsed_Statement_Kind
    location: Source_Location*
    next_statement: Parsed_Statement*
}

define Parsed_Statement__create_kind = func (kind: Parsed_Statement_Kind, kind_size: usize, location: Source_Location*) -> Parsed_Statement* {
    let statement: Parsed_Statement* = (Parsed_Statement*) malloc(kind_size)
    statement.kind = kind
    statement.location = location
    statement.next_statement = null
    return statement
}

define Parsed_Named_Statement = struct {
    super: Parsed_Statement
    name: Token*
}

define Parsed_Named_Statement__create_kind = func (kind: Parsed_Statement_Kind, kind_size: usize, location: Source_Location*, name: Token*) -> Parsed_Named_Statement* {
    let statement: Parsed_Named_Statement* = (Parsed_Named_Statement*) Parsed_Statement__create_kind(kind, kind_size, location)
    statement.name = name
    return statement
}

define Parsed_Assignment_Statement = struct {
    super: Parsed_Statement
    object_expression: Parsed_Expression*
    value_expression: Parsed_Expression*
}

define Parsed_Assignment_Statement__create = func (object_expression: Parsed_Expression*, value_expression: Parsed_Expression*) -> Parsed_Assignment_Statement* {
    let statement: Parsed_Assignment_Statement* = (Parsed_Assignment_Statement*) Parsed_Statement__create_kind(Parsed_Statement_Kind.ASSIGNMENT, sizeof(Parsed_Assignment_Statement), object_expression.location)
    statement.object_expression = object_expression
    statement.value_expression = value_expression
    return statement
}

define Parsed_Block_Statement = struct {
    super: Parsed_Statement
    statements: Parsed_Statements*
}

define Parsed_Block_Statement__create = func (location: Source_Location*, statements: Parsed_Statements*) -> Parsed_Block_Statement* {
    let statement: Parsed_Block_Statement* = (Parsed_Block_Statement*) Parsed_Statement__create_kind(Parsed_Statement_Kind.BLOCK, sizeof(Parsed_Block_Statement), location)
    statement.statements = statements
    return statement
}

define Parsed_Break_Statement = struct {
    super: Parsed_Statement
}

define Parsed_Break_Statement__create = func (location: Source_Location*) -> Parsed_Statement* {
    return Parsed_Statement__create_kind(Parsed_Statement_Kind.BREAK, sizeof(Parsed_Break_Statement), location)
}

define Parsed_Enum_Member = struct {
    name: Token*
    next_member: Parsed_Enum_Member*
}

define Parsed_Enum_Member__create = func (name: Token*) -> Parsed_Enum_Member* {
    let member: Parsed_Enum_Member* = (Parsed_Enum_Member*) malloc(sizeof(Parsed_Enum_Member))
    member.name = name
    member.next_member = null
    return member
}

define Parsed_Enum_Statement = struct {
    super: Parsed_Named_Statement
    first_member: Parsed_Enum_Member*
}

define Parsed_Enum_Statement__create = func (location: Source_Location*, name: Token*) -> Parsed_Enum_Statement* {
    let statement: Parsed_Enum_Statement* = (Parsed_Enum_Statement*) Parsed_Named_Statement__create_kind(Parsed_Statement_Kind.ENUM, sizeof(Parsed_Enum_Statement), location, name)
    statement.first_member = null
    return statement
}

define Parsed_Expression_Statement = struct {
    super: Parsed_Statement
    expression: Parsed_Expression*
}

define Parsed_Expression_Statement__create = func (expression: Parsed_Expression*) -> Parsed_Expression_Statement* {
    let statement: Parsed_Expression_Statement* = (Parsed_Expression_Statement*) Parsed_Statement__create_kind(Parsed_Statement_Kind.EXPRESSION, sizeof(Parsed_Expression_Statement), expression.location)
    statement.expression = expression
    return statement
}

define Parsed_Function_Parameter = struct {
    name: Token*
    type: Parsed_Type*
    next_parameter: Parsed_Function_Parameter*
}

define Parsed_Function_Parameter__create = func (name: Token*, type: Parsed_Type*) -> Parsed_Function_Parameter* {
    let parameter: Parsed_Function_Parameter* = (Parsed_Function_Parameter*) malloc(sizeof(Parsed_Function_Parameter))
    parameter.name = name
    parameter.type = type
    parameter.next_parameter = null
    return parameter
}

define Parsed_Function_Statement = struct {
    super: Parsed_Named_Statement
    first_parameter: Parsed_Function_Parameter*
    return_type: Parsed_Type*
    statements: Parsed_Statements*
    is_external: bool
}

define Parsed_Function_Statement__create = func (location: Source_Location*, name: Token*, first_parameter: Parsed_Function_Parameter*, resturn_type: Parsed_Type*, statements: Parsed_Statements*, is_external: bool) -> Parsed_Statement* {
    let statement: Parsed_Function_Statement* = (Parsed_Function_Statement*) Parsed_Named_Statement__create_kind(Parsed_Statement_Kind.FUNCTION, sizeof(Parsed_Function_Statement), location, name)
    statement.first_parameter = first_parameter
    statement.return_type = resturn_type
    statement.statements = statements
    statement.is_external = is_external
    return (Parsed_Statement*) statement
}

define Parsed_Function_Type_Parameter = struct {
    name: Token*
    type: Parsed_Type*
    next_parameter: Parsed_Function_Type_Parameter*
}

define Parsed_Function_Type_Parameter__create = func (name: Token*, type: Parsed_Type*) -> Parsed_Function_Type_Parameter* {
    let parameter: Parsed_Function_Type_Parameter* = (Parsed_Function_Type_Parameter*) malloc(sizeof(Parsed_Function_Type_Parameter))
    parameter.name = name
    parameter.type = type
    parameter.next_parameter = null
    return parameter
}

define Parsed_Function_Type_Statement = struct {
    super: Parsed_Named_Statement
    first_parameter: Parsed_Function_Type_Parameter*
    return_type: Parsed_Type*
}

define Parsed_Function_Type_Statement__create = func (location: Source_Location*, name: Token*, first_parameter: Parsed_Function_Type_Parameter*, resturn_type: Parsed_Type*) -> Parsed_Statement* {
    let statement: Parsed_Function_Type_Statement* = (Parsed_Function_Type_Statement*) Parsed_Named_Statement__create_kind(Parsed_Statement_Kind.FUNCTION_TYPE, sizeof(Parsed_Function_Type_Statement), location, name)
    statement.first_parameter = first_parameter
    statement.return_type = resturn_type
    return (Parsed_Statement*) statement
}

define Parsed_If_Statement = struct {
    super: Parsed_Statement
    condition_expression: Parsed_Expression*
    true_statement: Parsed_Statement*
    false_statement: Parsed_Statement*
}

define Parsed_If_Statement__create = func (location: Source_Location*, condition_expression: Parsed_Expression*, true_statement: Parsed_Statement*, false_statement: Parsed_Statement*) -> Parsed_Statement* {
    let statement: Parsed_If_Statement* = (Parsed_If_Statement*) Parsed_Statement__create_kind(Parsed_Statement_Kind.IF, sizeof(Parsed_If_Statement), location)
    statement.condition_expression = condition_expression
    statement.true_statement = true_statement
    statement.false_statement = false_statement
    return (Parsed_Statement*) statement
}

define Parsed_Opaque_Type_Statement = struct {
    super: Parsed_Named_Statement
}

define Parsed_Opaque_Type_Statement__create = func (location: Source_Location*, name: Token*) -> Parsed_Opaque_Type_Statement* {
    return (Parsed_Opaque_Type_Statement*) Parsed_Named_Statement__create_kind(Parsed_Statement_Kind.OPAQUE_TYPE, sizeof(Parsed_Opaque_Type_Statement), location, name)
}

define Parsed_Return_Statement = struct {
    super: Parsed_Statement
    expression: Parsed_Expression*
}

define Parsed_Return_Statement__create = func (location: Source_Location*, expression: Parsed_Expression*) -> Parsed_Statement* {
    let statement: Parsed_Return_Statement* = (Parsed_Return_Statement*) Parsed_Statement__create_kind(Parsed_Statement_Kind.RETURN, sizeof(Parsed_Return_Statement), location)
    statement.expression = expression
    return (Parsed_Statement*) statement
}

define Parsed_Struct_Member = struct {
    name: Token*
    type: Parsed_Type*
    next_member: Parsed_Struct_Member*
}

define Parsed_Struct_Member__create = func (name: Token*, type: Parsed_Type*) -> Parsed_Struct_Member* {
    let member: Parsed_Struct_Member* = (Parsed_Struct_Member*) malloc(sizeof(Parsed_Struct_Member))
    member.name = name
    member.type = type
    member.next_member = null
    return member
}

define Parsed_Struct_Statement = struct {
    super: Parsed_Named_Statement
    first_member: Parsed_Struct_Member*
}

define Parsed_Struct_Statement__create = func (location: Source_Location*, name: Token*) -> Parsed_Struct_Statement* {
    let statement: Parsed_Struct_Statement* = (Parsed_Struct_Statement*) Parsed_Named_Statement__create_kind(Parsed_Statement_Kind.STRUCT, sizeof(Parsed_Struct_Statement), location, name)
    statement.first_member = null
    return statement
}

define Parsed_Variable_Statement = struct {
    super: Parsed_Named_Statement
    type: Parsed_Type*
    expression: Parsed_Expression*
    is_external: bool
}

define Parsed_Variable_Statement__create = func (location: Source_Location*, name: Token*, type: Parsed_Type*, is_external: bool) -> Parsed_Variable_Statement* {
    let statement: Parsed_Variable_Statement* = (Parsed_Variable_Statement*) Parsed_Named_Statement__create_kind(Parsed_Statement_Kind.VARIABLE, sizeof(Parsed_Variable_Statement), location, name)
    statement.type = type
    statement.is_external = is_external
    return statement
}

define Parsed_While_Statement = struct {
    super: Parsed_Statement
    condition_expression: Parsed_Expression*
    body_statement: Parsed_Statement*
}

define Parsed_While_Statement__create = func (location: Source_Location*, condition_expression: Parsed_Expression*, body_statement: Parsed_Statement*) -> Parsed_Statement* {
    let statement: Parsed_While_Statement* = (Parsed_While_Statement*) Parsed_Statement__create_kind(Parsed_Statement_Kind.WHILE, sizeof(Parsed_While_Statement), location)
    statement.condition_expression = condition_expression
    statement.body_statement = body_statement
    return (Parsed_Statement*) statement
}

define Parsed_Statements = struct {
    first_statement: Parsed_Statement*
    last_statement: Parsed_Statement*
    has_globals: bool
}

define Parsed_Statements__create = func (has_globals: bool) -> Parsed_Statements* {
    let statements: Parsed_Statements* = (Parsed_Statements*) malloc(sizeof(Parsed_Statements))
    statements.first_statement = null
    statements.last_statement = null
    statements.has_globals = has_globals
    return statements
}

define Parsed_Statements__append = func (self: Parsed_Statements*, statement: Parsed_Statement*) -> void {
    if (self.first_statement == null) {
        self.first_statement = statement
    } else {
        self.last_statement.next_statement = statement
    }
    self.last_statement = statement
}

define Parsed_Compilation_Unit__create = func () -> Parsed_Source* {
    let compilation_unit: Parsed_Source* = (Parsed_Source*) malloc(sizeof(Parsed_Source))
    compilation_unit.statements = Parsed_Statements__create(true)
    return compilation_unit
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Parser
\ ---------------------------------------------------------------------------------------------------------------------

define Parser = struct {
    scanner: Scanner*
    compilation_unit: Parsed_Source*
    current_identation: u16
}

define Parser__error = func (self: Parser*, message: String*) -> void {
    Token__error(self.scanner.current_token, message)
}

define Parser__warning = func (self: Parser*, message: String*) -> void {
    Token__warning(self.scanner.current_token, message)
}

define Parser__peek_token = func (self: Parser*, offset: u8) -> Token* {
    return Scanner__peek_token(self.scanner, offset)
}

typedef bool Token_Is_Function(Token* self)

define Parser__matches_three = func (self: Parser*, first_is: Token_Is_Function*, first_required: bool, second_is: Token_Is_Function*, second_required: bool, third_is: Token_Is_Function*) -> bool {
    let peek_offset: u8 = (u8) 0
    if (first_is(Parser__peek_token(self, peek_offset))) {
        peek_offset = peek_offset + (u8) 1
    } else if (first_required) {
        return false
    }
    if (second_is != null) {
        if (second_is(Parser__peek_token(self, peek_offset))) {
            peek_offset = peek_offset + (u8) 1
        } else if (second_required) {
            return false
        }
    }
    if (third_is != null) {
        return third_is(Parser__peek_token(self, peek_offset))
    }
    return true
}

define Parser__matches_two = func (self: Parser*, first_is: Token_Is_Function*, first_required: bool, second_is: Token_Is_Function*) -> bool {
    return Parser__matches_three(self, first_is, first_required, second_is, true, null)
}

define Parser__matches_one = func (self: Parser*, first_is: Token_Is_Function*) -> bool {
    return Parser__matches_two(self, first_is, true, null)
}

define Parser__consume_token = func (self: Parser*, check: Token_Is_Function*) -> Token* {
    if (Parser__matches_one(self, check)) {
        let token: Token* = self.scanner.current_token
        Scanner__next_token(self.scanner)
        return token
    }
    Parser__error(self, String__create_from("Unexpected token"))
    abort()
}

define Parser__consume_comment = func (self: Parser*) -> void {
    Parser__consume_token(self, Token__is_comment)
}

define Parser__consume_space = func (self: Parser*, count: u16) -> void {
    if (Parser__matches_one(self, Token__is_space)) {
        let token: Space_Token* = (Space_Token*) Parser__consume_token(self, Token__is_space)
        if (token.count != count) {
            let message: String* = String__append_cstring(String__append_i16(String__append_cstring(String__append_i16(String__create_from("Consumed "), (i16) token.count), " spaces where "), (i16) count), " were expected")
            Token__warning((Token*) token, message)
            String__delete(message)
        }
    } else if (count > (u16) 0) {
        let message: String* = String__append_cstring(String__append_i16(String__append_cstring(String__append_i16(String__create_from("Consumed "), (i16) 0), " spaces where "), (i16) count), " were expected")
        Parser__warning(self, message)
        String__delete(message)
    }
}

define Parser__consume_end_of_line = func (self: Parser*) -> void {
    if (Parser__matches_two(self, Token__is_space, false, Token__is_comment)) {
        Parser__consume_space(self, (u16) 1)
        Parser__consume_comment(self)
    } else {
        Parser__consume_space(self, (u16) 0)
    }
    let token: Token* = Parser__consume_token(self, Token__is_end_of_line)
    if (Token__is_end_of_file(token)) {
        Token__warning(token, String__create_from("Unexpected end of file"))
    }
}

define Parser__consume_empty_line = func (self: Parser*) -> bool {
    if (Parser__matches_one(self, Token__is_end_of_file)) {
        return false
    }
    if (Parser__matches_three(self, Token__is_space, false, Token__is_comment, false, Token__is_end_of_line)) {
        if (Parser__matches_two(self, Token__is_space, false, Token__is_comment)) {
            Parser__consume_space(self, self.current_identation * (u16) 4)
            Parser__consume_comment(self)
        } else {
            Parser__consume_space(self, (u16) 0)
        }
        Parser__consume_token(self, Token__is_end_of_line)
        return true
    }
    return false
}

\ primary_expression
\      | "false"
\      | "null"
\      | "true"
\      | CHARACTER
\      | IDENTIFIER
\      | INTEGER
\      | STRING
define Parser__parse_primary_expression = func (self: Parser*) -> Parsed_Expression* {
    if (Parser__matches_one(self, Token__is_true)) {
        return (Parsed_Expression*) Parsed_Bool_Expression__create(Parser__consume_token(self, Token__is_true), true)
    }
    if (Parser__matches_one(self, Token__is_null)) {
        return (Parsed_Expression*) Parsed_Null_Expression__create(Parser__consume_token(self, Token__is_null))
    }
    if (Parser__matches_one(self, Token__is_false)) {
        return (Parsed_Expression*) Parsed_Bool_Expression__create(Parser__consume_token(self, Token__is_false), false)
    }
    if (Parser__matches_one(self, Token__is_identifier)) {
        return (Parsed_Expression*) Parsed_Symbol_Expression__create(Parser__consume_token(self, Token__is_identifier))
    }
    if (Parser__matches_one(self, Token__is_integer)) {
        return (Parsed_Expression*) Parsed_Integer_Expression__create((Integer_Token*) Parser__consume_token(self, Token__is_integer))
    }
    if (Parser__matches_one(self, Token__is_character)) {
        return (Parsed_Expression*) Parsed_Character_Expression__create((Character_Token*) Parser__consume_token(self, Token__is_character))
    }
    if (Parser__matches_one(self, Token__is_string)) {
        return (Parsed_Expression*) Parsed_String_Expression__create((String_Token*) Parser__consume_token(self, Token__is_string))
    }
    if (Parser__matches_one(self, Token__is_opening_paren)) {
        let location: Source_Location* = Parser__consume_token(self, Token__is_opening_paren).location
        Parser__consume_space(self, (u16) 0)
        let expression: Parsed_Expression* = Parser__parse_expression(self)
        Parser__consume_space(self, (u16) 0)
        Parser__consume_token(self, Token__is_closing_paren)
        return (Parsed_Expression*) Parsed_Group_Expression__create(location, expression)
    }
    Parser__error(self, String__create_from("Unsupported primary expression"))
    abort()
}

\ access_expression
\      | primary_expression ( "." "*" | "." IDENTIFIER | "(" ( expression ( "," expression )*)? ")" | "[" expression "]" )*
define Parser__parse_access_expression = func (self: Parser*) -> Parsed_Expression* {
    let expression: Parsed_Expression* = Parser__parse_primary_expression(self)
    while (true) {
        let old_expression: Parsed_Expression* = expression
        if (Parser__matches_two(self, Token__is_space, false, Token__is_dot)) {
            Parser__consume_space(self, (u16) 0)
            Parser__consume_token(self, Token__is_dot)
            Parser__consume_space(self, (u16) 0)
            if (Parser__matches_one(self, Token__is_asterisk)) {
                Parser__consume_token(self, Token__is_asterisk)
                expression = (Parsed_Expression*) Parsed_Dereference_Expression__create(expression)
            } else {
                let name: Token* = Parser__consume_token(self, Token__is_identifier)
                expression = (Parsed_Expression*) Parsed_Member_Access_Expression__create(expression, name)
            }
        }
        if (Parser__matches_two(self, Token__is_space, false, Token__is_opening_paren)) {
            Parser__consume_space(self, (u16) 0)
            Parser__consume_token(self, Token__is_opening_paren)
            Parser__consume_space(self, (u16) 0)
            let call_expression: Parsed_Call_Expression* = Parsed_Call_Expression__create(expression)
            if (!Parser__matches_one(self, Token__is_closing_paren)) {
                let last_argument: Parsed_Call_Argument* = Parsed_Call_Argument__create(Parser__parse_expression(self))
                call_expression.first_argument = last_argument
                Parser__consume_space(self, (u16) 0)
                while (Parser__matches_one(self, Token__is_comma)) {
                    Parser__consume_token(self, Token__is_comma)
                    Parser__consume_space(self, (u16) 1)
                    let argument: Parsed_Call_Argument* = Parsed_Call_Argument__create(Parser__parse_expression(self))
                    last_argument.next_argument = argument
                    last_argument = argument
                    Parser__consume_space(self, (u16) 0)
                }
            }
            expression = (Parsed_Expression*) call_expression
            Parser__consume_token(self, Token__is_closing_paren)
        }
        if (Parser__matches_two(self, Token__is_space, false, Token__is_opening_bracket)) {
            Parser__consume_space(self, (u16) 0)
            Parser__consume_token(self, Token__is_opening_bracket)
            Parser__consume_space(self, (u16) 0)
            let index_expression: Parsed_Expression* = Parser__parse_expression(self)
            Parser__consume_space(self, (u16) 0)
            Parser__consume_token(self, Token__is_closing_bracket)
            expression = (Parsed_Expression*) Parsed_Array_Access_Expression__create(expression, index_expression)
        }
        if (old_expression == expression) {
            break
        }
    }
    return expression
}

\ unary_expression
\      | "-" unary_expression
\      | "!" unary_expression
\      | "&" unary_expression
\      | "(" type ")" unary_expression
\      | "sizeof" "(" type ")"
\      | access_expression
define Parser__parse_unary_expression = func (self: Parser*) -> Parsed_Expression* {
    if (Parser__matches_one(self, Token__is_minus)) {
        let location: Source_Location* = Parser__consume_token(self, Token__is_minus).location
        Parser__consume_space(self, (u16) 0)
        let expression: Parsed_Expression* = Parser__parse_unary_expression(self)
        return (Parsed_Expression*) Parsed_Minus_Expression__create(location, expression)
    }
    if (Parser__matches_one(self, Token__is_exclamation_mark)) {
        let location: Source_Location* = Parser__consume_token(self, Token__is_exclamation_mark).location
        Parser__consume_space(self, (u16) 0)
        let expression: Parsed_Expression* = Parser__parse_unary_expression(self)
        return (Parsed_Expression*) Parsed_Not_Expression__create(location, expression)
    }
    if (Parser__matches_one(self, Token__is_ampersand)) {
        let location: Source_Location* = Parser__consume_token(self, Token__is_ampersand).location
        Parser__consume_space(self, (u16) 0)
        let expression: Parsed_Expression* = Parser__parse_unary_expression(self)
        return (Parsed_Expression*) Parsed_Address_Of_Expression__create(location, expression)
    }
    if (Parser__matches_three(self, Token__is_opening_paren, true, Token__is_space, false, Token__is_identifier)) {
        let peek_offset: u8 = (u8) 1
        if (Token__is_space(Parser__peek_token(self, peek_offset))) {
            peek_offset = peek_offset + (u8) 1
        }
        if (Token__is_identifier(Parser__peek_token(self, peek_offset))) {
            peek_offset = peek_offset + (u8) 1
            if (Token__is_space(Parser__peek_token(self, peek_offset))) {
                peek_offset = peek_offset + (u8) 1
            }
            while (Token__is_asterisk(Parser__peek_token(self, peek_offset))) {
                peek_offset = peek_offset + (u8) 1
                if (Token__is_space(Parser__peek_token(self, peek_offset))) {
                    peek_offset = peek_offset + (u8) 1
                }
            }
            if (Token__is_closing_paren(Parser__peek_token(self, peek_offset))) {
                peek_offset = peek_offset + (u8) 1
                if (Token__is_space(Parser__peek_token(self, peek_offset))) {
                    peek_offset = peek_offset + (u8) 1
                }
                let location: Source_Location* = Parser__consume_token(self, Token__is_opening_paren).location
                Parser__consume_space(self, (u16) 0)
                let type: Parsed_Type* = Parser__parse_type(self)
                Parser__consume_space(self, (u16) 0)
                Parser__consume_token(self, Token__is_closing_paren)
                Parser__consume_space(self, (u16) 1)
                let expression: Parsed_Expression* = Parser__parse_unary_expression(self)
                return (Parsed_Expression*) Parsed_Cast_Expression__create(location, expression, type)
            }
        }
    }
    if (Parser__matches_one(self, Token__is_sizeof)) {
        let location: Source_Location* = Parser__consume_token(self, Token__is_sizeof).location
        Parser__consume_space(self, (u16) 0)
        Parser__consume_token(self, Token__is_opening_paren)
        Parser__consume_space(self, (u16) 0)
        let type: Parsed_Type* = Parser__parse_type(self)
        Parser__consume_space(self, (u16) 0)
        Parser__consume_token(self, Token__is_closing_paren)
        return (Parsed_Expression*) Parsed_Sizeof_Expression__create(location, type)
    }
    return Parser__parse_access_expression(self)
}

define Token__is_mutliplication = func (self: Token*) -> bool {
    return Token__is_asterisk(self) || Token__is_slash(self) || Token__is_percent(self)
}

\ multiplication
\      | unary_expression ( ( "*" | "/" | "%" ) unary_expression )*
define Parser__parse_multiplication_expression = func (self: Parser*) -> Parsed_Expression* {
    let expression: Parsed_Expression* = Parser__parse_unary_expression(self)
    while (Parser__matches_two(self, Token__is_space, false, Token__is_mutliplication)) {
        Parser__consume_space(self, (u16) 1)
        if (Parser__matches_one(self, Token__is_asterisk)) {
            Parser__consume_token(self, Token__is_asterisk)
            Parser__consume_space(self, (u16) 1)
            let right_expression: Parsed_Expression* = Parser__parse_unary_expression(self)
            expression = (Parsed_Expression*) Parsed_Multiply_Expression__create(expression, right_expression)
        } else if (Parser__matches_one(self, Token__is_slash)) {
            Parser__consume_token(self, Token__is_slash)
            Parser__consume_space(self, (u16) 1)
            let right_expression: Parsed_Expression* = Parser__parse_unary_expression(self)
            expression = (Parsed_Expression*) Parsed_Divide_Expression__create(expression, right_expression)
        } else {
            Parser__consume_token(self, Token__is_percent)
            Parser__consume_space(self, (u16) 1)
            let right_expression: Parsed_Expression* = Parser__parse_unary_expression(self)
            expression = (Parsed_Expression*) Parsed_Modulo_Expression__create(expression, right_expression)
        }
    }
    return expression
}

define Token__is_addition = func (self: Token*) -> bool {
    return Token__is_plus(self) || Token__is_minus(self)
}

\ addition
\      | multiplication ( ( "+" | "-" ) multiplication )*
define Parser__parse_addition_expression = func (self: Parser*) -> Parsed_Expression* {
    let expression: Parsed_Expression* = Parser__parse_multiplication_expression(self)
    while (Parser__matches_two(self, Token__is_space, false, Token__is_addition)) {
        Parser__consume_space(self, (u16) 1)
        if (Parser__matches_one(self, Token__is_plus)) {
            Parser__consume_token(self, Token__is_plus)
            Parser__consume_space(self, (u16) 1)
            let right_expression: Parsed_Expression* = Parser__parse_multiplication_expression(self)
            expression = (Parsed_Expression*) Parsed_Add_Expression__create(expression, right_expression)
        } else {
            Parser__consume_token(self, Token__is_minus)
            Parser__consume_space(self, (u16) 1)
            let right_expression: Parsed_Expression* = Parser__parse_multiplication_expression(self)
            expression = (Parsed_Expression*) Parsed_Substract_Expression__create(expression, right_expression)
        }
    }
    return expression
}

\ comparison
\      | addition ( ( "<=" | "<" | ">" | ">=") addition )*
define Parser__parse_comparison_expression = func (self: Parser*) -> Parsed_Expression* {
    let expression: Parsed_Expression* = Parser__parse_addition_expression(self)
    if (Parser__matches_two(self, Token__is_space, false, Token__is_less_than)) {
        Parser__consume_space(self, (u16) 1)
        Parser__consume_token(self, Token__is_less_than)
        if (Parser__matches_one(self, Token__is_equals)) {
            Parser__consume_token(self, Token__is_equals)
            Parser__consume_space(self, (u16) 1)
            let right_expression: Parsed_Expression* = Parser__parse_addition_expression(self)
            expression = (Parsed_Expression*) Parsed_Less_Or_Equals_Expression__create(expression, right_expression)
        } else {
            Parser__consume_space(self, (u16) 1)
            let right_expression: Parsed_Expression* = Parser__parse_addition_expression(self)
            expression = (Parsed_Expression*) Parsed_Less_Expression__create(expression, right_expression)
        }
    } else if (Parser__matches_two(self, Token__is_space, false, Token__is_greater_than)) {
        Parser__consume_space(self, (u16) 1)
        Parser__consume_token(self, Token__is_greater_than)
        if (Parser__matches_one(self, Token__is_equals)) {
            Parser__consume_token(self, Token__is_equals)
            Parser__consume_space(self, (u16) 1)
            let right_expression: Parsed_Expression* = Parser__parse_addition_expression(self)
            expression = (Parsed_Expression*) Parsed_Greater_Or_Equals_Expression__create(expression, right_expression)
        } else {
            Parser__consume_space(self, (u16) 1)
            let right_expression: Parsed_Expression* = Parser__parse_addition_expression(self)
            expression = (Parsed_Expression*) Parsed_Greater_Expression__create(expression, right_expression)
        }
    }
    return expression
}

\ equality
\      | comparison ( ( "==" | "!=" ) comparison )*
define Parser__parse_equality_expression = func (self: Parser*) -> Parsed_Expression* {
    let expression: Parsed_Expression* = Parser__parse_comparison_expression(self)
    if (Parser__matches_three(self, Token__is_space, false, Token__is_equals, true, Token__is_equals)) {
        Parser__consume_space(self, (u16) 1)
        Parser__consume_token(self, Token__is_equals)
        Parser__consume_token(self, Token__is_equals)
        Parser__consume_space(self, (u16) 1)
        let right_expression: Parsed_Expression* = Parser__parse_comparison_expression(self)
        expression = (Parsed_Expression*) Parsed_Equals_Expression__create(expression, right_expression)
    } else if (Parser__matches_three(self, Token__is_space, false, Token__is_exclamation_mark, true, Token__is_equals)) {
        Parser__consume_space(self, (u16) 1)
        Parser__consume_token(self, Token__is_exclamation_mark)
        Parser__consume_token(self, Token__is_equals)
        Parser__consume_space(self, (u16) 1)
        let right_expression: Parsed_Expression* = Parser__parse_comparison_expression(self)
        expression = (Parsed_Expression*) Parsed_Not_Equals_Expression__create(expression, right_expression)
    }
    return expression
}

\ logic_and
\      | equality ( "&&" equality )*
define Parser__parse_logic_and_expression = func (self: Parser*) -> Parsed_Expression* {
    let expression: Parsed_Expression* = Parser__parse_equality_expression(self)
    while (Parser__matches_three(self, Token__is_space, false, Token__is_ampersand, true, Token__is_ampersand)) {
        Parser__consume_space(self, (u16) 1)
        Parser__consume_token(self, Token__is_ampersand)
        Parser__consume_token(self, Token__is_ampersand)
        Parser__consume_space(self, (u16) 1)
        let right_expression: Parsed_Expression* = Parser__parse_equality_expression(self)
        expression = (Parsed_Expression*) Parsed_Logic_And_Expression__create(expression, right_expression)
    }
    return expression
}

\ logic_or
\      | logic_and ( "||" logic_and )*
define Parser__parse_logic_or_expression = func (self: Parser*) -> Parsed_Expression* {
    let expression: Parsed_Expression* = Parser__parse_logic_and_expression(self)
    while (Parser__matches_three(self, Token__is_space, false, Token__is_vertical_bar, true, Token__is_vertical_bar)) {
        Parser__consume_space(self, (u16) 1)
        Parser__consume_token(self, Token__is_vertical_bar)
        Parser__consume_token(self, Token__is_vertical_bar)
        Parser__consume_space(self, (u16) 1)
        let right_expression: Parsed_Expression* = Parser__parse_logic_and_expression(self)
        expression = (Parsed_Expression*) Parsed_Logic_Or_Expression__create(expression, right_expression)
    }
    return expression
}

\ expression
\      | logic_or
define Parser__parse_expression = func (self: Parser*) -> Parsed_Expression* {
    return Parser__parse_logic_or_expression(self)
}

\ struct
\   | "opaque" "type"
define Parser__parse_opaque_type = func (self: Parser*, name: Token*) -> Parsed_Statement* {
    Parser__consume_token(self, Token__is_opaque)
    Parser__consume_space(self, (u16) 1)
    Parser__consume_token(self, Token__is_type)
    return (Parsed_Statement*) Parsed_Opaque_Type_Statement__create(name.location, name)
}

\ struct
\   | "struct" "{" ( IDENTIFIER ":" type )* "}"
define Parser__parse_struct = func (self: Parser*, name: Token*) -> Parsed_Statement* {
    Parser__consume_token(self, Token__is_struct)
    Parser__consume_space(self, (u16) 1)
    Parser__consume_token(self, Token__is_opening_brace)
    Parser__consume_end_of_line(self)
    let struct_statement: Parsed_Struct_Statement* = Parsed_Struct_Statement__create(name.location, name)
    let last_member: Parsed_Struct_Member* = null
    self.current_identation = self.current_identation + (u16) 1
    while (Parser__consume_empty_line(self)) {
        \ ignored
    }
    while (!Parser__matches_two(self, Token__is_space, false, Token__is_closing_brace)) {
        Parser__consume_space(self, self.current_identation * (u16) 4)
        let name: Token* = Parser__consume_token(self, Token__is_identifier)
        Parser__consume_space(self, (u16) 0)
        Parser__consume_token(self, Token__is_colon)
        Parser__consume_space(self, (u16) 1)
        let type: Parsed_Type* = Parser__parse_type(self)
        Parser__consume_end_of_line(self)
        let member: Parsed_Struct_Member* = Parsed_Struct_Member__create(name, type)
        if (last_member == null) {
            struct_statement.first_member = member
            last_member = member
        } else {
            last_member.next_member = member
            last_member = member
        }
        while (Parser__consume_empty_line(self)) {
            \ ignored
        }
    }
    self.current_identation = self.current_identation - (u16) 1
    Parser__consume_space(self, self.current_identation * (u16) 4)
    Parser__consume_token(self, Token__is_closing_brace)
    return (Parsed_Statement*) struct_statement
}

\ enum
\      | "enum" "{" ( IDENTIFIER )* "}"
define Parser__parse_enum = func (self: Parser*, name: Token*) -> Parsed_Statement* {
    Parser__consume_token(self, Token__is_enum)
    Parser__consume_space(self, (u16) 1)
    Parser__consume_token(self, Token__is_opening_brace)
    Parser__consume_end_of_line(self)
    let enum_statement: Parsed_Enum_Statement* = Parsed_Enum_Statement__create(name.location, name)
    let last_member: Parsed_Enum_Member* = null
    self.current_identation = self.current_identation + (u16) 1
    while (Parser__consume_empty_line(self)) {
        \ ignored
    }
    while (!Parser__matches_two(self, Token__is_space, false, Token__is_closing_brace)) {
        Parser__consume_space(self, self.current_identation * (u16) 4)
        let name: Token* = Parser__consume_token(self, Token__is_identifier)
        Parser__consume_end_of_line(self)
        let member: Parsed_Enum_Member* = Parsed_Enum_Member__create(name)
        if (last_member == null) {
            enum_statement.first_member = member
            last_member = member
        } else {
            last_member.next_member = member
            last_member = member
        }
        while (Parser__consume_empty_line(self)) {
            \ ignored
        }
    }
    self.current_identation = self.current_identation - (u16) 1
    Parser__consume_space(self, self.current_identation * (u16) 4)
    Parser__consume_token(self, Token__is_closing_brace)
    return (Parsed_Statement*) enum_statement
}

\ type
\   | IDENTIFIER "*"*
define Parser__parse_type = func (self: Parser*) -> Parsed_Type* {
    let name: Token* = Parser__consume_token(self, Token__is_identifier)
    let type: Parsed_Type* = Parsed_Named_Type__create(name)
    while (Parser__matches_two(self, Token__is_space, false, Token__is_asterisk)) {
        Parser__consume_space(self, (u16) 0)
        Parser__consume_token(self, Token__is_asterisk)
        type = Parsed_Pointer_Type__create(type)
    }
    return type
}

\ type_alias
\      | "typedef" type IDENTIFIER "(" ( type IDENTIFIER ( "," type IDENTIFIER )* )? ")"
define Parser__parse_type_alias = func (self: Parser*) -> Parsed_Statement* {
    let location: Source_Location* = Parser__consume_token(self, Token__is_typedef).location
    Parser__consume_space(self, (u16) 1)
    let return_type: Parsed_Type* = Parser__parse_type(self)
    Parser__consume_space(self, (u16) 1)
    let name: Token* = Parser__consume_token(self, Token__is_identifier)
    Parser__consume_space(self, (u16) 0)
    Parser__consume_token(self, Token__is_opening_paren)
    let first_parameter: Parsed_Function_Type_Parameter* = null
    if (!Parser__matches_two(self, Token__is_space, false, Token__is_closing_paren)) {
        Parser__consume_space(self, (u16) 0)
        let parameter_type: Parsed_Type* = Parser__parse_type(self)
        Parser__consume_space(self, (u16) 1)
        let parameter_name: Token* = Parser__consume_token(self, Token__is_identifier)
        first_parameter = Parsed_Function_Type_Parameter__create(parameter_name, parameter_type)
        let last_parameter: Parsed_Function_Type_Parameter* = first_parameter
        while (Parser__matches_two(self, Token__is_space, false, Token__is_comma)) {
            Parser__consume_space(self, (u16) 0)
            Parser__consume_token(self, Token__is_comma)
            Parser__consume_space(self, (u16) 1)
            let parameter_type: Parsed_Type* = Parser__parse_type(self)
            Parser__consume_space(self, (u16) 1)
            let parameter_name: Token* = Parser__consume_token(self, Token__is_identifier)
            let parameter: Parsed_Function_Type_Parameter* = Parsed_Function_Type_Parameter__create(parameter_name, parameter_type)
            last_parameter.next_parameter = parameter
            last_parameter = parameter
        }
    }
    Parser__consume_space(self, (u16) 0)
    Parser__consume_token(self, Token__is_closing_paren)
    return Parsed_Function_Type_Statement__create(location, name, first_parameter, return_type)
}

\ variable
\      | "let" IDENTIFIER ":" type "=" ( "external" | "undefined" | expression )
define Parser__parse_variable = func (self: Parser*) -> Parsed_Statement* {
    Parser__consume_token(self, Token__is_let)
    Parser__consume_space(self, (u16) 1)
    let name: Token* = Parser__consume_token(self, Token__is_identifier)
    Parser__consume_space(self, (u16) 0)
    Parser__consume_token(self, Token__is_colon)
    Parser__consume_space(self, (u16) 1)
    let type: Parsed_Type* = Parser__parse_type(self)
    Parser__consume_space(self, (u16) 1)
    Parser__consume_token(self, Token__is_equals)
    Parser__consume_space(self, (u16) 1)

    let is_external: bool = undefined
    let value_expression: Parsed_Expression* = undefined
    if (Parser__matches_one(self, Token__is_external)) {
        Parser__consume_token(self, Token__is_external)
        value_expression = null
        is_external = true
    } else if (Parser__matches_one(self, Token__is_undefined)) {
        Parser__consume_token(self, Token__is_undefined)
        value_expression = null
        is_external = false
    } else {
        value_expression = Parser__parse_expression(self)
        is_external = false
    }
    let variable_statement: Parsed_Variable_Statement* = Parsed_Variable_Statement__create(name.location, name, type, is_external)
    variable_statement.expression = value_expression
    return (Parsed_Statement*) variable_statement
}

\ old_variable
\      | "extern"? type IDENTIFIER ( "=" expression )?
define Parser__parse_old_variable = func (self: Parser*) -> Parsed_Statement* {
    let is_external: bool = undefined
    let location: Source_Location* = undefined
    if (Parser__matches_one(self, Token__is_external)) {
        is_external = true
        location = Parser__consume_token(self, Token__is_external).location
        Parser__consume_space(self, (u16) 1)
    } else {
        is_external = false
        location = Parser__peek_token(self, (u8) 0).location
    }
    let type: Parsed_Type* = Parser__parse_type(self)
    Parser__consume_space(self, (u16) 1)
    let name: Token* = Parser__consume_token(self, Token__is_identifier)
    let variable_statement: Parsed_Variable_Statement* = Parsed_Variable_Statement__create(location, name, type, is_external)
    if (Parser__matches_two(self, Token__is_space, false, Token__is_equals)) {
        Parser__consume_space(self, (u16) 1)
        Parser__consume_token(self, Token__is_equals)
        Parser__consume_space(self, (u16) 1)
        variable_statement.expression = Parser__parse_expression(self)
    }
    return (Parsed_Statement*) variable_statement
}

\ block
\      | "{" statements "}"
define Parser__parse_block_statement = func (self: Parser*) -> Parsed_Block_Statement* {
    let location: Source_Location* = Parser__consume_token(self, Token__is_opening_brace).location
    Parser__consume_end_of_line(self)
    let statements: Parsed_Statements* = Parsed_Statements__create(false)
    self.current_identation = self.current_identation + (u16) 1
    Parser__parse_statements(self, statements)
    self.current_identation = self.current_identation - (u16) 1
    Parser__consume_space(self, self.current_identation * (u16) 4)
    Parser__consume_token(self, Token__is_closing_brace)
    return Parsed_Block_Statement__create(location, statements)
}

\ function_parameter
\   IDENTIFIER ":" type
define Parser__parse_function_parameter = func (self: Parser*) -> Parsed_Function_Parameter* {
    let name: Token* = Parser__consume_token(self, Token__is_identifier)
    Parser__consume_space(self, (u16) 0)
    Parser__consume_token(self, Token__is_colon)
    Parser__consume_space(self, (u16) 1)
    let type: Parsed_Type* = Parser__parse_type(self)
    return Parsed_Function_Parameter__create(name, type)
}

\ function
\   | "func" "(" function_parameter* ")" "->" type "{" statements "}"
define Parser__parse_function = func (self: Parser*, name: Token*) -> Parsed_Statement* {
    Parser__consume_token(self, Token__is_func)
    Parser__consume_space(self, (u16) 1)
    Parser__consume_token(self, Token__is_opening_paren)
    let first_parameter: Parsed_Function_Parameter* = null
    if (!Parser__matches_two(self, Token__is_space, false, Token__is_closing_paren)) {
        Parser__consume_space(self, (u16) 0)
        first_parameter = Parser__parse_function_parameter(self)
        let last_parameter: Parsed_Function_Parameter* = first_parameter
        while (Parser__matches_two(self, Token__is_space, false, Token__is_comma)) {
            Parser__consume_space(self, (u16) 0)
            Parser__consume_token(self, Token__is_comma)
            Parser__consume_space(self, (u16) 1)
            last_parameter.next_parameter = Parser__parse_function_parameter(self)
            last_parameter = last_parameter.next_parameter
        }
    }
    Parser__consume_space(self, (u16) 0)
    Parser__consume_token(self, Token__is_closing_paren)
    Parser__consume_space(self, (u16) 1)
    Parser__consume_token(self, Token__is_minus)
    Parser__consume_space(self, (u16) 0)
    Parser__consume_token(self, Token__is_greater_than)
    Parser__consume_space(self, (u16) 1)
    let return_type: Parsed_Type* = Parser__parse_type(self)
    Parser__consume_space(self, (u16) 1)
    Parser__consume_token(self, Token__is_opening_brace)
    Parser__consume_end_of_line(self)
    let statements: Parsed_Statements* = Parsed_Statements__create(false)
    self.current_identation = self.current_identation + (u16) 1
    Parser__parse_statements(self, statements)
    self.current_identation = self.current_identation - (u16) 1
    Parser__consume_space(self, self.current_identation * (u16) 4)
    Parser__consume_token(self, Token__is_closing_brace)
    return Parsed_Function_Statement__create(name.location, name, first_parameter, return_type, statements, false)
}

\ function
\   | "external" "func" "(" function_parameter* ")" "->" type "{" statements "}"
define Parser__parse_external_function = func (self: Parser*, name: Token*) -> Parsed_Statement* {
    Parser__consume_token(self, Token__is_external)
    Parser__consume_space(self, (u16) 1)
    Parser__consume_token(self, Token__is_func)
    Parser__consume_space(self, (u16) 1)
    Parser__consume_token(self, Token__is_opening_paren)
    let first_parameter: Parsed_Function_Parameter* = null
    if (!Parser__matches_two(self, Token__is_space, false, Token__is_closing_paren)) {
        Parser__consume_space(self, (u16) 0)
        first_parameter = Parser__parse_function_parameter(self)
        let last_parameter: Parsed_Function_Parameter* = first_parameter
        while (Parser__matches_two(self, Token__is_space, false, Token__is_comma)) {
            Parser__consume_space(self, (u16) 0)
            Parser__consume_token(self, Token__is_comma)
            Parser__consume_space(self, (u16) 1)
            last_parameter.next_parameter = Parser__parse_function_parameter(self)
            last_parameter = last_parameter.next_parameter
        }
    }
    Parser__consume_space(self, (u16) 0)
    Parser__consume_token(self, Token__is_closing_paren)
    Parser__consume_space(self, (u16) 1)
    Parser__consume_token(self, Token__is_minus)
    Parser__consume_space(self, (u16) 0)
    Parser__consume_token(self, Token__is_greater_than)
    Parser__consume_space(self, (u16) 1)
    let return_type: Parsed_Type* = Parser__parse_type(self)
    return Parsed_Function_Statement__create(name.location, name, first_parameter, return_type, null, true)
}

\ return
\      | "return" expression?
define Parser__parse_return_statement = func (self: Parser*) -> Parsed_Statement* {
    let location: Source_Location* = Parser__consume_token(self, Token__is_return).location
    let expression: Parsed_Expression* = null
    if (!Parser__matches_three(self, Token__is_space, false, Token__is_comment, false, Token__is_end_of_line)) {
        Parser__consume_space(self, (u16) 1)
        expression = Parser__parse_expression(self)
    }
    return Parsed_Return_Statement__create(location, expression)
}

\ break
\      | "break"
define Parser__parse_break_statement = func (self: Parser*) -> Parsed_Statement* {
    let location: Source_Location* = Parser__consume_token(self, Token__is_break).location
    return Parsed_Break_Statement__create(location)
}

\ if
\      | "if" "(" expression ")" statement ( "else" statement )?
define Parser__parse_if_statement = func (self: Parser*) -> Parsed_Statement* {
    let location: Source_Location* = Parser__consume_token(self, Token__is_if).location
    Parser__consume_space(self, (u16) 1)
    Parser__consume_token(self, Token__is_opening_paren)
    Parser__consume_space(self, (u16) 0)
    let condition_expression: Parsed_Expression* = Parser__parse_expression(self)
    Parser__consume_space(self, (u16) 0)
    Parser__consume_token(self, Token__is_closing_paren)
    Parser__consume_space(self, (u16) 1)
    let true_statement: Parsed_Statement* = (Parsed_Statement*) Parser__parse_block_statement(self)
    let false_statement: Parsed_Statement* = null
    if (Parser__matches_two(self, Token__is_space, false, Token__is_else)) {
        Parser__consume_space(self, (u16) 1)
        Parser__consume_token(self, Token__is_else)
        Parser__consume_space(self, (u16) 1)
        if (Parser__matches_one(self, Token__is_if)) {
            false_statement = Parser__parse_if_statement(self)
        } else {
            false_statement = (Parsed_Statement*) Parser__parse_block_statement(self)
        }
    }
    return Parsed_If_Statement__create(location, condition_expression, true_statement, false_statement)
}

\ while
\      | "while" "(" expression ")" statement
define Parser__parse_while_statement = func (self: Parser*) -> Parsed_Statement* {
    let location: Source_Location* = Parser__consume_token(self, Token__is_while).location
    Parser__consume_space(self, (u16) 1)
    Parser__consume_token(self, Token__is_opening_paren)
    Parser__consume_space(self, (u16) 0)
    let condition_expression: Parsed_Expression* = Parser__parse_expression(self)
    Parser__consume_space(self, (u16) 0)
    Parser__consume_token(self, Token__is_closing_paren)
    Parser__consume_space(self, (u16) 1)
    let body_statement: Parsed_Statement* = (Parsed_Statement*) Parser__parse_block_statement(self)
    return Parsed_While_Statement__create(location, condition_expression, body_statement)
}

\ statement
\   | define ( enum | function | opaque_type | struct )
\   | old_function
\   | if
\   | return
\   | type_alias
\   | variable
define Parser__parse_statement = func (self: Parser*) -> Parsed_Statement* {
    Parser__consume_space(self, self.current_identation * (u16) 4)

    if (Parser__matches_one(self, Token__is_if)) {
        return Parser__parse_if_statement(self)
    }
    if (Parser__matches_one(self, Token__is_while)) {
        return Parser__parse_while_statement(self)
    }
    if (Parser__matches_one(self, Token__is_return)) {
        return Parser__parse_return_statement(self)
    }
    if (Parser__matches_one(self, Token__is_break)) {
        return Parser__parse_break_statement(self)
    }

    if (Parser__matches_one(self, Token__is_define)) {
        Parser__consume_token(self, Token__is_define)
        Parser__consume_space(self, (u16) 1)
        let name: Token* = Parser__consume_token(self, Token__is_identifier)
        Parser__consume_space(self, (u16) 1)
        Parser__consume_token(self, Token__is_equals)
        Parser__consume_space(self, (u16) 1)
        if (Parser__matches_one(self, Token__is_func)) {
            return Parser__parse_function(self, name)
        } else if (Parser__matches_one(self, Token__is_struct)) {
            return Parser__parse_struct(self, name)
        } else if (Parser__matches_three(self, Token__is_opaque, true, Token__is_space, true, Token__is_type)) {
            return Parser__parse_opaque_type(self, name)
        } else if (Parser__matches_one(self, Token__is_enum)) {
            return Parser__parse_enum(self, name)
        } else if (Parser__matches_three(self, Token__is_external, true, Token__is_space, true, Token__is_func)) {
            return Parser__parse_external_function(self, name)
        }
        Parser__error(self, String__create_from("Unsupported define"))
        abort()
    }

    if (Parser__matches_one(self, Token__is_typedef)) {
        return Parser__parse_type_alias(self)
    }

    if (Parser__matches_one(self, Token__is_let)) {
        return Parser__parse_variable(self)
    }

    let expresion: Parsed_Expression* = Parser__parse_access_expression(self)
    if (Parser__matches_two(self, Token__is_space, false, Token__is_equals)) {
        Parser__consume_space(self, (u16) 1)
        Parser__consume_token(self, Token__is_equals)
        Parser__consume_space(self, (u16) 1)
        let value_expression: Parsed_Expression* = Parser__parse_expression(self)
        return (Parsed_Statement*) Parsed_Assignment_Statement__create(expresion, value_expression)
    }
    return (Parsed_Statement*) Parsed_Expression_Statement__create(expresion)
}

\ statements
\      | ( statement )*
define Parser__parse_statements = func (self: Parser*, statements: Parsed_Statements*) -> void {
    while (true) {
        while (Parser__consume_empty_line(self)) {
            \ ignored
        }

        if (statements.has_globals) {
            if (Parser__matches_three(self, Token__is_space, false, Token__is_comment, false, Token__is_end_of_line)) {
                return
            }
        } else {
            if (Parser__matches_two(self, Token__is_space, false, Token__is_closing_brace)) {
                return
            }
        }

        let statement: Parsed_Statement* = Parser__parse_statement(self)

        Parser__consume_end_of_line(self)

        Parsed_Statements__append(statements, statement)
    }
}

define Parser__parse_source = func (self: Parser*, source: Source*) -> void {
    let other_scanner: Scanner* = self.scanner

    self.scanner = Scanner__create(source)

    Parser__parse_statements(self, self.compilation_unit.statements)

    let last_token: Token* = Parser__peek_token(self, (u8) 0)
    if (!Token__is_end_of_file(last_token)) {
        Parser__error(self, String__create_from("Scanner didn't reach end of file"))
        abort()
    } else if (last_token.location.column != (u16) 1) {
        Parser__warning(self, String__create_from("No new line at the end of file"))
    }

    self.scanner = other_scanner
}

define parse = func (source: Source*) -> Parsed_Source* {
    let parser: Parser = undefined
    parser.scanner = null
    parser.compilation_unit = Parsed_Compilation_Unit__create()
    parser.current_identation = (u16) 0

    Parser__parse_source(&parser, source)

    return parser.compilation_unit
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Checked Types
\ ---------------------------------------------------------------------------------------------------------------------

define Checked_Type_Kind = enum {
    \ Builtins
    BOOL
    CHAR
    I16
    I32
    I64
    I8
    USIZE
    U16
    U32
    U64
    U8
    VOID
    NULL \ Pseudo type
    \ Defined
    DEFINED
    ENUM
    FUNCTION
    OPAQUE
    STRUCT
    \ Dynamic
    POINTER
}

define Checked_Type = struct {
    kind: Checked_Type_Kind
    location: Source_Location*
    next_type: Checked_Type*
}

define Checked_Type__create_kind = func (kind: Checked_Type_Kind, kind_size: usize, location: Source_Location*) -> Checked_Type* {
    let type: Checked_Type* = (Checked_Type*) malloc(kind_size)
    type.kind = kind
    type.location = location
    type.next_type = null
    return type
}

define Checked_Type__expect_same_type = func (self: Checked_Type*, other_type: Checked_Type*, location: Source_Location*) -> void {
    if (self.kind == Checked_Type_Kind.POINTER && other_type.kind == Checked_Type_Kind.NULL) {
        return
    }
    if (!Checked_Type__equals(self, other_type)) {
        let message: String* = String__create_from("Unexpected type. Got \"")
        String__append_checked_type(message, other_type)
        String__append_cstring(message, "\" instead of \"")
        String__append_checked_type(message, self)
        String__append_char(message, '"')
        Source_Location__error(location, message)
        abort()
    }
}

define Checked_Type__is_scalar_type = func (self: Checked_Type*) -> bool {
    if (self.kind == Checked_Type_Kind.CHAR) {
        return true
    } else if (self.kind == Checked_Type_Kind.I16) {
        return true
    } else if (self.kind == Checked_Type_Kind.I32) {
        return true
    } else if (self.kind == Checked_Type_Kind.I64) {
        return true
    } else if (self.kind == Checked_Type_Kind.I8) {
        return true
    } else if (self.kind == Checked_Type_Kind.U16) {
        return true
    } else if (self.kind == Checked_Type_Kind.U32) {
        return true
    } else if (self.kind == Checked_Type_Kind.U64) {
        return true
    } else if (self.kind == Checked_Type_Kind.U8) {
        return true
    } else if (self.kind == Checked_Type_Kind.USIZE) {
        return true
    } else if (self.kind == Checked_Type_Kind.ENUM) {
        return true
    }
    return false
}

define Checked_Type__expect_scalar_type = func (self: Checked_Type*, location: Source_Location*) -> void {
    if (!Checked_Type__is_scalar_type(self)) {
        let message: String* = String__create_from("Type \"")
        String__append_checked_type(message, self)
        String__append_cstring(message, "\" is not a scalar type")
        Source_Location__error(location, message)
        abort()
    }
}

define Checked_Named_Type = struct {
    super: Checked_Type
    name: String*
}

define Checked_Named_Type__create_kind = func (kind: Checked_Type_Kind, kind_size: usize, location: Source_Location*, name: String*) -> Checked_Named_Type* {
    let type: Checked_Named_Type* = (Checked_Named_Type*) Checked_Type__create_kind(kind, kind_size, location)
    type.name = name
    return type
}

define Checked_Enum_Member = struct {
    location: Source_Location*
    name: String*
    symbol: Checked_Symbol*
    next_member: Checked_Enum_Member*
}

define Checked_Enum_Member__create = func (location: Source_Location*, name: String*) -> Checked_Enum_Member* {
    let member: Checked_Enum_Member* = (Checked_Enum_Member*) malloc(sizeof(Checked_Enum_Member))
    member.location = location
    member.name = name
    member.symbol = null
    member.next_member = null
    return member
}

define Checked_Enum_Type = struct {
    super: Checked_Named_Type
    first_member: Checked_Enum_Member*
}

define Checked_Enum_Type__create = func (location: Source_Location*, name: String*) -> Checked_Enum_Type* {
    let type: Checked_Enum_Type* = (Checked_Enum_Type*) Checked_Named_Type__create_kind(Checked_Type_Kind.ENUM, sizeof(Checked_Enum_Type), location, name)
    type.first_member = null
    return type
}

define Checked_Enum_Type__find_member = func (self: Checked_Enum_Type*, name: String*) -> Checked_Enum_Member* {
    let member: Checked_Enum_Member* = self.first_member
    while (member != null) {
        if (String__equals_string(name, member.name)) {
            break
        }
        member = member.next_member
    }
    return member
}

define Checked_Function_Parameter = struct {
    location: Source_Location*
    name: String*
    type: Checked_Type*
    next_parameter: Checked_Function_Parameter*
}

define Checked_Function_Parameter__create = func (location: Source_Location*, name: String*, type: Checked_Type*) -> Checked_Function_Parameter* {
    let parameter: Checked_Function_Parameter* = (Checked_Function_Parameter*) malloc(sizeof(Checked_Function_Parameter))
    parameter.location = location
    parameter.name = name
    parameter.type = type
    parameter.next_parameter = null
    return parameter
}

define Checked_Function_Type = struct {
    super: Checked_Named_Type
    return_type: Checked_Type*
    first_parameter: Checked_Function_Parameter*
}

define Checked_Function_Type__create = func (location: Source_Location*, name: String*, return_type: Checked_Type*) -> Checked_Function_Type* {
    let type: Checked_Function_Type* = (Checked_Function_Type*) Checked_Named_Type__create_kind(Checked_Type_Kind.FUNCTION, sizeof(Checked_Function_Type), location, name)
    type.return_type = return_type
    type.first_parameter = null
    return type
}

define Checked_Function_Type__equals = func (self: Checked_Function_Type*, other_type: Checked_Type*) -> bool {
    if (other_type.kind != self.super.super.kind) {
        return false
    }
    let function_type: Checked_Function_Type* = (Checked_Function_Type*) other_type
    if (!Checked_Type__equals(self.return_type, function_type.return_type)) {
        return false
    }
    let self_parameter: Checked_Function_Parameter* = self.first_parameter
    let function_parameter: Checked_Function_Parameter* = function_type.first_parameter
    while (self_parameter != null && function_parameter != null) {
        if (!Checked_Type__equals(self_parameter.type, function_parameter.type)) {
            return false
        }
        self_parameter = self_parameter.next_parameter
        function_parameter = function_parameter.next_parameter
    }
    if (self_parameter != null || function_parameter != null) {
        return false
    }
    return true
}

define Checked_Opaque_Type = struct {
    super: Checked_Named_Type
}

define Checked_Opaque_Type__create = func (location: Source_Location*, name: String*) -> Checked_Opaque_Type* {
    return (Checked_Opaque_Type*) Checked_Named_Type__create_kind(Checked_Type_Kind.OPAQUE, sizeof(Checked_Opaque_Type), location, name)
}

define Checked_Pointer_Type = struct {
    super: Checked_Type
    other_type: Checked_Type*
}

define Checked_Pointer_Type__create = func (location: Source_Location*, other_type: Checked_Type*) -> Checked_Pointer_Type* {
    let type: Checked_Pointer_Type* = (Checked_Pointer_Type*) Checked_Type__create_kind(Checked_Type_Kind.POINTER, sizeof(Checked_Pointer_Type), location)
    type.other_type = other_type
    return type
}

define Checked_Pointer_Type__equals = func (self: Checked_Pointer_Type*, other_type: Checked_Type*) -> bool {
    if (other_type.kind != self.super.kind) {
        return false
    }
    return Checked_Type__equals(self.other_type, ((Checked_Pointer_Type*) other_type).other_type)
}

define Checked_Defined_Type = struct {
    super: Checked_Type
    defined_type: Checked_Named_Type*
}

define Checked_Defined_Type__create = func (defined_type: Checked_Named_Type*) -> Checked_Defined_Type* {
    let type: Checked_Defined_Type* = (Checked_Defined_Type*) Checked_Type__create_kind(Checked_Type_Kind.DEFINED, sizeof(Checked_Defined_Type), defined_type.super.location)
    type.defined_type = defined_type
    return type
}

define Checked_Struct_Member = struct {
    location: Source_Location*
    name: String*
    type: Checked_Type*
    next_member: Checked_Struct_Member*
}

define Checked_Struct_Member__create = func (location: Source_Location*, name: String*, type: Checked_Type*) -> Checked_Struct_Member* {
    let member: Checked_Struct_Member* = (Checked_Struct_Member*) malloc(sizeof(Checked_Struct_Member))
    member.location = location
    member.name = name
    member.type = type
    member.next_member = null
    return member
}

define Checked_Struct_Type = struct {
    super: Checked_Named_Type
    first_member: Checked_Struct_Member*
}

define Checked_Struct_Type__create = func (location: Source_Location*, name: String*) -> Checked_Struct_Type* {
    let type: Checked_Struct_Type* = (Checked_Struct_Type*) Checked_Named_Type__create_kind(Checked_Type_Kind.STRUCT, sizeof(Checked_Struct_Type), location, name)
    type.first_member = null
    return type
}

define Checked_Struct_Type__find_member = func (self: Checked_Struct_Type*, name: String*) -> Checked_Struct_Member* {
    let member: Checked_Struct_Member* = self.first_member
    while (member != null) {
        if (String__equals_string(name, member.name)) {
            break
        }
        member = member.next_member
    }
    return member
}

define Checked_Struct_Type__equals = func (self: Checked_Struct_Type*, other_type: Checked_Type*) -> bool {
    if (self.super.super.kind != other_type.kind) {
        return false
    }
    return String__equals_string(self.super.name, ((Checked_Struct_Type*) other_type).super.name)
}

define Checked_Type__equals = func (self: Checked_Type*, other_type: Checked_Type*) -> bool {
    if (self == other_type) {
        return true
    }
    if (self.kind != other_type.kind) {
        return false
    }
    if (self.kind == Checked_Type_Kind.FUNCTION) {
        return Checked_Function_Type__equals((Checked_Function_Type*) self, other_type)
    }
    if (self.kind == Checked_Type_Kind.POINTER) {
        return Checked_Pointer_Type__equals((Checked_Pointer_Type*) self, other_type)
    }
    if (self.kind == Checked_Type_Kind.STRUCT) {
        return Checked_Struct_Type__equals((Checked_Struct_Type*) self, other_type)
    }
    Source_Location__error(self.location, String__create_from("Unsupported type"))
    abort()
}

define String__append_checked_type = func (self: String*, type: Checked_Type*) -> String* {
    if (type.kind <= Checked_Type_Kind.NULL) {
        let named_type: Checked_Named_Type* = (Checked_Named_Type*) type
        String__append_string(self, named_type.name)
    } else if (type.kind == Checked_Type_Kind.STRUCT) {
        let struct_type: Checked_Struct_Type* = (Checked_Struct_Type*) type
        String__append_cstring(self, "struct ")
        String__append_string(self, struct_type.super.name)
    } else if (type.kind == Checked_Type_Kind.FUNCTION) {
        let function_type: Checked_Function_Type* = (Checked_Function_Type*) type
        String__append_checked_type(self, function_type.return_type)
        String__append_char(self, ' ')
        String__append_string(self, function_type.super.name)
        String__append_char(self, '(')
        let function_parameter: Checked_Function_Parameter* = function_type.first_parameter
        while (function_parameter != null) {
            String__append_checked_type(self, function_parameter.type)
            String__append_char(self, ' ')
            String__append_string(self, function_parameter.name)
            function_parameter = function_parameter.next_parameter
            if (function_parameter != null) {
                String__append_cstring(self, ", ")
            }
        }
        String__append_char(self, ')')
    } else if (type.kind == Checked_Type_Kind.ENUM) {
        let enum_type: Checked_Enum_Type* = (Checked_Enum_Type*) type
        String__append_cstring(self, "enum ")
        String__append_string(self, enum_type.super.name)
    } else if (type.kind == Checked_Type_Kind.POINTER) {
        let pointer_type: Checked_Pointer_Type* = (Checked_Pointer_Type*) type
        String__append_checked_type(self, pointer_type.other_type)
        String__append_char(self, '*')
    } else {
        Source_Location__error(type.location, String__create_from("Unsupported type"))
        abort()
    }
    return self
}

define File__write_checked_function_parameter = func (self: File*, parameter: Checked_Function_Parameter*) -> void {
    if (parameter.type.kind == Checked_Type_Kind.POINTER && ((Checked_Pointer_Type*) parameter.type).other_type.kind == Checked_Type_Kind.FUNCTION) {
        let function_type: Checked_Function_Type* = (Checked_Function_Type*) ((Checked_Pointer_Type*) parameter.type).other_type
        File__write_checked_type(self, function_type.return_type)
        File__write_cstring(self, " (*")
        File__write_string(self, parameter.name)
        File__write_cstring(self, ")(")
        let function_parameter: Checked_Function_Parameter* = function_type.first_parameter
        while (function_parameter != null) {
            File__write_checked_function_parameter(self, function_parameter)
            function_parameter = function_parameter.next_parameter
            if (function_parameter != null) {
                File__write_cstring(self, ", ")
            }
        }
        File__write_char(self, ')')
    } else {
        File__write_checked_type(self, parameter.type)
        File__write_char(self, ' ')
        File__write_string(self, parameter.name)
    }
}

define File__write_checked_type = func (self: File*, type: Checked_Type*) -> void {
    if (type == null) {
        File__write_cstring(self, "null")
    } else if (type.kind == Checked_Type_Kind.I16) {
        File__write_cstring(self, "int16_t")
    } else if (type.kind == Checked_Type_Kind.I32) {
        File__write_cstring(self, "int32_t")
    } else if (type.kind == Checked_Type_Kind.I64) {
        File__write_cstring(self, "int64_t")
    } else if (type.kind == Checked_Type_Kind.I8) {
        File__write_cstring(self, "int8_t")
    } else if (type.kind == Checked_Type_Kind.U16) {
        File__write_cstring(self, "uint16_t")
    } else if (type.kind == Checked_Type_Kind.U32) {
        File__write_cstring(self, "uint32_t")
    } else if (type.kind == Checked_Type_Kind.U64) {
        File__write_cstring(self, "uint64_t")
    } else if (type.kind == Checked_Type_Kind.U8) {
        File__write_cstring(self, "uint8_t")
    } else if (type.kind == Checked_Type_Kind.USIZE) {
        File__write_cstring(self, "size_t")
    } else if (type.kind <= Checked_Type_Kind.NULL) {
        let named_type: Checked_Named_Type* = (Checked_Named_Type*) type
        File__write_string(self, named_type.name)
    } else if (type.kind == Checked_Type_Kind.STRUCT) {
        let struct_type: Checked_Struct_Type* = (Checked_Struct_Type*) type
        File__write_cstring(self, "struct ")
        File__write_string(self, struct_type.super.name)
    } else if (type.kind == Checked_Type_Kind.OPAQUE) {
        let opaque_type: Checked_Opaque_Type* = (Checked_Opaque_Type*) type
        File__write_cstring(self, "struct ")
        File__write_string(self, opaque_type.super.name)
    } else if (type.kind == Checked_Type_Kind.FUNCTION) {
        let function_type: Checked_Function_Type* = (Checked_Function_Type*) type
        File__write_checked_type(self, function_type.return_type)
        File__write_char(self, ' ')
        File__write_string(self, function_type.super.name)
        File__write_char(self, '(')
        let function_parameter: Checked_Function_Parameter* = function_type.first_parameter
        while (function_parameter != null) {
            File__write_checked_function_parameter(self, function_parameter)
            function_parameter = function_parameter.next_parameter
            if (function_parameter != null) {
                File__write_cstring(self, ", ")
            }
        }
        File__write_char(self, ')')
    } else if (type.kind == Checked_Type_Kind.ENUM) {
        let enum_type: Checked_Enum_Type* = (Checked_Enum_Type*) type
        File__write_cstring(self, "enum ")
        File__write_string(self, enum_type.super.name)
    } else if (type.kind == Checked_Type_Kind.POINTER) {
        let pointer_type: Checked_Pointer_Type* = (Checked_Pointer_Type*) type
        File__write_checked_type(self, pointer_type.other_type)
        File__write_char(self, '*')
    } else {
        Source_Location__error(type.location, String__create_from("Unsupported type"))
        abort()
    }
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Checked Symbols
\ ---------------------------------------------------------------------------------------------------------------------

define Checked_Symbol_Kind = enum {
    ENUM_MEMBER
    FUNCTION
    FUNCTION_PARAMETER
    TYPE
    VARIABLE
}

define Checked_Symbol = struct {
    kind: Checked_Symbol_Kind
    location: Source_Location*
    name: String*
    type: Checked_Type*
    prev_symbol: Checked_Symbol*
    next_symbol: Checked_Symbol*
}

define Checked_Symbol__create_kind = func (kind: Checked_Symbol_Kind, kind_size: usize, location: Source_Location*, name: String*, type: Checked_Type*) -> Checked_Symbol* {
    let symbol: Checked_Symbol* = (Checked_Symbol*) malloc(kind_size)
    symbol.kind = kind
    symbol.location = location
    symbol.name = name
    symbol.type = type
    symbol.prev_symbol = null
    symbol.next_symbol = null
    return symbol
}

define Checked_Enum_Member_Symbol = struct {
    super: Checked_Symbol
}

define Checked_Enum_Member_Symbol__create = func (location: Source_Location*, name: String*, type: Checked_Type*) -> Checked_Enum_Member_Symbol* {
    return (Checked_Enum_Member_Symbol*) Checked_Symbol__create_kind(Checked_Symbol_Kind.ENUM_MEMBER, sizeof(Checked_Enum_Member_Symbol), location, name, type)
}

define Checked_Function_Symbol = struct {
    super: Checked_Symbol
    function_type: Checked_Function_Type*
    checked_statements: Checked_Statements*
}

define Checked_Function_Symbol__create = func (location: Source_Location*, name: String*, function_type: Checked_Function_Type*) -> Checked_Function_Symbol* {
    let symbol: Checked_Function_Symbol* = (Checked_Function_Symbol*) Checked_Symbol__create_kind(Checked_Symbol_Kind.FUNCTION, sizeof(Checked_Function_Symbol), location, name, (Checked_Type*) Checked_Pointer_Type__create(function_type.super.super.location, (Checked_Type*) function_type))
    symbol.function_type = function_type
    symbol.checked_statements = null
    return symbol
}

define Checked_Function_Parameter_Symbol = struct {
    super: Checked_Symbol
}

define Checked_Function_Parameter_Symbol__create = func (location: Source_Location*, name: String*, type: Checked_Type*) -> Checked_Function_Parameter_Symbol* {
    return (Checked_Function_Parameter_Symbol*) Checked_Symbol__create_kind(Checked_Symbol_Kind.FUNCTION_PARAMETER, sizeof(Checked_Function_Parameter_Symbol), location, name, type)
}

define Checked_Type_Symbol = struct {
    super: Checked_Symbol
    named_type: Checked_Named_Type*
}

define Checked_Type_Symbol__create = func (location: Source_Location*, name: String*, named_type: Checked_Named_Type*) -> Checked_Type_Symbol* {
    let symbol: Checked_Type_Symbol* = (Checked_Type_Symbol*) Checked_Symbol__create_kind(Checked_Symbol_Kind.TYPE, sizeof(Checked_Type_Symbol), location, name, (Checked_Type*) Checked_Defined_Type__create(named_type))
    symbol.named_type = named_type
    return symbol
}

define Checked_Variable_Symbol = struct {
    super: Checked_Symbol
}

define Checked_Variable__create = func (location: Source_Location*, name: String*, type: Checked_Type*) -> Checked_Variable_Symbol* {
    return (Checked_Variable_Symbol*) Checked_Symbol__create_kind(Checked_Symbol_Kind.VARIABLE, sizeof(Checked_Variable_Symbol), location, name, type)
}

define Checked_Symbols = struct {
    parent: Checked_Symbols*
    first_symbol: Checked_Symbol*
    last_symbol: Checked_Symbol*
}

define Checked_Symbols__create = func (parent: Checked_Symbols*) -> Checked_Symbols* {
    let symbols: Checked_Symbols* = (Checked_Symbols*) malloc(sizeof(Checked_Symbols))
    symbols.parent = parent
    symbols.first_symbol = null
    symbols.last_symbol = null
    return symbols
}

define Checked_Symbols__find_sibling_symbol = func (self: Checked_Symbols*, name: String*) -> Checked_Symbol* {
    let symbol: Checked_Symbol* = self.first_symbol
    while (symbol != null) {
        if (String__equals_string(name, symbol.name)) {
            return symbol
        }
        symbol = symbol.next_symbol
    }
    return null
}

define Checked_Symbols__append_symbol = func (self: Checked_Symbols*, symbol: Checked_Symbol*) -> void {
    let other_symbol: Checked_Symbol* = Checked_Symbols__find_sibling_symbol(self, symbol.name)
    if (other_symbol != null) {
        Source_Location__error(symbol.location, String__append_source_location(String__create_from("Symbol declared first here: "), other_symbol.location))
        abort()
    }

    if (self.last_symbol == null) {
        self.first_symbol = symbol
    } else {
        self.last_symbol.next_symbol = symbol
        symbol.prev_symbol = self.last_symbol
    }
    self.last_symbol = symbol
}

define Checked_Symbols__find_symbol = func (self: Checked_Symbols*, name: String*) -> Checked_Symbol* {
    let symbol: Checked_Symbol* = self.last_symbol
    while (symbol != null) {
        if (String__equals_string(name, symbol.name)) {
            return symbol
        }
        symbol = symbol.prev_symbol
    }
    if (self.parent != null) {
        return Checked_Symbols__find_symbol(self.parent, name)
    }
    return null
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Checked Expressions
\ ---------------------------------------------------------------------------------------------------------------------

define Checked_Expression_Kind = enum {
    ADD
    ADDRESS_OF
    ARRAY_ACCESS
    BOOL
    CALL
    CAST
    CHARACTER
    DEREFERENCE
    DIVIDE
    EQUALS
    GREATER
    GREATER_OR_EQUALS
    GROUP
    INTEGER
    LESS
    LESS_OR_EQUALS
    LOGIC_AND
    LOGIC_OR
    MEMBER_ACCESS
    MINUS
    MODULO
    MULTIPLY
    NOT
    NOT_EQUALS
    NULL
    SIZEOF
    STRING
    SUBSTRACT
    SYMBOL
}

define Checked_Expression = struct {
    kind: Checked_Expression_Kind
    location: Source_Location*
    type: Checked_Type*
}

define Checked_Expression__create_kind = func (kind: Checked_Expression_Kind, kind_size: usize, location: Source_Location*, type: Checked_Type*) -> Checked_Expression* {
    let expression: Checked_Expression* = (Checked_Expression*) malloc(kind_size)
    expression.kind = kind
    expression.location = location
    expression.type = type
    return expression
}

define Checked_Binary_Expression = struct {
    super: Checked_Expression
    left_expression: Checked_Expression*
    right_expression: Checked_Expression*
}

define Checked_Binary_Expression__create_kind = func (kind: Checked_Expression_Kind, location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Binary_Expression* {
    let expression: Checked_Binary_Expression* = (Checked_Binary_Expression*) Checked_Expression__create_kind(kind, sizeof(Checked_Binary_Expression), location, type)
    expression.left_expression = left_expression
    expression.right_expression = right_expression
    return expression
}

define Checked_Unary_Expression = struct {
    super: Checked_Expression
    other_expression: Checked_Expression*
}

define Checked_Unary_Expression__create_kind = func (kind: Checked_Expression_Kind, kind_size: usize, location: Source_Location*, type: Checked_Type*, other_expression: Checked_Expression*) -> Checked_Unary_Expression* {
    let expression: Checked_Unary_Expression* = (Checked_Unary_Expression*) Checked_Expression__create_kind(kind, kind_size, location, type)
    expression.other_expression = other_expression
    return expression
}

define Checked_Add_Expression = struct {
    super: Checked_Binary_Expression
}

define Checked_Add_Expression__create = func (location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Add_Expression* {
    return (Checked_Add_Expression*) Checked_Binary_Expression__create_kind(Checked_Expression_Kind.ADD, location, type, left_expression, right_expression)
}

define Checked_Address_Of_Expression = struct {
    super: Checked_Unary_Expression
}

define Checked_Address_Of_Expression__create = func (location: Source_Location*, type: Checked_Type*, other_expression: Checked_Expression*) -> Checked_Address_Of_Expression* {
    return (Checked_Address_Of_Expression*) Checked_Unary_Expression__create_kind(Checked_Expression_Kind.ADDRESS_OF, sizeof(Checked_Address_Of_Expression), location, type, other_expression)
}

define Checked_Array_Access_Expression = struct {
    super: Checked_Expression
    array_expression: Checked_Expression*
    index_expression: Checked_Expression*
}

define Checked_Array_Access_Expression__create = func (location: Source_Location*, type: Checked_Type*, array_expression: Checked_Expression*, index_expression: Checked_Expression*) -> Checked_Array_Access_Expression* {
    let expression: Checked_Array_Access_Expression* = (Checked_Array_Access_Expression*) Checked_Expression__create_kind(Checked_Expression_Kind.ARRAY_ACCESS, sizeof(Checked_Array_Access_Expression), location, type)
    expression.array_expression = array_expression
    expression.index_expression = index_expression
    return expression
}

define Checked_Bool_Expression = struct {
    super: Checked_Expression
    value: bool
}

define Checked_Bool_Expression__create = func (location: Source_Location*, type: Checked_Type*, value: bool) -> Checked_Bool_Expression* {
    let expression: Checked_Bool_Expression* = (Checked_Bool_Expression*) Checked_Expression__create_kind(Checked_Expression_Kind.BOOL, sizeof(Checked_Bool_Expression), location, type)
    expression.value = value
    return expression
}

define Checked_Call_Argument = struct {
    expression: Checked_Expression*
    next_argument: Checked_Call_Argument*
}

define Checked_Call_Argument__create = func (expression: Checked_Expression*) -> Checked_Call_Argument* {
    let argument: Checked_Call_Argument* = (Checked_Call_Argument*) malloc(sizeof(Checked_Call_Argument))
    argument.expression = expression
    argument.next_argument = null
    return argument
}

define Checked_Call_Expression = struct {
    super: Checked_Expression
    callee_expression: Checked_Expression*
    first_argument: Checked_Call_Argument*
}

define Checked_Call_Expression__create = func (location: Source_Location*, type: Checked_Type*, callee_expression: Checked_Expression*, first_argument: Checked_Call_Argument*) -> Checked_Call_Expression* {
    let expression: Checked_Call_Expression* = (Checked_Call_Expression*) Checked_Expression__create_kind(Checked_Expression_Kind.CALL, sizeof(Checked_Call_Expression), location, type)
    expression.callee_expression = callee_expression
    expression.first_argument = first_argument
    return expression
}

define Checked_Cast_Expression = struct {
    super: Checked_Expression
    other_expression: Checked_Expression*
}

define Checked_Cast_Expression__create = func (location: Source_Location*, type: Checked_Type*, other_expression: Checked_Expression*) -> Checked_Cast_Expression* {
    let expression: Checked_Cast_Expression* = (Checked_Cast_Expression*) Checked_Expression__create_kind(Checked_Expression_Kind.CAST, sizeof(Checked_Cast_Expression), location, type)
    expression.other_expression = other_expression
    return expression
}

define Checked_Character_Expression = struct {
    super: Checked_Expression
    value: char
}

define Checked_Character_Expression__create = func (location: Source_Location*, type: Checked_Type*, value: char) -> Checked_Character_Expression* {
    let expression: Checked_Character_Expression* = (Checked_Character_Expression*) Checked_Expression__create_kind(Checked_Expression_Kind.CHARACTER, sizeof(Checked_Character_Expression), location, type)
    expression.value = value
    return expression
}

define Checked_Dereference_Expression = struct {
    super: Checked_Expression
    value_expression: Checked_Expression*
}

define Checked_Dereference_Expression__create = func (location: Source_Location*, type: Checked_Type*, value_expression: Checked_Expression*) -> Checked_Dereference_Expression* {
    let expresion: Checked_Dereference_Expression* = (Checked_Dereference_Expression*) Checked_Expression__create_kind(Checked_Expression_Kind.DEREFERENCE, sizeof(Checked_Dereference_Expression), location, type)
    expresion.value_expression = value_expression
    return expresion
}

define Checked_Divide_Expression = struct {
    super: Checked_Binary_Expression
}

define Checked_Divide_Expression__create = func (location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Divide_Expression* {
    return (Checked_Divide_Expression*) Checked_Binary_Expression__create_kind(Checked_Expression_Kind.DIVIDE, location, type, left_expression, right_expression)
}

define Checked_Equals_Expression = struct {
    super: Checked_Binary_Expression
}

define Checked_Equals_Expression__create = func (location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Equals_Expression* {
    return (Checked_Equals_Expression*) Checked_Binary_Expression__create_kind(Checked_Expression_Kind.EQUALS, location, type, left_expression, right_expression)
}

define Checked_Greater_Expression = struct {
    super: Checked_Binary_Expression
}

define Checked_Greater_Expression__create = func (location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Greater_Expression* {
    return (Checked_Greater_Expression*) Checked_Binary_Expression__create_kind(Checked_Expression_Kind.GREATER, location, type, left_expression, right_expression)
}

define Checked_Greater_Or_Equals_Expression = struct {
    super: Checked_Binary_Expression
}

define Checked_Greater_Or_Equals_Expression__create = func (location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Greater_Or_Equals_Expression* {
    return (Checked_Greater_Or_Equals_Expression*) Checked_Binary_Expression__create_kind(Checked_Expression_Kind.GREATER_OR_EQUALS, location, type, left_expression, right_expression)
}

define Checked_Group_Expression = struct {
    super: Checked_Expression
    other_expression: Checked_Expression*
}

define Checked_Group_Expression__create = func (location: Source_Location*, type: Checked_Type*, other_expression: Checked_Expression*) -> Checked_Group_Expression* {
    let expression: Checked_Group_Expression* = (Checked_Group_Expression*) Checked_Expression__create_kind(Checked_Expression_Kind.GROUP, sizeof(Checked_Group_Expression), location, type)
    expression.other_expression = other_expression
    return expression
}

define Checked_Integer_Expression = struct {
    super: Checked_Expression
    value: u64
}

define Checked_Integer_Expression__create = func (location: Source_Location*, type: Checked_Type*, value: u64) -> Checked_Integer_Expression* {
    let expression: Checked_Integer_Expression* = (Checked_Integer_Expression*) Checked_Expression__create_kind(Checked_Expression_Kind.INTEGER, sizeof(Checked_Integer_Expression), location, type)
    expression.value = value
    return expression
}

define Checked_Less_Expression = struct {
    super: Checked_Binary_Expression
}

define Checked_Less_Expression__create = func (location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Less_Expression* {
    return (Checked_Less_Expression*) Checked_Binary_Expression__create_kind(Checked_Expression_Kind.LESS, location, type, left_expression, right_expression)
}

define Checked_Less_Or_Equals_Expression = struct {
    super: Checked_Binary_Expression
}

define Checked_Less_Or_Equals_Expression__create = func (location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Less_Or_Equals_Expression* {
    return (Checked_Less_Or_Equals_Expression*) Checked_Binary_Expression__create_kind(Checked_Expression_Kind.LESS_OR_EQUALS, location, type, left_expression, right_expression)
}

define Checked_Logic_And_Expression = struct {
    super: Checked_Binary_Expression
}

define Checked_Logic_And_Expression__create = func (location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Logic_And_Expression* {
    return (Checked_Logic_And_Expression*) Checked_Binary_Expression__create_kind(Checked_Expression_Kind.LOGIC_AND, location, type, left_expression, right_expression)
}

define Checked_Logic_Or_Expression = struct {
    super: Checked_Binary_Expression
}

define Checked_Logic_Or_Expression__create = func (location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Logic_Or_Expression* {
    return (Checked_Logic_Or_Expression*) Checked_Binary_Expression__create_kind(Checked_Expression_Kind.LOGIC_OR, location, type, left_expression, right_expression)
}

define Checked_Member_Access_Expression = struct {
    super: Checked_Expression
    object_expression: Checked_Expression*
    member: Checked_Struct_Member*
}

define Checked_Member_Access_Expression__create = func (location: Source_Location*, type: Checked_Type*, object_expression: Checked_Expression*, member: Checked_Struct_Member*) -> Checked_Member_Access_Expression* {
    let expression: Checked_Member_Access_Expression* = (Checked_Member_Access_Expression*) Checked_Expression__create_kind(Checked_Expression_Kind.MEMBER_ACCESS, sizeof(Checked_Member_Access_Expression), location, type)
    expression.object_expression = object_expression
    expression.member = member
    return expression
}

define Checked_Minus_Expression = struct {
    super: Checked_Unary_Expression
}

define Checked_Minus_Expression__create = func (location: Source_Location*, type: Checked_Type*, other_expression: Checked_Expression*) -> Checked_Minus_Expression* {
    return (Checked_Minus_Expression*) Checked_Unary_Expression__create_kind(Checked_Expression_Kind.MINUS, sizeof(Checked_Minus_Expression), location, type, other_expression)
}

define Checked_Modulo_Expression = struct {
    super: Checked_Binary_Expression
}

define Checked_Modulo_Expression__create = func (location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Modulo_Expression* {
    return (Checked_Modulo_Expression*) Checked_Binary_Expression__create_kind(Checked_Expression_Kind.MODULO, location, type, left_expression, right_expression)
}

define Checked_Multiply_Expression = struct {
    super: Checked_Binary_Expression
}

define Checked_Multiply_Expression__create = func (location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Multiply_Expression* {
    return (Checked_Multiply_Expression*) Checked_Binary_Expression__create_kind(Checked_Expression_Kind.MULTIPLY, location, type, left_expression, right_expression)
}

define Checked_Not_Expression = struct {
    super: Checked_Unary_Expression
}

define Checked_Not_Expression__create = func (location: Source_Location*, type: Checked_Type*, other_expression: Checked_Expression*) -> Checked_Not_Expression* {
    return (Checked_Not_Expression*) Checked_Unary_Expression__create_kind(Checked_Expression_Kind.NOT, sizeof(Checked_Not_Expression), location, type, other_expression)
}

define Checked_Not_Equals_Expression = struct {
    super: Checked_Binary_Expression
}

define Checked_Not_Equals_Expression__create = func (location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Not_Equals_Expression* {
    return (Checked_Not_Equals_Expression*) Checked_Binary_Expression__create_kind(Checked_Expression_Kind.NOT_EQUALS, location, type, left_expression, right_expression)
}

define Checked_Null_Expression = struct {
    super: Checked_Expression
}

define Checked_Null_Expression__create = func (location: Source_Location*, type: Checked_Type*) -> Checked_Null_Expression* {
    return (Checked_Null_Expression*) Checked_Expression__create_kind(Checked_Expression_Kind.NULL, sizeof(Checked_Null_Expression), location, type)
}

define Checked_Sizeof_Expression = struct {
    super: Checked_Expression
    sized_type: Checked_Type*
}

define Checked_Sizeof_Expression__create = func (location: Source_Location*, type: Checked_Type*, sized_type: Checked_Type*) -> Checked_Sizeof_Expression* {
    let expression: Checked_Sizeof_Expression* = (Checked_Sizeof_Expression*) Checked_Expression__create_kind(Checked_Expression_Kind.SIZEOF, sizeof(Checked_Sizeof_Expression), location, type)
    expression.sized_type = sized_type
    return expression
}

define Checked_String_Expression = struct {
    super: Checked_Expression
    value: String*
}

define Checked_String_Expression__create = func (location: Source_Location*, type: Checked_Type*, value: String*) -> Checked_String_Expression* {
    let expression: Checked_String_Expression* = (Checked_String_Expression*) Checked_Expression__create_kind(Checked_Expression_Kind.STRING, sizeof(Checked_String_Expression), location, type)
    expression.value = value
    return expression
}

define Checked_Substract_Expression = struct {
    super: Checked_Binary_Expression
}

define Checked_Substract_Expression__create = func (location: Source_Location*, type: Checked_Type*, left_expression: Checked_Expression*, right_expression: Checked_Expression*) -> Checked_Substract_Expression* {
    return (Checked_Substract_Expression*) Checked_Binary_Expression__create_kind(Checked_Expression_Kind.SUBSTRACT, location, type, left_expression, right_expression)
}

define Checked_Symbol_Expression = struct {
    super: Checked_Expression
    symbol: Checked_Symbol*
}

define Checked_Symbol_Expression__create = func (location: Source_Location*, type: Checked_Type*, symbol: Checked_Symbol*) -> Checked_Symbol_Expression* {
    let expression: Checked_Symbol_Expression* = (Checked_Symbol_Expression*) Checked_Expression__create_kind(Checked_Expression_Kind.SYMBOL, sizeof(Checked_Symbol_Expression), location, type)
    expression.symbol = symbol
    return expression
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Checked Statements
\ ---------------------------------------------------------------------------------------------------------------------

define Checked_Statement_Kind = enum {
    ASSIGNMENT
    BLOCK
    BREAK
    EXPRESSION
    IF
    RETURN
    VARIABLE
    WHILE
}

define Checked_Statement = struct {
    kind: Checked_Statement_Kind
    location: Source_Location*
    next_statement: Checked_Statement*
}

define Checked_Statement__create_kind = func (kind: Checked_Statement_Kind, kind_size: usize, location: Source_Location*) -> Checked_Statement* {
    let statement: Checked_Statement* = (Checked_Statement*) malloc(kind_size)
    statement.kind = kind
    statement.location = location
    statement.next_statement = null
    return statement
}

define Checked_Assignment_Statement = struct {
    super: Checked_Statement
    object_expression: Checked_Expression*
    value_expression: Checked_Expression*
}

define Checked_Assignment_Statement__create = func (location: Source_Location*, object_expression: Checked_Expression*, value_expression: Checked_Expression*) -> Checked_Assignment_Statement* {
    let statement: Checked_Assignment_Statement* = (Checked_Assignment_Statement*) Checked_Statement__create_kind(Checked_Statement_Kind.ASSIGNMENT, sizeof(Checked_Assignment_Statement), location)
    statement.object_expression = object_expression
    statement.value_expression = value_expression
    return statement
}

define Checked_Block_Statement = struct {
    super: Checked_Statement
    statements: Checked_Statements*
}

define Checked_Block_Statement__create = func (location: Source_Location*, statements: Checked_Statements*) -> Checked_Block_Statement* {
    let statement: Checked_Block_Statement* = (Checked_Block_Statement*) Checked_Statement__create_kind(Checked_Statement_Kind.BLOCK, sizeof(Checked_Block_Statement), location)
    statement.statements = statements
    return statement
}

define Checked_Break_Statement = struct {
    super: Checked_Statement
}

define Checked_Break_Statement__create = func (location: Source_Location*) -> Checked_Break_Statement* {
    return (Checked_Break_Statement*) Checked_Statement__create_kind(Checked_Statement_Kind.BREAK, sizeof(Checked_Break_Statement), location)
}

define Checked_Expression_Statement = struct {
    super: Checked_Statement
    expression: Checked_Expression*
}

define Checked_Expression_Statement__create = func (location: Source_Location*, expression: Checked_Expression*) -> Checked_Expression_Statement* {
    let statement: Checked_Expression_Statement* = (Checked_Expression_Statement*) Checked_Statement__create_kind(Checked_Statement_Kind.EXPRESSION, sizeof(Checked_Expression_Statement), location)
    statement.expression = expression
    return statement
}

define Checked_If_Statement = struct {
    super: Checked_Statement
    condition_expression: Checked_Expression*
    true_statement: Checked_Statement*
    false_statement: Checked_Statement*
}

define Checked_If_Statement__create = func (location: Source_Location*, condition_expression: Checked_Expression*, true_statement: Checked_Statement*, false_statement: Checked_Statement*) -> Checked_If_Statement* {
    let statement: Checked_If_Statement* = (Checked_If_Statement*) Checked_Statement__create_kind(Checked_Statement_Kind.IF, sizeof(Checked_If_Statement), location)
    statement.condition_expression = condition_expression
    statement.true_statement = true_statement
    statement.false_statement = false_statement
    return statement
}

define Checked_Return_Statement = struct {
    super: Checked_Statement
    expression: Checked_Expression*
}

define Checked_Return_Statement__create = func (location: Source_Location*, expression: Checked_Expression*) -> Checked_Return_Statement* {
    let statement: Checked_Return_Statement* = (Checked_Return_Statement*) Checked_Statement__create_kind(Checked_Statement_Kind.RETURN, sizeof(Checked_Return_Statement), location)
    statement.expression = expression
    return statement
}

define Checked_Variable_Statement = struct {
    super: Checked_Statement
    variable: Checked_Variable_Symbol*
    expression: Checked_Expression*
    is_external: bool
}

define Checked_Variable_Statement__create = func (location: Source_Location*, variable: Checked_Variable_Symbol*, expression: Checked_Expression*, is_external: bool) -> Checked_Variable_Statement* {
    let statement: Checked_Variable_Statement* = (Checked_Variable_Statement*) Checked_Statement__create_kind(Checked_Statement_Kind.VARIABLE, sizeof(Checked_Variable_Statement), location)
    statement.variable = variable
    statement.expression = expression
    statement.is_external = is_external
    return statement
}

define Checked_While_Statement = struct {
    super: Checked_Statement
    condition_expression: Checked_Expression*
    body_statement: Checked_Statement*
}

define Checked_While_Statement__create = func (location: Source_Location*, condition_expression: Checked_Expression*, body_statement: Checked_Statement*) -> Checked_While_Statement* {
    let statement: Checked_While_Statement* = (Checked_While_Statement*) Checked_Statement__create_kind(Checked_Statement_Kind.WHILE, sizeof(Checked_While_Statement), location)
    statement.condition_expression = condition_expression
    statement.body_statement = body_statement
    return statement
}

define Checked_Statements = struct {
    first_statement: Checked_Statement*
    last_statement: Checked_Statement*
}

define Checked_Statements__create = func () -> Checked_Statements* {
    let statements: Checked_Statements* = (Checked_Statements*) malloc(sizeof(Checked_Statements))
    statements.first_statement = null
    statements.last_statement = null
    return statements
}

define Checked_Statements__append = func (self: Checked_Statements*, statement: Checked_Statement*) -> void {
    if (self.first_statement == null) {
        self.first_statement = statement
    } else {
        self.last_statement.next_statement = statement
    }
    self.last_statement = statement
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Checked Source
\ ---------------------------------------------------------------------------------------------------------------------

define Checked_Source = struct {
    first_symbol: Checked_Symbol*
    statements: Checked_Statements*
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Checker
\ ---------------------------------------------------------------------------------------------------------------------

define Checker = struct {
    first_type: Checked_Named_Type*
    last_type: Checked_Named_Type*
    last_builting_type: Checked_Named_Type*
    symbols: Checked_Symbols*
    return_type: Checked_Type*
}

define Checker__create = func () -> Checker* {
    let checker: Checker* = (Checker*) malloc(sizeof(Checker))
    checker.first_type = null
    checker.last_type = null
    checker.symbols = Checked_Symbols__create(null)

    let location: Source_Location* = Source_Location__create(null, (u16) 0, (u16) 1)
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.BOOL, sizeof(Checked_Named_Type), location, String__create_from("bool")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.CHAR, sizeof(Checked_Named_Type), location, String__create_from("char")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.I16, sizeof(Checked_Named_Type), location, String__create_from("i16")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.I32, sizeof(Checked_Named_Type), location, String__create_from("i32")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.I64, sizeof(Checked_Named_Type), location, String__create_from("i64")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.I8, sizeof(Checked_Named_Type), location, String__create_from("i8")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.U16, sizeof(Checked_Named_Type), location, String__create_from("u16")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.U32, sizeof(Checked_Named_Type), location, String__create_from("u32")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.U64, sizeof(Checked_Named_Type), location, String__create_from("u64")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.U8, sizeof(Checked_Named_Type), location, String__create_from("u8")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.USIZE, sizeof(Checked_Named_Type), location, String__create_from("usize")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.VOID, sizeof(Checked_Named_Type), location, String__create_from("void")))
    Checker__append_type(checker, Checked_Named_Type__create_kind(Checked_Type_Kind.NULL, sizeof(Checked_Named_Type), location, String__create_from("null")))
    checker.last_builting_type = checker.last_type

    return checker
}

define Checker__append_type = func (self: Checker*, type: Checked_Named_Type*) -> void {
    if (self.first_type == null) {
        self.first_type = type
    } else {
        self.last_type.super.next_type = (Checked_Type*) type
    }
    self.last_type = type

    Checked_Symbols__append_symbol(self.symbols, (Checked_Symbol*) Checked_Type_Symbol__create(type.super.location, type.name, type))
}

define Checker__find_type = func (self: Checker*, name: String*) -> Checked_Named_Type* {
    let type: Checked_Named_Type* = self.first_type
    while (type != null) {
        if (String__equals_string(name, type.name)) {
            break
        }
        type = (Checked_Named_Type*) type.super.next_type
    }
    return type
}

define Checker__get_builtin_type = func (self: Checker*, kind: Checked_Type_Kind) -> Checked_Named_Type* {
    let type: Checked_Named_Type* = self.first_type
    let custom_type: Checked_Named_Type* = (Checked_Named_Type*) self.last_builting_type.super.next_type
    while (type != custom_type) {
        if (type.super.kind == kind) {
            return type
        }
        type = (Checked_Named_Type*) type.super.next_type
    }
    error(String__create_from("No such builtin type"))
    abort()
}

define Checker__resolve_type = func (self: Checker*, parsed_type: Parsed_Type*) -> Checked_Type* {
    if (parsed_type.kind == Parsed_Type_Kind.NAMED) {
        let type: Checked_Named_Type* = Checker__find_type(self, ((Parsed_Named_Type*) parsed_type).name)
        if (type != null) {
            return (Checked_Type*) type
        }
    }
    if (parsed_type.kind == Parsed_Type_Kind.POINTER) {
        return (Checked_Type*) Checked_Pointer_Type__create(parsed_type.location, Checker__resolve_type(self, ((Parsed_Pointer_Type*) parsed_type).other_type))
    }
    if (parsed_type.kind == Parsed_Type_Kind.STRUCT) {
        let type: Checked_Type* = Checker__resolve_type(self, ((Parsed_Struct_Type*) parsed_type).other_type)
        if (type.kind != Checked_Type_Kind.STRUCT) {
            TODO("Report unexpected type")
            abort()
        }
        return type
    }
    Source_Location__error(parsed_type.location, String__create_from("Undefined type"))
    abort()
}

define Checker__check_add_expression = func (self: Checker*, parsed_expression: Parsed_Add_Expression*) -> Checked_Expression* {
    let left_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.left_expression)
    Checked_Type__expect_scalar_type(left_expression.type, left_expression.location)
    let right_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return (Checked_Expression*) Checked_Add_Expression__create(parsed_expression.super.super.location, left_expression.type, left_expression, right_expression)
}

define Checker__check_address_of_expression = func (self: Checker*, parsed_expression: Parsed_Address_Of_Expression*) -> Checked_Expression* {
    let other_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.other_expression)
    if (other_expression.kind != Checked_Expression_Kind.SYMBOL) {
        Source_Location__error(parsed_expression.super.super.location, String__create_from("Not a symbol"))
        abort()
    }
    return (Checked_Expression*) Checked_Address_Of_Expression__create(parsed_expression.super.super.location, (Checked_Type*) Checked_Pointer_Type__create(other_expression.location, other_expression.type), other_expression)
}

define Checker__check_array_access_expression = func (self: Checker*, parsed_expression: Parsed_Array_Access_Expression*) -> Checked_Expression* {
    let array_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.array_expression)
    let array_type: Checked_Type* = array_expression.type
    if (array_type.kind != Checked_Type_Kind.POINTER) {
        let message: String* = String__create()
        String__append_char(message, '"')
        String__append_checked_type(message, array_type)
        String__append_cstring(message, "\" is not a pointer type.")
        Source_Location__error(parsed_expression.array_expression.location, message)
        abort()
    }
    let type: Checked_Type* = ((Checked_Pointer_Type*) array_type).other_type
    let index_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.index_expression)
    Checked_Type__expect_same_type((Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.USIZE), index_expression.type, index_expression.location)
    return (Checked_Expression*) Checked_Array_Access_Expression__create(parsed_expression.super.location, type, array_expression, index_expression)
}

define Checker__check_bool_expression = func (self: Checker*, parsed_expression: Parsed_Bool_Expression*) -> Checked_Expression* {
    let expression_type: Checked_Type* = (Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.BOOL)
    let value: bool = parsed_expression.value
    return (Checked_Expression*) Checked_Bool_Expression__create(parsed_expression.super.super.location, expression_type, value)
}

define Checker__check_call_expression = func (self: Checker*, parsed_expression: Parsed_Call_Expression*) -> Checked_Expression* {
    let callee_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.callee_expression)
    let callee_type: Checked_Type* = callee_expression.type
    if (callee_type.kind != Checked_Type_Kind.POINTER || ((Checked_Pointer_Type*) callee_type).other_type.kind != Checked_Type_Kind.FUNCTION) {
        Source_Location__error(parsed_expression.super.location, String__create_from("Not a function"))
        abort()
    }
    let function_type: Checked_Function_Type* = (Checked_Function_Type*) ((Checked_Pointer_Type*) callee_type).other_type
    let first_argument: Checked_Call_Argument* = null
    if (parsed_expression.first_argument != null) {
        let last_argument: Checked_Call_Argument* = null
        let function_parameter: Checked_Function_Parameter* = function_type.first_parameter
        let parsed_argument: Parsed_Call_Argument* = parsed_expression.first_argument
        while (function_parameter != null && parsed_argument != null) {
            let argument_expression: Checked_Expression* = Checker__check_expression(self, parsed_argument.expression)
            Checked_Type__expect_same_type(function_parameter.type, argument_expression.type, argument_expression.location)
            let argument: Checked_Call_Argument* = Checked_Call_Argument__create(argument_expression)
            if (last_argument == null) {
                first_argument = argument
            } else {
                last_argument.next_argument = argument
            }
            last_argument = argument
            function_parameter = function_parameter.next_parameter
            parsed_argument = parsed_argument.next_argument
        }
        if (function_parameter != null) {
            Source_Location__error(parsed_expression.super.location, String__create_from("Report too few arguments"))
            abort()
        }
        if (parsed_argument != null) {
            Source_Location__error(parsed_expression.super.location, String__create_from("Report too many arguments"))
            abort()
        }
    }
    return (Checked_Expression*) Checked_Call_Expression__create(parsed_expression.super.location, function_type.return_type, callee_expression, first_argument)
}

define Checker__check_cast_expression = func (self: Checker*, parsed_expression: Parsed_Cast_Expression*) -> Checked_Expression* {
    let type: Checked_Type* = Checker__resolve_type(self, parsed_expression.type)
    let other_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.other_expression)
    let other_type: Checked_Type* = other_expression.type
    let can_cast: bool = false
    if (type.kind == Checked_Type_Kind.POINTER) {
        if (other_type.kind == Checked_Type_Kind.POINTER) {
            can_cast = true
        }
    } else if (Checked_Type__is_scalar_type(type)) {
        if (Checked_Type__is_scalar_type(type)) {
            can_cast = true
        }
    }
    if (Checked_Type__equals(type, other_type)) {
        Source_Location__warning(parsed_expression.super.super.location, String__create_from("Redundant cast"))
    }
    if (!can_cast) {
        let message: String* = String__create_from("Cannot cast \"")
        String__append_checked_type(message, other_expression.type)
        String__append_cstring(message, "\" to \"")
        String__append_checked_type(message, type)
        String__append_cstring(message, "\".")
        Source_Location__error(parsed_expression.super.super.location, message)
        abort()
    }
    return (Checked_Expression*) Checked_Cast_Expression__create(parsed_expression.super.super.location, type, other_expression)
}

define Checker__check_character_expression = func (self: Checker*, parsed_expression: Parsed_Character_Expression*) -> Checked_Expression* {
    let expression_type: Checked_Type* = (Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.CHAR)
    let value: char = parsed_expression.value
    return (Checked_Expression*) Checked_Character_Expression__create(parsed_expression.super.super.location, expression_type, value)
}

define Checker__check_dereference_expression = func (self: Checker*, parsed_expression: Parsed_Dereference_Expression*) -> Checked_Expression* {
    let value_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.value_expression)
    let value_type: Checked_Type* = value_expression.type
    if (value_type.kind != Checked_Type_Kind.POINTER) {
        Source_Location__error(parsed_expression.super.location, String__create_from("Not a pointer value"))
        abort()
    }
    return (Checked_Expression*) Checked_Dereference_Expression__create(parsed_expression.super.location, ((Checked_Pointer_Type*) value_type).other_type, value_expression)
}

define Checker__check_divide_expression = func (self: Checker*, parsed_expression: Parsed_Divide_Expression*) -> Checked_Expression* {
    let left_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.left_expression)
    Checked_Type__expect_scalar_type(left_expression.type, left_expression.location)
    let right_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return (Checked_Expression*) Checked_Divide_Expression__create(parsed_expression.super.super.location, left_expression.type, left_expression, right_expression)
}

define Checker__check_equals_expression = func (self: Checker*, parsed_expression: Parsed_Equals_Expression*) -> Checked_Expression* {
    let left_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.left_expression)
    let right_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return (Checked_Expression*) Checked_Equals_Expression__create(parsed_expression.super.super.location, (Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.BOOL), left_expression, right_expression)
}

define Checker__check_greater_expression = func (self: Checker*, parsed_expression: Parsed_Greater_Expression*) -> Checked_Expression* {
    let left_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.left_expression)
    Checked_Type__expect_scalar_type(left_expression.type, left_expression.location)
    let right_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return (Checked_Expression*) Checked_Greater_Expression__create(parsed_expression.super.super.location, (Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.BOOL), left_expression, right_expression)
}

define Checker__check_greater_or_equals_expression = func (self: Checker*, parsed_expression: Parsed_Greater_Or_Equals_Expression*) -> Checked_Expression* {
    let left_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.left_expression)
    Checked_Type__expect_scalar_type(left_expression.type, left_expression.location)
    let right_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return (Checked_Expression*) Checked_Greater_Or_Equals_Expression__create(parsed_expression.super.super.location, (Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.BOOL), left_expression, right_expression)
}

define Checker__check_group_expression = func (self: Checker*, parsed_expression: Parsed_Group_Expression*) -> Checked_Expression* {
    let other_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.other_expression)
    return (Checked_Expression*) Checked_Group_Expression__create(parsed_expression.super.location, other_expression.type, other_expression)
}

define Checker__check_integer_expression = func (self: Checker*, parsed_expression: Parsed_Integer_Expression*) -> Checked_Expression* {
    let expression_type: Checked_Type* = (Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.I32)
    let value: u64 = parsed_expression.value
    return (Checked_Expression*) Checked_Integer_Expression__create(parsed_expression.super.super.location, expression_type, value)
}

define Checker__check_less_expression = func (self: Checker*, parsed_expression: Parsed_Less_Expression*) -> Checked_Expression* {
    let left_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.left_expression)
    Checked_Type__expect_scalar_type(left_expression.type, left_expression.location)
    let right_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return (Checked_Expression*) Checked_Less_Expression__create(parsed_expression.super.super.location, (Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.BOOL), left_expression, right_expression)
}

define Checker__check_less_or_equals_expression = func (self: Checker*, parsed_expression: Parsed_Less_Or_Equals_Expression*) -> Checked_Expression* {
    let left_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.left_expression)
    Checked_Type__expect_scalar_type(left_expression.type, left_expression.location)
    let right_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return (Checked_Expression*) Checked_Less_Or_Equals_Expression__create(parsed_expression.super.super.location, (Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.BOOL), left_expression, right_expression)
}

define Checker__check_logic_and_expression = func (self: Checker*, parsed_expression: Parsed_Logic_And_Expression*) -> Checked_Expression* {
    let left_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.left_expression)
    Checked_Type__expect_same_type((Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.BOOL), left_expression.type, left_expression.location)
    let right_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return (Checked_Expression*) Checked_Logic_And_Expression__create(parsed_expression.super.super.location, left_expression.type, left_expression, right_expression)
}

define Checker__check_logic_or_expression = func (self: Checker*, parsed_expression: Parsed_Logic_Or_Expression*) -> Checked_Expression* {
    let left_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.left_expression)
    Checked_Type__expect_same_type((Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.BOOL), left_expression.type, left_expression.location)
    let right_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return (Checked_Expression*) Checked_Logic_Or_Expression__create(parsed_expression.super.super.location, left_expression.type, left_expression, right_expression)
}

define Checker__check_member_access_expression = func (self: Checker*, parsed_expression: Parsed_Member_Access_Expression*) -> Checked_Expression* {
    let object_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.object_expression)
    let object_type: Checked_Type* = object_expression.type
    if (object_type.kind == Checked_Type_Kind.POINTER) {
        object_type = ((Checked_Pointer_Type*) object_type).other_type
        if (object_type.kind == Checked_Type_Kind.STRUCT) {
            return Checker__check_struct_member_access_expression(self, object_expression, (Checked_Struct_Type*) object_type, parsed_expression.member_name)
        }
    } else if (object_type.kind == Checked_Type_Kind.STRUCT) {
        return Checker__check_struct_member_access_expression(self, object_expression, (Checked_Struct_Type*) object_type, parsed_expression.member_name)
    } else if (object_type.kind == Checked_Type_Kind.DEFINED) {
        let defined_type: Checked_Named_Type* = ((Checked_Defined_Type*) object_type).defined_type
        if (defined_type.super.kind == Checked_Type_Kind.ENUM) {
            let enum_type: Checked_Enum_Type* = (Checked_Enum_Type*) defined_type
            let enum_member: Checked_Enum_Member* = Checked_Enum_Type__find_member(enum_type, parsed_expression.member_name.lexeme)
            if (enum_member == null) {
                Source_Location__error(object_expression.location, String__create_from("No such enum members"))
                abort()
            }
            return (Checked_Expression*) Checked_Symbol_Expression__create(object_expression.location, (Checked_Type*) enum_type, enum_member.symbol)
        }
        Source_Location__error(object_expression.location, String__create_from("Type has no members"))
        abort()
    }
    Source_Location__error(object_expression.location, String__create_from("Unsupported type"))
    abort()
}

define Checker__check_struct_member_access_expression = func (self: Checker*, object_expression: Checked_Expression*, struct_type: Checked_Struct_Type*, member_name: Token*) -> Checked_Expression* {
    let member: Checked_Struct_Member* = Checked_Struct_Type__find_member(struct_type, member_name.lexeme)
    if (member == null) {
        Source_Location__error(object_expression.location, String__create_from("No such struct member"))
        abort()
    }
    return (Checked_Expression*) Checked_Member_Access_Expression__create(object_expression.location, member.type, object_expression, member)
}

define Checker__check_minus_expression = func (self: Checker*, parsed_expression: Parsed_Minus_Expression*) -> Checked_Expression* {
    let other_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.other_expression)
    let other_expression_type: Checked_Type* = other_expression.type
    Checked_Type__expect_scalar_type(other_expression_type, other_expression.location)
    return (Checked_Expression*) Checked_Minus_Expression__create(parsed_expression.super.super.location, other_expression_type, other_expression)
}

define Checker__check_modulo_expression = func (self: Checker*, parsed_expression: Parsed_Modulo_Expression*) -> Checked_Expression* {
    let left_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.left_expression)
    Checked_Type__expect_scalar_type(left_expression.type, left_expression.location)
    let right_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return (Checked_Expression*) Checked_Modulo_Expression__create(parsed_expression.super.super.location, left_expression.type, left_expression, right_expression)
}

define Checker__check_multiply_expression = func (self: Checker*, parsed_expression: Parsed_Multiply_Expression*) -> Checked_Expression* {
    let left_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.left_expression)
    Checked_Type__expect_scalar_type(left_expression.type, left_expression.location)
    let right_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return (Checked_Expression*) Checked_Multiply_Expression__create(parsed_expression.super.super.location, left_expression.type, left_expression, right_expression)
}

define Checker__check_not_expression = func (self: Checker*, parsed_expression: Parsed_Not_Expression*) -> Checked_Expression* {
    let other_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.other_expression)
    let other_expression_type: Checked_Type* = other_expression.type
    Checked_Type__expect_same_type((Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.BOOL), other_expression_type, other_expression.location)
    return (Checked_Expression*) Checked_Not_Expression__create(parsed_expression.super.super.location, other_expression_type, other_expression)
}

define Checker__check_not_equals_expression = func (self: Checker*, parsed_expression: Parsed_Not_Equals_Expression*) -> Checked_Expression* {
    let left_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.left_expression)
    let right_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return (Checked_Expression*) Checked_Not_Equals_Expression__create(parsed_expression.super.super.location, (Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.BOOL), left_expression, right_expression)
}

define Checker__check_null_expression = func (self: Checker*, parsed_expression: Parsed_Null_Expression*) -> Checked_Expression* {
    let expression_type: Checked_Type* = (Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.NULL)
    return (Checked_Expression*) Checked_Null_Expression__create(parsed_expression.super.literal.location, expression_type)
}

define Checker__check_sizeof_expression = func (self: Checker*, parsed_expression: Parsed_Sizeof_Expression*) -> Checked_Expression* {
    let expression_type: Checked_Type* = (Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.USIZE)
    let sized_type: Checked_Type* = Checker__resolve_type(self, parsed_expression.type)
    return (Checked_Expression*) Checked_Sizeof_Expression__create(parsed_expression.super.location, expression_type, sized_type)
}

define Checker__check_string_expression = func (self: Checker*, parsed_expression: Parsed_String_Expression*) -> Checked_Expression* {
    let char_type: Checked_Type* = (Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.CHAR)
    let expression_type: Checked_Type* = (Checked_Type*) Checked_Pointer_Type__create(parsed_expression.super.literal.location, char_type)
    let value: String* = parsed_expression.value
    return (Checked_Expression*) Checked_String_Expression__create(parsed_expression.super.super.location, expression_type, value)
}

define Checker__check_substract_expression = func (self: Checker*, parsed_expression: Parsed_Substract_Expression*) -> Checked_Expression* {
    let left_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.left_expression)
    Checked_Type__expect_scalar_type(left_expression.type, left_expression.location)
    let right_expression: Checked_Expression* = Checker__check_expression(self, parsed_expression.super.right_expression)
    Checked_Type__expect_same_type(left_expression.type, right_expression.type, right_expression.location)
    return (Checked_Expression*) Checked_Substract_Expression__create(parsed_expression.super.super.location, left_expression.type, left_expression, right_expression)
}

define Checker__check_symbol_expression = func (self: Checker*, parsed_expression: Parsed_Symbol_Expression*) -> Checked_Expression* {
    let symbol: Checked_Symbol* = Checked_Symbols__find_symbol(self.symbols, parsed_expression.name.lexeme)
    if (symbol == null) {
        Token__error(parsed_expression.name, String__create_from("Undefined symbol"))
        abort()
    }
    if (symbol.type == null) {
        Token__error(parsed_expression.name, String__create_from("Symbol without type"))
        abort()
    }
    return (Checked_Expression*) Checked_Symbol_Expression__create(parsed_expression.super.location, symbol.type, symbol)
}

define Checker__check_expression = func (self: Checker*, parsed_expression: Parsed_Expression*) -> Checked_Expression* {
    if (parsed_expression.kind == Parsed_Expression_Kind.ADD) {
        return Checker__check_add_expression(self, (Parsed_Add_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.ADDRESS_OF) {
        return Checker__check_address_of_expression(self, (Parsed_Address_Of_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.ARRAY_ACCESS) {
        return Checker__check_array_access_expression(self, (Parsed_Array_Access_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.BOOL) {
        return Checker__check_bool_expression(self, (Parsed_Bool_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.CALL) {
        return Checker__check_call_expression(self, (Parsed_Call_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.CAST) {
        return Checker__check_cast_expression(self, (Parsed_Cast_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.CHARACTER) {
        return Checker__check_character_expression(self, (Parsed_Character_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.DEREFERENCE) {
        return Checker__check_dereference_expression(self, (Parsed_Dereference_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.DIVIDE) {
        return Checker__check_divide_expression(self, (Parsed_Divide_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.EQUALS) {
        return Checker__check_equals_expression(self, (Parsed_Equals_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.GREATER) {
        return Checker__check_greater_expression(self, (Parsed_Greater_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.GREATER_OR_EQUALS) {
        return Checker__check_greater_or_equals_expression(self, (Parsed_Greater_Or_Equals_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.GROUP) {
        return Checker__check_group_expression(self, (Parsed_Group_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.INTEGER) {
        return Checker__check_integer_expression(self, (Parsed_Integer_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.LESS) {
        return Checker__check_less_expression(self, (Parsed_Less_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.LESS_OR_EQUALS) {
        return Checker__check_less_or_equals_expression(self, (Parsed_Less_Or_Equals_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.LOGIC_AND) {
        return Checker__check_logic_and_expression(self, (Parsed_Logic_And_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.LOGIC_OR) {
        return Checker__check_logic_or_expression(self, (Parsed_Logic_Or_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.MEMBER_ACCESS) {
        return Checker__check_member_access_expression(self, (Parsed_Member_Access_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.MINUS) {
        return Checker__check_minus_expression(self, (Parsed_Minus_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.MODULO) {
        return Checker__check_modulo_expression(self, (Parsed_Modulo_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.MULTIPLY) {
        return Checker__check_multiply_expression(self, (Parsed_Multiply_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.NOT) {
        return Checker__check_not_expression(self, (Parsed_Not_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.NOT_EQUALS) {
        return Checker__check_not_equals_expression(self, (Parsed_Not_Equals_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.NULL) {
        return Checker__check_null_expression(self, (Parsed_Null_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.SIZEOF) {
        return Checker__check_sizeof_expression(self, (Parsed_Sizeof_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.STRING) {
        return Checker__check_string_expression(self, (Parsed_String_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.SUBSTRACT) {
        return Checker__check_substract_expression(self, (Parsed_Substract_Expression*) parsed_expression)
    } else if (parsed_expression.kind == Parsed_Expression_Kind.SYMBOL) {
        return Checker__check_symbol_expression(self, (Parsed_Symbol_Expression*) parsed_expression)
    }
    Source_Location__error(parsed_expression.location, String__create_from("Unsupported expression kind"))
    abort()
}

define Checker__check_enum_statement = func (self: Checker*, parsed_statement: Parsed_Enum_Statement*) -> void {
    let enum_type: Checked_Enum_Type* = Checked_Enum_Type__create(parsed_statement.super.name.location, parsed_statement.super.name.lexeme)
    Checker__append_type(self, (Checked_Named_Type*) enum_type)

    let last_enum_member: Checked_Enum_Member* = null
    let parsed_enum_member: Parsed_Enum_Member* = parsed_statement.first_member
    while (parsed_enum_member != null) {
        let enum_member: Checked_Enum_Member* = Checked_Enum_Member__create(parsed_enum_member.name.location, parsed_enum_member.name.lexeme)
        let enum_member_symbol_name: String* = String__append_string(String__append_cstring(String__append_string(String__create(), enum_type.super.name), "__"), enum_member.name)
        enum_member.symbol = (Checked_Symbol*) Checked_Enum_Member_Symbol__create(enum_member.location, enum_member_symbol_name, (Checked_Type*) enum_type)
        Checked_Symbols__append_symbol(self.symbols, enum_member.symbol)
        if (last_enum_member == null) {
            enum_type.first_member = enum_member
        } else {
            last_enum_member.next_member = enum_member
        }
        last_enum_member = enum_member
        parsed_enum_member = parsed_enum_member.next_member
    }
}

define Checker__check_function_type_statement = func (self: Checker*, parsed_statement: Parsed_Function_Type_Statement*) -> void {
    let other_type: Checked_Named_Type* = Checker__find_type(self, parsed_statement.super.name.lexeme)
    let function_type: Checked_Function_Type* = undefined
    if (other_type != null) {
        TODO("Handle type redeclaration")
        abort()
    } else {
        let return_type: Checked_Type* = Checker__resolve_type(self, parsed_statement.return_type)
        function_type = Checked_Function_Type__create(parsed_statement.super.name.location, parsed_statement.super.name.lexeme, return_type)
        Checker__append_type(self, (Checked_Named_Type*) function_type)
    }

    if (parsed_statement.first_parameter != null) {
        let last_function_parameter: Checked_Function_Parameter* = null
        let parsed_parameter: Parsed_Function_Type_Parameter* = parsed_statement.first_parameter
        while (parsed_parameter != null) {
            let function_parameter_type: Checked_Type* = Checker__resolve_type(self, parsed_parameter.type)
            let function_parameter: Checked_Function_Parameter* = Checked_Function_Parameter__create(parsed_parameter.name.location, parsed_parameter.name.lexeme, function_parameter_type)
            if (last_function_parameter == null) {
                function_type.first_parameter = function_parameter
            } else {
                last_function_parameter.next_parameter = function_parameter
            }
            last_function_parameter = function_parameter
            parsed_parameter = parsed_parameter.next_parameter
        }
    }
}

define Checker__create_opaque_type = func (self: Checker*, parsed_statement: Parsed_Opaque_Type_Statement*) -> void {
    let other_type: Checked_Named_Type* = Checker__find_type(self, parsed_statement.super.name.lexeme)
    if (other_type != null) {
        Source_Location__error(parsed_statement.super.name.location, String__append_source_location(String__create_from("Type declared first here: "), other_type.super.location))
        abort()
    } else {
        let opaque_type: Checked_Opaque_Type* = Checked_Opaque_Type__create(parsed_statement.super.name.location, parsed_statement.super.name.lexeme)
        Checker__append_type(self, (Checked_Named_Type*) opaque_type)
    }
}

define Checker__create_struct_type = func (self: Checker*, parsed_statement: Parsed_Struct_Statement*) -> void {
    let other_type: Checked_Named_Type* = Checker__find_type(self, parsed_statement.super.name.lexeme)
    if (other_type != null) {
        Source_Location__error(parsed_statement.super.name.location, String__append_source_location(String__create_from("Type declared first here: "), other_type.super.location))
        abort()
    } else {
        let struct_type: Checked_Struct_Type* = Checked_Struct_Type__create(parsed_statement.super.name.location, parsed_statement.super.name.lexeme)
        Checker__append_type(self, (Checked_Named_Type*) struct_type)
    }
}

define Checker__check_struct_statement = func (self: Checker*, parsed_statement: Parsed_Struct_Statement*) -> void {
    let struct_type: Checked_Struct_Type* = (Checked_Struct_Type*) Checker__find_type(self, parsed_statement.super.name.lexeme)
    if (parsed_statement.first_member != null) {
        let last_struct_member: Checked_Struct_Member* = null
        let parsed_member: Parsed_Struct_Member* = parsed_statement.first_member
        while (parsed_member != null) {
            let struct_member: Checked_Struct_Member* = Checked_Struct_Type__find_member(struct_type, parsed_member.name.lexeme)
            if (struct_member != null) {
                TODO("Handle struct member duplicate")
                abort()
            }
            let struct_member_type: Checked_Type* = Checker__resolve_type(self, parsed_member.type)
            struct_member = Checked_Struct_Member__create(parsed_member.name.location, parsed_member.name.lexeme, struct_member_type)
            if (last_struct_member == null) {
                struct_type.first_member = struct_member
            } else {
                last_struct_member.next_member = struct_member
            }
            last_struct_member = struct_member
            parsed_member = parsed_member.next_member
        }
    }
}

define Checker__check_assignment_statement = func (self: Checker*, parsed_statement: Parsed_Assignment_Statement*) -> Checked_Assignment_Statement* {
    let object_expression: Checked_Expression* = Checker__check_expression(self, parsed_statement.object_expression)
    let value_expression: Checked_Expression* = Checker__check_expression(self, parsed_statement.value_expression)
    Checked_Type__expect_same_type(object_expression.type, value_expression.type, value_expression.location)
    return Checked_Assignment_Statement__create(parsed_statement.super.location, object_expression, value_expression)
}

define Checker__check_block_statement = func (self: Checker*, parsed_statement: Parsed_Block_Statement*) -> Checked_Block_Statement* {
    let statements: Checked_Statements* = Checker__check_statements(self, parsed_statement.statements)
    return Checked_Block_Statement__create(parsed_statement.super.location, statements)
}

define Checker__check_break_statement = func (self: Checker*, parsed_statement: Parsed_Break_Statement*) -> Checked_Break_Statement* {
    return Checked_Break_Statement__create(parsed_statement.super.location)
}

define Checker__check_expression_statement = func (self: Checker*, parsed_statement: Parsed_Expression_Statement*) -> Checked_Expression_Statement* {
    let expression: Checked_Expression* = Checker__check_expression(self, parsed_statement.expression)
    if (!Checked_Type__equals((Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.VOID), expression.type)) {
        \ TODO: Source_Location__warning(expression.location, String__create_from("Unused result value"))
    }
    return Checked_Expression_Statement__create(parsed_statement.super.location, expression)
}

define Checker__check_if_statement = func (self: Checker*, parsed_statement: Parsed_If_Statement*) -> Checked_If_Statement* {
    let considition_expression: Checked_Expression* = Checker__check_expression(self, parsed_statement.condition_expression)
    Checked_Type__expect_same_type((Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.BOOL), considition_expression.type, considition_expression.location)
    let true_statement: Checked_Statement* = Checker__check_statement(self, parsed_statement.true_statement)
    let false_statement: Checked_Statement* = null
    if (parsed_statement.false_statement != null) {
        false_statement = Checker__check_statement(self, parsed_statement.false_statement)
    }
    return Checked_If_Statement__create(parsed_statement.super.location, considition_expression, true_statement, false_statement)
}

define Checker__check_return_statement = func (self: Checker*, parsed_statement: Parsed_Return_Statement*) -> Checked_Return_Statement* {
    let expression: Checked_Expression* = null
    if (parsed_statement.expression != null) {
        expression = Checker__check_expression(self, parsed_statement.expression)
        Checked_Type__expect_same_type(self.return_type, expression.type, expression.location)
    } else if (self.return_type.kind != Checked_Type_Kind.VOID) {
        Source_Location__error(parsed_statement.super.location, String__create_from("Missing expression"))
        abort()
    }
    return Checked_Return_Statement__create(parsed_statement.super.location, expression)
}

define Checker__check_variable_statement = func (self: Checker*, parsed_statement: Parsed_Variable_Statement*) -> Checked_Variable_Statement* {
    let type: Checked_Type* = Checker__resolve_type(self, parsed_statement.type)
    let expression: Checked_Expression* = null
    if (parsed_statement.expression != null) {
        expression = Checker__check_expression(self, parsed_statement.expression)
        Checked_Type__expect_same_type(type, expression.type, expression.location)
    }
    let variable: Checked_Variable_Symbol* = Checked_Variable__create(parsed_statement.super.name.location, parsed_statement.super.name.lexeme, type)
    Checked_Symbols__append_symbol(self.symbols, (Checked_Symbol*) variable)
    return Checked_Variable_Statement__create(parsed_statement.super.super.location, variable, expression, parsed_statement.is_external)
}

define Checker__check_while_statement = func (self: Checker*, parsed_statement: Parsed_While_Statement*) -> Checked_While_Statement* {
    let considition_expression: Checked_Expression* = Checker__check_expression(self, parsed_statement.condition_expression)
    Checked_Type__expect_same_type((Checked_Type*) Checker__get_builtin_type(self, Checked_Type_Kind.BOOL), considition_expression.type, considition_expression.location)
    let body_statement: Checked_Statement* = Checker__check_statement(self, parsed_statement.body_statement)
    return Checked_While_Statement__create(parsed_statement.super.location, considition_expression, body_statement)
}

define Checker__check_function_declaration = func (self: Checker*, parsed_statement: Parsed_Function_Statement*) -> void {
    let function_name: String* = parsed_statement.super.name.lexeme
    let function_return_type: Checked_Type* = Checker__resolve_type(self, parsed_statement.return_type)
    let function_first_parameter: Checked_Function_Parameter* = null
    let parsed_parameter: Parsed_Function_Parameter* = parsed_statement.first_parameter
    if (parsed_parameter != null) {
        function_first_parameter = Checked_Function_Parameter__create(parsed_parameter.name.location, parsed_parameter.name.lexeme, Checker__resolve_type(self, parsed_parameter.type))
        let function_last_parameter: Checked_Function_Parameter* = function_first_parameter
        parsed_parameter = parsed_parameter.next_parameter
        while (parsed_parameter != null) {
            let function_parameter: Checked_Function_Parameter* = Checked_Function_Parameter__create(parsed_parameter.name.location, parsed_parameter.name.lexeme, Checker__resolve_type(self, parsed_parameter.type))
            function_last_parameter.next_parameter = function_parameter
            function_last_parameter = function_parameter
            parsed_parameter = parsed_parameter.next_parameter
        }
    }
    let function_type: Checked_Function_Type* = Checked_Function_Type__create(parsed_statement.super.super.location, function_name, function_return_type)
    function_type.first_parameter = function_first_parameter

    let other_symbol: Checked_Symbol* = Checked_Symbols__find_sibling_symbol(self.symbols, function_name)
    if (other_symbol != null) {
        if (other_symbol.kind != Checked_Symbol_Kind.FUNCTION || !Checked_Type__equals((Checked_Type*) function_type, (Checked_Type*) ((Checked_Function_Symbol*) other_symbol).function_type)) {
            TODO("Report overloaded function")
            abort()
        } else {
            Source_Location__error(parsed_statement.super.name.location, String__append_source_location(String__create_from("Function declared first here: "), other_symbol.location))
            abort()
        }
    } else {
        Checked_Symbols__append_symbol(self.symbols, (Checked_Symbol*) Checked_Function_Symbol__create(parsed_statement.super.name.location, function_name, function_type))
    }
}

define Checker__check_statement = func (self: Checker*, parsed_statement: Parsed_Statement*) -> Checked_Statement* {
    if (parsed_statement.kind == Parsed_Statement_Kind.ASSIGNMENT) {
        return (Checked_Statement*) Checker__check_assignment_statement(self, (Parsed_Assignment_Statement*) parsed_statement)
    } else if (parsed_statement.kind == Parsed_Statement_Kind.BLOCK) {
        return (Checked_Statement*) Checker__check_block_statement(self, (Parsed_Block_Statement*) parsed_statement)
    } else if (parsed_statement.kind == Parsed_Statement_Kind.BREAK) {
        return (Checked_Statement*) Checker__check_break_statement(self, (Parsed_Break_Statement*) parsed_statement)
    } else if (parsed_statement.kind == Parsed_Statement_Kind.EXPRESSION) {
        return (Checked_Statement*) Checker__check_expression_statement(self, (Parsed_Expression_Statement*) parsed_statement)
    } else if (parsed_statement.kind == Parsed_Statement_Kind.IF) {
        return (Checked_Statement*) Checker__check_if_statement(self, (Parsed_If_Statement*) parsed_statement)
    } else if (parsed_statement.kind == Parsed_Statement_Kind.RETURN) {
        return (Checked_Statement*) Checker__check_return_statement(self, (Parsed_Return_Statement*) parsed_statement)
    } else if (parsed_statement.kind == Parsed_Statement_Kind.VARIABLE) {
        return (Checked_Statement*) Checker__check_variable_statement(self, (Parsed_Variable_Statement*) parsed_statement)
    } else if (parsed_statement.kind == Parsed_Statement_Kind.WHILE) {
        return (Checked_Statement*) Checker__check_while_statement(self, (Parsed_While_Statement*) parsed_statement)
    }
    Source_Location__error(parsed_statement.location, String__create_from("Unsupported statement"))
    abort()
}

define Checker__check_statements = func (self: Checker*, parsed_statements: Parsed_Statements*) -> Checked_Statements* {
    \ Create and push block symbols
    self.symbols = Checked_Symbols__create(self.symbols)

    let checked_statements: Checked_Statements* = Checked_Statements__create()
    let parsed_statement: Parsed_Statement* = parsed_statements.first_statement
    while (parsed_statement != null) {
        let checked_statement: Checked_Statement* = Checker__check_statement(self, parsed_statement)
        Checked_Statements__append(checked_statements, checked_statement)
        parsed_statement = parsed_statement.next_statement
    }

    \ Pop block symbols
    self.symbols = self.symbols.parent

    return checked_statements
}

define Checker__check_function_definition = func (self: Checker*, parsed_statement: Parsed_Function_Statement*) -> void {
    let symbol: Checked_Symbol* = Checked_Symbols__find_sibling_symbol(self.symbols, parsed_statement.super.name.lexeme)
    if (symbol == null || symbol.kind != Checked_Symbol_Kind.FUNCTION) {
        TODO("Report missing function symbol")
        abort()
    }
    let function_symbol: Checked_Function_Symbol* = (Checked_Function_Symbol*) symbol
    let function_type: Checked_Function_Type* = function_symbol.function_type
    self.return_type = function_type.return_type

    \ Create and push function symbols
    self.symbols = Checked_Symbols__create(self.symbols)

    if (function_type.first_parameter != null) {
        \ Create a symbol for each function parameter
        let parameter: Checked_Function_Parameter* = function_type.first_parameter
        while (parameter != null) {
            Checked_Symbols__append_symbol(self.symbols, (Checked_Symbol*) Checked_Function_Parameter_Symbol__create(parameter.location, parameter.name, parameter.type))
            parameter = parameter.next_parameter
        }
    }

    \ Check statements
    function_symbol.checked_statements = Checker__check_statements(self, parsed_statement.statements)

    \ Pop function symbols
    self.symbols = self.symbols.parent
}

define Checker__check_source = func (self: Checker*, parsed_source: Parsed_Source*) -> Checked_Source* {
    let checked_statements: Checked_Statements* = Checked_Statements__create()

    let parsed_statement: Parsed_Statement* = undefined

    \ Collect all type definitions
    parsed_statement = parsed_source.statements.first_statement
    while (parsed_statement != null) {
        let checked_statement: Checked_Statement* = null
        if (parsed_statement.kind == Parsed_Statement_Kind.FUNCTION) {
            \ ignored
        } else if (parsed_statement.kind == Parsed_Statement_Kind.VARIABLE) {
            \ ignored
        } else if (parsed_statement.kind == Parsed_Statement_Kind.STRUCT) {
            Checker__create_struct_type(self, (Parsed_Struct_Statement*) parsed_statement)
        } else if (parsed_statement.kind == Parsed_Statement_Kind.OPAQUE_TYPE) {
            Checker__create_opaque_type(self, (Parsed_Opaque_Type_Statement*) parsed_statement)
        } else if (parsed_statement.kind == Parsed_Statement_Kind.ENUM) {
            Checker__check_enum_statement(self, (Parsed_Enum_Statement*) parsed_statement)
        } else if (parsed_statement.kind == Parsed_Statement_Kind.FUNCTION_TYPE) {
            \ ignored
        } else {
            Source_Location__error(parsed_statement.location, String__create_from("Unsupported statement"))
            abort()
        }
        if (checked_statement != null) {
            Checked_Statements__append(checked_statements, checked_statement)
        }
        parsed_statement = parsed_statement.next_statement
    }

    \ Check all defined types
    parsed_statement = parsed_source.statements.first_statement
    while (parsed_statement != null) {
        if (parsed_statement.kind == Parsed_Statement_Kind.STRUCT) {
            Checker__check_struct_statement(self, (Parsed_Struct_Statement*) parsed_statement)
        } else if (parsed_statement.kind == Parsed_Statement_Kind.FUNCTION_TYPE) {
            Checker__check_function_type_statement(self, (Parsed_Function_Type_Statement*) parsed_statement)
        }
        parsed_statement = parsed_statement.next_statement
    }

    \ Collect other declarations
    parsed_statement = parsed_source.statements.first_statement
    while (parsed_statement != null) {
        let checked_statement: Checked_Statement* = null
        if (parsed_statement.kind == Parsed_Statement_Kind.FUNCTION) {
            Checker__check_function_declaration(self, (Parsed_Function_Statement*) parsed_statement)
        } else if (parsed_statement.kind == Parsed_Statement_Kind.VARIABLE) {
            checked_statement = (Checked_Statement*) Checker__check_variable_statement(self, (Parsed_Variable_Statement*) parsed_statement)
        } else if (parsed_statement.kind == Parsed_Statement_Kind.STRUCT) {
            \ ignored
        } else if (parsed_statement.kind == Parsed_Statement_Kind.OPAQUE_TYPE) {
            \ ignored
        } else if (parsed_statement.kind == Parsed_Statement_Kind.ENUM) {
            \ ignored
        } else if (parsed_statement.kind == Parsed_Statement_Kind.FUNCTION_TYPE) {
            \ ignored
        } else {
            Source_Location__error(parsed_statement.location, String__create_from("Unsupported statement"))
            abort()
        }
        if (checked_statement != null) {
            Checked_Statements__append(checked_statements, checked_statement)
        }
        parsed_statement = parsed_statement.next_statement
    }

    \ Check function definitions
    parsed_statement = parsed_source.statements.first_statement
    while (parsed_statement != null) {
        if (parsed_statement.kind == Parsed_Statement_Kind.FUNCTION) {
            let function_statement: Parsed_Function_Statement* = (Parsed_Function_Statement*) parsed_statement
            if (function_statement.statements != null) {
                Checker__check_function_definition(self, function_statement)
            }
        } else if (parsed_statement.kind == Parsed_Statement_Kind.VARIABLE) {
            \ ignored
        } else if (parsed_statement.kind == Parsed_Statement_Kind.STRUCT) {
            \ ignored
        } else if (parsed_statement.kind == Parsed_Statement_Kind.OPAQUE_TYPE) {
            \ ignored
        } else if (parsed_statement.kind == Parsed_Statement_Kind.ENUM) {
            \ ignored
        } else if (parsed_statement.kind == Parsed_Statement_Kind.FUNCTION_TYPE) {
            \ ignored
        } else {
            Source_Location__error(parsed_statement.location, String__create_from("Unsupported statement"))
            abort()
        }
        parsed_statement = parsed_statement.next_statement
    }

    let checked_source: Checked_Source* = (Checked_Source*) malloc(sizeof(Checked_Source))
    checked_source.first_symbol = self.symbols.first_symbol
    checked_source.statements = checked_statements
    return checked_source
}

define check = func (parsed_source: Parsed_Source*) -> Checked_Source* {
    let type_checker: Checker* = Checker__create()

    return Checker__check_source(type_checker, parsed_source)
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Generator
\ ---------------------------------------------------------------------------------------------------------------------

define Generator = struct {
    file: File*
    identation: u16
}

define Generator__write_source_location = func (self: Generator*, location: Source_Location*) -> void {
    File__write_cstring(self.file, "#line ")
    File__write_i32(self.file, (i32) location.line)
    File__write_cstring(self.file, " \"")
    File__write_cstring(self.file, location.source.path)
    File__write_cstring(self.file, "\"\n")
}

define Generator__generate_add_expression = func (self: Generator*, expression: Checked_Add_Expression*) -> void {
    Generator__generate_expression(self, expression.super.left_expression)
    File__write_cstring(self.file, " + ")
    Generator__generate_expression(self, expression.super.right_expression)
}

define Generator__generate_address_of_expression = func (self: Generator*, expression: Checked_Address_Of_Expression*) -> void {
    File__write_cstring(self.file, "&")
    Generator__generate_expression(self, expression.super.other_expression)
}

define Generator__generate_array_access_expression = func (self: Generator*, expression: Checked_Array_Access_Expression*) -> void {
    Generator__generate_expression(self, expression.array_expression)
    File__write_cstring(self.file, "[")
    Generator__generate_expression(self, expression.index_expression)
    File__write_cstring(self.file, "]")
}

define Generator__generate_bool_expression = func (self: Generator*, expression: Checked_Bool_Expression*) -> void {
    if (expression.value) {
        File__write_cstring(self.file, "true")
    } else {
        File__write_cstring(self.file, "false")
    }
}

define Generator__generate_call_expression = func (self: Generator*, expression: Checked_Call_Expression*) -> void {
    Generator__generate_expression(self, expression.callee_expression)
    File__write_cstring(self.file, "(")
    let argument: Checked_Call_Argument* = expression.first_argument
    while (argument != null) {
        Generator__generate_expression(self, argument.expression)
        argument = argument.next_argument
        if (argument != null) {
            File__write_cstring(self.file, ", ")
        }
    }
    File__write_cstring(self.file, ")")
}

define Generator__generate_cast_expression = func (self: Generator*, expression: Checked_Cast_Expression*) -> void {
    File__write_cstring(self.file, "(")
    File__write_checked_type(self.file, expression.super.type)
    File__write_cstring(self.file, ") ")
    Generator__generate_expression(self, expression.other_expression)
}

define File__write_octal_escaped_char = func (stream: File*, value: char) -> void {
    File__write_char(stream, '\\')
    if (value > (char) 64) {
        File__write_char(stream, value / (char) 64 % (char) 8 + '0')
    }
    if (value > (char) 8) {
        File__write_char(stream, value / (char) 8 % (char) 8 + '0')
    }
    File__write_char(stream, value % (char) 8 + '0')
}

define File__write_escaped_char = func (stream: File*, ch: char) -> void {
    if (ch < (char) 32) {
        if (ch == '\n') {
            File__write_cstring(stream, "\\n")
        } else if (ch == '\t') {
            File__write_cstring(stream, "\\t")
        } else {
            File__write_octal_escaped_char(stream, ch)
        }
    } else if (ch < (char) 127) {
        if (ch == '\"') {
            File__write_cstring(stream, "\\\"")
        } else if (ch == '\'') {
            File__write_cstring(stream, "\\'")
        } else if (ch == '\\') {
            File__write_cstring(stream, "\\\\")
        } else {
            File__write_char(stream, ch)
        }
    } else {
        File__write_octal_escaped_char(stream, ch)
    }
}

define Generator__generate_character_expression = func (self: Generator*, expression: Checked_Character_Expression*) -> void {
    File__write_char(self.file, '\'')
    File__write_escaped_char(self.file, expression.value)
    File__write_char(self.file, '\'')
}

define Generator__generate_dereference_expression = func (self: Generator*, expression: Checked_Dereference_Expression*) -> void {
    File__write_cstring(self.file, "*(")
    Generator__generate_expression(self, expression.value_expression)
    File__write_char(self.file, ')')
}

define Generator__generate_divide_expression = func (self: Generator*, expression: Checked_Divide_Expression*) -> void {
    Generator__generate_expression(self, expression.super.left_expression)
    File__write_cstring(self.file, " / ")
    Generator__generate_expression(self, expression.super.right_expression)
}

define Generator__generate_equals_expression = func (self: Generator*, expression: Checked_Equals_Expression*) -> void {
    Generator__generate_expression(self, expression.super.left_expression)
    File__write_cstring(self.file, " == ")
    Generator__generate_expression(self, expression.super.right_expression)
}

define Generator__generate_greater_expression = func (self: Generator*, expression: Checked_Greater_Expression*) -> void {
    Generator__generate_expression(self, expression.super.left_expression)
    File__write_cstring(self.file, " > ")
    Generator__generate_expression(self, expression.super.right_expression)
}

define Generator__generate_greater_or_equals_expression = func (self: Generator*, expression: Checked_Greater_Or_Equals_Expression*) -> void {
    Generator__generate_expression(self, expression.super.left_expression)
    File__write_cstring(self.file, " >= ")
    Generator__generate_expression(self, expression.super.right_expression)
}

define Generator__generate_group_expression = func (self: Generator*, expression: Checked_Group_Expression*) -> void {
    File__write_cstring(self.file, "(")
    Generator__generate_expression(self, expression.other_expression)
    File__write_cstring(self.file, ")")
}

define Generator__generate_integer_expression = func (self: Generator*, expression: Checked_Integer_Expression*) -> void {
    File__write_u64(self.file, expression.value)
}

define Generator__generate_less_expression = func (self: Generator*, expression: Checked_Less_Expression*) -> void {
    Generator__generate_expression(self, expression.super.left_expression)
    File__write_cstring(self.file, " < ")
    Generator__generate_expression(self, expression.super.right_expression)
}

define Generator__generate_less_or_equals_expression = func (self: Generator*, expression: Checked_Less_Or_Equals_Expression*) -> void {
    Generator__generate_expression(self, expression.super.left_expression)
    File__write_cstring(self.file, " <= ")
    Generator__generate_expression(self, expression.super.right_expression)
}

define Generator__generate_logic_and_expression = func (self: Generator*, expression: Checked_Logic_And_Expression*) -> void {
    Generator__generate_expression(self, expression.super.left_expression)
    File__write_cstring(self.file, " && ")
    Generator__generate_expression(self, expression.super.right_expression)
}

define Generator__generate_logic_or_expression = func (self: Generator*, expression: Checked_Logic_Or_Expression*) -> void {
    Generator__generate_expression(self, expression.super.left_expression)
    File__write_cstring(self.file, " || ")
    Generator__generate_expression(self, expression.super.right_expression)
}

define Generator__generate_member_access_expression = func (self: Generator*, expression: Checked_Member_Access_Expression*) -> void {
    Generator__generate_expression(self, expression.object_expression)
    if (expression.object_expression.type.kind == Checked_Type_Kind.POINTER) {
        File__write_cstring(self.file, "->")
    } else {
        File__write_cstring(self.file, ".")
    }
    File__write_string(self.file, expression.member.name)
}

define Generator__generate_minus_expression = func (self: Generator*, expression: Checked_Minus_Expression*) -> void {
    File__write_cstring(self.file, "-")
    Generator__generate_expression(self, expression.super.other_expression)
}

define Generator__generate_modulo_expression = func (self: Generator*, expression: Checked_Modulo_Expression*) -> void {
    Generator__generate_expression(self, expression.super.left_expression)
    File__write_cstring(self.file, " % ")
    Generator__generate_expression(self, expression.super.right_expression)
}

define Generator__generate_multiply_expression = func (self: Generator*, expression: Checked_Multiply_Expression*) -> void {
    Generator__generate_expression(self, expression.super.left_expression)
    File__write_cstring(self.file, " * ")
    Generator__generate_expression(self, expression.super.right_expression)
}

define Generator__generate_not_expression = func (self: Generator*, expression: Checked_Not_Expression*) -> void {
    File__write_cstring(self.file, "!")
    Generator__generate_expression(self, expression.super.other_expression)
}

define Generator__generate_not_equals_expression = func (self: Generator*, expression: Checked_Not_Equals_Expression*) -> void {
    Generator__generate_expression(self, expression.super.left_expression)
    File__write_cstring(self.file, " != ")
    Generator__generate_expression(self, expression.super.right_expression)
}

define Generator__generate_null_expression = func (self: Generator*, expression: Checked_Null_Expression*) -> void {
    File__write_cstring(self.file, "NULL")
}

define Generator__generate_sizeof_expression = func (self: Generator*, expression: Checked_Sizeof_Expression*) -> void {
    File__write_cstring(self.file, "sizeof(")
    File__write_checked_type(self.file, expression.sized_type)
    File__write_cstring(self.file, ")")
}

define Generator__generate_string_expression = func (self: Generator*, expression: Checked_String_Expression*) -> void {
    File__write_char(self.file, '"')
    let index: usize = (usize) 0
    while (index < expression.value.length) {
        File__write_escaped_char(self.file, expression.value.data[index])
        index = index + (usize) 1
    }
    File__write_char(self.file, '"')
}

define Generator__generate_substract_expression = func (self: Generator*, expression: Checked_Substract_Expression*) -> void {
    Generator__generate_expression(self, expression.super.left_expression)
    File__write_cstring(self.file, " - ")
    Generator__generate_expression(self, expression.super.right_expression)
}

define Generator__generate_symbol_expression = func (self: Generator*, expression: Checked_Symbol_Expression*) -> void {
    File__write_string(self.file, expression.symbol.name)
}

define Generator__generate_expression = func (self: Generator*, expression: Checked_Expression*) -> void {
    if (expression.kind == Checked_Expression_Kind.ADD) {
        Generator__generate_add_expression(self, (Checked_Add_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.ADDRESS_OF) {
        Generator__generate_address_of_expression(self, (Checked_Address_Of_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.ARRAY_ACCESS) {
        Generator__generate_array_access_expression(self, (Checked_Array_Access_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.BOOL) {
        Generator__generate_bool_expression(self, (Checked_Bool_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.CALL) {
        Generator__generate_call_expression(self, (Checked_Call_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.CAST) {
        Generator__generate_cast_expression(self, (Checked_Cast_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.CHARACTER) {
        Generator__generate_character_expression(self, (Checked_Character_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.DEREFERENCE) {
        Generator__generate_dereference_expression(self, (Checked_Dereference_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.DIVIDE) {
        Generator__generate_divide_expression(self, (Checked_Divide_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.EQUALS) {
        Generator__generate_equals_expression(self, (Checked_Equals_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.GREATER) {
        Generator__generate_greater_expression(self, (Checked_Greater_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.GREATER_OR_EQUALS) {
        Generator__generate_greater_or_equals_expression(self, (Checked_Greater_Or_Equals_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.GROUP) {
        Generator__generate_group_expression(self, (Checked_Group_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.INTEGER) {
        Generator__generate_integer_expression(self, (Checked_Integer_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.LESS) {
        Generator__generate_less_expression(self, (Checked_Less_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.LESS_OR_EQUALS) {
        Generator__generate_less_or_equals_expression(self, (Checked_Less_Or_Equals_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.LOGIC_AND) {
        Generator__generate_logic_and_expression(self, (Checked_Logic_And_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.LOGIC_OR) {
        Generator__generate_logic_or_expression(self, (Checked_Logic_Or_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.MEMBER_ACCESS) {
        Generator__generate_member_access_expression(self, (Checked_Member_Access_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.MINUS) {
        Generator__generate_minus_expression(self, (Checked_Minus_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.MODULO) {
        Generator__generate_modulo_expression(self, (Checked_Modulo_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.MULTIPLY) {
        Generator__generate_multiply_expression(self, (Checked_Multiply_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.NOT) {
        Generator__generate_not_expression(self, (Checked_Not_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.NOT_EQUALS) {
        Generator__generate_not_equals_expression(self, (Checked_Not_Equals_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.NULL) {
        Generator__generate_null_expression(self, (Checked_Null_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.SIZEOF) {
        Generator__generate_sizeof_expression(self, (Checked_Sizeof_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.STRING) {
        Generator__generate_string_expression(self, (Checked_String_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.SUBSTRACT) {
        Generator__generate_substract_expression(self, (Checked_Substract_Expression*) expression)
    } else if (expression.kind == Checked_Expression_Kind.SYMBOL) {
        Generator__generate_symbol_expression(self, (Checked_Symbol_Expression*) expression)
    } else {
        Source_Location__error(expression.location, String__create_from("Unsupported expression"))
        abort()
    }
}

define Generator__write_identation = func (self: Generator*) -> void {
    let identation: u16 = self.identation
    while (identation > (u16) 0) {
        File__write_cstring(self.file, "    ")
        identation = identation - (u16) 1
    }
}

define Generator__generate_assignment_statement = func (self: Generator*, statement: Checked_Assignment_Statement*) -> void {
    Generator__generate_expression(self, statement.object_expression)
    File__write_cstring(self.file, " = ")
    Generator__generate_expression(self, statement.value_expression)
    File__write_cstring(self.file, ";")
}

define Generator__generate_block_statement = func (self: Generator*, statement: Checked_Block_Statement*) -> void {
    File__write_cstring(self.file, "{\n")
    Generator__generate_statements(self, statement.statements)
    Generator__write_identation(self)
    File__write_cstring(self.file, "}")
}

define Generator__generate_break_statement = func (self: Generator*, statement: Checked_Break_Statement*) -> void {
    File__write_cstring(self.file, "break;")
}

define Generator__generate_expression_statement = func (self: Generator*, statement: Checked_Expression_Statement*) -> void {
    Generator__generate_expression(self, statement.expression)
    File__write_cstring(self.file, ";")
}

define Generator__generate_if_statement = func (self: Generator*, statement: Checked_If_Statement*) -> void {
    File__write_cstring(self.file, "if (")
    Generator__generate_expression(self, statement.condition_expression)
    File__write_cstring(self.file, ") ")
    Generator__generate_statement(self, statement.true_statement)
    if (statement.false_statement != null) {
        File__write_cstring(self.file, " else ")
        Generator__generate_statement(self, statement.false_statement)
    }
}

define Generator__generate_return_statement = func (self: Generator*, statement: Checked_Return_Statement*) -> void {
    File__write_cstring(self.file, "return")
    if (statement.expression != null) {
        File__write_cstring(self.file, " ")
        Generator__generate_expression(self, statement.expression)
    }
    File__write_cstring(self.file, ";")
}

define Generator__generate_variable_statement = func (self: Generator*, statement: Checked_Variable_Statement*) -> void {
    if (statement.is_external) {
        File__write_cstring(self.file, "extern ")
    }
    File__write_checked_type(self.file, statement.variable.super.type)
    File__write_char(self.file, ' ')
    File__write_string(self.file, statement.variable.super.name)
    if (statement.expression != null) {
        File__write_cstring(self.file, " = ")
        Generator__generate_expression(self, statement.expression)
    }
    File__write_cstring(self.file, ";")
}

define Generator__generate_while_statement = func (self: Generator*, statement: Checked_While_Statement*) -> void {
    File__write_cstring(self.file, "while (")
    Generator__generate_expression(self, statement.condition_expression)
    File__write_cstring(self.file, ") ")
    Generator__generate_statement(self, statement.body_statement)
}

define Generator__generate_statement = func (self: Generator*, statement: Checked_Statement*) -> void {
    if (statement.kind == Checked_Statement_Kind.ASSIGNMENT) {
        Generator__generate_assignment_statement(self, (Checked_Assignment_Statement*) statement)
    } else if (statement.kind == Checked_Statement_Kind.BLOCK) {
        Generator__generate_block_statement(self, (Checked_Block_Statement*) statement)
    } else if (statement.kind == Checked_Statement_Kind.BREAK) {
        Generator__generate_break_statement(self, (Checked_Break_Statement*) statement)
    } else if (statement.kind == Checked_Statement_Kind.EXPRESSION) {
        Generator__generate_expression_statement(self, (Checked_Expression_Statement*) statement)
    } else if (statement.kind == Checked_Statement_Kind.IF) {
        Generator__generate_if_statement(self, (Checked_If_Statement*) statement)
    } else if (statement.kind == Checked_Statement_Kind.RETURN) {
        Generator__generate_return_statement(self, (Checked_Return_Statement*) statement)
    } else if (statement.kind == Checked_Statement_Kind.VARIABLE) {
        Generator__generate_variable_statement(self, (Checked_Variable_Statement*) statement)
    } else if (statement.kind == Checked_Statement_Kind.WHILE) {
        Generator__generate_while_statement(self, (Checked_While_Statement*) statement)
    } else {
        Source_Location__error(statement.location, String__create_from("Unsupported statement"))
        abort()
    }
}

define Generator__generate_statements = func (self: Generator*, statements: Checked_Statements*) -> void {
    self.identation = self.identation + (u16) 1

    let statement: Checked_Statement* = statements.first_statement
    while (statement != null) {
        Generator__write_source_location(self, statement.location)

        Generator__write_identation(self)

        Generator__generate_statement(self, statement)

        File__write_cstring(self.file, "\n")

        statement = statement.next_statement
    }

    self.identation = self.identation - (u16) 1
}

define Generator__generate_enum = func (self: Generator*, enum_type: Checked_Enum_Type*) -> void {
    File__write_checked_type(self.file, (Checked_Type*) enum_type)
    File__write_cstring(self.file, " {\n")
    let enum_member: Checked_Enum_Member* = enum_type.first_member
    while (enum_member != null) {
        File__write_char(self.file, '\t')
        File__write_string(self.file, enum_member.symbol.name)
        enum_member = enum_member.next_member
        if (enum_member != null) {
            File__write_cstring(self.file, ",\n")
        } else {
            File__write_char(self.file, '\n')
        }
    }
    File__write_cstring(self.file, "};\n")
}

define Generator__declare_function = func (self: Generator*, function_symbol: Checked_Function_Symbol*) -> void {
    File__write_checked_type(self.file, (Checked_Type*) function_symbol.function_type)
    File__write_cstring(self.file, ";\n")
}

define Generator__generate_function = func (self: Generator*, function_symbol: Checked_Function_Symbol*) -> void {
    if (function_symbol.checked_statements == null) {
        return
    }
    Generator__write_source_location(self, function_symbol.super.location)
    File__write_checked_type(self.file, (Checked_Type*) function_symbol.function_type)
    File__write_cstring(self.file, " {\n")
    Generator__generate_statements(self, function_symbol.checked_statements)
    File__write_cstring(self.file, "}\n\n")
}

define Generator__declare_opaque_type = func (self: Generator*, opaque_type: Checked_Opaque_Type*) -> void {
    File__write_checked_type(self.file, (Checked_Type*) opaque_type)
    File__write_cstring(self.file, ";\n")
}

define Generator__declare_struct = func (self: Generator*, struct_type: Checked_Struct_Type*) -> void {
    File__write_checked_type(self.file, (Checked_Type*) struct_type)
    File__write_cstring(self.file, ";\n")
}

define Generator__generate_struct = func (self: Generator*, struct_type: Checked_Struct_Type*) -> void {
    let struct_member: Checked_Struct_Member* = struct_type.first_member
    if (struct_member == null) {
        return
    }
    File__write_checked_type(self.file, (Checked_Type*) struct_type)
    File__write_cstring(self.file, " {\n")
    while (struct_member != null) {
        File__write_char(self.file, '\t')
        File__write_checked_type(self.file, struct_member.type)
        File__write_char(self.file, ' ')
        File__write_string(self.file, struct_member.name)
        File__write_cstring(self.file, ";\n")
        struct_member = struct_member.next_member
    }
    File__write_cstring(self.file, "};\n\n")
}

define generate = func (file: File*, checked_source: Checked_Source*) -> void {
    let generator: Generator = undefined
    generator.file = file
    generator.identation = (u16) 0

    let checked_symbol: Checked_Symbol* = undefined

    File__write_cstring(generator.file, "/* Copyright (C) 2023 Stefan Selariu */\n")
    File__write_cstring(generator.file, "\n")
    File__write_cstring(generator.file, "#include <inttypes.h>\n")
    File__write_cstring(generator.file, "#include <stdbool.h>\n")
    File__write_cstring(generator.file, "#include <stddef.h>\n")
    File__write_cstring(generator.file, "\n")

    \ Declare all defined types
    checked_symbol = checked_source.first_symbol
    while (checked_symbol != null) {
        if (checked_symbol.kind == Checked_Symbol_Kind.TYPE) {
            let named_type: Checked_Named_Type* = ((Checked_Type_Symbol*) checked_symbol).named_type
            if (named_type.super.kind == Checked_Type_Kind.STRUCT) {
                Generator__declare_struct(&generator, (Checked_Struct_Type*) named_type)
            } else if (named_type.super.kind == Checked_Type_Kind.OPAQUE) {
                Generator__declare_opaque_type(&generator, (Checked_Opaque_Type*) named_type)
            } else if (named_type.super.kind == Checked_Type_Kind.ENUM) {
                Generator__generate_enum(&generator, (Checked_Enum_Type*) named_type)
            }
        }
        checked_symbol = checked_symbol.next_symbol
    }
    File__write_cstring(generator.file, "\n")

    \ Generate all defined types
    checked_symbol = checked_source.first_symbol
    while (checked_symbol != null) {
        if (checked_symbol.kind == Checked_Symbol_Kind.TYPE) {
            let named_type: Checked_Named_Type* = ((Checked_Type_Symbol*) checked_symbol).named_type
            if (named_type.super.kind == Checked_Type_Kind.STRUCT) {
                Generator__generate_struct(&generator, (Checked_Struct_Type*) named_type)
            }
        }
        checked_symbol = checked_symbol.next_symbol
    }

    \ Declare all global variables
    let checked_statement: Checked_Statement* = checked_source.statements.first_statement
    while (checked_statement != null) {
        if (checked_statement.kind == Checked_Statement_Kind.VARIABLE) {
            Generator__generate_variable_statement(&generator, (Checked_Variable_Statement*) checked_statement)
            File__write_cstring(generator.file, "\n")
        } else {
            Source_Location__error(checked_statement.location, String__create_from("Unsupported statement"))
            abort()
        }
        checked_statement = checked_statement.next_statement
    }
    File__write_cstring(generator.file, "\n")

    \ Declare all defined functions
    checked_symbol = checked_source.first_symbol
    while (checked_symbol != null) {
        if (checked_symbol.kind == Checked_Symbol_Kind.FUNCTION) {
            Generator__declare_function(&generator, (Checked_Function_Symbol*) checked_symbol)
        }
        checked_symbol = checked_symbol.next_symbol
    }
    File__write_cstring(generator.file, "\n")

    \ Generate all defined functions
    checked_symbol = checked_source.first_symbol
    while (checked_symbol != null) {
        if (checked_symbol.kind == Checked_Symbol_Kind.FUNCTION) {
            Generator__generate_function(&generator, (Checked_Function_Symbol*) checked_symbol)
        }
        checked_symbol = checked_symbol.next_symbol
    }
}

\ ---------------------------------------------------------------------------------------------------------------------
\   Main
\ ---------------------------------------------------------------------------------------------------------------------

define main = func (argc: i32, argv: char**) -> i32 {
    if (argc < 3) {
        error(String__append_cstring(String__append_cstring(String__create_from("Usage: "), argv[(usize) 0]), " SOURCE OUTPUT"))
        return 1
    }

    let source_file_path: char* = argv[(usize) 1]
    let source_file: File* = fopen(source_file_path, "r")
    if (source_file == null) {
        error(String__append_cstring(String__create_from("Cannot open file: "), source_file_path))
        return 1
    }

    let output_file_path: char* = argv[(usize) 2]
    let output_file: File* = undefined
    if (String__equals_cstring(String__create_from(output_file_path), "-")) {
        output_file = stdout
    } else {
        output_file = fopen(output_file_path, "w")
        if (output_file == null) {
            error(String__append_cstring(String__create_from("Cannot open file: "), output_file_path))
            return 1
        }
    }

    let source: Source* = Source__create(source_file, source_file_path)
    let parsed_source: Parsed_Source* = parse(source)
    let checked_source: Checked_Source* = check(parsed_source)
    generate(output_file, checked_source)

    fclose(source_file)
    return fclose(output_file)
}
