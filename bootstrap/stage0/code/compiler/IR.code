\ Copyright (c) 2020-2021, Stefan Selariu

include "./Map.code"

define IR_Type = struct {
    extends Object
    name: String
}

define IR_Any_Type = struct {
    extends IR_Type
}

define IR_Boolean_Type = struct {
    extends IR_Type
}

define IR_Integer_Type = struct {
    extends IR_Type
}

define IR_Int_Type = struct {
    extends IR_Integer_Type
}

define IR_Int16_Type = struct {
    extends IR_Int_Type
}

define IR_Int32_Type = struct {
    extends IR_Int_Type
}

define IR_Int64_Type = struct {
    extends IR_Int_Type
}

define IR_Int8_Type = struct {
    extends IR_Int_Type
}

define IR_IntMax_Type = struct {
    extends IR_Int_Type
}

define IR_UInt_Type = struct {
    extends IR_Integer_Type
}

define IR_UInt16_Type = struct {
    extends IR_UInt_Type
}

define IR_UInt32_Type = struct {
    extends IR_UInt_Type
}

define IR_UInt64_Type = struct {
    extends IR_UInt_Type
}

define IR_UInt8_Type = struct {
    extends IR_UInt_Type
}

define IR_UIntMax_Type = struct {
    extends IR_UInt_Type
}

define IR_Nothing_Type = struct {
    extends IR_Type
}

define IR_Null_Type = struct {
    extends IR_Type
}

define IR_Undefined_Type = struct {
    extends IR_Type
}

define IR_Pointer_Type = struct {
    extends IR_Type
    pointed_type: IR_Type
}

define IR_Unchecked_Array_Type = struct {
    extends IR_Type
    item_type: IR_Type
}

define IR_Fixed_Array_Type = struct {
    extends IR_Type
    item_type: IR_Type
    size: i64
}

define IR_Callable_Type = struct {
    extends IR_Type
    parameters: List[IR_Callable_Parameter]
}

define IR_Callable_Parameter = struct {
    location: Source_Location
    name: String
    type: IR_Type
}

define IR_Function_Type = struct {
    extends IR_Callable_Type
    return_type: IR_Type
}

define create_ir_function_type = func (parameters: List[IR_Callable_Parameter], return_type: IR_Type) -> IR_Function_Type {
    let type_name = make String().append("func (")
    let parameters_item = parameters.first_item
    while (parameters_item != null) {
        let parameter = parameters_item.data
        type_name.append(parameter.name).append(": ").append(parameter.type.name)
        parameters_item = parameters_item.next_item
        if (parameters_item != null) {
            type_name.append(", ")
        }
    }
    type_name.append(") -> ").append(return_type.name)

    return make IR_Function_Type(name = type_name, parameters = parameters, return_type = return_type)
}

define IR_Macro_Body_Type = struct {
    extends IR_Type
}

define IR_Macro_Type = struct {
    extends IR_Callable_Type
}

define create_ir_macro_type = func (parameters: List[IR_Callable_Parameter]) -> IR_Macro_Type {
    let type_name = make String().append("macro (")
    let parameters_item = parameters.first_item
    while (parameters_item != null) {
        let parameter = parameters_item.data
        type_name.append(parameter.name).append(": ").append(parameter.type.name)
        parameters_item = parameters_item.next_item
        if (parameters_item != null) {
            type_name.append(", ")
        }
    }
    type_name.append(')')

    return make IR_Macro_Type(name = type_name, parameters = parameters)
}

define IR_Struct_Type = struct {
    extends IR_Type
    base_type: IR_Struct_Type = null
    derived_types: List[IR_Struct_Type] = make List[IR_Struct_Type]()
    members: List[IR_Struct_Type_Member] = make List[IR_Struct_Type_Member]()
    statement: AST_Struct_Statement
    object_type_variable: IR_Global_Variable = null
    object_type_id: u32 = 0
    object_type_max_derivate_id: u32 = 0
}

define IR_Struct_Type_Member = struct {
    struct_type: IR_Struct_Type
    name: String
    type: IR_Type
}

define add_member = func (self: IR_Struct_Type, name: String, type: IR_Type) -> IR_Struct_Type_Member {
    let member = make IR_Struct_Type_Member(struct_type = self, name = name, type = type)
    self.members.append(member)
    return member
}

define get_member = func (self: IR_Struct_Type, name: String) -> IR_Struct_Type_Member {
    let struct_type = self
    loop {
        let members_item = struct_type.members.first_item
        while (members_item != null) {
            let member = members_item.data
            if (member.name.equals(name)) {
                return member
            }
            members_item = members_item.next_item
        }
        struct_type = struct_type.base_type
        if (struct_type == null) {
            return null
        }
    }
}

define is_base_type = func (self: IR_Struct_Type, other: IR_Struct_Type) -> bool {
    let struct_type = other
    loop {
        if (self == struct_type.base_type) {
            return true
        }
        struct_type = struct_type.base_type
        if (struct_type == null) {
            return false
        }
    }
}

define is_object_type = func (self: IR_Struct_Type) -> bool {
    let struct_type = self
    loop {
        if (struct_type.name.equals("Object")) {
            return true
        }
        struct_type = struct_type.base_type
        if (struct_type == null) {
            return false
        }
    }
}

define IR_Specialized_Struct_Type = struct {
    extends IR_Struct_Type
    type_arguments: List[IR_Type_Argument]
}

define IR_Type_Argument = struct {
    type: IR_Type
}

define IR_Placeholder_Type = struct {
    extends IR_Type
    ast_type: AST_Placeholder_Type
}

define IR_Value = struct {
    extends Object
    type: IR_Type
    creator_instruction: IR_Instruction = null
    user_instructions: List[IR_Instruction] = make List[IR_Instruction]()
    links: List[IR_Link] = make List[IR_Link]()
    dump: func (value: IR_Value, file: FILE) -> FILE = func (value: IR_Value, file: FILE) -> FILE {
        file.flush()
        abort(clone("Unsupported type: ").append(value.object_type.name))
    }
}

define write = func (file: FILE, value: IR_Value, check_users: bool) -> FILE {
    if (check_users && value.user_instructions.size == 0 as i64) {
        file.flush()
        if (value is IR_Variable_Value) {
            let value = value as IR_Variable_Value
            let value_version = value.version
        }
        stderr.write("Found ").write(value.object_type.name).write(" without user instructions: ")
        value.dump(stderr)
        stderr.end_line()
    }
    return value.dump(file)
}

define IR_Link = struct {
    extends Object
}

define IR_Requires_Value_Link = struct {
    extends IR_Link
    back_link: IR_Required_By_Value_Link
    value: IR_Value
}

define IR_Required_By_Value_Link = struct {
    extends IR_Link
    back_link: IR_Requires_Value_Link
    value: IR_Value
}

define IR_Undefined_Value = struct {
    extends IR_Value(
        dump = func (value: IR_Value, file: FILE) -> FILE {
            return file.write("undefined")
        }
    )
}

define IR_Constant_Value = struct {
    extends IR_Value(
        dump = func (value: IR_Value, file: FILE) -> FILE {
            return file.write((value as IR_Constant_Value).literal.lexeme)
        }
    )
    literal: Literal_Token
}

define IR_Struct_Literal_Value = struct {
    extends IR_Value(
        dump = func (value: IR_Value, file: FILE) -> FILE {
            let value = value as IR_Struct_Literal_Value
            file.write(value.type.name).write('(')
            let value_links_item = value.links.first_item
            let is_first_value_link = true
            while (value_links_item != null) {
                let value_link = value_links_item.data
                if (value_link is IR_Struct_Literal_Member_Value_Link) {
                    let value_link = value_link as IR_Struct_Literal_Member_Value_Link
                    if (is_first_value_link) {
                        is_first_value_link = false
                    } else {
                        file.write(", ")
                    }
                    file.write(value_link.struct_type_member.name).write(" = ").write(value_link.value, false)
                }
                value_links_item = value_links_item.next_item
            }
            return file.write(')')
        }
    )
    location: Source_Location
}

define IR_Struct_Literal_Member_Value_Link = struct {
    extends IR_Requires_Value_Link
    struct_type_member: IR_Struct_Type_Member
}

define get_member_value = func (self: IR_Struct_Literal_Value, struct_type_member: IR_Struct_Type_Member) -> IR_Value {
    let links_item = self.links.first_item
    while (links_item != null) {
        let link = links_item.data
        if (link is IR_Struct_Literal_Member_Value_Link) {
            let link = link as IR_Struct_Literal_Member_Value_Link
            if (link.struct_type_member == struct_type_member) {
                return link.value
            }
        }
        links_item = links_item.next_item
    }
    return null
}

define set_member_value = func (self: IR_Struct_Literal_Value, struct_type_member: IR_Struct_Type_Member, value: IR_Value) -> Nothing {
    let member_value_link = make IR_Struct_Literal_Member_Value_Link(value = value, struct_type_member = struct_type_member, back_link = undefined)
    member_value_link.back_link = make IR_Required_By_Value_Link(value = self, back_link = member_value_link)
    self.links.append(member_value_link)
    value.links.append(member_value_link.back_link)
}

define IR_Macro_Body_Value = struct {
    extends IR_Value(
        dump = func (value: IR_Value, file: FILE) -> FILE {
            let value = value as IR_Macro_Body_Value
            return file.write("{ ... }")
        }
    )
    macro_body: AST_Block_Statement
}

define IR_Global_Variable_Value = struct {
    extends IR_Value(
        dump = func (value: IR_Value, file: FILE) -> FILE {
            let value = value as IR_Variable_Value
            return file.write(value.variable.name)
        }
    )
    variable: IR_Variable
}

define IR_Global_Variable_Address_Value = struct {
    extends IR_Value(
        dump = func (value: IR_Value, file: FILE) -> FILE {
            let value = value as IR_Variable_Value
            return file.write(value.variable.name).write(".address")
        }
    )
    variable: IR_Variable
}

define IR_Variable_Value = struct {
    extends IR_Value(
        dump = func (value: IR_Value, file: FILE) -> FILE {
            let value = value as IR_Variable_Value
            return file.write(value.variable.name).write('.').write(value.version)
        }
    )
    variable: IR_Variable
    version: i64
}

define init = func (self: IR_Variable_Value, variable: IR_Variable) -> IR_Variable_Value {
    self.variable = variable
    self.version = variable.values.size + 1
    variable.values.append(self)
    return self
}

define IR_Variable_Address_Value = struct {
    extends IR_Value(
        dump = func (value: IR_Value, file: FILE) -> FILE {
            let value = value as IR_Variable_Address_Value
            return file.write(value.variable_value, true).write(".address")
        }
    )
    variable_value: IR_Variable_Value
}

define IR_Function_Address_Value = struct {
    extends IR_Value(
        dump = func (value: IR_Value, file: FILE) -> FILE {
            let value = value as IR_Function_Address_Value
            return file.write_function_label(value.function).write(".address")
        }
    )
    function: IR_Function
}

define IR_Block = struct {
    id: i64
    function: IR_Function
    predecessors: List[IR_Block] = make List[IR_Block]()
    first_instruction: IR_Instruction = null
    last_instruction: IR_Instruction = null
    is_being_generated: bool = false
    is_generated: bool = false
}

define has_instructions = func (self: IR_Block) -> bool {
    return self.first_instruction != null
}

define prepend = func (self: IR_Block, instruction: IR_Instruction) -> IR_Instruction {
    instruction.parent_block = self
    instruction.prev_instruction = null
    instruction.next_instruction = self.first_instruction
    if (self.first_instruction == null) {
        self.last_instruction = instruction
    } else {
        self.first_instruction.prev_instruction = instruction
    }
    self.first_instruction = instruction
    return instruction
}

define append = func (self: IR_Block, instruction: IR_Instruction) -> IR_Instruction {
    instruction.parent_block = self
    instruction.prev_instruction = self.last_instruction
    instruction.next_instruction = null
    if (self.last_instruction == null) {
        self.first_instruction = instruction
    } else {
        self.last_instruction.next_instruction = instruction
    }
    self.last_instruction = instruction
    return instruction
}

define append_jump = func (self: IR_Block, block: IR_Block) -> IR_Direct_Jump_Instruction {
    let instruction = make IR_Direct_Jump_Instruction(result_value = null, block = block)
    block.predecessors.append(self)
    self.append(instruction)
    return instruction
}

define append_jump = func (self: IR_Block, condition_value: IR_Value, true_block: IR_Block, false_block: IR_Block) -> IR_Conditional_Jump_Instruction {
    let instruction = make IR_Conditional_Jump_Instruction(result_value = null, true_block = true_block, false_block = false_block)
    instruction.set_operand_value("condition", condition_value)
    true_block.predecessors.append(self)
    false_block.predecessors.append(self)
    self.append(instruction)
    return instruction
}

define remove = func (self: IR_Block, instruction: IR_Instruction) -> Nothing {
    if (instruction.parent_block != self) {
        abort("Tried to remove instruction belonging to another block")
    }
    if (instruction.prev_instruction != null) {
        instruction.prev_instruction.next_instruction = instruction.next_instruction
    }
    if (instruction.next_instruction != null) {
        instruction.next_instruction.prev_instruction = instruction.prev_instruction
    }
    if (self.first_instruction == instruction) {
        self.first_instruction = instruction.next_instruction
    }
    if (self.last_instruction == instruction) {
        self.last_instruction = instruction.prev_instruction
    }
    instruction.parent_block = null
    instruction.prev_instruction = null
    instruction.next_instruction = null
}

define dump = func (block: IR_Block, file: FILE) -> FILE {
    file.write("block.").write(block.id)
    let block_predecessors = block.predecessors.create_iterator()
    if (block_predecessors.has_next()) {
        file.write('(')
        loop {
            let block_predecessor = block_predecessors.next()
            file.write("block.").write(block_predecessor.id)
            if (block_predecessors.has_next()) {
                file.write(", ")
            } else {
                break
            }
        }
        file.write(')')
    }
    file.write(':').end_line()
    let block_instruction = block.first_instruction
    while (block_instruction != null) {
        block_instruction.dump(file, "   ")
        block_instruction = block_instruction.next_instruction
    }
    return file
}

define IR_Callable = struct {
    extends IR_Symbol
    type: IR_Callable_Type
}

define IR_Function = struct {
    extends IR_Callable
    id: i64
    statement: AST_Function_Statement
    return_type: IR_Type
    parameters: List[IR_Function_Parameter]
    is_external: bool
    context_type_arguments: List[AST_Type_Argument]
    blocks: List[IR_Block]
}

define create_block = func (self: IR_Function) -> IR_Block {
    let block = make IR_Block(id = self.blocks.size + 1, function = self)
    self.blocks.append(block)
    return block
}

define dump = func (function: IR_Function, file: FILE) -> Nothing {
    file.write_function_label(function).write(" :: (")
    let function_parameters = function.parameters.create_iterator()
    while (function_parameters.has_next()) {
        let function_parameter = function_parameters.next()
        file.write(function_parameter.name).write(": ").write(function_parameter.type.name)
        if (function_parameters.has_next()) {
            file.write(", ")
        }
    }
    file.write(") -> ").write(function.return_type.name).write(" {").end_line()
    let block_item = function.blocks.first_item
    while (block_item != null) {
        block_item.data.dump(file)
        block_item = block_item.next_item
    }
    file.write('}').end_line()
}

define IR_Parameter = struct {
    extends IR_Function_Parameter
}

define IR_Macro = struct {
    extends IR_Callable
    context: IR_Builder_Context
    statement: AST_Block_Statement
}

define IR_Symbol = struct {
    extends Object
    name: String
    location: Source_Location
}

define IR_Variable = struct {
    extends IR_Symbol
    type: IR_Type
    values: List[IR_Value] = make List[IR_Value]()
}

define IR_Global_Variable = struct {
    extends IR_Variable
    value: IR_Value
    is_external: bool
}

define IR_Function_Parameter = struct {
    extends IR_Variable
}

define IR_Constant = struct {
    extends IR_Symbol
    value: IR_Constant_Value
}

define IR_Instruction = struct {
    extends Object
    location: Source_Location = null
    result_value: IR_Variable_Value
    operand_values: Map[Any, IR_Value] = make Map[Any, IR_Value]()
    parent_block: IR_Block = undefined
    prev_instruction: IR_Instruction = null
    next_instruction: IR_Instruction = null
    is_generated: bool = false
    dump: func (self: IR_Instruction, file: FILE, prefix: String) -> FILE = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
        file.flush()
        abort(clone("Unsupported type: ").append(instruction.object_type.name))
    }
}

define dump_ir_instruction_result = func (self: IR_Instruction, file: FILE, prefix: String) -> Nothing {
    file.write(prefix)
    if (self.result_value != null) {
        file.write(self.result_value, false).write(": ").write(self.result_value.type.name).write(" = ")
    }
}

define is_exit_instruction = func (self: IR_Instruction) -> bool {
    if (self == null) {
        return false
    }
    if (self is IR_Jump_Instruction || self is IR_Return_Instruction) {
        return true
    }
    if (self is IR_Direct_Call_Instruction) {
        let self = self as IR_Direct_Call_Instruction
        let function = self.function
        if (function.name.equals("abort")) {
            return true
        }
        if (function.name.equals("exit") && function.parameters.size == 1 as i64) {
            let function_parameter = function.parameters.get(0 as i64)
            if (function_parameter.type is IR_IntMax_Type) {
                return true
            }
        }
    }
    return false
}

define set_operand_value = func (self: IR_Instruction, key: Any, value: IR_Value) -> Nothing {
    self.operand_values.put(key, value)
    value.user_instructions.append(self)
}

define replace_operand_value = func (self: IR_Instruction, old_value: IR_Value, new_value: IR_Value) -> Nothing {
    old_value.user_instructions.remove(self).prune()
    new_value.user_instructions.append(self)
    if (self is IR_Phi_Instruction) {
        self.operand_values.remove(old_value)
        self.operand_values.put(new_value, new_value)
    } else {
        self.operand_values.replace_values(old_value, new_value)
    }
}

define IR_Call_Instruction = struct {
    extends IR_Instruction
    arguments_size: i64 = 0
}

define dump_ir_call_instruction_arguments = func (instruction: IR_Call_Instruction, file: FILE) -> Nothing {
    let call_argument_index = 0 as i64
    while (call_argument_index < instruction.arguments_size) {
        file.write(", ").write(instruction.get_argument_value(call_argument_index), true)
        call_argument_index = call_argument_index + 1
    }
}

define IR_Call_Argument = struct {
    name: String = null
    value: IR_Value
}

define add_arguments = func (self: IR_Call_Instruction, call_arguments: List[IR_Call_Argument]) -> IR_Call_Instruction {
    let call_arguments_item = call_arguments.first_item
    while (call_arguments_item != null) {
        let call_argument = call_arguments_item.data
        self.set_operand_value(get_argument_key(self.arguments_size), call_argument.value)
        self.arguments_size = self.arguments_size + 1
        call_arguments_item = call_arguments_item.next_item
    }
    return self
}

define get_argument_value = func (self: IR_Call_Instruction, index: i64) -> IR_Value {
    return self.operand_values.get(get_argument_key(index))
}

define get_argument_key = func (index: i64) -> String {
    if (index == 0 as i64) {
        return "argument-0-value"
    } else if (index == 1 as i64) {
        return "argument-1-value"
    } else if (index == 2 as i64) {
        return "argument-2-value"
    } else if (index == 3 as i64) {
        return "argument-3-value"
    } else if (index == 4 as i64) {
        return "argument-4-value"
    } else if (index == 5 as i64) {
        return "argument-5-value"
    }
    abort(clone("Missing argument index: ").append(index))
}

define IR_Direct_Call_Instruction = struct {
    extends IR_Call_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Direct_Call_Instruction
            file.write("call").write('(').write_function_label(instruction.function)
            instruction.dump_ir_call_instruction_arguments(file)
            return file.write(')').end_line()
        }
    )
    function: IR_Function
}

define create_ir_direct_call_instruction = func (result_value: IR_Variable_Value, call_arguments: List[IR_Call_Argument], function: IR_Function) -> IR_Call_Instruction {
    let instruction = make IR_Direct_Call_Instruction(result_value = result_value, function = function)
    instruction.add_arguments(call_arguments)
    if (result_value != null) {
        result_value.creator_instruction = instruction
    }
    return instruction
}

define IR_Dynamic_Call_Instruction = struct {
    extends IR_Call_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Dynamic_Call_Instruction
            let function_address = instruction.get_function_address()
            file.write("call").write('(').write(function_address.variable.name).write('.').write(function_address.version)
            instruction.dump_ir_call_instruction_arguments(file)
            return file.write(')').end_line()
        }
    )
}

define create_ir_dynamic_call_instruction = func (result_value: IR_Variable_Value, call_arguments: List[IR_Call_Argument], function_address: IR_Variable_Value) -> IR_Call_Instruction {
    let instruction = make IR_Dynamic_Call_Instruction(result_value = result_value)
    instruction.add_arguments(call_arguments)
    instruction.set_operand_value("function_address", function_address)
    if (result_value != null) {
        result_value.creator_instruction = instruction
    }
    return instruction
}

define get_function_address = func (self: IR_Dynamic_Call_Instruction) -> IR_Variable_Value {
    return self.operand_values.get("function_address") as IR_Variable_Value
}

define IR_Cast_Instruction = struct {
    extends IR_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Cast_Instruction
            return file.write("cast").write('(').write(instruction.get_value(), true).write(')').end_line()
        }
    )
}

define create_ir_cast_instruction = func (result_value: IR_Variable_Value, value: IR_Value) -> IR_Cast_Instruction {
    let instruction = make IR_Cast_Instruction(result_value = result_value)
    instruction.set_operand_value("value", value)
    result_value.creator_instruction = instruction
    return instruction
}

define get_value = func (self: IR_Cast_Instruction) -> IR_Value {
    return self.operand_values.get("value")
}

define IR_Is_Instruction = struct {
    extends IR_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Is_Instruction
            return file.write("is").write('(').write(instruction.get_value(), true).write(", ").write(instruction.type.name).write(')').end_line()
        }
    )
    type: IR_Struct_Type
}

define create_ir_is_instruction = func (result_value: IR_Variable_Value, value: IR_Value, type: IR_Struct_Type) -> IR_Is_Instruction {
    let instruction = make IR_Is_Instruction(result_value = result_value, type = type)
    instruction.set_operand_value("value", value)
    result_value.creator_instruction = instruction
    return instruction
}

define get_value = func (self: IR_Is_Instruction) -> IR_Value {
    return self.operand_values.get("value")
}

define IR_Jump_Instruction = struct {
    extends IR_Instruction
}

define IR_Conditional_Jump_Instruction = struct {
    extends IR_Jump_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Conditional_Jump_Instruction
            return file.write("jump").write('(').write(instruction.get_condition_value(), true).write(", ").write_block_label(instruction.true_block).write(", ").write_block_label(instruction.false_block).write(')').end_line()
        }
    )
    true_block: IR_Block
    false_block: IR_Block
}

define get_condition_value = func (self: IR_Conditional_Jump_Instruction) -> IR_Value {
    return self.operand_values.get("condition")
}

define IR_Direct_Jump_Instruction = struct {
    extends IR_Jump_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Direct_Jump_Instruction
            return file.write("jump").write('(').write_block_label(instruction.block).write(')').end_line()
        }
    )
    block: IR_Block
}

define IR_Load_Array_Item_Instruction = struct {
    extends IR_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Load_Array_Item_Instruction
            return file.write("load_array_item").write('(').write(instruction.get_array_value(), true).write(", ").write(instruction.get_index_value(), true).write(')').end_line()
        }
    )
    array_item_type: IR_Type
    load_address: bool
}

define create_ir_load_array_item_instruction = func (result_value: IR_Variable_Value, array_value: IR_Value, index_value: IR_Value, array_item_type: IR_Type, load_address: bool) -> IR_Load_Array_Item_Instruction {
    let instruction = make IR_Load_Array_Item_Instruction(result_value = result_value, array_item_type = array_item_type, load_address = load_address)
    instruction.set_operand_value("array_value", array_value)
    instruction.set_operand_value("index_value", index_value)
    result_value.creator_instruction = instruction
    return instruction
}

define get_array_value = func (self: IR_Load_Array_Item_Instruction) -> IR_Value {
    return self.operand_values.get("array_value")
}

define get_index_value = func (self: IR_Load_Array_Item_Instruction) -> IR_Value {
    return self.operand_values.get("index_value")
}

define IR_Load_Struct_Member_Instruction = struct {
    extends IR_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Load_Struct_Member_Instruction
            if (instruction.load_address) {
                file.write("load_struct_member_address")
            } else {
                file.write("load_struct_member")
            }
            return file.write('(').write(instruction.get_struct_pointer_value(), true).write(", ").write(instruction.struct_type_member.name).write(')').end_line()
        }
    )
    struct_type_member: IR_Struct_Type_Member
    load_address: bool
}

define create_ir_load_struct_member_instruction = func (result_value: IR_Variable_Value, struct_pointer_value: IR_Value, struct_type_member: IR_Struct_Type_Member, load_address: bool) -> IR_Load_Struct_Member_Instruction {
    let instruction = make IR_Load_Struct_Member_Instruction(result_value = result_value, struct_type_member = struct_type_member, load_address = load_address)
    instruction.set_operand_value("struct_pointer_value", struct_pointer_value)
    result_value.creator_instruction = instruction

    if (struct_type_member.type is IR_Struct_Type) {
        let result_value_link = make IR_Requires_Value_Link(value = struct_pointer_value, back_link = undefined)
        result_value_link.back_link = make IR_Required_By_Value_Link(value = result_value, back_link = result_value_link)
        result_value.links.append(result_value_link)
        struct_pointer_value.links.append(result_value_link.back_link)
    }

    return instruction
}

define get_struct_pointer_value = func (self: IR_Load_Struct_Member_Instruction) -> IR_Value {
    return self.operand_values.get("struct_pointer_value")
}

define IR_Load_Variable_Address_Instruction = struct {
    extends IR_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Load_Variable_Address_Instruction
            return file.write("load_variable_address").write('(').write(instruction.get_variable_value(), true).write(')').end_line()
        }
    )
}

define create_ir_load_variable_address_instruction = func (result_value: IR_Variable_Value, variable_value: IR_Variable_Value) -> IR_Load_Variable_Address_Instruction {
    let instruction = make IR_Load_Variable_Address_Instruction(result_value = result_value)
    instruction.set_operand_value("variable_value", variable_value)
    result_value.creator_instruction = instruction

    let result_value_link = make IR_Requires_Value_Link(value = variable_value, back_link = undefined)
    result_value_link.back_link = make IR_Required_By_Value_Link(value = result_value, back_link = result_value_link)
    result_value.links.append(result_value_link)
    variable_value.links.append(result_value_link.back_link)

    return instruction
}

define get_variable_value = func (self: IR_Load_Variable_Address_Instruction) -> IR_Variable_Value {
    return self.operand_values.get("variable_value") as IR_Variable_Value
}

define IR_Load_Variable_Instruction = struct {
    extends IR_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            return file.write("load_variable").write('(').write((instruction as IR_Load_Variable_Instruction).variable.name).write(')').end_line()
        }
    )
    variable: IR_Variable
}

define create_ir_load_variable_instruction = func (result_value: IR_Variable_Value) -> IR_Load_Variable_Instruction {
    let instruction = make IR_Load_Variable_Instruction(result_value = result_value, variable = result_value.variable)
    result_value.creator_instruction = instruction
    return instruction
}

define IR_New_Instruction = struct {
    extends IR_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_New_Instruction
            return file.write("new").write(' ').write(instruction.get_init_value(), true).end_line()
        }
    )
    type: IR_Type
}

define create_ir_new_instruction = func (result_value: IR_Variable_Value, type: IR_Type, init_value: IR_Value) -> IR_New_Instruction {
    let instruction = make IR_New_Instruction(result_value = result_value, type = type)
    instruction.set_operand_value("init_value", init_value)
    result_value.creator_instruction = instruction
    return instruction
}

define get_init_value = func (self: IR_New_Instruction) -> IR_Value {
    return self.operand_values.get("init_value")
}

define IR_Return_Instruction = struct {
    extends IR_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Return_Instruction
            if (instruction.get_return_value() == null) {
                return file.write("return").write('(').write(')').end_line()
            }
            return file.write("return").write('(').write(instruction.get_return_value(), true).write(')').end_line()
        }
    )
}

define create_ir_return_instruction = func (return_value: IR_Value) -> IR_Return_Instruction {
    let instruction = make IR_Return_Instruction(result_value = null)
    if (return_value != null) {
        instruction.set_operand_value("return_value", return_value)
    }
    return instruction
}

define get_return_value = func (self: IR_Return_Instruction) -> IR_Value {
    return self.operand_values.get("return_value")
}

define IR_Set_Instruction = struct {
    extends IR_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Set_Instruction
            return file.write(instruction.get_value(), true).end_line()
        }
    )
}

define create_ir_set_instruction = func (result_value: IR_Variable_Value, value: IR_Value) -> IR_Set_Instruction {
    let instruction = make IR_Set_Instruction(result_value = result_value)
    instruction.set_operand_value("value", value)
    result_value.creator_instruction = instruction
    return instruction
}

define get_value = func (self: IR_Set_Instruction) -> IR_Value {
    return self.operand_values.get("value")
}

define IR_Store_Array_Item_Instruction = struct {
    extends IR_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Store_Array_Item_Instruction
            return file.write("store_array_item").write('(').write(instruction.get_array_value(), true).write(", ").write(instruction.get_index_value(), true).write(", ").write(instruction.get_value(), true).write(')').end_line()
        }
    )
}

define create_ir_store_array_item_instruction = func (array_value: IR_Value, index_value: IR_Value, value: IR_Value) -> IR_Store_Array_Item_Instruction {
    let instruction = make IR_Store_Array_Item_Instruction(result_value = null)
    instruction.set_operand_value("array_value", array_value)
    instruction.set_operand_value("index_value", index_value)
    instruction.set_operand_value("value", value)
    return instruction
}

define get_array_value = func (self: IR_Store_Array_Item_Instruction) -> IR_Value {
    return self.operand_values.get("array_value")
}

define get_index_value = func (self: IR_Store_Array_Item_Instruction) -> IR_Value {
    return self.operand_values.get("index_value")
}

define get_value = func (self: IR_Store_Array_Item_Instruction) -> IR_Value {
    return self.operand_values.get("value")
}

define IR_Store_Struct_Member_Instruction = struct {
    extends IR_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Store_Struct_Member_Instruction
            return file.write("store_struct_member").write('(').write(instruction.get_struct_pointer_value(), true).write(", ").write(instruction.struct_type_member.name).write(", ").write(instruction.get_value(), true).write(')').end_line()
        }
    )
    struct_type_member: IR_Struct_Type_Member
}

define create_ir_store_struct_member_instruction = func (struct_pointer_value: IR_Value, struct_type_member: IR_Struct_Type_Member, value: IR_Value) -> IR_Store_Struct_Member_Instruction {
    let instruction = make IR_Store_Struct_Member_Instruction(result_value = null, struct_type_member = struct_type_member)
    instruction.set_operand_value("struct_pointer_value", struct_pointer_value)
    instruction.set_operand_value("value", value)
    return instruction
}

define get_struct_pointer_value = func (self: IR_Store_Struct_Member_Instruction) -> IR_Value {
    return self.operand_values.get("struct_pointer_value")
}

define get_value = func (self: IR_Store_Struct_Member_Instruction) -> IR_Value {
    return self.operand_values.get("value")
}

define IR_Binary_Instruction = struct {
    extends IR_Instruction
}

define init = func (self: IR_Binary_Instruction, left_value: IR_Value, right_value: IR_Value) -> IR_Binary_Instruction {
    self.set_operand_value("left_value", left_value)
    self.set_operand_value("right_value", right_value)
    return self
}

define get_left_value = func (self: IR_Binary_Instruction) -> IR_Value {
    return self.operand_values.get("left_value")
}

define get_right_value = func (self: IR_Binary_Instruction) -> IR_Value {
    return self.operand_values.get("right_value")
}

define IR_Add_Instruction = struct {
    extends IR_Binary_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Binary_Instruction
            return file.write(instruction.get_left_value(), true).write(" + ").write(instruction.get_right_value(), true).end_line()
        }
    )
}

define IR_Comparison_Instruction = struct {
    extends IR_Binary_Instruction
}

define IR_Divide_Instruction = struct {
    extends IR_Binary_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Binary_Instruction
            return file.write(instruction.get_left_value(), true).write(" / ").write(instruction.get_right_value(), true).end_line()
        }
    )
}

define IR_Equals_Comparison_Instruction = struct {
    extends IR_Comparison_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Binary_Instruction
            return file.write(instruction.get_left_value(), true).write(" == ").write(instruction.get_right_value(), true).end_line()
        }
    )
}

define IR_Greater_Comparison_Instruction = struct {
    extends IR_Comparison_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Binary_Instruction
            return file.write(instruction.get_left_value(), true).write(" > ").write(instruction.get_right_value(), true).end_line()
        }
    )
}

define IR_Greater_Or_Equal_Comparison_Instruction = struct {
    extends IR_Comparison_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Binary_Instruction
            return file.write(instruction.get_left_value(), true).write(" >= ").write(instruction.get_right_value(), true).end_line()
        }
    )
}

define IR_Less_Comparison_Instruction = struct {
    extends IR_Comparison_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Binary_Instruction
            return file.write(instruction.get_left_value(), true).write(" < ").write(instruction.get_right_value(), true).end_line()
        }
    )
}

define IR_Less_Or_Equal_Comparison_Instruction = struct {
    extends IR_Comparison_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Binary_Instruction
            return file.write(instruction.get_left_value(), true).write(" <= ").write(instruction.get_right_value(), true).end_line()
        }
    )
}

define IR_Modulo_Instruction = struct {
    extends IR_Binary_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Binary_Instruction
            return file.write(instruction.get_left_value(), true).write(" // ").write(instruction.get_right_value(), true).end_line()
        }
    )
}

define IR_Multiply_Instruction = struct {
    extends IR_Binary_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Binary_Instruction
            return file.write(instruction.get_left_value(), true).write(" * ").write(instruction.get_right_value(), true).end_line()
        }
    )
}

define IR_Not_Equal_Comparison_Instruction = struct {
    extends IR_Comparison_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Binary_Instruction
            return file.write(instruction.get_left_value(), true).write(" != ").write(instruction.get_right_value(), true).end_line()
        }
    )
}

define IR_Substract_Instruction = struct {
    extends IR_Binary_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            let instruction = instruction as IR_Binary_Instruction
            instruction.dump_ir_instruction_result(file, prefix)
            return file.write(instruction.get_left_value(), true).write(" - ").write(instruction.get_right_value(), true).end_line()
        }
    )
}

define IR_Phi_Instruction = struct {
    extends IR_Instruction(
        dump = func (instruction: IR_Instruction, file: FILE, prefix: String) -> FILE {
            instruction.dump_ir_instruction_result(file, prefix)
            let instruction = instruction as IR_Phi_Instruction
            file.write("phi").write('(')
            let operand_values_entry = instruction.operand_values.first_entry
            if (operand_values_entry != null) {
                loop {
                    file.write(operand_values_entry.value, true)
                    operand_values_entry = operand_values_entry.next_entry
                    if (operand_values_entry == null) {
                        break
                    }
                    file.write(", ")
                }
            }
            return file.write(')').end_line()
        }
    )
}

define create_ir_phi_instruction = func (result_value: IR_Variable_Value) -> IR_Phi_Instruction {
    let instruction = make IR_Phi_Instruction(result_value = result_value)
    result_value.creator_instruction = instruction
    return instruction
}

define append = func (self: IR_Phi_Instruction, value: IR_Value) -> Nothing {
    self.set_operand_value(value, value)
}

define is_redundant = func (self: IR_Phi_Instruction) -> bool {
    \ redundant phi instruction:
    \   v.1 = phi(v.2)

    let operand_values_entry = self.operand_values.first_entry
    if (operand_values_entry == null) {
        abort()
    }
    let other_value = operand_values_entry.value
    operand_values_entry = operand_values_entry.next_entry
    while (operand_values_entry != null) {
        if (operand_values_entry.value != other_value) {
            return false
        }
        operand_values_entry = operand_values_entry.next_entry
    }
    return true
}

define is_trivial = func (self: IR_Phi_Instruction) -> bool {
    \ trivial phi instructions:
    \   v.1 = phi(v.1)
    \   v.1 = phi(v.1, v.2)

    let operand_values_entry = self.operand_values.first_entry
    if (operand_values_entry == null) {
        abort()
    }
    let result_value: IR_Value = self.result_value
    let other_value: IR_Value = null
    while (operand_values_entry != null) {
        let value = operand_values_entry.value
        if (value != result_value) {
            if (value != other_value) {
                if (other_value != null) {
                    return false
                }
                other_value = value
            }
        }
        operand_values_entry = operand_values_entry.next_entry
    }
    return true
}
