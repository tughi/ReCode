\ Copyright (c) 2020-2021, 2023, Stefan Selariu

struct Parser {
    scanner: @Scanner = null
    compilation_unit: @Compilation_Unit = make @Compilation_Unit()
    current_alignment: i32 = 0
    anonymous_functions_counter: Counter[i64] = make Counter[i64]()
}

define parse = func (file_path: @String) -> @Compilation_Unit {
    let parser = make @Parser()
    parser.parse(file_path, null)
    return parser.compilation_unit
}

define parse = func (self: @Parser, file_path: @String, location: @Source_Location) -> Nothing {
    let source = create_source(file_path)
    if (source == null) {
        let message = clone("Failed to open file: ").append(file_path)
        if (location != null) {
            abort(location, message)
        }
        abort(message)
    }

    self.compilation_unit.sources.append(source)
    source.id = self.compilation_unit.sources.size

    let other_scanner = self.scanner
    self.scanner = create_scanner(source)
    self.parse_statements(self.compilation_unit.statements)

    let token = self.scanner.current_token
    if (token is End_Of_File_Token == false) {
        abort(self, self.scanner.current_token)
    }
    let token = token as @End_Of_File_Token
    if (token.location.column != 1 as i64) {
        stderr.write(token.location).write(": File doesn't end with a new line").end_line()
    }

    self.scanner = other_scanner
}

\ statements
\   | ( statement <EOL> )*
define parse_statements = func (self: @Parser, statements: @List[@AST_Statement]) -> Nothing {
    loop {
        let statement = self.parse_statement()
        if (statement == null) {
            break
        }
        self.consume_end_of_line()
        if (statement is AST_Include_Statement) {
            let statement = statement as @AST_Include_Statement

            let statement_file_path = statement.file_path.make_relative_path(statement.location.source.file_path)
            if (statement_file_path == null) {
                abort(statement.location, clone("Unsupported file path: ").append(statement.file_path))
            }

            let compilation_unit_sources_item = self.compilation_unit.sources.first_item
            while (compilation_unit_sources_item != null) {
                if (compilation_unit_sources_item.data.file_path.equals(statement_file_path)) {
                    break
                }
                compilation_unit_sources_item = compilation_unit_sources_item.next_item
            }

            if (compilation_unit_sources_item == null) {
                self.parse(statement_file_path, statement.location)
            }
        } else {
            statements.append(statement)
        }
    }
}

define make_relative_path = func (file_path: @String, base_file_path: @String) -> @String {
    if (file_path.starts_with("./")) {
        let relative_path = clone(base_file_path).append(file_path).remove(base_file_path.last_index_of('/') + 1, base_file_path.length + 2)
        return relative_path
    }
    if (file_path.starts_with("../")) {
        let relative_path = clone(base_file_path).append(file_path).remove(base_file_path.last_index_of('/') + 1, base_file_path.length)
        loop {
            let index = relative_path.index_of("/../")
            if (index <= 0) {
                break
            }
            relative_path.remove(relative_path.last_index_of('/', index - 1), index + 3)
        }
        return relative_path
    }
    return file_path
}

\ statement
\   | define
\   | let
\   | if
\   | loop
\   | while
\   | break
\   | return
\   | expression ( "=" expression )?
define parse_statement = func (self: @Parser) -> @AST_Statement {
    while (self.consume_empty_line()) {
    }

    if (self.matches(optional_space, required_close_brace) || self.matches(required_end_of_file)) {
        return null
    }

    self.consume_space(self.current_alignment * 4)

    if (self.matches(required_define)) {
        return self.parse_define()
    }
    if (self.matches(required_external)) {
        return self.parse_external()
    }
    if (self.matches(required_let)) {
        return self.parse_let()
    }
    if (self.matches(required_if)) {
        return self.parse_if()
    }
    if (self.matches(required_return)) {
        let token = self.consume(required_return)
        let value_expression: @AST_Expression = null
        if (self.matches_end_of_line() == false) {
            self.consume_space(1)
            value_expression = self.parse_expression()
        }
        return make @AST_Return_Statement(location = token.location, value_expression = value_expression)
    }
    if (self.matches(required_loop)) {
        return self.parse_loop()
    }
    if (self.matches(required_while)) {
        return self.parse_while()
    }
    if (self.matches(required_break)) {
        let token = self.consume(required_break)
        return make @AST_Break_Statement(location = token.location)
    }
    if (self.matches(required_struct)) {
        return self.parse_struct()
    }
    if (self.matches(required_include)) {
        return self.parse_include()
    }

    let expression = self.parse_expression()

    if (self.matches(optional_space, optional_comment, required_end_of_line)) {
        return make @AST_Expression_Statement(location = expression.location, expression = expression)
    }

    if (self.matches(optional_space, required_equals)) {
        self.consume_space(1)
        let operator = self.consume(required_equals) as @Other_Token
        self.consume_space(1)
        return make @AST_Assignment_Statement(location = expression.location, storage_expression = expression, operator = operator, value_expression = self.parse_expression())
    }

    return null
}

\ include
\   | "include" STRING
define parse_include = func (self: @Parser) -> @AST_Include_Statement {
    let location = self.consume(required_include).location
    self.consume_space(1)
    let file_path = (self.consume(required_string_literal) as @String_Token).value
    return make @AST_Include_Statement(location = location, file_path = file_path)
}

\ define
\   | "define" IDENTIFIER "=" ( struct | function | expression )
define parse_define = func (self: @Parser) -> @AST_Statement {
    self.consume(required_define)
    self.consume_space(1)
    let name = self.consume(required_identifier) as @Identifier_Token
    self.consume_space(1)
    self.consume(required_equals)
    self.consume_space(1)
    if (self.matches(required_func)) {
        return self.parse_function(name)
    }
    if (self.matches(required_macro)) {
        return self.parse_macro(name)
    }
    let expression = self.parse_expression()
    return make @AST_Constant_Statement(location = name.location, name = name, expression = expression)
}

\ external
\   | "external" ( external_function | external_type | external_variable )
define parse_external = func (self: @Parser) -> @AST_Statement {
    let location = self.consume(required_external).location
    self.consume_space(1)
    if (self.matches(required_type)) {
        return self.parse_external_type()
    }
    abort(location, "Unsupported external statement")
}

\ external_type
\   | "type" IDENTIFIER
define parse_external_type = func (self: @Parser) -> @AST_Struct_Statement {
    self.consume(required_type)
    self.consume_space(1)
    let name = self.consume(required_identifier) as @Identifier_Token
    return make @AST_Struct_Statement(
        location = name.location
        name = name
        type_parameters = null
        base_type = null
        members = null
        init_arguments = null
    )
}

\ struct
\   | "struct" IDENTIFIER type_parameters? "{" <EOL> ( "extends" IDENTIFIER ( "(" call_arguments ")" )? <EOL> )? ( IDENTIFIER ( ":" type ( "=" expression )? | "=" expression )? <EOL> )* "}"
define parse_struct = func (self: @Parser) -> @AST_Struct_Statement {
    self.consume(required_struct)
    self.consume_space(1)
    let struct_name = self.consume(required_identifier) as @Identifier_Token
    let struct_type_parameters: @List[@AST_Type_Parameter] = null
    if (self.matches(optional_space, required_open_bracket)) {
        self.consume_space(0)
        struct_type_parameters = self.parse_type_parameters()
    }
    self.consume_space(1)
    self.consume(required_open_brace)
    self.consume_end_of_line()
    self.current_alignment = self.current_alignment + 1
    let base_type: @AST_Type = null
    let struct_init_arguments = make @List[@AST_Call_Argument]()
    if (self.matches(optional_space, required_extends)) {
        self.consume_space(self.current_alignment * 4)
        self.consume(required_extends)
        self.consume_space(1)
        base_type = self.parse_type()
        if (self.matches(optional_space, required_open_paren)) {
            self.consume_space(0)
            self.consume(required_open_paren)
            self.parse_call_arguments(struct_init_arguments)
            self.consume_space(0)
            self.consume(required_close_paren)
        }
        self.consume_end_of_line()
    }
    let struct_members = make @List[@AST_Struct_Member]()
    while (self.matches(optional_space, required_close_brace) == false) {
        if (self.consume_empty_line() == false) {
            self.consume_space(self.current_alignment * 4)
            let struct_member_name = self.consume(required_identifier) as @Identifier_Token
            self.consume_space(0)
            self.consume(required_colon)
            self.consume_space(1)
            let struct_member_value_type = self.parse_type()
            if (self.matches(optional_space, required_equals)) {
                self.consume_space(1)
                self.consume(required_equals)
                self.consume_space(1)
                let value_expression = self.parse_expression()
                struct_init_arguments.append(make @AST_Call_Argument(name = struct_member_name, value_expression = value_expression))
            }
            self.consume_end_of_line()
            struct_members.append(make @AST_Struct_Member(location = struct_member_name.location, name = struct_member_name, type = struct_member_value_type))
        }
    }
    self.current_alignment = self.current_alignment - 1
    self.consume_space(self.current_alignment * 4)
    self.consume(required_close_brace)
    return make @AST_Struct_Statement(
        location = struct_name.location
        name = struct_name
        type_parameters = struct_type_parameters
        base_type = base_type
        members = struct_members
        init_arguments = struct_init_arguments
    )
}

\ type_parameters
\   | "[" IDENTIFIER ( "," IDENTIFIER )* "]"
define parse_type_parameters = func (self: @Parser) -> @List[@AST_Type_Parameter] {
    let type_parameters = make @List[@AST_Type_Parameter]()
    self.consume(required_open_bracket)
    self.consume_space(0)
    loop {
        let type_parameter_name = self.consume(required_identifier) as @Identifier_Token
        type_parameters.append(make @AST_Type_Parameter(name = type_parameter_name))
        self.consume_space(0)
        if (self.matches(required_comma) == false) {
            break
        }
        self.consume(required_comma)
        self.consume_space(1)
    }
    self.consume(required_close_bracket)
    return type_parameters
}

\ function
\   | function_type block?
define parse_function = func (self: @Parser, function_name: @Identifier_Token) -> @AST_Function_Statement {
    let function_is_anonymous = function_name is Generated_Identifier_Token
    let function_type = self.parse_function_type()
    let function_body: @AST_Block_Statement
    if (self.matches(optional_space, required_open_brace)) {
        self.consume_space(1)
        function_body = self.parse_block()
    } else {
        if (function_is_anonymous) {
            abort(function_name.location, "Anonymous function without body")
        }
        function_body = null
    }
    let function_statement = make @AST_Function_Statement(location = function_name.location, name = function_name, type = function_type, body = function_body, is_anonymous = function_is_anonymous)
    self.compilation_unit.function_statements.append(function_statement)
    return function_statement
}

\ function_type
\   | "func" type_parameters? parameters "->" type
define parse_function_type = func (self: @Parser) -> @AST_Function_Type {
    let location = self.consume(required_func).location
    self.consume_space(1)
    let function_type_parameters: @List[@AST_Type_Parameter] = null
    if (self.matches(required_open_bracket)) {
        function_type_parameters = self.parse_type_parameters()
        self.consume_space(1)
    }
    let function_parameters = self.parse_parameters()
    self.consume_space(1)
    self.consume(required_hyphen, required_greater_than)
    self.consume_space(1)
    let function_return_type = self.parse_type()
    return make @AST_Function_Type(location = location, type_parameters = function_type_parameters, parameters = function_parameters, return_type = function_return_type)
}

\ parameters
\   | "(" ( parameter ( "," parameter )* )? ")"
define parse_parameters = func (self: @Parser) -> @List[@AST_Parameter] {
    let parameters = make @List[@AST_Parameter]()
    self.consume(required_open_paren)
    self.consume_space(0)
    if (self.matches(required_close_paren) == false) {
        parameters.append(self.parse_parameter())
        while (self.matches(optional_space, required_close_paren) == false) {
            self.consume_space(0)
            self.consume(required_comma)
            self.consume_space(1)
            parameters.append(self.parse_parameter())
        }
    }
    self.consume(required_close_paren)
    return parameters
}

\ parameter
\   | IDENTIFIER ":" type
define parse_parameter = func (self: @Parser) -> @AST_Parameter {
    let parameter_name = self.consume(required_identifier) as @Identifier_Token
    self.consume_space(0)
    self.consume(required_colon)
    self.consume_space(1)
    let parameter_type = self.parse_type()
    return make @AST_Parameter(location = parameter_name.location, name = parameter_name, type = parameter_type)
}

\ macro
\   | macro_type block
define parse_macro = func (self: @Parser, macro_name: @Identifier_Token) -> @AST_Macro_Statement {
    let macro_type = self.parse_macro_type()
    self.consume_space(1)
    let macro_body = self.parse_block()
    let macro_statement = make @AST_Macro_Statement(location = macro_name.location, name = macro_name, type = macro_type, body = macro_body)
    self.compilation_unit.macro_statements.append(macro_statement)
    return macro_statement
}

\ macro_type
\   | "macro" type_parameters? parameters
define parse_macro_type = func (self: @Parser) -> @AST_Macro_Type {
    let location = self.consume(required_macro).location
    self.consume_space(1)
    let macro_type_parameters: @List[@AST_Type_Parameter] = null
    if (self.matches(required_open_bracket)) {
        macro_type_parameters = self.parse_type_parameters()
        self.consume_space(1)
    }
    let macro_parameters = self.parse_parameters()
    return make @AST_Macro_Type(location = location, type_parameters = macro_type_parameters, parameters = macro_parameters)
}

\ block
\   | "{" statements "}"
define parse_block = func (self: @Parser) -> @AST_Block_Statement {
    let location = self.consume(required_open_brace).location
    self.consume_end_of_line()
    self.current_alignment = self.current_alignment + 1
    let statements = make @List[@AST_Statement]()
    self.parse_statements(statements)
    self.current_alignment = self.current_alignment - 1
    self.consume_space(self.current_alignment * 4)
    self.consume(required_close_brace)
    return make @AST_Block_Statement(location = location, statements = statements)
}

\ let
\   | "let" IDENTIFIER ( ":" type ( "=" expression )? | "=" expression )
define parse_let = func (self: @Parser) -> @AST_Variable_Statement {
    let location = self.consume(required_let).location
    self.consume_space(1)
    let variable_name = self.consume(required_identifier) as @Identifier_Token
    let variable_value_type: @AST_Type = null
    let variable_value_expression: @AST_Expression = null
    let variable_is_global = self.current_alignment == 0
    let variable_is_external = false
    if (self.matches(optional_space, required_colon)) {
        self.consume_space(0)
        self.consume(required_colon)
        self.consume_space(1)
        variable_value_type = self.parse_type()
    }
    if (self.matches(optional_space, required_equals)) {
        self.consume_space(1)
        self.consume(required_equals)
        self.consume_space(1)
        if (self.matches(required_external)) {
            self.consume(required_external)
            if (variable_is_global == false) {
                abort(location, "Only global variables can have an external value")
            }
            if (variable_value_type == null) {
                abort(location, "External variables require a type")
            }
            variable_is_external = true
        } else {
            variable_value_expression = self.parse_expression()
        }
    }
    return make @AST_Variable_Statement(location = variable_name.location, name = variable_name, type = variable_value_type, value_expression = variable_value_expression, is_external = variable_is_external)
}

\ if
\   | "if" "(" expression ")" block ( "else" ( block | if ) )?
define parse_if = func (self: @Parser) -> @AST_Statement {
    let location = self.consume(required_if).location
    self.consume_space(1)
    self.consume(required_open_paren)
    self.consume_space(0)
    let condition_expression = self.parse_expression()
    self.consume_space(0)
    self.consume(required_close_paren)
    self.consume_space(1)
    let true_statement = self.parse_block()
    let false_statement: @AST_Statement = null
    if (self.matches(optional_space, required_else)) {
        self.consume_space(1)
        self.consume(required_else)
        self.consume_space(1)
        if (self.matches(required_if)) {
            false_statement = self.parse_if()
        } else {
            false_statement = self.parse_block()
        }
    }
    return make @AST_If_Statement(location = location, condition_expression = condition_expression, true_statement = true_statement, false_statement = false_statement)
}

\ loop
\   | "loop" block
define parse_loop = func (self: @Parser) -> @AST_Statement {
    let location = self.consume(required_loop).location
    self.consume_space(1)
    let loop_block = self.parse_block()
    return make @AST_Loop_Statement(location = location, block = loop_block)
}

\ while
\   | "while" "(" expression ")" block
define parse_while = func (self: @Parser) -> @AST_Statement {
    let location = self.consume(required_while).location
    self.consume_space(1)
    self.consume(required_open_paren)
    self.consume_space(0)
    let condition_expression = self.parse_expression()
    self.consume_space(0)
    self.consume(required_close_paren)
    self.consume_space(1)
    let loop_block = self.parse_block()
    return make @AST_While_Statement(location = location, condition_expression = condition_expression, block = loop_block)
}

\ type
\   | "@" type
\   | IDENTIFIER ( "[" type ( "," type )* "]" )?
\   | "[" type ( ";" expression )? "]"
\   | function_type
\   | macro_type
define parse_type = func (self: @Parser) -> @AST_Type {
    if (self.matches(required_at)) {
        let location = self.consume(required_at).location
        self.consume_space(0)
        let pointed_type = self.parse_type()
        return make @AST_Pointer_Type(location = location, pointed_type = pointed_type)
    }

    if (self.matches(required_open_bracket)) {
        let token = self.consume(required_open_bracket)
        self.consume_space(0)
        let array_item_type = self.parse_type()
        let array_is_checked = true
        let array_size_expression: @AST_Expression = null
        if (self.matches(optional_space, required_column)) {
            self.consume_space(0)
            self.consume(required_column)
            self.consume_space(1)
            if (self.matches(required_question_mark)) {
                self.consume(required_question_mark)
                array_is_checked = false
            } else {
                array_size_expression = self.parse_expression()
            }
        }
        self.consume_space(0)
        self.consume(required_close_bracket)
        return make @AST_Array_Type(location = token.location, item_type = array_item_type, is_checked = array_is_checked, size_expression = array_size_expression)
    }

    if (self.matches(required_func)) {
        return self.parse_function_type()
    }

    if (self.matches(required_macro)) {
        return self.parse_macro_type()
    }

    let type_name = self.consume(required_identifier) as @Identifier_Token
    if (self.matches(optional_space, required_open_bracket)) {
        self.consume_space(0)
        self.consume(required_open_bracket)
        self.consume_space(0)
        let type_arguments = make @List[@AST_Type_Argument]()
        loop {
            type_arguments.append(make @AST_Type_Argument(type = self.parse_type()))
            self.consume_space(0)
            if (self.matches(required_comma) == false) {
                break
            }
            self.consume(required_comma)
            self.consume_space(1)
        }
        self.consume(required_close_bracket)
        return make @AST_Specialized_Type(location = type_name.location, name = type_name, type_arguments = type_arguments)
    }

    return make @AST_Named_Type(location = type_name.location, name = type_name)
}

define parse_expression = func (self: @Parser) -> @AST_Expression {
    return self.parse_logic_or_expression()
}

\ logic_or_expression
\   | logic_and_expression ( "||" logic_and_expression )*
define parse_logic_or_expression = func (self: @Parser) -> @AST_Expression {
    let expression = self.parse_logic_and_expression()
    while (self.matches(optional_space, required_vertical_bar, required_vertical_bar)) {
        self.consume_space(1)
        self.consume(required_vertical_bar, required_vertical_bar)
        self.consume_space(1)
        expression = make @AST_Logic_Or_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_logic_and_expression())
    }
    return expression
}

\ logic_and_expression
\   | equality_expression ( "&&" equality_expression )*
define parse_logic_and_expression = func (self: @Parser) -> @AST_Expression {
    let expression = self.parse_equality_expression()
    while (self.matches(optional_space, required_ampersand, required_ampersand)) {
        self.consume_space(1)
        self.consume(required_ampersand, required_ampersand)
        self.consume_space(1)
        expression = make @AST_Logic_And_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_equality_expression())
    }
    return expression
}

\ equality_expression
\   | comparison_expression ( ( "==" | "!=" ) comparison_expression )?
define parse_equality_expression = func (self: @Parser) -> @AST_Expression {
    let expression = self.parse_comparison_expression()
    if (self.matches(optional_space, required_equals, required_equals) || self.matches(optional_space, required_exclamation_mark, required_equals)) {
        self.consume_space(1)
        if (self.matches(required_equals)) {
            self.consume(required_equals, required_equals)
            self.consume_space(1)
            expression = make @AST_Equals_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_comparison_expression())
        } else {
            self.consume(required_exclamation_mark, required_equals)
            self.consume_space(1)
            expression = make @AST_Not_Equals_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_comparison_expression())
        }
    }
    return expression
}

\ comparison_expression
\   | addition_expression ( ( "<" | "<=" | ">" | ">=" ) addition_expression )?
define parse_comparison_expression = func (self: @Parser) -> @AST_Expression {
    let expression = self.parse_addition_expression()
    if (self.matches(optional_space, required_less_than) || self.matches(optional_space, required_greater_than)) {
        self.consume_space(1)
        if (self.matches(required_less_than)) {
            self.consume(required_less_than)
            if (self.matches(required_equals)) {
                self.consume(required_equals)
                self.consume_space(1)
                expression = make @AST_Less_Than_Or_Equals_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_addition_expression())
            } else {
                self.consume_space(1)
                expression = make @AST_Less_Than_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_addition_expression())
            }
        } else {
            self.consume(required_greater_than)
            if (self.matches(required_equals)) {
                self.consume(required_equals)
                self.consume_space(1)
                expression = make @AST_Greater_Than_Or_Equals_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_addition_expression())
            } else {
                self.consume_space(1)
                expression = make @AST_Greater_Than_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_addition_expression())
            }
        }
    }
    return expression
}

\ addition_expression
\   | multiplication_expression ( ( "+" | "-" ) multiplication_expression )*
define parse_addition_expression = func (self: @Parser) -> @AST_Expression {
    let expression = self.parse_multiplication_expression()
    while (self.matches(optional_space, required_plus) || self.matches(optional_space, required_hyphen)) {
        self.consume_space(1)
        let binary_expression: @AST_Binary_Expression
        if (self.matches(required_plus)) {
            self.consume(required_plus)
            self.consume_space(1)
            expression = make @AST_Add_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_multiplication_expression())
        } else {
            self.consume(required_hyphen)
            self.consume_space(1)
            expression = make @AST_Substract_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_multiplication_expression())
        }
    }
    return expression
}

\ multiplication_expression
\   | unary_expression ( ( "*" | "/" | "//" ) unary_expression )*
define parse_multiplication_expression = func (self: @Parser) -> @AST_Expression {
    let expression = self.parse_unary_expression()
    while (self.matches(optional_space, required_asterisk) || self.matches(optional_space, required_slash)) {
        self.consume_space(1)
        if (self.matches(required_slash)) {
            self.consume(required_slash)
            if (self.matches(required_slash)) {
                self.consume(required_slash)
                self.consume_space(1)
                expression = make @AST_Modulo_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_unary_expression())
            } else {
                self.consume_space(1)
                expression = make @AST_Divide_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_unary_expression())
            }
        } else {
            self.consume(required_asterisk)
            self.consume_space(1)
            expression = make @AST_Multiply_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_unary_expression())
        }
    }
    return expression
}

\ unary_expression
\   | "-" unary_expression
\   | cast_expression
define parse_unary_expression = func (self: @Parser) -> @AST_Expression {
    if (self.matches(required_hyphen)) {
        let location = self.consume(required_hyphen).location
        self.consume_space(0)
        let expression = self.parse_unary_expression()
        if (expression is AST_Literal_Expression && (expression as @AST_Literal_Expression).literal is Integer_Token) {
            let old_literal = (expression as @AST_Literal_Expression).literal as @Integer_Token
            let new_literal = make @Integer_Token(location = location, lexeme = clone("-").append(old_literal.lexeme), value = -old_literal.value, type = old_literal.type)
            return make @AST_Wrapped_Expression(
                location = location
                expression = make @AST_Literal_Expression(
                    location = location
                    literal = new_literal
                )
            )
        }
        return make @AST_Negate_Expression(location = location, expression = expression)
    }
    return self.parse_cast_expression()
}

\ cast_expression
\   | is_expression ( "as" type )?
define parse_cast_expression = func (self: @Parser) -> @AST_Expression {
    let expression = self.parse_is_expression()
    if (self.matches(optional_space, required_as)) {
        self.consume_space(1)
        self.consume(required_as)
        self.consume_space(1)
        let type = self.parse_type()
        return make @AST_Cast_Expression(location = expression.location, value_expression = expression, type = type)
    }
    return expression
}

\ is_expression
\   | access_expression ( "is" type )?
define parse_is_expression = func (self: @Parser) -> @AST_Expression {
    let expression = self.parse_access_expression()
    if (self.matches(optional_space, required_is)) {
        self.consume_space(1)
        self.consume(required_is)
        self.consume_space(1)
        let type = self.parse_type()
        return make @AST_Is_Expression(location = expression.location, value_expression = expression, type = type)
    }
    return expression
}

\ access_expression
\   | primary_expression ( "." IDENTIFIER | "(" call_arguments? ")" block? | "[" expression "]" )*
define parse_access_expression = func (self: @Parser) -> @AST_Expression {
    let expression = self.parse_primary_expression()
    if (expression != null) {
        loop {
            let old_expression = expression
            if (self.matches(optional_space, required_dot)) {
                self.consume_space(0)
                self.consume(required_dot)
                self.consume_space(0)
                expression = make @AST_Member_Access_Expression(location = expression.location, object_expression = expression, member_name = self.consume(required_identifier) as @Identifier_Token)
            }
            if (self.matches(optional_space, required_open_paren)) {
                self.consume_space(0)
                self.consume(required_open_paren)
                self.consume_space(0)
                let call_arguments = make @List[@AST_Call_Argument]()
                if (self.matches(optional_space, required_close_paren) == false) {
                    self.parse_call_arguments(call_arguments)
                }
                self.consume_space(0)
                self.consume(required_close_paren)
                if (self.matches(optional_space, required_open_brace)) {
                    self.consume_space(1)
                    let block_statement = self.parse_block()
                    call_arguments.append(
                        make @AST_Call_Argument(
                            name = null
                            value_expression = make @AST_Macro_Body(location = block_statement.location, statement = block_statement)
                        )
                    )
                }
                expression = make @AST_Call_Expression(location = expression.location, callee_expression = expression, arguments = call_arguments)
            }
            if (self.matches(optional_space, required_open_bracket)) {
                self.consume_space(0)
                self.consume(required_open_bracket)
                self.consume_space(0)
                let index_expression = self.parse_expression()
                self.consume_space(0)
                self.consume(required_close_bracket)
                expression = make @AST_Array_Access_Expression(location = expression.location, array_expression = expression, index_expression = index_expression)
            }
            if (expression == old_expression) {
                break
            }
        }
    }
    return expression
}

\ call_arguments
\   | call_argument ( "," call_argument )*
\   | END_OF_LINE call_argument ( END_OF_LINE call_argument )*
define parse_call_arguments = func (self: @Parser, call_arguments: @List[@AST_Call_Argument]) -> Nothing {
    if (self.matches_end_of_line()) {
        self.consume_end_of_line()
        self.current_alignment = self.current_alignment + 1
        while (self.matches(optional_space, required_close_paren) == false) {
            self.consume_space(self.current_alignment * 4)
            call_arguments.append(self.parse_call_argument())
            self.consume_end_of_line()
        }
        self.current_alignment = self.current_alignment - 1
        self.consume_space(self.current_alignment * 4)
    } else {
        call_arguments.append(self.parse_call_argument())
        while (self.matches(optional_space, required_comma)) {
            self.consume_space(0)
            self.consume(required_comma)
            self.consume_space(1)
            call_arguments.append(self.parse_call_argument())
        }
    }
}

\ call_argument
\   | ( IDENTIFIER "=" )? expression
define parse_call_argument = func (self: @Parser) -> @AST_Call_Argument {
    if (self.matches(required_identifier, optional_space, required_equals)) {
        let name = self.consume(required_identifier) as @Identifier_Token
        self.consume_space(1)
        self.consume(required_equals)
        self.consume_space(1)
        let value = self.parse_expression()
        return make @AST_Call_Argument(name = name, value_expression = value)
    }
    let value = self.parse_expression()
    return make @AST_Call_Argument(name = null, value_expression = value)
}

\ primary_expression
\   | "@"? IDENTIFIER
\   | INTEGER
\   | STRING
\   | CHARACTER
\   | "null"
\   | "false"
\   | "true"
\   | "undefined"
\   | "(" expression ")"
\   | "make" type "(" call_arguments? ")"
\   | function
define parse_primary_expression = func (self: @Parser) -> @AST_Expression {
    if (self.matches(required_make)) {
        let location = self.consume(required_make).location
        self.consume_space(1)
        let type = self.parse_type()
        self.consume_space(0)
        self.consume(required_open_paren)
        let call_arguments = make @List[@AST_Call_Argument]()
        if (self.matches(optional_space, required_close_paren) == false) {
            self.parse_call_arguments(call_arguments)
        }
        self.consume_space(0)
        self.consume(required_close_paren)
        return make @AST_Make_Expression(location = location, type = type, init_arguments = call_arguments)
    }
    if (self.matches(required_literal)) {
        let token = self.consume(required_literal) as @Literal_Token
        return make @AST_Literal_Expression(location = token.location, literal = token)
    }
    if (self.matches(required_func)) {
        let function_name = clone("anonymous_function_").append(self.anonymous_functions_counter.next())
        let function_statement = self.parse_function(make @Generated_Identifier_Token(location = self.scanner.current_token.location, lexeme = function_name))
        return make @AST_Function_Expression(location = function_statement.location, function_statement = function_statement)
    }
    if (self.matches(required_at)) {
        let location = self.consume(required_at).location
        self.consume_space(0)
        let identifier = self.consume(required_identifier) as @Identifier_Token
        return make @AST_Variable_Reference_Expression(
            location = location
            variable_expression = make @AST_Variable_Expression(location = identifier.location, name = identifier)
        )
    }
    if (self.matches(required_identifier)) {
        let identifier = self.consume(required_identifier) as @Identifier_Token
        return make @AST_Variable_Expression(location = identifier.location, name = identifier)
    }
    if (self.matches(required_open_paren)) {
        let location = self.consume(required_open_paren).location
        self.consume_space(0)
        let expression = self.parse_expression()
        self.consume_space(0)
        self.consume(required_close_paren)
        return make @AST_Paren_Expression(location = location, expression = expression)
    }
    return null
}

struct Generated_Identifier_Token {
    extends Identifier_Token
}

define consume_end_of_line = func (self: @Parser) -> Nothing {
    if (self.matches(optional_space, required_comment)) {
        self.consume_space(1)
        self.consume(required_comment)
    } else {
        self.consume_space(0)
    }
    if (self.matches(required_end_of_file) == false) {
        self.consume(required_end_of_line)
    }
}

define consume_empty_line = func (self: @Parser) -> bool {
    if (self.matches(optional_space, optional_comment, required_end_of_line)) {
        if (self.matches(optional_space, required_comment)) {
            self.consume_space(self.current_alignment * 4)
            self.consume(required_comment)
        } else {
            self.consume_space(0)
        }
        self.consume(required_end_of_line)
        return true
    }
    return false
}

define consume_space = func (self: @Parser, expected_space_count: i32) -> Nothing {
    let space_count: i32
    let token = self.scanner.current_token
    if (token is Space_Token) {
        self.scanner.next_token()
        let space = token as @Space_Token
        space_count = space.count
    } else {
        space_count = 0
    }
    if (space_count != expected_space_count) {
        stderr.write(token.location).write(": Consumed ").write(space_count).write(" spaces where ").write(expected_space_count).write(" are expected").end_line()
    }
}

define consume = func (self: @Parser, first_matcher: @Matcher) -> @Token {
    return self.consume(first_matcher, null)
}

define consume = func (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher) -> @Token {
    return self.consume(first_matcher, second_matcher, null)
}

define consume = func (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher, third_matcher: @Matcher) -> @Token {
    let token = self.scanner.current_token
    let first_token = token
    if (first_matcher.accepts(token)) {
        token = self.scanner.next_token()
    } else {
        if (first_matcher.is_required) {
            self.abort(token)
        }
    }
    if (second_matcher != null) {
        if (second_matcher.accepts(token)) {
            token = self.scanner.next_token()
        } else {
            if (second_matcher.is_required) {
                self.abort(token)
            }
        }
    }
    if (third_matcher != null) {
        if (third_matcher.accepts(token)) {
            token = self.scanner.next_token()
        } else {
            if (third_matcher.is_required) {
                self.abort(token)
            }
        }
    }
    return first_token
}

define matches_end_of_line = func (self: @Parser) -> bool {
    return self.matches(optional_space, optional_comment, required_end_of_line)
}

define matches = func (self: @Parser, first_matcher: @Matcher) -> bool {
    return self.matches(first_matcher, null)
}

define matches = func (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher) -> bool {
    return self.matches(first_matcher, second_matcher, null)
}

define matches = func (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher, third_matcher: @Matcher) -> bool {
    let token = self.scanner.current_token
    let peek_offset = 0 as i64
    if (first_matcher.accepts(token)) {
        token = self.scanner.peek_token(peek_offset)
        peek_offset = peek_offset + 1
    } else if (first_matcher.is_required) {
        return false
    }
    if (second_matcher != null) {
        if (second_matcher.accepts(token)) {
            token = self.scanner.peek_token(peek_offset)
            peek_offset = peek_offset + 1
        } else if (second_matcher.is_required) {
            return false
        }
    }
    if (third_matcher != null) {
        if (third_matcher.accepts(token)) {
            token = self.scanner.peek_token(peek_offset)
            peek_offset = peek_offset + 1
        } else if (third_matcher.is_required) {
            return false
        }
    }
    return true
}

struct Matcher {
    extends Object
    is_required: bool
    accepts: func (self: @Matcher, token: @Token) -> bool = func (self: @Matcher, token: @Token) -> bool {
        abort(token.location, "Invalid state")
    }
}

struct Comment_Matcher {
    extends Matcher(
        accepts = func (self: @Matcher, token: @Token) -> bool {
            return token is Comment_Token
        }
    )
}

struct End_Of_File_Matcher {
    extends Matcher(
        accepts = func (self: @Matcher, token: @Token) -> bool {
            return token is End_Of_File_Token
        }
    )
}

struct End_Of_Line_Matcher {
    extends Matcher(
        accepts = func (self: @Matcher, token: @Token) -> bool {
            return token is End_Of_Line_Token
        }
    )
}

struct Identifier_Matcher {
    extends Matcher(
        accepts = func (self: @Matcher, token: @Token) -> bool {
            return token is Identifier_Token
        }
    )
}

struct Keyword_Matcher {
    extends Matcher(
        accepts = func (self: @Matcher, token: @Token) -> bool {
            if (token is Identifier_Token) {
                return token.lexeme.equals((self as @Keyword_Matcher).lexeme)
            }
            return false
        }
    )
    lexeme: @String
}

struct Literal_Matcher {
    extends Matcher(
        accepts = func (self: @Matcher, token: @Token) -> bool {
            return token is Integer_Token || token is String_Token || token is Character_Token || token is Boolean_Token || token is Null_Token || token is Undefined_Token
        }
    )
}

struct Other_Matcher {
    extends Matcher(
        accepts = func (self: @Matcher, token: @Token) -> bool {
            if (token is Other_Token) {
                return token.lexeme.equals((self as @Other_Matcher).lexeme)
            }
            return false
        }
    )
    lexeme: @String
}

struct Space_Matcher {
    extends Matcher(
        accepts = func (self: @Matcher, token: @Token) -> bool {
            return token is Space_Token
        }
    )
}

struct String_Literal_Matcher {
    extends Matcher(
        accepts = func (self: @Matcher, token: @Token) -> bool {
            return token is String_Token
        }
    )
}

let optional_comment: @Matcher = undefined
let optional_space: @Matcher = undefined
let required_ampersand: @Matcher = undefined
let required_as: @Matcher = undefined
let required_asterisk: @Matcher = undefined
let required_at: @Matcher = undefined
let required_break: @Matcher = undefined
let required_close_brace: @Matcher = undefined
let required_close_bracket: @Matcher = undefined
let required_close_paren: @Matcher = undefined
let required_colon: @Matcher = undefined
let required_column: @Matcher = undefined
let required_comma: @Matcher = undefined
let required_comment: @Matcher = undefined
let required_define: @Matcher = undefined
let required_dot: @Matcher = undefined
let required_else: @Matcher = undefined
let required_end_of_file: @Matcher = undefined
let required_end_of_line: @Matcher = undefined
let required_equals: @Matcher = undefined
let required_exclamation_mark: @Matcher = undefined
let required_extends: @Matcher = undefined
let required_external: @Matcher = undefined
let required_func: @Matcher = undefined
let required_greater_than: @Matcher = undefined
let required_hyphen: @Matcher = undefined
let required_identifier: @Matcher = undefined
let required_if: @Matcher = undefined
let required_include: @Matcher = undefined
let required_is: @Matcher = undefined
let required_less_than: @Matcher = undefined
let required_let: @Matcher = undefined
let required_literal: @Matcher = undefined
let required_loop: @Matcher = undefined
let required_macro: @Matcher = undefined
let required_make: @Matcher = undefined
let required_open_brace: @Matcher = undefined
let required_open_bracket: @Matcher = undefined
let required_open_paren: @Matcher = undefined
let required_plus: @Matcher = undefined
let required_question_mark: @Matcher = undefined
let required_return: @Matcher = undefined
let required_slash: @Matcher = undefined
let required_string_literal: @Matcher = undefined
let required_struct: @Matcher = undefined
let required_type: @Matcher = undefined
let required_vertical_bar: @Matcher = undefined
let required_while: @Matcher = undefined

define init_matchers = func () -> Nothing {
    optional_comment = make @Comment_Matcher(is_required = false)
    optional_space = make @Space_Matcher(is_required = false)
    required_ampersand = make @Other_Matcher(is_required = true, lexeme = "&")
    required_as = make @Keyword_Matcher(is_required = true, lexeme = "as")
    required_asterisk = make @Other_Matcher(is_required = true, lexeme = "*")
    required_at = make @Other_Matcher(is_required = true, lexeme = "@")
    required_break = make @Keyword_Matcher(is_required = true, lexeme = "break")
    required_close_brace = make @Other_Matcher(is_required = true, lexeme = "}")
    required_close_bracket = make @Other_Matcher(is_required = true, lexeme = "]")
    required_close_paren = make @Other_Matcher(is_required = true, lexeme = ")")
    required_colon = make @Other_Matcher(is_required = true, lexeme = ":")
    required_column = make @Other_Matcher(is_required = true, lexeme = ";")
    required_comma = make @Other_Matcher(is_required = true, lexeme = ",")
    required_comment = make @Comment_Matcher(is_required = true)
    required_define = make @Keyword_Matcher(is_required = true, lexeme = "define")
    required_dot = make @Other_Matcher(is_required = true, lexeme = ".")
    required_else = make @Keyword_Matcher(is_required = true, lexeme = "else")
    required_end_of_file = make @End_Of_File_Matcher(is_required = true)
    required_end_of_line = make @End_Of_Line_Matcher(is_required = true)
    required_equals = make @Other_Matcher(is_required = true, lexeme = "=")
    required_exclamation_mark = make @Other_Matcher(is_required = true, lexeme = "!")
    required_extends = make @Keyword_Matcher(is_required = true, lexeme = "extends")
    required_external = make @Keyword_Matcher(is_required = true, lexeme = "external")
    required_func = make @Keyword_Matcher(is_required = true, lexeme = "func")
    required_greater_than = make @Other_Matcher(is_required = true, lexeme = ">")
    required_hyphen = make @Other_Matcher(is_required = true, lexeme = "-")
    required_identifier = make @Identifier_Matcher(is_required = true)
    required_if = make @Keyword_Matcher(is_required = true, lexeme = "if")
    required_include = make @Keyword_Matcher(is_required = true, lexeme = "include")
    required_is = make @Keyword_Matcher(is_required = true, lexeme = "is")
    required_less_than = make @Other_Matcher(is_required = true, lexeme = "<")
    required_let = make @Keyword_Matcher(is_required = true, lexeme = "let")
    required_literal = make @Literal_Matcher(is_required = true)
    required_loop = make @Keyword_Matcher(is_required = true, lexeme = "loop")
    required_macro = make @Keyword_Matcher(is_required = true, lexeme = "macro")
    required_make = make @Keyword_Matcher(is_required = true, lexeme = "make")
    required_open_brace = make @Other_Matcher(is_required = true, lexeme = "{")
    required_open_bracket = make @Other_Matcher(is_required = true, lexeme = "[")
    required_open_paren = make @Other_Matcher(is_required = true, lexeme = "(")
    required_plus = make @Other_Matcher(is_required = true, lexeme = "+")
    required_question_mark = make @Other_Matcher(is_required = true, lexeme = "?")
    required_return = make @Keyword_Matcher(is_required = true, lexeme = "return")
    required_slash = make @Other_Matcher(is_required = true, lexeme = "/")
    required_string_literal = make @String_Literal_Matcher(is_required = true)
    required_struct = make @Keyword_Matcher(is_required = true, lexeme = "struct")
    required_type = make @Keyword_Matcher(is_required = true, lexeme = "type")
    required_vertical_bar = make @Other_Matcher(is_required = true, lexeme = "|")
    required_while = make @Keyword_Matcher(is_required = true, lexeme = "while")
}
