\ Copyright (c) 2020-2021, 2023, Stefan Selariu

struct List[T] {
    first_item: List_Item[T] = null
    last_item: List_Item[T] = null
    size: i64 = 0
}

define append = func [T] (self: List[T], data: T) -> Nothing {
    let item = make List_Item[T](data = data, prev_item = self.last_item)
    if (self.last_item == null) {
        self.first_item = item
    } else {
        self.last_item.next_item = item
    }
    self.last_item = item
    self.size = self.size + 1
}

define prepend = func [T] (self: List[T], data: T) -> Nothing {
    let item = make List_Item[T](data = data, next_item = self.first_item)
    if (self.first_item == null) {
        self.last_item = item
    } else {
        self.first_item.prev_item = item
    }
    self.first_item = item
    self.size = self.size + 1
}

define remove = func [T] (self: List[T], data: T) -> List[T] {
    let item = self.first_item
    while (item != null) {
        if (item.data == data) {
            item.is_removed = true
            break
        }
        item = item.next_item
    }
    return self
}

define remove_all = func [T] (self: List[T], data: T) -> List[T] {
    let item = self.first_item
    while (item != null) {
        if (item.data == data) {
            item.is_removed = true
        }
        item = item.next_item
    }
    return self
}

define prune = func [T] (self: List[T]) -> List[T] {
    let item = self.first_item
    while (item != null) {
        if (item.is_removed) {
            if (item.prev_item != null) {
                item.prev_item.next_item = item.next_item
            }
            if (item.next_item != null) {
                item.next_item.prev_item = item.prev_item
            }
            if (self.first_item == item) {
                self.first_item = item.next_item
            }
            if (self.last_item == item) {
                self.last_item = item.prev_item
            }
            self.size = self.size - 1
        }
        item = item.next_item
    }
    return self
}

define replace = func [T] (self: List[T], data: T, new_data: T) -> Nothing {
    let item = self.first_item
    while (item != null) {
        if (item.data == data) {
            item.data = new_data
        }
        item = item.next_item
    }
}

define contains = func [T] (self: List[T], data: T) -> bool {
    let item = self.first_item
    while (item != null) {
        if (item.data == data) {
            return true
        }
        item = item.next_item
    }
    return false
}

define index_of = func [T] (self: List[T], data: T) -> i64 {
    let index = 0 as i64
    let item = self.first_item
    while (item != null) {
        if (item.data == data) {
            return index
        }
        item = item.next_item
        index = index + 1
    }
    return -1 as i64
}

define get = func [T] (self: List[T], index: i64) -> T {
    if (index >= self.size || index < 0) {
        return null
    }
    let item = self.first_item
    while (index > 0) {
        item = item.next_item
        index = index - 1
    }
    return item.data
}

define first = func [T] (self: List[T]) -> T {
    if (self.first_item == null) {
        return null
    }
    return self.first_item.data
}

define last = func [T] (self: List[T]) -> T {
    if (self.last_item == null) {
        return null
    }
    return self.last_item.data
}

struct List_Item[T] {
    prev_item: List_Item[T] = null
    next_item: List_Item[T] = null
    data: T
    is_removed: bool = false
}

struct List_Iterator[T] {
    current_item: List_Item[T]
    next_item: List_Item[T]
}

define create_iterator = func [T] (list: List[T]) -> List_Iterator[T] {
    return make List_Iterator[T](current_item = null, next_item = list.first_item)
}

define current = func [T] (self: List_Iterator[T]) -> T {
    if (self.current_item != null) {
        return self.current_item.data
    }
    return null
}

define remove_current = func [T] (self: List_Iterator[T]) -> Nothing {
    self.current_item.is_removed = true
}

define has_next = func [T] (self: List_Iterator[T]) -> bool {
    return self.next_item != null
}

define next = func [T] (self: List_Iterator[T]) -> T {
    if (self.next_item == null) {
        return null
    }
    self.current_item = self.next_item
    self.next_item = self.next_item.next_item
    return self.current_item.data
}

define change = func [T] (self: List_Iterator[T], data: T) -> Nothing {
    if (self.current_item != null) {
        self.current_item.data = data
    }
}

define for_each_list_item = macro [T] (self: List[T], block: macro (list_item: List_Item[T])) {
    let item = self.first_item
    while (item != null) {
        block(item)
        item = item.next_item
    }
}
