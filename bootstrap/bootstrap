#!/usr/bin/env python3

import os
import re
import subprocess
import sys
from collections import OrderedDict

BUILD_DIR = 'build'
BIN_FILE = os.path.join(BUILD_DIR, 'bootstrap')


def execute(command):
    print(command)
    return_code = subprocess.call(command.split(' '))
    if return_code != 0:
        exit(return_code)


def clean():
    execute(f"""rm -fr {BUILD_DIR}""")


def build():
    if not os.path.exists(BUILD_DIR):
        execute(f"""mkdir {BUILD_DIR}""")

    obj_files = []
    obj_files_changed = False

    loaded_includes = {}
    include_re = re.compile(r'#include\s+"\s*([^"]+)\s*"')

    def load_includes(source_file):
        source_file_includes = set()
        with open(source_file, 'r') as source_file_text:
            for source_line in source_file_text.readlines():
                match = include_re.search(source_line)
                if match:
                    source_file_include = match.group(1)
                    if not os.path.exists(source_file_include):
                        print(f"""File "{source_file}" includes non-existing file: {source_file_include}""")
                        exit(1)
                    if source_file_include not in source_file_includes:
                        source_file_includes.add(source_file_include)
                        if source_file_include not in loaded_includes:
                            loaded_includes[source_file_include] = set()  # avoids recursive loads
                            loaded_includes[source_file_include] = load_includes(source_file_include)
                        source_file_includes.update(loaded_includes[source_file_include])
        return source_file_includes

    cpp_files = [file for file in os.listdir('.') if file[0] != '.' and file.endswith('.cpp')]
    cpp_files.sort()
    for cpp_file in cpp_files:
        obj_file = os.path.join(BUILD_DIR, cpp_file.replace('.cpp', '.o'))
        obj_files.append(obj_file)

        if os.path.exists(obj_file):
            obj_file_timestamp = os.path.getmtime(obj_file)

            obj_file_dependencies = set()
            obj_file_dependencies.add(cpp_file)
            obj_file_dependencies.update(load_includes(cpp_file))

            compile_file = False
            for obj_file_dependency in obj_file_dependencies:
                if os.path.getmtime(obj_file_dependency) > obj_file_timestamp:
                    compile_file = True
                    break
        else:
            compile_file = True

        if compile_file:
            execute(f"""g++ -c -o {obj_file} {cpp_file}""")
            obj_files_changed = True

    if obj_files_changed or not os.path.exists(BIN_FILE):
        execute(f"""g++ -o {BIN_FILE} {' '.join(obj_files)}""")


def run():
    build()

    execute(f"""./{BIN_FILE}""")


TASKS = OrderedDict(
    clean=clean,
    build=build,
    run=run,
)

if len(sys.argv) > 1:
    for task_name in sys.argv[1:]:
        if task_name in TASKS:
            TASKS[task_name]()
        else:
            print(f"Unrecognized task: {task_name}")
else:
    print(f"Usage: {sys.argv[0]} [ {' | '.join(TASKS.keys())} ]+ ")
