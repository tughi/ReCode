\ Copyright (c) 2020, Stefan Selariu

define build = func (compilation_unit: Compilation_Unit) -> IR_Build {
    let builder = create_ir_builder(compilation_unit)
    builder.build()
    return new IR_Build(
        sources = compilation_unit.sources
        named_functions = builder.named_functions
        named_types = builder.types
        global_variables = builder.context.variables
    )
}

define IR_Build = struct {
    sources: List
    named_functions: List
    named_types: List
    global_variables: List
}

define dump = func (build: IR_Build, file: FILE) -> Nothing {
    let functions = build.named_functions.create_iterator()
    while (functions.has_next()) {
        let function = functions.next() as IR_Function
        if (function.is_external == false) {
            function.dump(file)
            file.end_line()
        }
    }
}

define IR_Builder = struct {
    context: IR_Builder_Context
    compilation_unit: Compilation_Unit
    types: List
    named_functions: List = new List()
    current_block: IR_Block = null
    current_loop: IR_Loop = null
    counter: Counter = new Counter()
}

define IR_Builder_Context = struct {
    parent: IR_Builder_Context
    variables: List = new List()
    named_values: List = new List()
}

define IR_Loop = struct {
    parent: IR_Loop
    end_block: IR_Block
}

define create_ir_builder = func (compilation_unit: Compilation_Unit) -> IR_Builder {
    let types = new List()
    types.append(new IR_Any_Type(name = "Any"))
    types.append(new IR_Boolean_Type(name = "bool"))
    types.append(new IR_Int_Type(name = "isize"))
    types.append(new IR_Int8_Type(name = "i8"))
    types.append(new IR_Int16_Type(name = "i16"))
    types.append(new IR_Int32_Type(name = "i32"))
    types.append(new IR_Int64_Type(name = "i64"))
    types.append(new IR_Nothing_Type(name = "Nothing"))
    types.append(new IR_Null_Type(name = "Null"))
    types.append(new IR_Undefined_Type(name = "Undefined"))
    return new IR_Builder(
        context = new IR_Builder_Context(parent = null)
        compilation_unit = compilation_unit
        types = types
    )
}

define get_named_type = func (self: IR_Builder, name: String) -> IR_Type {
    let types_item = self.types.first_item
    while (types_item != null) {
        let type = types_item.data as IR_Type
        if (name.equals(type.name)) {
            return type
        }
        types_item = types_item.next_item
    }
    return null
}

define get_struct_statement = func (self: IR_Builder, name: String) -> AST_Struct_Statement {
    let type_statements_item = self.compilation_unit.types.first_item
    while (type_statements_item != null) {
        let type_statement = type_statements_item.data as AST_Statement
        if (type_statement.is(AST_Struct_Statement)) {
            let type_statement = type_statement as AST_Struct_Statement
            if (type_statement.name.lexeme.equals(name)) {
                return type_statement as AST_Struct_Statement
            }
        }
        type_statements_item = type_statements_item.next_item
    }
    return null
}

define add_variable = func (self: IR_Builder, variable: IR_Variable) -> IR_Variable {
    self.context.variables.prepend(variable)
    return variable
}

define get_variable = func (self: IR_Builder, name: String) -> IR_Variable {
    let context = self.context
    loop {
        let variables = context.variables.create_iterator()
        while (variables.has_next()) {
            let variable = variables.next() as IR_Variable
            if (name.equals(variable.name)) {
                return variable
            }
        }
        context = context.parent
        if (context == null) {
            return null
        }
    }
}

define get_variable_value = func (self: IR_Builder, variable: IR_Variable) -> IR_Value {
    if (variable.is(IR_Global_Variable)) {
        return new IR_Global_Variable_Value(type = variable.type, variable = variable)
    }
    let current_block_instruction = self.current_block.last_instruction
    while (current_block_instruction != null) {
        if (current_block_instruction.result_value != null && current_block_instruction.result_value.variable == variable) {
            return current_block_instruction.result_value
        }
        current_block_instruction = current_block_instruction.prev_instruction
    }
    let instruction = self.current_block.prepend(create_ir_phi_instruction(self.create_variable_value(variable)))
    return instruction.result_value
}

define create_variable_value = func (self: IR_Builder, variable: IR_Variable) -> IR_Variable_Value {
    return new IR_Variable_Value(type = variable.type, variable = undefined, version = undefined).init(variable)
}

define get_named_function = func (self: IR_Builder, name: Identifier_Token, argument_types: List) -> IR_Function {
    let function = self.get_named_function(name.lexeme, argument_types)
    if (function == null) {
        let message = clone("Undefined function: ").append(name.lexeme).append(" :: (")
        let argument_types = argument_types.create_iterator()
        while (argument_types.has_next()) {
            let argument_type = argument_types.next() as IR_Type
            message.append(argument_type.name)
            if (argument_types.has_next()) {
                message.append(", ")
            }
        }
        message.append(")")
        abort(name.location, message)
    }
    return function
}

define get_named_function = func (self: IR_Builder, name: String, argument_types: List) -> IR_Function {
    let function: IR_Function = null
    let named_functions = self.named_functions.create_iterator()
    while (named_functions.has_next()) {
        let named_function = named_functions.next() as IR_Function
        if (name.equals(named_function.name)) {
            let is_match = true
            let argument_types = argument_types.create_iterator()
            let named_function_parameters = named_function.parameters.create_iterator()
            while (argument_types.has_next() && named_function_parameters.has_next()) {
                let argument_type = argument_types.next() as IR_Type
                let named_function_parameter = named_function_parameters.next() as IR_Function_Parameter
                if (named_function_parameter.type.accepts(argument_type) == false) {
                    is_match = false
                    break
                }
            }
            if (is_match && argument_types.has_next() == false && named_function_parameters.has_next() == false) {
                if (function != null) {
                    abort(name)
                }
                function = named_function
            }
        }
    }
    return function
}

define get_named_function = func (self: IR_Builder, name: String, function_type: IR_Function_Type) -> IR_Function {
    let function: IR_Function = null
    let named_functions = self.named_functions.create_iterator()
    while (named_functions.has_next()) {
        let named_function = named_functions.next() as IR_Function
        if (name.equals(named_function.name) && named_function.return_type == function_type.return_type && named_function.parameters.size == function_type.parameters.size) {
            let is_match = true
            let function_type_parameters = function_type.parameters.create_iterator()
            let named_function_parameters = named_function.parameters.create_iterator()
            while (function_type_parameters.has_next() && named_function_parameters.has_next()) {
                let function_type_parameter = function_type_parameters.next() as IR_Function_Type_Parameter
                let named_function_parameter = named_function_parameters.next() as IR_Function_Parameter
                if (named_function_parameter.type != function_type_parameter.type) {
                    is_match = false
                    break
                }
            }
            if (is_match && function_type_parameters.has_next() == false && named_function_parameters.has_next() == false) {
                if (function != null) {
                    abort(name)
                }
                function = named_function
            }
        }
    }
    return function
}

define accepts = func (self: IR_Type, other: IR_Type) -> bool {
    if (self == other || other.is(IR_Undefined_Type)) {
        return true
    }
    if (self.is(IR_Pointer_Type)) {
        let self = self as IR_Pointer_Type
        if (self.pointed_type.is(IR_Pointer_Type)) {
            let stop = true
        }
        if (other.is(IR_Pointer_Type)) {
            let other = other as IR_Pointer_Type
            if (self.pointed_type == other.pointed_type) {
                return true
            }
            if (self.pointed_type.is(IR_Any_Type)) {
                return true
            }
            if (self.pointed_type.is(IR_Struct_Type) && other.pointed_type.is(IR_Struct_Type)) {
                return (self.pointed_type as IR_Struct_Type).is_base_type(other.pointed_type as IR_Struct_Type)
            }
            return self.pointed_type.accepts(other.pointed_type)
        }
        if (other.is(IR_Null_Type)) {
            return true
        }
        return false
    }
    if (self.is(IR_Function_Type)) {
        if (other.is(IR_Null_Type)) {
            return true
        }
        if (other.is(IR_Function_Type)) {
            let self = self as IR_Function_Type
            let other = other as IR_Function_Type
            let self_parameters_item = self.parameters.first_item
            let other_parameters_item = other.parameters.first_item
            while (self_parameters_item != null && other_parameters_item != null) {
                let self_parameter = self_parameters_item.data as IR_Function_Type_Parameter
                let other_parameter = other_parameters_item.data as IR_Function_Type_Parameter
                if (self_parameter.type.accepts(other_parameter.type) == false) {
                    return false
                }
                self_parameters_item = self_parameters_item.next_item
                other_parameters_item = other_parameters_item.next_item
            }
            if (self_parameters_item != null || other_parameters_item != null) {
                return false
            }
            return self.return_type.accepts(other.return_type)
        }
    }
    return false
}

define create_temp_variable = func (self: IR_Builder, type: IR_Type) -> IR_Variable {
    return new IR_Variable(location = null, name = clone("$").append(self.counter.next()), type = type)
}

define create_temp_value = func (self: IR_Builder, type: IR_Type) -> IR_Variable_Value {
    return self.create_variable_value(self.create_temp_variable(type))
}

define append = func (self: IR_Builder, instruction: IR_Instruction, location: Source_Location) -> IR_Variable_Value {
    instruction.location = location
    self.current_block.append(instruction)
    return instruction.result_value
}

define build = func (self: IR_Builder) -> Nothing {
    let types = self.compilation_unit.types.create_iterator()
    while (types.has_next()) {
        let statement = types.next() as AST_Statement
        self.convert_type_statement(statement)
    }

    let global_variables = self.compilation_unit.global_variables.create_iterator()
    while (global_variables.has_next()) {
        let variable_statement = global_variables.next() as AST_Variable_Statement
        self.convert_variable_statement(variable_statement, true)
    }

    let functions = self.compilation_unit.functions.create_iterator()
    while (functions.has_next()) {
        let function_statement = functions.next() as AST_Function_Statement
        self.create_function(function_statement)
    }

    let functions = self.compilation_unit.functions.create_iterator()
    while (functions.has_next()) {
        let function_statement = functions.next() as AST_Function_Statement
        self.build_function(function_statement)
    }
}

define convert_type_statement = func (self: IR_Builder, statement: AST_Statement) -> IR_Type {
    if (statement.is(AST_Struct_Statement)) {
        return self.convert_struct_statement(statement as AST_Struct_Statement)
    }
    abort(statement.location, statement.object_type)
}

define convert_struct_statement = func (self: IR_Builder, struct_statement: AST_Struct_Statement) -> IR_Struct_Type {
    let struct_name = struct_statement.name.lexeme

    let type = self.get_named_type(struct_name)
    if (type != null) {
        if (type.is(IR_Struct_Type)) {
            let type = type as IR_Struct_Type
            if (type.statement == struct_statement) {
                return type
            }
        }
        abort(struct_statement.location, clone("Duplicate type declaration: ").append(struct_name))
    }

    let type = new IR_Struct_Type(
        name = struct_name
        statement = struct_statement
    )
    self.types.append(type)

    if (struct_statement.base_type != null) {
        let base_type = struct_statement.base_type
        if (base_type.is(AST_Named_Type) == false) {
            abort(struct_statement.base_type.location, "Cannot be used as base type.")
        }
        let base_type_name = (base_type as AST_Named_Type).name.lexeme
        let base_struct_statement = self.get_struct_statement(base_type_name)
        if (base_struct_statement == null) {
            abort(struct_statement.base_type.location, "Not a struct type.")
        }
        type.base_type = self.convert_struct_statement(base_struct_statement)
    }

    if (struct_statement.members != null) {
        let struct_members = struct_statement.members.create_iterator()
        while (struct_members.has_next()) {
            let struct_member = struct_members.next() as AST_Struct_Member
            let struct_member_name = struct_member.name.lexeme
            let struct_member_type = self.convert_type(struct_member.type)
            type.add_member(struct_member_name, struct_member_type)
        }
    }

    if (type.is_object_type()) {
        self.convert_variable_statement(
            new AST_Variable_Statement(
                location = struct_statement.name.location
                name = struct_statement.name
                type = new AST_Named_Type(
                    name = new Identifier_Token(lexeme = "Object_Type", location = null)
                )
                is_external = true
            )
            true
        )
    }

    return type
}

define convert_type = func (self: IR_Builder, type: AST_Type) -> IR_Type {
    if (type.is(AST_Array_Type)) {
        return self.convert_array_type(type as AST_Array_Type)
    }
    if (type.is(AST_Function_Type)) {
        return self.convert_function_type(type as AST_Function_Type)
    }
    if (type.is(AST_Named_Type)) {
        return self.convert_named_type(type as AST_Named_Type)
    }
    if (type.is(AST_Embedded_Type)) {
        return self.convert_embedded_type(type as AST_Embedded_Type)
    }
    abort(type.location, type.object_type)
}

define convert_array_type = func (self: IR_Builder, type: AST_Array_Type) -> IR_Type {
    if (type.is_checked) {
        abort(type.location, "Checked array types are not supported yet")
    }
    let item_type = self.convert_type(type.item_type)
    return self.create_ir_unchecked_array_type(item_type)
}

define create_ir_unchecked_array_type = func (self: IR_Builder, item_type: IR_Type) -> IR_Unchecked_Array_Type {
    let types_item = self.types.first_item
    while (types_item != null) {
        let type = types_item.data as IR_Type
        if (type.is(IR_Unchecked_Array_Type)) {
            let type = type as IR_Unchecked_Array_Type
            if (type.item_type == item_type) {
                return type
            }
        }
        types_item = types_item.next_item
    }

    let array_type = new IR_Unchecked_Array_Type(
        name = clone("[").append(item_type.name).append("; ?").append("]")
        item_type = item_type
    )

    self.types.append(array_type)

    return array_type
}

define convert_embedded_type = func (self: IR_Builder, type: AST_Embedded_Type) -> IR_Type {
    if (type.embedded_type.is(AST_Named_Type) == false) {
        abort(type.location, "Unsupported type")
    }
    let embedded_type_name = (type.embedded_type as AST_Named_Type).name.lexeme
    let embedded_type = self.get_named_type(embedded_type_name)
    if (embedded_type == null) {
        let struct_statement = self.get_struct_statement(embedded_type_name)
        if (struct_statement != null) {
            embedded_type = self.convert_struct_statement(struct_statement)
        }
    }
    if (embedded_type == null) {
        abort(type.location, "Unsupported type")
    }
    return embedded_type
}

define convert_function_type = func (self: IR_Builder, type: AST_Function_Type) -> IR_Type {
    let parameters = new List()
    let function_parameters_item = type.parameters.first_item
    while (function_parameters_item != null) {
        let function_parameter = function_parameters_item.data as AST_Function_Parameter
        parameters.append(new IR_Function_Type_Parameter(name = function_parameter.name.lexeme, type = self.convert_type(function_parameter.type)))
        function_parameters_item = function_parameters_item.next_item
    }
    return create_ir_function_type(parameters, self.convert_type(type.return_type))
}

define convert_named_type = func (self: IR_Builder, type: AST_Named_Type) -> IR_Type {
    let type_name = type.name.lexeme
    let named_type = self.get_named_type(type_name)
    if (named_type == null) {
        let struct_statement = self.get_struct_statement(type_name)
        if (struct_statement != null) {
            named_type = self.convert_struct_statement(struct_statement)
        } else {
            abort(type.name.location, clone("Unknown type: ").append(type_name))
        }
    }
    if (named_type.is(IR_Struct_Type) || named_type.is(IR_Any_Type)) {
        named_type = self.create_ir_pointer_type(named_type)
    }
    return named_type
}

define create_ir_pointer_type = func (self: IR_Builder, pointed_type: IR_Type) -> IR_Pointer_Type {
    if (pointed_type == null) {
        abort("Invalid state")
    }

    let types_item = self.types.first_item
    while (types_item != null) {
        let type = types_item.data as IR_Type
        if (type.is(IR_Pointer_Type)) {
            let type = type as IR_Pointer_Type
            if (type.pointed_type == pointed_type) {
                return type
            }
        }
        types_item = types_item.next_item
    }

    let pointer_type = new IR_Pointer_Type(
        name = clone("@").append(pointed_type.name)
        pointed_type = pointed_type
    )

    self.types.append(pointer_type)

    return pointer_type
}

define create_function = func (self: IR_Builder, function_statement: AST_Function_Statement) -> IR_Function {
    let function = new IR_Function(
        id = self.named_functions.size + 1
        location = function_statement.location
        blocks = new List()
        name = function_statement.name.lexeme
        parameters = new List()
        return_type = self.convert_type(function_statement.type.return_type)
        is_external = function_statement.body == null
        type = undefined
    )

    let parameters = function_statement.type.parameters.create_iterator()
    let function_type_parameters = new List()
    while (parameters.has_next()) {
        let parameter = parameters.next() as AST_Function_Parameter
        let parameter_type = self.convert_type(parameter.type)
        let parameter_name = parameter.name.lexeme
        let function_parameter = new IR_Function_Parameter(location = parameter.location, name = parameter_name, type = parameter_type)
        function.parameters.append(function_parameter)
        function_type_parameters.append(new IR_Function_Type_Parameter(name = parameter_name, type = parameter_type))
    }

    function_statement.ir_function = function
    self.named_functions.append(function)

    function.type = create_ir_function_type(function_type_parameters, function.return_type)

    return function
}

define build_function = func (self: IR_Builder, function_statement: AST_Function_Statement) -> Nothing {
    if (function_statement.body == null) {
        return
    }

    let function = function_statement.ir_function

    self.context = new IR_Builder_Context(parent = self.context)
    self.counter.reset()

    self.current_block = function.create_block()

    let function_parameters = function.parameters.create_iterator()
    while (function_parameters.has_next()) {
        let function_parameter = function_parameters.next() as IR_Function_Parameter
        self.add_variable(function_parameter)
        self.current_block.append(create_ir_load_variable_instruction(self.create_variable_value(function_parameter)))
    }

    self.convert_block_statement(function_statement.body)
    if (self.current_block.last_instruction == null || self.current_block.last_instruction.is_exit_instruction() == false) {
        if (self.current_block.predecessors.size == 0 as i64 && self.current_block.id != 1 as i64) {
            \ this block is unreachable
            function.blocks.remove(self.current_block).prune()
        } else if (function.return_type.is(IR_Nothing_Type)) {
            self.append(create_ir_return_instruction(null), null)
        } else {
            abort(function_statement.location, "Missing return statement")
        }
    }
    self.current_block = null

    self.remove_redundant_blocks(function)
    self.populate_phi_instructions(function)
    self.remove_trivial_phi_instructions(function)
    self.remove_redundant_set_instructions(function)

    self.context = self.context.parent
}

define remove_redundant_blocks = func (self: IR_Builder, function: IR_Function) -> Nothing {
    loop {
        let repeat = false

        let blocks = function.blocks.prune().create_iterator()

        while (blocks.has_next()) {
            let block = blocks.next() as IR_Block
            if (block.id != 1 as i64) {
                if (block.predecessors.size == 0 as i64) {
                    \ found unreachable block
                    if (block.last_instruction == null) {
                        blocks.remove_current()
                    } else if (block.last_instruction == block.first_instruction && block.last_instruction.is(IR_Direct_Jump_Instruction)) {
                        let block_instruction = block.last_instruction as IR_Direct_Jump_Instruction
                        block_instruction.block.predecessors.remove(block)
                        block_instruction.block.predecessors.prune()
                        blocks.remove_current()
                        repeat = true
                        break
                    } else {
                        abort(function.location, clone("Found non-empty unreachable block: block.").append(block.id))
                    }
                }
                if (block.first_instruction == block.last_instruction && block.first_instruction.is(IR_Direct_Jump_Instruction)) {
                    \ found jump block
                    let block_predecessor = block.predecessors.last() as IR_Block
                    let block_successor = (block.first_instruction as IR_Direct_Jump_Instruction).block
                    if (block_predecessor.last_instruction.is(IR_Conditional_Jump_Instruction)) {
                        block.predecessors.remove(block_predecessor).prune()
                        let block_predecessor_instruction = block_predecessor.last_instruction as IR_Conditional_Jump_Instruction
                        if (block_predecessor_instruction.false_block == block) {
                            block_predecessor_instruction.false_block = block_successor
                        } else {
                            block_predecessor_instruction.true_block = block_successor
                        }
                        block_successor.predecessors.remove(block).prune().append(block_predecessor)
                        repeat = true
                        break
                    }
                    if (block_predecessor.last_instruction.is(IR_Direct_Jump_Instruction)) {
                        block.predecessors.remove(block_predecessor).prune()
                        let block_predecessor_instruction = block_predecessor.last_instruction as IR_Direct_Jump_Instruction
                        block_predecessor_instruction.block = block_successor
                        block_successor.predecessors.remove(block).prune().append(block_predecessor)
                        repeat = true
                        break
                    }
                }
            }
        }

        if (repeat == false) {
            break
        }
    }
}

define populate_phi_instructions = func (self: IR_Builder, function: IR_Function) -> Nothing {
    let blocks = function.blocks.create_iterator()
    while (blocks.has_next()) {
        let block = blocks.next() as IR_Block
        let block_instruction = block.first_instruction
        while (block_instruction != null && block_instruction.is(IR_Phi_Instruction)) {
            let instruction = block_instruction as IR_Phi_Instruction
            if (instruction.operand_values.first_entry == null) {
                let block_predecessors = block.predecessors.create_iterator()
                while (block_predecessors.has_next()) {
                    let block_predecessor = block_predecessors.next() as IR_Block
                    instruction.append(self.get_block_variable_value(block_predecessor, instruction.result_value.variable))
                }
            }
            block_instruction = block_instruction.next_instruction
        }
    }
}

define get_block_variable_value = func (self: IR_Builder, block: IR_Block, variable: IR_Variable) -> IR_Value {
    let block_instruction = block.last_instruction
    while (block_instruction != null) {
        if (block_instruction.result_value != null && block_instruction.result_value.variable == variable) {
            return block_instruction.result_value
        }
        block_instruction = block_instruction.prev_instruction
    }
    if (block.predecessors.size == 1 as i64) {
        return self.get_block_variable_value(block.predecessors.last() as IR_Block, variable)
    }
    let instruction = create_ir_phi_instruction(self.create_variable_value(variable))
    block.prepend(instruction)
    let block_predecessors = block.predecessors.create_iterator()
    while (block_predecessors.has_next()) {
        let block_predecessor = block_predecessors.next() as IR_Block
        instruction.append(self.get_block_variable_value(block_predecessor, variable))
    }
    return instruction.result_value
}

define remove_trivial_phi_instructions = func (self: IR_Builder, function: IR_Function) -> Nothing {
    loop {
        let repeat = false

        let blocks = function.blocks.prune().create_iterator()

        \ skip entry block
        blocks.next()

        while (blocks.has_next()) {
            let block = blocks.next() as IR_Block
            let block_instruction = block.first_instruction
            while (block_instruction != null && block_instruction.is(IR_Phi_Instruction)) {
                let instruction = block_instruction as IR_Phi_Instruction
                let instruction_is_redundant = instruction.is_redundant()
                if (instruction_is_redundant == false && instruction.is_trivial()) {
                    \ found a trivial phi instruction
                    instruction.operand_values.remove_values(instruction.result_value)
                    instruction_is_redundant = true
                }
                if (instruction_is_redundant) {
                    \ found redundant phi instruction
                    let old_value = instruction.result_value
                    let new_value = instruction.operand_values.first_entry.value
                    let user_instructions = old_value.user_instructions.create_iterator()
                    while (user_instructions.has_next()) {
                        let user_instruction = user_instructions.next() as IR_Instruction
                        user_instruction.replace_operand_value(old_value, new_value)
                    }
                    new_value.user_instructions.remove_all(instruction).prune()
                    let old_value_links_item = old_value.links.first_item
                    while (old_value_links_item != null) {
                        let old_value_link = old_value_links_item.data as IR_Link
                        if (old_value_link.is(IR_Required_By_Value_Link)) {
                            let old_value_link = old_value_link as IR_Required_By_Value_Link
                            old_value_link.back_link.value = new_value
                            new_value.links.append(old_value_link)
                        }
                        old_value_links_item = old_value_links_item.next_item
                    }
                    block.remove(instruction)
                    repeat = true
                }
                block_instruction = block_instruction.next_instruction
            }
        }

        if (repeat == false) {
            break
        }
    }
}

define remove_redundant_set_instructions = func (self: IR_Builder, function: IR_Function) -> Nothing {
    loop {
        let repeat = false

        let blocks = function.blocks.prune().create_iterator()
        while (blocks.has_next()) {
            let block = blocks.next() as IR_Block

            let block_instruction = block.first_instruction
            while (block_instruction != null) {
                if (block_instruction.is(IR_Set_Instruction)) {
                    let value = (block_instruction as IR_Set_Instruction).get_value()
                    if (value.is(IR_Undefined_Value) && block_instruction.result_value.user_instructions.size == 0 as i64) {
                        block.remove(block_instruction)
                        repeat = true
                        break
                    }
                    if (value.user_instructions.size == 1 as i64 && value.user_instructions.first_item.data as IR_Instruction == block_instruction) {
                        let value_creator_instruction = value.creator_instruction
                        if (value_creator_instruction != null && value_creator_instruction.parent_block == block) {
                            let redundant_value = value_creator_instruction.result_value
                            let replacement_value: IR_Value = block_instruction.result_value
                            let redundant_value_links_item = redundant_value.links.first_item
                            while (redundant_value_links_item != null) {
                                let redundant_value_link = redundant_value_links_item.data as IR_Link
                                if (redundant_value_link.is(IR_Requires_Value_Link)) {
                                    let redundant_value_link = redundant_value_link as IR_Requires_Value_Link
                                    redundant_value_link.back_link.value = replacement_value
                                    replacement_value.links.append(redundant_value_link)
                                }
                                redundant_value_links_item = redundant_value_links_item.next_item
                            }
                            value_creator_instruction.result_value = block_instruction.result_value
                            value_creator_instruction.result_value.creator_instruction = value_creator_instruction
                            block.remove(block_instruction)
                            repeat = true
                            break
                        }
                    }
                }
                block_instruction = block_instruction.next_instruction
            }
        }

        if (repeat == false) {
            break
        }
    }
}

define convert_statement = func (self: IR_Builder, statement: AST_Statement) -> Nothing {
    if (self.current_block == null) {
        abort(statement.location, clone(statement.object_type.name).append(" requires a basic block."))
    }
    statement.convert(self)
}

define convert_assignment_statement = func (self: IR_Builder, assignment_statement: AST_Assignment_Statement) -> Nothing {
    if (assignment_statement.storage_expression.is(AST_Array_Access_Expression)) {
        let array_access_expression = assignment_statement.storage_expression as AST_Array_Access_Expression
        let array_item_index_value = self.convert_expression(array_access_expression.index_expression, self.get_named_type("isize"))
        let array_address = self.convert_expression_address(array_access_expression.array_expression)
        if (array_address.type.is(IR_Unchecked_Array_Type)) {
            let array_item_type = (array_address.type as IR_Unchecked_Array_Type).item_type
            let value = self.convert_expression(assignment_statement.value_expression, array_item_type)
            self.append(create_ir_store_array_item_instruction(array_address, array_item_index_value, value), assignment_statement.location)
        } else {
            abort(assignment_statement.location, clone("Not an array value"))
        }
    } else if (assignment_statement.storage_expression.is(AST_Member_Access_Expression)) {
        let member_access_expression = assignment_statement.storage_expression as AST_Member_Access_Expression
        let object_address_value = self.convert_expression_address(member_access_expression.object_expression)
        if (object_address_value.type.is(IR_Pointer_Type) == false) {
            abort(assignment_statement.location, clone("Not a pointer value"))
        }
        let object_type = (object_address_value.type as IR_Pointer_Type).pointed_type
        if (object_type.is(IR_Struct_Type) == false) {
            abort(assignment_statement.location, clone(object_type.name).append(" is not a struct type"))
        }
        let struct_type = (object_type as IR_Struct_Type)
        let struct_type_member = struct_type.get_member(member_access_expression.member_name.lexeme)
        if (struct_type_member == null) {
            struct_type.dump_struct_members()
            abort(member_access_expression.member_name.location, clone(object_type.name).append(" doesn't have a ").append(member_access_expression.member_name.lexeme).append(" member"))
        }
        let value = self.convert_expression(assignment_statement.value_expression, struct_type_member.type)
        self.append(create_ir_store_struct_member_instruction(object_address_value, struct_type_member, value), assignment_statement.location)
    } else if (assignment_statement.storage_expression.is(AST_Variable_Expression)) {
        let variable_expression = assignment_statement.storage_expression as AST_Variable_Expression
        let variable_name = variable_expression.name.lexeme
        let variable = self.get_variable(variable_name)
        if (variable == null) {
            abort(variable_expression.location, clone("Undeclared variable: ").append(variable_name))
        }
        let value = self.convert_expression(assignment_statement.value_expression, variable.type)
        self.append(create_ir_set_instruction(self.create_variable_value(variable), value), assignment_statement.location)
    } else {
        abort(assignment_statement.location, assignment_statement.storage_expression.object_type)
    }
}

define convert_block_statement = func (self: IR_Builder, statement: AST_Block_Statement) -> Nothing {
    self.context = new IR_Builder_Context(parent = self.context, named_values = self.context.named_values)
    let block_statements = statement.statements.create_iterator()
    while (block_statements.has_next()) {
        let block_statement = block_statements.next() as AST_Statement
        self.convert_statement(block_statement)
    }
    self.context = self.context.parent
}

define convert_break_statement = func (self: IR_Builder, statement: AST_Break_Statement) -> Nothing {
    if (self.current_loop == null) {
        abort(statement.location, "Break outside of a loop?")
    }
    self.current_block.append_jump(self.current_loop.end_block)
    self.current_block = self.current_block.function.create_block()
}

define convert_expression_statement = func (self: IR_Builder, statement: AST_Expression_Statement, expected_type: IR_Type) -> Nothing {
    self.convert_expression(statement.expression, expected_type)
}

define convert_if_statement = func (self: IR_Builder, statement: AST_If_Statement) -> Nothing {
    let condition_value = self.convert_expression(statement.condition_expression, self.get_named_type("bool"))
    let true_block = self.current_block.function.create_block()
    let end_block = self.current_block.function.create_block()
    if (statement.false_statement != null) {
        let false_block = self.current_block.function.create_block()
        self.current_block.append_jump(condition_value, true_block, false_block)
        self.current_block = false_block
        self.convert_statement(statement.false_statement)
        if (self.current_block.last_instruction.is_exit_instruction() == false) {
            self.current_block.append_jump(end_block)
        }
    } else {
        self.current_block.append_jump(condition_value, true_block, end_block)
    }
    self.current_block = true_block
    self.convert_statement(statement.true_statement)
    if (self.current_block.last_instruction.is_exit_instruction() == false) {
        self.current_block.append_jump(end_block)
    }
    self.current_block = end_block
}

define convert_loop_statement = func (self: IR_Builder, statement: AST_Loop_Statement) -> Nothing {
    let loop_block = self.current_block.function.create_block()
    let end_block = self.current_block.function.create_block()
    self.current_block.append_jump(loop_block)
    self.current_block = loop_block
    self.current_loop = new IR_Loop(parent = self.current_loop, end_block = end_block)
    self.convert_block_statement(statement.block)
    self.current_block.append_jump(loop_block)
    self.current_block = end_block
    self.current_loop = self.current_loop.parent
}

define convert_return_statement = func (self: IR_Builder, statement: AST_Return_Statement) -> Nothing {
    if (statement.value_expression != null) {
        let return_value = self.convert_expression(statement.value_expression, self.current_block.function.return_type)
        self.append(create_ir_return_instruction(return_value), statement.location)
    } else {
        self.append(create_ir_return_instruction(null), statement.location)
    }
    self.current_block = self.current_block.function.create_block()
}

define convert_variable_statement = func (self: IR_Builder, variable_statement: AST_Variable_Statement, is_global: bool) -> Nothing {
    let variable_name = variable_statement.name.lexeme
    let variable_type: IR_Type = null
    if (variable_statement.type != null) {
        variable_type = self.convert_type(variable_statement.type)
    }
    let variable_value: IR_Value = null
    if (variable_statement.value_expression != null) {
        variable_value = self.convert_expression(variable_statement.value_expression, variable_type)
    }
    if (variable_statement.is_external == false) {
        if (variable_type != null) {
            if (variable_value != null) {
                if (variable_type.accepts(variable_value.type) == false) {
                    abort(variable_statement.value_expression.location, clone("Cannot assign a '").append(variable_value.type.name).append("' value to a '").append(variable_type.name).append("' variable"))
                }
                if (variable_type == variable_value.type) {
                    stderr.write(variable_statement.type.location).write(": Redundant type declaration").end_line()
                }
            }
        } else {
            if (variable_value == null) {
                abort(variable_statement.location, "Invalid state")
            }
            if (variable_value.type.is(IR_Null_Type)) {
                abort(variable_statement.value_expression.location, "Cannot infer type from null value")
            }
            variable_type = variable_value.type
        }
        if (variable_value == null) {
            variable_value = new IR_Undefined_Value(type = variable_type)
        }
    }
    if (variable_type.is(IR_Any_Type) || variable_type.is(IR_Nothing_Type) || variable_type.is(IR_Undefined_Type)) {
        abort(variable_statement.location, clone("Invalid variable type: ").append(variable_type.name))
    }
    if (is_global) {
        let variable = new IR_Global_Variable(
            location = variable_statement.location
            name = variable_name
            type = variable_type
            value = variable_value
            is_external = variable_statement.is_external
        )
        if (self.current_block != null) {
            abort(variable_statement.location, "Invalid state")
        }
        self.add_variable(variable)
    } else {
        let variable = new IR_Variable(location = variable_statement.location, name = variable_name, type = variable_type)
        self.add_variable(variable)
        self.append(create_ir_set_instruction(self.create_variable_value(variable), variable_value), variable_statement.location)
    }
}

define convert_while_statement = func (self: IR_Builder, statement: AST_While_Statement) -> Nothing {
    let condition_block = self.current_block.function.create_block()
    let loop_block = self.current_block.function.create_block()
    let end_block = self.current_block.function.create_block()
    self.current_block.append_jump(condition_block)
    self.current_block = condition_block
    let condition_value = self.convert_expression(statement.condition_expression, self.get_named_type("bool"))
    self.current_block.append_jump(condition_value, loop_block, end_block)
    self.current_block = loop_block
    self.current_loop = new IR_Loop(parent = self.current_loop, end_block = end_block)
    self.convert_block_statement(statement.block)
    self.current_block.append_jump(condition_block)
    self.current_block = end_block
    self.current_loop = self.current_loop.parent
}

define convert_expression = func (self: IR_Builder, expression: AST_Expression, expected_type: IR_Type) -> IR_Value {
    let value = expression.convert(self, expected_type)
    if (expected_type != null && expected_type.accepts(value.type) == false) {
        abort(expression.location, clone("Incompatible types: got ").append(value.type.name).append(" instead of ").append(expected_type.name))
    }
    return value
}

define convert_expression_address = func (self: IR_Builder, expression: AST_Expression) -> IR_Value {
    if (expression.is(AST_Member_Access_Expression)) {
        return self.convert_member_access_expression_address(expression as AST_Member_Access_Expression)
    }
    if (expression.is(AST_Variable_Expression)) {
        return self.convert_variable_expression_address(expression as AST_Variable_Expression)
    }
    abort(expression.location, expression.object_type)
}

define convert_add_expression = func (self: IR_Builder, expression: AST_Add_Expression) -> IR_Value {
    let left_value = self.convert_expression(expression.left_expression, null)
    if (left_value.type.is(IR_Integer_Type) == false) {
        abort(expression.left_expression.location, "Not an integer value")
    }
    let right_value = self.convert_expression(expression.right_expression, left_value.type)
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Add_Instruction(result_value = self.create_temp_value(left_value.type)).init(left_value, right_value), expression.location)
}

define convert_array_access_expression = func (self: IR_Builder, array_access_expression: AST_Array_Access_Expression) -> IR_Value {
    let index_value = self.convert_expression(array_access_expression.index_expression, self.get_named_type("isize"))
    let object_value = self.convert_expression(array_access_expression.array_expression, null)
    let object_value_type = object_value.type
    if ((object_value_type.is(IR_Unchecked_Array_Type))) {
        let object_value_type = object_value_type as IR_Unchecked_Array_Type
        return self.append(create_ir_load_array_item_instruction(self.create_temp_value(object_value_type.item_type), object_value, index_value), array_access_expression.location)
    }
    abort(array_access_expression.location, clone("Got ").append(object_value_type.name).append(" value instead of an array"))
}

define convert_call_expression = func (self: IR_Builder, call_expression: AST_Call_Expression) -> IR_Value {
    if (call_expression.callee_expression.is(AST_Atomic_Expression)) {
        let callee_value = self.convert_expression(call_expression.callee_expression, null)
        if (callee_value.type.is(IR_Function_Type) == false) {
            abort(call_expression.location, clone("Values of type ").append(callee_value.type.name).append(" are not callable"))
        }
        return self.convert_dynamic_call_expression(call_expression, callee_value, null)
    }
    if (call_expression.callee_expression.is(AST_Member_Access_Expression)) {
        let callee_expression = call_expression.callee_expression as AST_Member_Access_Expression
        let callee_value = self.convert_expression(callee_expression.object_expression, null)
        let callee_value_type = callee_value.type
        if (callee_value_type.is(IR_Pointer_Type)) {
            let callee_value_type = callee_value_type as IR_Pointer_Type
            if (callee_value_type.pointed_type.is(IR_Struct_Type)) {
                let struct_type_member = (callee_value_type.pointed_type as IR_Struct_Type).get_member(callee_expression.member_name.lexeme)
                if (struct_type_member != null && struct_type_member.type.is(IR_Function_Type)) {
                    let call_function_value = self.append(create_ir_load_struct_member_instruction(self.create_temp_value(struct_type_member.type), callee_value, struct_type_member, false), call_expression.location)
                    return self.convert_dynamic_call_expression(call_expression, call_function_value, callee_value)
                }
            }
        }
        return self.convert_direct_call_expression(call_expression, callee_expression.member_name, callee_value)
    }
    if (call_expression.callee_expression.is(AST_Variable_Expression)) {
        let callee_expression = call_expression.callee_expression as AST_Variable_Expression
        let variable = self.get_variable(callee_expression.name.lexeme)
        if (variable != null && variable.type.is(IR_Function_Type)) {
            let call_function_value = self.convert_expression(callee_expression, null)
            return self.convert_dynamic_call_expression(call_expression, call_function_value, null)
        }
        return self.convert_direct_call_expression(call_expression, callee_expression.name, null)
    }
    abort(call_expression.location, call_expression.callee_expression.object_type)
}

define convert_direct_call_expression = func (self: IR_Builder, call_expression: AST_Call_Expression, callee_name: Identifier_Token, first_argument: IR_Value) -> IR_Value {
    let type = self.get_named_type(callee_name.lexeme)
    if (type != null && type.is(IR_Struct_Type)) {
        if (first_argument != null) {
            abort(call_expression.location, "Invalid type literal syntax")
        }
        return self.convert_struct_literal_expression(call_expression, type as IR_Struct_Type)
    }

    let call_arguments = self.convert_call_arguments(call_expression.arguments)
    if (first_argument != null) {
        call_arguments.prepend(new IR_Call_Argument(value = first_argument))
    }

    let call_function: IR_Function = null
    let named_functions_item = self.named_functions.first_item
    while (named_functions_item != null) {
        let named_function = named_functions_item.data as IR_Function
        if (named_function.name.equals(callee_name.lexeme)) {
            if (named_function.type.accepts(call_arguments)) {
                if (call_function != null) {
                    abort(call_expression.location, "Found at least two matching functions")
                }
                call_function = named_function
            }
        }
        named_functions_item = named_functions_item.next_item
    }
    if (call_function == null) {
        let named_functions_item = self.named_functions.first_item
        while (named_functions_item != null) {
            let named_function = named_functions_item.data as IR_Function
            if (named_function.name.equals(callee_name.lexeme)) {
                stderr.end_line().write(named_function.location).write(": ").write(named_function.name).write(" = ").write(named_function.type.name).end_line()
            }
            named_functions_item = named_functions_item.next_item
        }
        let message = clone("Found no matching function: ").append(callee_name.lexeme).append(" = func (")
        let call_arguments_item = call_arguments.first_item
        if (call_arguments_item != null) {
            loop {
                let call_argument = call_arguments_item.data as IR_Call_Argument
                if (call_argument.name != null) {
                    message.append(call_argument.name).append(": ")
                }
                message.append(call_argument.value.type.name)
                call_arguments_item = call_arguments_item.next_item
                if (call_arguments_item == null) {
                    break
                }
                message.append(", ")
            }
        }
        message.append(") -> Any")
        abort(call_expression.location, message)
    }

    let result_value: IR_Variable_Value = null
    if (call_function.return_type.is(IR_Nothing_Type) == false) {
        result_value = self.create_temp_value(call_function.return_type)
    }
    return self.append(create_ir_direct_call_instruction(result_value, call_arguments, call_function), call_expression.location)
}

define convert_dynamic_call_expression = func (self: IR_Builder, call_expression: AST_Call_Expression, call_function: IR_Value, first_argument: IR_Value) -> IR_Value {
    let call_arguments = self.convert_call_arguments(call_expression.arguments)
    if (first_argument != null) {
        call_arguments.prepend(new IR_Call_Argument(value = first_argument))
    }
    let call_function_type = call_function.type as IR_Function_Type
    if (call_function_type.accepts(call_arguments) == false) {
        abort(call_expression.location, "Unsupported arguments")
    }
    let result_value: IR_Variable_Value = null
    if (call_function_type.return_type.is(IR_Nothing_Type) == false) {
        result_value = self.create_temp_value(call_function_type.return_type)
    }
    return self.append(create_ir_dynamic_call_instruction(result_value, call_arguments, call_function as IR_Variable_Value), call_expression.location)
}

define accepts = func (self: IR_Function_Type, call_arguments: List) -> bool {
    let call_arguments_item = call_arguments.first_item
    let function_parameters_item = self.parameters.first_item
    while (call_arguments_item != null && function_parameters_item != null && (function_parameters_item.data as IR_Function_Type_Parameter).type.accepts((call_arguments_item.data as IR_Call_Argument).value.type)) {
        call_arguments_item = call_arguments_item.next_item
        function_parameters_item = function_parameters_item.next_item
    }
    return call_arguments_item == null && function_parameters_item == null
}

define convert_call_arguments = func (self: IR_Builder, ast_call_arguments: List) -> List {
    let has_named_arguments = false
    let call_arguments = new List()
    let ast_call_arguments_item = ast_call_arguments.first_item
    while (ast_call_arguments_item != null) {
        let call_argument = ast_call_arguments_item.data as AST_Call_Argument
        let call_argument_value = self.convert_expression(call_argument.value_expression, null)
        if (call_argument.name != null) {
            call_arguments.append(new IR_Call_Argument(name = call_argument.name.lexeme, value = call_argument_value))
            has_named_arguments = true
        } else {
            if (has_named_arguments) {
                abort(call_argument.value_expression.location, "Positional arguments cannot be added after named ones")
            }
            call_arguments.append(new IR_Call_Argument(value = call_argument_value))
        }
        ast_call_arguments_item = ast_call_arguments_item.next_item
    }
    return call_arguments
}

define convert_cast_expression = func (self: IR_Builder, cast_expression: AST_Cast_Expression) -> IR_Value {
    let value = self.convert_expression(cast_expression.value_expression, null)
    let result_value = self.create_temp_value(self.convert_type(cast_expression.type))
    if (value.type.is(IR_Pointer_Type) && (result_value.type.is(IR_Pointer_Type) || result_value.type.is(IR_Unchecked_Array_Type))) {
        return self.append(create_ir_set_instruction(result_value, value), cast_expression.location)
    }
    if (value.type.is(IR_Integer_Type) && result_value.type.is(IR_Integer_Type)) {
        return self.append(create_ir_cast_instruction(result_value, value), cast_expression.location)
    }
    abort(cast_expression.location, clone("Cannot cast ").append(value.type.name).append(" to ").append(result_value.type.name))
}

define convert_divide_expression = func (self: IR_Builder, expression: AST_Divide_Expression) -> IR_Value {
    let left_value = self.convert_expression(expression.left_expression, null)
    if (left_value.type.is(IR_Integer_Type) == false) {
        abort(expression.left_expression.location, "Not an integer value")
    }
    let right_value = self.convert_expression(expression.right_expression, left_value.type)
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Divide_Instruction(result_value = self.create_temp_value(left_value.type)).init(left_value, right_value), expression.location)
}

define convert_equals_expression = func (self: IR_Builder, expression: AST_Equals_Expression) -> IR_Value {
    let left_value = self.convert_expression(expression.left_expression, null)
    let right_value = self.convert_expression(expression.right_expression, null)
    if (left_value.type != right_value.type && (left_value.type.is(IR_Pointer_Type) == false || right_value.type.is(IR_Null_Type) == false)) {
        abort(expression.location, "Operands are not the same type")
    }
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Equals_Comparison_Instruction(result_value = self.create_temp_value(self.get_named_type("bool"))).init(left_value, right_value), expression.location)
}

define convert_function_expression = func (self: IR_Builder, expression: AST_Function_Expression) -> IR_Value {
    let function: IR_Function = null
    let named_functions_item = self.named_functions.first_item
    while (named_functions_item != null) {
        let named_function = named_functions_item.data as IR_Function
        if (named_function.name == expression.function_statement.name.lexeme) {
            function = named_function
            break
        }
        named_functions_item = named_functions_item.next_item
    }
    if (function == null) {
        abort("Invalid state")
    }
    return new IR_Function_Address_Value(type = function.type, function = function)
}

define convert_greater_than_expression = func (self: IR_Builder, expression: AST_Greater_Than_Expression) -> IR_Value {
    let left_value = self.convert_expression(expression.left_expression, null)
    if (left_value.type.is(IR_Integer_Type) == false) {
        abort(expression.left_expression.location, "Not an integer value")
    }
    let right_value = self.convert_expression(expression.right_expression, left_value.type)
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Greater_Comparison_Instruction(result_value = self.create_temp_value(self.get_named_type("bool"))).init(left_value, right_value), expression.location)
}

define convert_greater_than_or_equals_expression = func (self: IR_Builder, expression: AST_Greater_Than_Or_Equals_Expression) -> IR_Value {
    let left_value = self.convert_expression(expression.left_expression, null)
    if (left_value.type.is(IR_Integer_Type) == false) {
        abort(expression.left_expression.location, "Not an integer value")
    }
    let right_value = self.convert_expression(expression.right_expression, left_value.type)
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Greater_Or_Equal_Comparison_Instruction(result_value = self.create_temp_value(self.get_named_type("bool"))).init(left_value, right_value), expression.location)
}

define convert_less_than_expression = func (self: IR_Builder, expression: AST_Less_Than_Expression) -> IR_Value {
    let left_value = self.convert_expression(expression.left_expression, null)
    if (left_value.type.is(IR_Integer_Type) == false) {
        abort(expression.left_expression.location, "Not an integer value")
    }
    let right_value = self.convert_expression(expression.right_expression, left_value.type)
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Less_Comparison_Instruction(result_value = self.create_temp_value(self.get_named_type("bool"))).init(left_value, right_value), expression.location)
}

define convert_less_than_or_equals_expression = func (self: IR_Builder, expression: AST_Less_Than_Or_Equals_Expression) -> IR_Value {
    let left_value = self.convert_expression(expression.left_expression, null)
    if (left_value.type.is(IR_Integer_Type) == false) {
        abort(expression.left_expression.location, "Not an integer value")
    }
    let right_value = self.convert_expression(expression.right_expression, left_value.type)
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Less_Or_Equal_Comparison_Instruction(result_value = self.create_temp_value(self.get_named_type("bool"))).init(left_value, right_value), expression.location)
}

define convert_literal_expression = func (self: IR_Builder, expression: AST_Literal_Expression, expected_type: IR_Type) -> IR_Value {
    if (expression.literal.is(Boolean_Token)) {
        return new IR_Constant_Value(type = self.get_named_type("bool"), literal = expression.literal)
    }
    if (expression.literal.is(Character_Token)) {
        return new IR_Constant_Value(type = self.get_named_type("i8"), literal = expression.literal)
    }
    if (expression.literal.is(Integer_Token)) {
        if (expected_type == null || expected_type.is(IR_Integer_Type) == false) {
            expected_type = self.get_named_type("isize")
        }
        return new IR_Constant_Value(type = expected_type, literal = expression.literal)
    }
    if (expression.literal.is(Null_Token)) {
        return new IR_Constant_Value(type = self.get_named_type("Null"), literal = expression.literal)
    }
    if (expression.literal.is(String_Token)) {
        return new IR_Constant_Value(type = self.create_ir_pointer_type(self.get_named_type("String")), literal = expression.literal)
    }
    if (expression.literal.is(Undefined_Token)) {
        return new IR_Undefined_Value(type = self.get_named_type("Undefined"))
    }
    abort(expression.location, expression.literal.object_type)
}

define convert_logic_and_expression = func (self: IR_Builder, expression: AST_Logic_And_Expression) -> IR_Value {
    let next_block = self.current_block.function.create_block()
    let end_block = self.current_block.function.create_block()
    let left_value = self.convert_expression(expression.left_expression, self.get_named_type("bool"))
    let result_variable = self.create_temp_variable(self.get_named_type("bool"))
    let result_value_left = self.create_variable_value(result_variable)
    self.append(create_ir_set_instruction(result_value_left, left_value), expression.location)
    self.current_block.append_jump(result_value_left, next_block, end_block)
    self.current_block = next_block
    let right_value = self.convert_expression(expression.right_expression, self.get_named_type("bool"))
    self.append(create_ir_set_instruction(self.create_variable_value(result_variable), right_value), expression.location)
    self.current_block.append_jump(end_block)
    self.current_block = end_block
    return self.append(create_ir_phi_instruction(self.create_variable_value(result_variable)), expression.location)
}

define convert_logic_or_expression = func (self: IR_Builder, expression: AST_Logic_Or_Expression) -> IR_Value {
    let next_block = self.current_block.function.create_block()
    let end_block = self.current_block.function.create_block()
    let left_value = self.convert_expression(expression.left_expression, self.get_named_type("bool"))
    let result_variable = self.create_temp_variable(self.get_named_type("bool"))
    let result_value_left = self.create_variable_value(result_variable)
    self.append(create_ir_set_instruction(result_value_left, left_value), expression.location)
    self.current_block.append_jump(result_value_left, end_block, next_block)
    self.current_block = next_block
    let right_value = self.convert_expression(expression.right_expression, self.get_named_type("bool"))
    self.append(create_ir_set_instruction(self.create_variable_value(result_variable), right_value), expression.location)
    self.current_block.append_jump(end_block)
    self.current_block = end_block
    return self.append(create_ir_phi_instruction(self.create_variable_value(result_variable)), expression.location)
}

define convert_member_access_expression = func (self: IR_Builder, member_access_expression: AST_Member_Access_Expression) -> IR_Value {
    let object_value = self.convert_expression(member_access_expression.object_expression, null)
    let object_value_type = object_value.type
    let struct_type: IR_Struct_Type
    if (object_value_type.is(IR_Struct_Type)) {
        if (object_value.is(IR_Variable_Value)) {
            struct_type = object_value_type as IR_Struct_Type
            object_value = self.append(
                create_ir_load_variable_address_instruction(
                    self.create_temp_value(self.create_ir_pointer_type(struct_type))
                    object_value as IR_Variable_Value
                )
                member_access_expression.location
            )
        } else if (object_value.is(IR_Global_Variable_Value)) {
            struct_type = object_value_type as IR_Struct_Type
            object_value = new IR_Global_Variable_Address_Value(
                type = self.create_ir_pointer_type(struct_type)
                variable = (object_value as IR_Global_Variable_Value).variable
            )
        } else {
            abort(member_access_expression.location, clone("Unuspported value type: ").append(object_value.object_type.name))
        }
    } else if (object_value_type.is(IR_Pointer_Type)) {
        let pointed_type = (object_value_type as IR_Pointer_Type).pointed_type
        if (pointed_type.is(IR_Struct_Type) == false) {
            abort(member_access_expression.location, clone("Not a IR_Struct_Type pointer value: ").append(object_value_type.name))
        }
        struct_type = pointed_type as IR_Struct_Type
    } else {
        abort(member_access_expression.location, clone("Not an IR_Pointer_Type value: ").append(object_value_type.name))
    }
    let struct_type_member = struct_type.get_member(member_access_expression.member_name.lexeme)
    if (struct_type_member == null) {
        struct_type.dump_struct_members()
        abort(member_access_expression.member_name.location, clone(struct_type.name).append(" has no such member: ").append(member_access_expression.member_name.lexeme))
    }
    if (struct_type_member.type.is(IR_Struct_Type)) {
        return self.append(create_ir_load_struct_member_instruction(self.create_temp_value(self.create_ir_pointer_type(struct_type_member.type)), object_value, struct_type_member, true), member_access_expression.location)
    }
    return self.append(create_ir_load_struct_member_instruction(self.create_temp_value(struct_type_member.type), object_value, struct_type_member, false), member_access_expression.location)
}

define dump_struct_members = func (struct_type: IR_Struct_Type) -> Nothing {
    stderr.end_line()
    while (struct_type != null) {
        let struct_type_members_item = struct_type.statement.members.first_item
        while (struct_type_members_item != null) {
            let struct_type_member = struct_type_members_item.data as AST_Struct_Member
            let struct_type_member_name = struct_type_member.name.lexeme
            let struct_type_member_type = struct_type.get_member(struct_type_member_name).type
            stderr.write(struct_type_member.location).write(": ").write(struct_type.name).write('.').write(struct_type_member_name).write(": ").write(struct_type_member_type.name).end_line()
            struct_type_members_item = struct_type_members_item.next_item
        }
        struct_type = struct_type.base_type
    }
}

define convert_member_access_expression_address = func (self: IR_Builder, member_access_expression: AST_Member_Access_Expression) -> IR_Value {
    let result_type = self.deduce_expression_type(member_access_expression)
    if (result_type.is(IR_Pointer_Type)) {
        return self.convert_member_access_expression(member_access_expression)
    }
    if (result_type.is(IR_Unchecked_Array_Type)) {
        return self.convert_member_access_expression(member_access_expression)
    }
    abort(member_access_expression.location, result_type.object_type)
}

define convert_modulo_expression = func (self: IR_Builder, expression: AST_Modulo_Expression) -> IR_Value {
    let left_value = self.convert_expression(expression.left_expression, null)
    if (left_value.type.is(IR_Integer_Type) == false) {
        abort(expression.left_expression.location, "Not an integer value")
    }
    let right_value = self.convert_expression(expression.right_expression, left_value.type)
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Modulo_Instruction(result_value = self.create_temp_value(left_value.type)).init(left_value, right_value), expression.location)
}

define convert_multiply_expression = func (self: IR_Builder, expression: AST_Multiply_Expression) -> IR_Value {
    let left_value = self.convert_expression(expression.left_expression, null)
    if (left_value.type.is(IR_Integer_Type) == false) {
        abort(expression.left_expression.location, "Not an integer value")
    }
    let right_value = self.convert_expression(expression.right_expression, left_value.type)
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Multiply_Instruction(result_value = self.create_temp_value(left_value.type)).init(left_value, right_value), expression.location)
}

define convert_negate_expression = func (self: IR_Builder, expression: AST_Negate_Expression) -> IR_Value {
    let value = self.convert_expression(expression.expression, null)
    if (value.type.is(IR_Integer_Type) == false) {
        abort(expression.expression.location, "Not an integer value")
    }
    return self.append(
        new IR_Substract_Instruction(result_value = self.create_temp_value(value.type)).init(
            new IR_Constant_Value(
                type = value.type
                literal = new Integer_Token(lexeme = "", location = expression.location, value = 0)
            )
            value
        )
        expression.location
    )
}

define convert_new_expression = func (self: IR_Builder, expression: AST_New_Expression) -> IR_Value {
    if (expression.type.is(AST_Named_Type) == false) {
        abort(expression.type.location, "Unuspported type")
    }
    let type_name = (expression.type as AST_Named_Type).name.lexeme
    let struct_statement = self.get_struct_statement(type_name)
    if (struct_statement == null) {
        abort(expression.type.location, clone("Unsupported type: ").append(type_name))
    }
    let type = self.convert_struct_statement(struct_statement)
    let init_arguments = new List()
    let init_value = self.convert_struct_literal_expression(expression, type)
    let result_value = self.append(create_ir_new_instruction(self.create_temp_value(self.create_ir_pointer_type(type)), type, init_value), expression.location)
    return result_value
}

define convert_struct_literal_expression = func (self: IR_Builder, expression: AST_Expression, struct_type: IR_Struct_Type) -> IR_Struct_Literal_Value {
    let call_arguments: List
    if (expression.is(AST_Call_Expression)) {
        call_arguments = (expression as AST_Call_Expression).arguments
    } else if (expression.is(AST_New_Expression)) {
        call_arguments = (expression as AST_New_Expression).init_arguments
    } else {
        abort(expression.location, clone("Unsupported type: ").append(expression.object_type.name))
    }
    let struct_literal_value = new IR_Struct_Literal_Value(type = struct_type, location = expression.location)
    if (struct_type.is_object_type()) {
        let variable = self.get_variable(struct_type.name)
        let object_type_member = struct_type.get_member("object_type")
        struct_literal_value.set_member_value(object_type_member, new IR_Global_Variable_Value(type = variable.type, variable = variable))
    }
    self.convert_struct_literal_value(struct_literal_value, call_arguments, struct_type, struct_type)
    return struct_literal_value
}

define convert_struct_literal_value = func (self: IR_Builder, struct_literal_value: IR_Struct_Literal_Value, call_arguments: List, struct_type: IR_Struct_Type, base_type: IR_Struct_Type) -> Nothing {
    let call_arguments_item = call_arguments.first_item
    while (call_arguments_item != null) {
        let call_argument = call_arguments_item.data as AST_Call_Argument
        let call_argument_name = call_argument.name
        if (call_argument_name == null) {
            abort(call_argument.value_expression.location, "Struct init argument without name")
        }
        let struct_type_member = struct_type.get_member(call_argument_name.lexeme)
        if (struct_type_member == null) {
            abort(call_argument_name.location, clone(struct_type.name).append(" has no such member: ").append(call_argument_name.lexeme))
        }
        if (struct_literal_value.get_member_value(struct_type_member) == null) {
            struct_literal_value.set_member_value(struct_type_member, self.convert_expression(call_argument.value_expression, struct_type_member.type))
        }
        call_arguments_item = call_arguments_item.next_item
    }
    if (base_type != null) {
        self.convert_struct_literal_value(struct_literal_value, base_type.statement.init_arguments, struct_type, base_type.base_type)
    }
}

define get_named_argument = func (list: List, name: String) -> IR_Call_Argument {
    let list_item = list.first_item
    while (list_item != null) {
        let call_argument = list_item.data as IR_Call_Argument
        if (name.equals(call_argument.name)) {
            return call_argument
        }
        list_item = list_item.next_item
    }
    return null
}

define convert_not_equals_expression = func (self: IR_Builder, expression: AST_Not_Equals_Expression) -> IR_Value {
    let left_value = self.convert_expression(expression.left_expression, null)
    let right_value = self.convert_expression(expression.right_expression, null)
    if (left_value.type != right_value.type && (left_value.type.is(IR_Pointer_Type) == false || right_value.type.is(IR_Null_Type) == false)) {
        abort(expression.location, "Operands are not the same type")
    }
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Not_Equal_Comparison_Instruction(result_value = self.create_temp_value(self.get_named_type("bool"))).init(left_value, right_value), expression.location)
}

define convert_substract_expression = func (self: IR_Builder, expression: AST_Substract_Expression) -> IR_Value {
    let left_value = self.convert_expression(expression.left_expression, null)
    if (left_value.type.is(IR_Integer_Type) == false) {
        abort(expression.left_expression.location, "Not an integer value")
    }
    let right_value = self.convert_expression(expression.right_expression, left_value.type)
    if (left_value.is(IR_Constant_Value) && right_value.is(IR_Constant_Value)) {
        abort(expression.location, "TODO: Evaluate constant expression")
    }
    return self.append(new IR_Substract_Instruction(result_value = self.create_temp_value(left_value.type)).init(left_value, right_value), expression.location)
}

define convert_variable_expression = func (self: IR_Builder, expression: AST_Variable_Expression, expected_type: IR_Type) -> IR_Value {
    let variable = self.get_variable(expression.name.lexeme)
    if (variable == null) {
        if (expected_type != null && expected_type.is(IR_Function_Type)) {
            let function = self.get_named_function(expression.name.lexeme, expected_type as IR_Function_Type)
            if (function != null) {
                return new IR_Function_Address_Value(type = expected_type, function = function)
            }
        }
        abort(expression.location, clone("Undeclared variable: ").append(expression.name.lexeme))
    }
    let value = self.get_variable_value(variable)
    if (value == null) {
        abort(expression.location, clone("Undeclared variable value: ").append(expression.name.lexeme))
    }
    return value
}

define convert_variable_expression_address = func (self: IR_Builder, expression: AST_Variable_Expression) -> IR_Value {
    let variable = self.get_variable(expression.name.lexeme)
    if (variable == null) {
        abort(expression.location, clone("Undeclared variable: ").append(expression.name.lexeme))
    }
    if (variable.type.is(IR_Pointer_Type)) {
        return self.get_variable_value(variable)
    }
    if (variable.is(IR_Global_Variable)) {
        return new IR_Global_Variable_Address_Value(type = self.create_ir_pointer_type(variable.type), variable = variable)
    }
    if (variable.type.is(IR_Unchecked_Array_Type)) {
        return self.get_variable_value(variable)
    }
    abort(expression.location, clone("Variable type without address: ").append(variable.type.name))
}

define deduce_expression_type = func (self: IR_Builder, expression: AST_Expression) -> IR_Type {
    if (expression.is(AST_Call_Expression)) {
        return self.deduce_call_expression_type(expression as AST_Call_Expression)
    }
    if (expression.is(AST_Literal_Expression)) {
        return self.deduce_literal_expression_type(expression as AST_Literal_Expression)
    }
    if (expression.is(AST_Member_Access_Expression)) {
        return self.deduce_member_access_expression_type(expression as AST_Member_Access_Expression)
    }
    if (expression.is(AST_Variable_Expression)) {
        return self.deduce_variable_expression_type(expression as AST_Variable_Expression)
    }
    abort(expression.location, expression.object_type)
}

define deduce_call_expression_type = func (self: IR_Builder, expression: AST_Call_Expression) -> IR_Type {
    let argument_types = new List()
    let arguments = expression.arguments.create_iterator()
    while (arguments.has_next()) {
        let argument = arguments.next() as AST_Expression
        let argument_type = self.deduce_expression_type(argument)
        argument_types.append(argument_type)
    }
    if (expression.callee_expression.is(AST_Member_Access_Expression)) {
        let callee_expression = expression.callee_expression as AST_Member_Access_Expression
        let object_type = self.deduce_expression_type(callee_expression.object_expression)
        if (object_type.is(IR_Struct_Type)) {
            argument_types.prepend(self.create_ir_pointer_type(object_type))
        } else {
            argument_types.prepend(object_type)
        }
        let function = self.get_named_function(callee_expression.member_name.lexeme, argument_types)
        if (function == null) {
            abort(callee_expression.member_name.location, clone("Unknown function: ").append(callee_expression.member_name.lexeme))
        }
        return function.return_type
    }
    abort(expression.location, expression.callee_expression.object_type)
}

define deduce_literal_expression_type = func (self: IR_Builder, expression: AST_Literal_Expression) -> IR_Type {
    let literal = expression.literal
    if (literal.is(String_Token)) {
        return self.create_ir_pointer_type(self.get_named_type("String"))
    }
    abort(literal.location, literal.object_type)
}

define deduce_member_access_expression_type = func (self: IR_Builder, expression: AST_Member_Access_Expression) -> IR_Type {
    let object_type = self.deduce_expression_type(expression.object_expression)
    if (object_type.is(IR_Pointer_Type) == false) {
        abort(expression.location, object_type.object_type)
    }
    let object_type = (object_type as IR_Pointer_Type).pointed_type
    if (object_type.is(IR_Struct_Type) == false) {
        abort(expression.location, object_type.object_type)
    }
    let object_type = object_type as IR_Struct_Type
    let member = object_type.get_member(expression.member_name.lexeme)
    if (member == null) {
        abort(expression.member_name.location, clone(object_type.name).append(" has no such member: ").append(expression.member_name.lexeme))
    }
    if (member.type.is(IR_Struct_Type)) {
        return self.create_ir_pointer_type(member.type)
    }
    return member.type
}

define deduce_variable_expression_type = func (self: IR_Builder, expression: AST_Variable_Expression) -> IR_Type {
    let variable = self.get_variable(expression.name.lexeme)
    if (variable == null) {
        abort(expression.location, clone("Unknown variable: ").append(expression.name.lexeme))
    }
    return variable.type
}
