\ Copyright (c) 2020, Stefan Selariu

IR_Type :: struct : Object {
    name: @String
}

IR_Any_Type :: struct : IR_Type {
}

IR_Boolean_Type :: struct : IR_Type {
}

IR_Int_Type :: struct : IR_Type {
}

IR_Int8_Type :: struct : IR_Type {
}

IR_Int16_Type :: struct : IR_Type {
}

IR_Int32_Type :: struct : IR_Type {
}

IR_Int64_Type :: struct : IR_Type {
}

IR_Nothing_Type :: struct : IR_Type {
}

IR_Null_Type :: struct : IR_Type {
}

IR_Undefined_Type :: struct : IR_Type {
}

IR_Pointer_Type :: struct : IR_Type {
    pointed_type: @IR_Type
}

equals :: (self: @IR_Type, other: @IR_Type) -> Boolean {
    if (self.is(IR_Pointer_Type) && other.is(IR_Pointer_Type)) {
        self := self as @IR_Pointer_Type
        other := other as @IR_Pointer_Type
        return self.pointed_type.equals(other.pointed_type)
    }
    return self == other
}

create_ir_pointer_type :: (pointed_type: @IR_Type) -> @IR_Pointer_Type {
    type_name := clone("@").append(pointed_type.name)
    return new IR_Pointer_Type(name = type_name, pointed_type = pointed_type)
}

IR_Array_Type :: struct : IR_Pointer_Type {
    size_expression: @AST_Expression
}

create_ir_array_type :: (item_type: @IR_Type, size_expression: @AST_Expression) -> @IR_Type {
    type_name := clone("[").append(item_type.name).append("]")
    return new IR_Array_Type(name = type_name, pointed_type = item_type, size_expression = size_expression)
}

IR_Function_Type :: struct : IR_Type {
    parameters: @List
    return_type: @IR_Type
}

IR_Function_Type_Parameter :: struct {
    name: @String
    type: @IR_Type
}

create_ir_function_type :: (parameters: @List, return_type: @IR_Type) -> @IR_Function_Type {
    type_name := new String().append("(")
    parameters_item := parameters.first_item
    while (parameters_item != null) {
        parameter := parameters_item.data as @IR_Function_Type_Parameter
        type_name.append(parameter.name).append(": ").append(parameter.type.name)
        parameters_item = parameters_item.next_item
        if (parameters_item != null) {
            type_name.append(", ")
        }
    }
    type_name.append(") -> ").append(return_type.name)

    return new IR_Function_Type(name = type_name, parameters = parameters, return_type = return_type)
}

IR_Struct_Type :: struct : IR_Type {
    base_type: @IR_Struct_Type = null
    members: @List = new List()
    statement: @AST_Struct_Statement
}

IR_Struct_Type_Member :: struct {
    struct_type: @IR_Struct_Type
    name: @String
    type: @IR_Type
}

create_ir_struct_type :: (name: @String, statement: @AST_Struct_Statement) -> @IR_Struct_Type {
    return new IR_Struct_Type(name = name, statement = statement)
}

add_member :: (self: @IR_Struct_Type, name: @String, type: @IR_Type) -> @IR_Struct_Type_Member {
    member := new IR_Struct_Type_Member(struct_type = self, name = name, type = type)
    self.members.append(member)
    return member
}

get_member :: (self: @IR_Struct_Type, name: @String) -> @IR_Struct_Type_Member {
    struct_type := self
    loop {
        members_item := struct_type.members.first_item
        while (members_item != null) {
            member := members_item.data as @IR_Struct_Type_Member
            if (member.name.equals(name)) {
                return member
            }
            members_item = members_item.next_item
        }
        struct_type = struct_type.base_type
        if (struct_type == null) {
            return null
        }
    }
}

is_base_type :: (self: @IR_Struct_Type, other: @IR_Struct_Type) -> Boolean {
    struct_type := other
    loop {
        if (self == struct_type.base_type) {
            return true
        }
        struct_type = struct_type.base_type
        if (struct_type == null) {
            return false
        }
    }
}

is_object_type :: (self: @IR_Struct_Type) -> Boolean {
    struct_type := self
    loop {
        if (struct_type.name.equals("Object")) {
            return true
        }
        struct_type = struct_type.base_type
        if (struct_type == null) {
            return false
        }
    }
}

IR_Value :: struct : Object {
    type: @IR_Type
    user_instructions: @List = new List()
}

IR_Undefined_Value :: struct : IR_Value {
}

IR_Constant_Value :: struct : IR_Value {
    literal: @Literal_Token
}

IR_Variable_Value :: struct : IR_Value {
    variable: @IR_Variable
    version: Int
}

init :: (self: @IR_Variable_Value, variable: @IR_Variable) -> @IR_Variable_Value {
    self.variable = variable
    self.version = variable.values.size + 1
    variable.values.append(self)
    return self
}

IR_Block :: struct : Object {
    id: Int
    function: @IR_Function
    predecessors: @List = new List()
    first_instruction: @IR_Instruction = null
    last_instruction: @IR_Instruction = null
    is_being_generated: Boolean = false
    is_generated: Boolean = false
}

has_instructions :: (self: @IR_Block) -> Boolean {
    return self.first_instruction != null
}

prepend :: (self: @IR_Block, instruction: @IR_Instruction) -> @IR_Instruction {
    instruction.parent_block = self
    instruction.prev_instruction = null
    instruction.next_instruction = self.first_instruction
    if (self.first_instruction == null) {
        self.last_instruction = instruction
    } else {
        self.first_instruction.prev_instruction = instruction
    }
    self.first_instruction = instruction
    return instruction
}

append :: (self: @IR_Block, instruction: @IR_Instruction) -> @IR_Instruction {
    instruction.parent_block = self
    instruction.prev_instruction = self.last_instruction
    instruction.next_instruction = null
    if (self.last_instruction == null) {
        self.first_instruction = instruction
    } else {
        self.last_instruction.next_instruction = instruction
    }
    self.last_instruction = instruction
    return instruction
}

append_jump :: (self: @IR_Block, block: @IR_Block) -> @IR_Direct_Jump_Instruction {
    instruction := new IR_Direct_Jump_Instruction(result_value = null, block = block)
    block.predecessors.append(self)
    self.append(instruction)
    return instruction
}

append_jump :: (self: @IR_Block, condition_value: @IR_Value, true_block: @IR_Block, false_block: @IR_Block) -> @IR_Conditional_Jump_Instruction {
    instruction := new IR_Conditional_Jump_Instruction(result_value = null, true_block = true_block, false_block = false_block)
    instruction.operand_values.append(condition_value)
    true_block.predecessors.append(self)
    false_block.predecessors.append(self)
    condition_value.user_instructions.append(instruction)
    self.append(instruction)
    return instruction
}

remove :: (self: @IR_Block, instruction: @IR_Instruction) -> Nothing {
    if (instruction.parent_block != self) {
        abort("Tried to remove instruction belonging to another block")
    }
    if (instruction.prev_instruction != null) {
        instruction.prev_instruction.next_instruction = instruction.next_instruction
    }
    if (instruction.next_instruction != null) {
        instruction.next_instruction.prev_instruction = instruction.prev_instruction
    }
    if (self.first_instruction == instruction) {
        self.first_instruction = instruction.next_instruction
    }
    if (self.last_instruction == instruction) {
        self.last_instruction = instruction.prev_instruction
    }
    instruction.parent_block = null
    instruction.prev_instruction = null
    instruction.next_instruction = null
}

IR_Function :: struct : Object {
    id: Int
    location: @Source_Location
    name: @String
    parameters: @List
    return_type: @IR_Type
    type: @IR_Function_Type
    is_external: Boolean
    blocks: @List
}

create_block :: (self: @IR_Function) -> @IR_Block {
    block := new IR_Block(id = self.blocks.size + 1, function = self)
    self.blocks.append(block)
    return block
}

IR_Variable :: struct : Object {
    name: @String
    type: @IR_Type
    values: @List = new List()
}

IR_Global_Variable :: struct : IR_Variable {
    is_external: Boolean
}

create_ir_global_variable :: (name: @String, type: @IR_Type, is_external: Boolean) -> @IR_Global_Variable {
    variable := new IR_Global_Variable(name = name, type = type, is_external = is_external)
    return variable
}

IR_Function_Parameter :: struct : IR_Variable {
}

IR_Instruction :: struct : Object {
    location: @Source_Location = null
    result_value: @IR_Variable_Value
    operand_values: @List = new List()
    parent_block: @IR_Block = undefined
    prev_instruction: @IR_Instruction = null
    next_instruction: @IR_Instruction = null
    is_generated: Boolean = false
}

is_exit_instruction :: (self: @IR_Instruction) -> Boolean {
    if (self == null) {
        return false
    }
    if (self.is(IR_Jump_Instruction) || self.is(IR_Return_Instruction)) {
        return true
    }
    if (self.is(IR_Direct_Call_Instruction)) {
        self := self as @IR_Direct_Call_Instruction
        function := self.function
        if (function.name.equals("abort")) {
            return true
        }
        if (function.name.equals("exit") && function.parameters.size == 1) {
            function_parameter := function.parameters.get(0) as @IR_Function_Parameter
            if (function_parameter.type.is(IR_Int_Type)) {
                return true
            }
        }
    }
    return false
}

IR_Call_Argument :: struct {
    name: @String = null
    value: @IR_Value
}

IR_Call_Instruction :: struct : IR_Instruction {
    arguments_size: Int = 0
}

add_arguments :: (self: @IR_Call_Instruction, call_arguments: @List) -> @IR_Call_Instruction {
    self.arguments_size = self.arguments_size + call_arguments.size
    call_arguments_item := call_arguments.first_item
    while (call_arguments_item != null) {
        call_argument := call_arguments_item.data as @IR_Call_Argument
        self.operand_values.append(call_argument.value)
        call_argument.value.user_instructions.append(self)
        call_arguments_item = call_arguments_item.next_item
    }
    return self
}

argument :: (self: @IR_Call_Instruction, index: Int) -> @IR_Value {
    if (index >= self.arguments_size) {
        return null
    }
    return self.operand_values.get(index) as @IR_Value
}

IR_Direct_Call_Instruction :: struct : IR_Call_Instruction {
    function: @IR_Function
}

create_ir_direct_call_instruction :: (result_value: @IR_Variable_Value, call_arguments: @List, function: @IR_Function) -> @IR_Call_Instruction {
    instruction := new IR_Direct_Call_Instruction(result_value = result_value, function = function)
    instruction.add_arguments(call_arguments)
    return instruction
}

IR_Dynamic_Call_Instruction :: struct : IR_Call_Instruction {
}

create_ir_dynamic_call_instruction :: (result_value: @IR_Variable_Value, call_arguments: @List, function_address: @IR_Variable_Value) -> @IR_Call_Instruction {
    instruction := new IR_Dynamic_Call_Instruction(result_value = result_value)
    instruction.add_arguments(call_arguments)
    instruction.operand_values.append(function_address)
    function_address.user_instructions.append(instruction)
    return instruction
}

function_address :: (self: @IR_Dynamic_Call_Instruction) -> @IR_Variable_Value {
    return self.operand_values.last() as @IR_Variable_Value
}

IR_Cast_Instruction :: struct : IR_Instruction {
}

create_ir_cast_instruction :: (result_value: @IR_Variable_Value, value: @IR_Value) -> @IR_Cast_Instruction {
    instruction := new IR_Cast_Instruction(result_value = result_value)
    instruction.operand_values.append(value)
    value.user_instructions.append(instruction)
    return instruction
}

get_value :: (self: @IR_Cast_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

IR_Jump_Instruction :: struct : IR_Instruction {
}

IR_Conditional_Jump_Instruction :: struct : IR_Jump_Instruction {
    true_block: @IR_Block
    false_block: @IR_Block
}

get_condition_value :: (self: @IR_Conditional_Jump_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

IR_Direct_Jump_Instruction :: struct : IR_Jump_Instruction {
    block: @IR_Block
}

IR_Load_Array_Item_Instruction :: struct : IR_Instruction {
}

create_ir_load_array_item_instruction :: (result_value: @IR_Variable_Value, array_value: @IR_Value, index_value: @IR_Value) -> @IR_Load_Array_Item_Instruction {
    instruction := new IR_Load_Array_Item_Instruction(result_value = result_value)
    instruction.operand_values.append(array_value)
    instruction.operand_values.append(index_value)
    array_value.user_instructions.append(instruction)
    index_value.user_instructions.append(instruction)
    return instruction
}

get_array_value :: (self: @IR_Load_Array_Item_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

get_index_value :: (self: @IR_Load_Array_Item_Instruction) -> @IR_Value {
    return self.operand_values.last() as @IR_Value
}

IR_Load_Function_Address_Instruction :: struct : IR_Instruction {
    function: @IR_Function
}

create_ir_load_function_address_instruction :: (result_value: @IR_Variable_Value, function: @IR_Function) -> @IR_Load_Function_Address_Instruction {
    instruction := new IR_Load_Function_Address_Instruction(result_value = result_value, function = function)
    return instruction
}

IR_Load_Struct_Member_Instruction :: struct : IR_Instruction {
    struct_type_member: @IR_Struct_Type_Member
    load_address: Boolean
}

create_ir_load_struct_member_instruction :: (result_value: @IR_Variable_Value, struct_pointer_value: @IR_Value, struct_type_member: @IR_Struct_Type_Member, load_address: Boolean) -> @IR_Load_Struct_Member_Instruction {
    instruction := new IR_Load_Struct_Member_Instruction(result_value = result_value, struct_type_member = struct_type_member, load_address = load_address)
    instruction.operand_values.append(struct_pointer_value)
    struct_pointer_value.user_instructions.append(instruction)
    return instruction
}

get_struct_pointer_value :: (self: @IR_Load_Struct_Member_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

IR_Load_Variable_Instruction :: struct : IR_Instruction {
    variable: @IR_Variable
}

create_ir_load_variable_instruction :: (result_value: @IR_Variable_Value) -> @IR_Load_Variable_Instruction {
    instruction := new IR_Load_Variable_Instruction(result_value = result_value, variable = result_value.variable)
    return instruction
}

IR_New_Instruction :: struct : IR_Instruction {
    type: @IR_Type
}

create_ir_new_instruction :: (result_value: @IR_Variable_Value, type: @IR_Type, size_value: @IR_Value) -> @IR_New_Instruction {
    instruction := new IR_New_Instruction(result_value = result_value, type = type)
    instruction.operand_values.append(size_value)
    if (size_value != null) {
        size_value.user_instructions.append(instruction)
    }
    return instruction
}

get_size_value :: (self: @IR_New_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

IR_Return_Instruction :: struct : IR_Instruction {
}

create_ir_return_instruction :: (return_value: @IR_Value) -> @IR_Return_Instruction {
    instruction := new IR_Return_Instruction(result_value = null)
    instruction.operand_values.append(return_value)
    if (return_value != null) {
        return_value.user_instructions.append(instruction)
    }
    return instruction
}

get_return_value :: (self: @IR_Return_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

IR_Set_Instruction :: struct : IR_Instruction {
}

create_ir_set_instruction :: (result_value: @IR_Variable_Value, value: @IR_Value) -> @IR_Set_Instruction {
    instruction := new IR_Set_Instruction(result_value = result_value)
    instruction.operand_values.append(value)
    value.user_instructions.append(instruction)
    return instruction
}

get_value :: (self: @IR_Set_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

IR_Store_Array_Item_Instruction :: struct : IR_Instruction {
}

create_ir_store_array_item_instruction :: (array_value: @IR_Value, index_value: @IR_Value, value: @IR_Value) -> @IR_Store_Array_Item_Instruction {
    instruction := new IR_Store_Array_Item_Instruction(result_value = null)
    instruction.operand_values.append(array_value)
    instruction.operand_values.append(index_value)
    instruction.operand_values.append(value)
    array_value.user_instructions.append(instruction)
    index_value.user_instructions.append(instruction)
    value.user_instructions.append(instruction)
    return instruction
}

get_array_value :: (self: @IR_Store_Array_Item_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

get_index_value :: (self: @IR_Store_Array_Item_Instruction) -> @IR_Value {
    return self.operand_values.get(1) as @IR_Value
}

get_value :: (self: @IR_Store_Array_Item_Instruction) -> @IR_Value {
    return self.operand_values.last() as @IR_Value
}

IR_Store_Struct_Member_Instruction :: struct : IR_Instruction {
    struct_type_member: @IR_Struct_Type_Member
}

create_ir_store_struct_member_instruction :: (struct_pointer_value: @IR_Value, struct_type_member: @IR_Struct_Type_Member, value: @IR_Value) -> @IR_Store_Struct_Member_Instruction {
    instruction := new IR_Store_Struct_Member_Instruction(result_value = null, struct_type_member = struct_type_member)
    instruction.operand_values.append(struct_pointer_value)
    instruction.operand_values.append(value)
    struct_pointer_value.user_instructions.append(instruction)
    value.user_instructions.append(instruction)
    return instruction
}

get_struct_pointer_value :: (self: @IR_Store_Struct_Member_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

get_value :: (self: @IR_Store_Struct_Member_Instruction) -> @IR_Value {
    return self.operand_values.last() as @IR_Value
}

IR_Binary_Instruction :: struct : IR_Instruction {
}

init :: (self: @IR_Binary_Instruction, left_value: @IR_Value, right_value: @IR_Value) -> @IR_Binary_Instruction {
    self.operand_values.append(left_value)
    self.operand_values.append(right_value)
    left_value.user_instructions.append(self)
    right_value.user_instructions.append(self)
    return self
}

get_left_value :: (self: @IR_Binary_Instruction) -> @IR_Value {
    return self.operand_values.first() as @IR_Value
}

get_right_value :: (self: @IR_Binary_Instruction) -> @IR_Value {
    return self.operand_values.last() as @IR_Value
}

IR_Add_Instruction :: struct : IR_Binary_Instruction {
}

IR_Comparison_Instruction :: struct : IR_Binary_Instruction {
}

IR_Divide_Instruction :: struct : IR_Binary_Instruction {
}

IR_Equals_Comparison_Instruction :: struct : IR_Comparison_Instruction {
}

IR_Greater_Than_Comparison_Instruction :: struct : IR_Comparison_Instruction {
}

IR_Greater_Than_Or_Equals_Comparison_Instruction :: struct : IR_Comparison_Instruction {
}

IR_Less_Than_Comparison_Instruction :: struct : IR_Comparison_Instruction {
}

IR_Less_Than_Or_Equals_Comparison_Instruction :: struct : IR_Comparison_Instruction {
}

IR_Modulo_Instruction :: struct : IR_Binary_Instruction {
}

IR_Multiply_Instruction :: struct : IR_Binary_Instruction {
}

IR_Not_Equals_Comparison_Instruction :: struct : IR_Comparison_Instruction {
}

IR_Substract_Instruction :: struct : IR_Binary_Instruction {
}

IR_Phi_Instruction :: struct : IR_Instruction {
    values: @List
}

create_ir_phi_instruction :: (result_value: @IR_Variable_Value) -> @IR_Phi_Instruction {
    instruction := new IR_Phi_Instruction(result_value = result_value, values = undefined)
    instruction.values = instruction.operand_values
    return instruction
}

append :: (self: @IR_Phi_Instruction, value: @IR_Value) -> Nothing {
    self.values.remove_all(value).prune().append(value)
    value.user_instructions.append(self)
}

is_redundant :: (self: @IR_Phi_Instruction) -> Boolean {
    \ redundant phi instruction:
    \   v.1 = phi(v.2)

    value_item := self.values.first_item
    if (value_item == null) {
        abort()
    }
    other_value := value_item.data as @IR_Value
    value_item = value_item.next_item
    while (value_item != null) {
        value := value_item.data as @IR_Value
        if (value != other_value) {
            return false
        }
        value_item = value_item.next_item
    }
    return true
}

is_trivial :: (self: @IR_Phi_Instruction) -> Boolean {
    \ trivial phi instructions:
    \   v.1 = phi(v.1)
    \   v.1 = phi(v.1, v.2)

    value_item := self.values.first_item
    if (value_item == null) {
        abort()
    }
    result_value: @IR_Value = self.result_value
    other_value: @IR_Value = null
    while (value_item != null) {
        value := value_item.data as @IR_Value
        if (value != result_value) {
            if (value != other_value) {
                if (other_value != null) {
                    return false
                }
                other_value = value
            }
        }
        value_item = value_item.next_item
    }
    return true
}
