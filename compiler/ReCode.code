include "./code/Checked_Code.code"
include "./code/Checker.code"
include "./code/Parsed_Code.code"
include "./code/Parser.code"
include "./ir/IR_Builder.code"
include "./ir/IR_Code.code"
include "./ir/IR_Liveness_Analysis.code"
include "./scanner/Scanner.code"
include "./scanner/Token.code"
include "./source/Source.code"
include "./utils/Counter.code"
include "./utils/File.code"
include "./utils/List.code"
include "./utils/LibC.code"
include "./utils/Map.code"
include "./utils/Object.code"
include "./utils/String.code"

func main(argc: i32, argv: [[u8; ?]; ?]) -> Nothing {
    let command = parse_args(argc, argv)

    \ workaround until global variable initialization is implemented
    init_matchers()

    let source = create_source(command.input_file, command.input_file_path)

    let ir_code: @IR_Code
    if command.input_file_type.equals("code") {
        let parsed_code = parse(source)

        let checked_code = check(parsed_code)

        ir_code = build(checked_code)
    } else {
        abort(clone("Unsupported input type: ").append(command.input_file_type))
    }

    command.passes.for_each() {
        let pass = it
        abort(clone("Unsupported pass: ").append(pass))
    }

    if command.output.equals("cfg") {
        command.output_file.write_cfg(ir_code)
    } else if command.output.equals("ir") {
        command.output_file.write(ir_code, false)
    } else if command.output.equals("irl") {
        ir_code.compute_live_values()
        command.output_file.write(ir_code, true)
    } else {
        abort(clone("Unsupported output: ").append(command.output))
    }

    if not command.output_file_path.equals("(stdout)") {
        command.output_file.fclose()
    }
}

struct Command {
    input_file: @FILE
    input_file_path: @String
    input_file_type: @String

    output_file: @FILE
    output_file_path: @String

    passes: @List[@String]
    output: @String
}

func parse_args(argc: i32, argv: [[u8; ?]; ?]) -> @Command {
    if argc < 2 {
        print_help(argv[0])
        exit(1)
    }

    \ create arguments list
    let arguments = make List[@String]()
    let argument_index = 1
    while argument_index < argc {
        arguments.append(create_string(argv[argument_index]))
        argument_index = argument_index + 1
    }

    let input_file = stdin
    let input_file_path = "(stdin)"
    let input_file_type = "code"
    let output_file = stdout
    let output_file_path = "(stdout)"

    let arguments_item = arguments.first_item
    while arguments_item != null and arguments_item.data.starts_with("--") {
        if arguments_item.data.equals("--ir") {
            input_file_type = "ir"
        } else if arguments_item.data.equals("--file") {
            arguments_item = arguments_item.next_item
            if arguments_item == null {
                stderr.error().write("Missing file path.").reset().end_line().end_line()
                print_help(argv[0])
                exit(1)
            }
            input_file_path = arguments_item.data
            input_file = fopen(input_file_path.data, "r".data)
            if input_file == null {
                stderr.error().write("Failed to open '").write(input_file_path).write("'.").reset().end_line().end_line()
                print_help(argv[0])
                exit(1)
            }
        } else {
            stderr.error().write("Unknown option: ").write(arguments_item.data).reset().end_line().end_line()
            print_help(argv[0])
            exit(1)
        }
        arguments_item = arguments_item.next_item
    }

    let passes = make @List[@String]()
    while arguments_item != null {
        if arguments_item.data.equals("cf") or arguments_item.data.equals("dce") or arguments_item.data.equals("cse") or arguments_item.data.equals("m2r") {
            passes.append(arguments_item.data)
        } else {
            break
        }
        arguments_item = arguments_item.next_item
    }

    if arguments_item == null {
        stderr.error().write("Missing output.").reset().end_line().end_line()
        print_help(argv[0])
        exit(1)
    }
    let output = arguments_item.data
    if not output.equals("asm") and not output.equals("cfg") and not output.equals("ir") and not output.equals("irl") {
        stderr.error().write("Unsupported output: ").write(output).reset().end_line().end_line()
        print_help(argv[0])
        abort()
    }

    arguments_item = arguments_item.next_item
    if arguments_item != null {
        stderr.error().write("Unexpected argument: ").write(output).reset().end_line().end_line()
        print_help(argv[0])
        exit(1)
    }

    return make @Command(
        input_file = input_file
        input_file_path = input_file_path
        input_file_type = input_file_type
        output_file = output_file
        output_file_path = output_file_path
        passes = passes
        output = output
    )
}

func print_help(path: [u8; ?]) -> Nothing {
    stderr.write("Usage:").end_line()
    stderr.write("    ").write(path).write(" \033[4moptions\033[0m \033[4mpasses\033[0m \033[4moutput\033[0m").end_line()
    stderr.end_line()
    stderr.write("Options:").end_line()
    stderr.write("    \033[1m--file\033[0m PATH").end_line()
    stderr.write("        Specifies the source file path. If not provided, the source is read from stdin.").end_line()
    stderr.write("    \033[1m--ir\033[0m").end_line()
    stderr.write("        The source is in IR format.").end_line()
    stderr.end_line()
    stderr.write("Passes:").end_line()
    stderr.write("    \033[1mcf\033[0m  - Constant Folding").end_line()
    stderr.write("    \033[1mdce\033[0m - Dead Code Elimination").end_line()
    stderr.write("    \033[1mcse\033[0m - Common Subexpression Elimination").end_line()
    stderr.write("    \033[1mm2r\033[0m - Move to Register").end_line()
    stderr.end_line()
    stderr.write("Outputs:").end_line()
    stderr.write("    \033[1masm\033[0m - Assembly").end_line()
    stderr.write("    \033[1mcfg\033[0m - Control Flow Graph").end_line()
    stderr.write("    \033[1mir\033[0m  - Intermediate Representation").end_line()
    stderr.write("    \033[1mirl\033[0m - Intermediate Representation with liveness analysis").end_line()
}

func abort(location: @Source_Location, unexpected_type: @Object_Type) -> Nothing {
    stderr.write(location).error().write(": Unexpected type: ").write(unexpected_type.name).reset().end_line()
    abort()
}

func abort(unexpected_type: @Object_Type) -> Nothing {
    stderr.error().write("Unexpected type: ").write(unexpected_type.name).reset().end_line()
    abort()
}

func abort(location: @Source_Location, message: @String) -> Nothing {
    stderr.write(location).write(": ").error().write(message).reset().end_line()
    abort()
}

func abort(message: @String) -> Nothing {
    stderr.error().write(message).reset().end_line()
    abort()
}
