\ Copyright (c) 2020, Stefan Selariu

main :: (argc: Int, argv: @@Int8) -> Nothing {
    if (argc < 3) {
        stdout.write("Usage:").end_line()
        stdout.write('\t').write(argv[0]).write(" <INPUT FILE> <OUTPUT FILE>").end_line()
        exit(1)
    }

    source_file_path := create_string(argv[1])
    if (source_file_path.ends_with(".code") == false) {
        stdout.write("'").write(source_file_path).write("' doesn't end with '.code'.").end_line()
        exit(1)
    }

    output_file_path := create_string(argv[2])
    if (output_file_path.ends_with(".s") == false) {
        stdout.write("'").write(output_file_path).write("' doesn't end with '.s'.").end_line()
        exit(1)
    }

    dump_file_path: @String = null
    if (argc >= 4) {
        dump_file_path = create_string(argv[3])
        if (dump_file_path.ends_with(".ir") == false) {
            stdout.write("'").write(dump_file_path).write("' doesn't end with '.ir'.").end_line()
            exit(1)
        }
    }

    compilation_unit := parse(source_file_path)
    \ stdout.write(compilation_unit).end_line()

    build := build(compilation_unit)
    if (dump_file_path != null) {
        dump_file := fopen(dump_file_path.data, "w".data)
        build.dump(dump_file)
        dump_file.fclose()
    }

    generate(build, output_file_path)
}

include "./code/compiler/Generator.code"

include "./code/compiler/IR_Builder.code"

abort :: (location: @Source_Location, unexpected_type: @Object_Type) -> Nothing {
    stderr.end_line().end_line().write(location).write(": Unexpected type: ").write(unexpected_type.name).end_line()
    abort()
}

include "./code/compiler/Counter.code"

include "./code/compiler/IR.code"

dump :: (build: @IR_Build, file: @FILE) -> Nothing {
    functions := build.named_functions.create_iterator()
    while (functions.has_next()) {
        function := functions.next() as @IR_Function
        if (function.is_external == false) {
            function.dump(file)
            file.end_line()
        }
    }
}

dump :: (function: @IR_Function, file: @FILE) -> Nothing {
    file.write(function.name).write('.').write(function.id).write(" :: (")
    function_parameters := function.parameters.create_iterator()
    while (function_parameters.has_next()) {
        function_parameter := function_parameters.next() as @IR_Function_Parameter
        file.write(function_parameter.name).write(": ").write(function_parameter.type.name)
        if (function_parameters.has_next()) {
            file.write(", ")
        }
    }
    file.write(") -> ").write(function.return_type.name).write(" {").end_line()
    block_item := function.blocks.first_item
    while (block_item != null) {
        (block_item.data as @IR_Block).dump(file)
        block_item = block_item.next_item
    }
    file.write('}').end_line()
}

dump :: (block: @IR_Block, file: @FILE) -> @FILE {
    file.write("block.").write(block.id)
    block_predecessors := block.predecessors.create_iterator()
    if (block_predecessors.has_next()) {
        file.write('(')
        loop {
            block_predecessor := block_predecessors.next() as @IR_Block
            file.write("block.").write(block_predecessor.id)
            if (block_predecessors.has_next()) {
                file.write(", ")
            } else {
                break
            }
        }
        file.write(')')
    }
    file.write(':').end_line()
    block_instruction := block.first_instruction
    while (block_instruction != null) {
        block_instruction.dump(file, "   ")
        block_instruction = block_instruction.next_instruction
    }
    return file
}

dump :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    file.write(prefix)
    if (instruction.is(IR_Add_Instruction)) {
        instruction := instruction as @IR_Add_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" + ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_Call_Instruction)) {
        instruction := instruction as @IR_Call_Instruction
        if (instruction.result_value != null) {
            file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ")
        }
        if (instruction.is(IR_Direct_Call_Instruction) != null) {
            file.write("call").write('(').write_function_label((instruction as @IR_Direct_Call_Instruction).function)
        } else if (instruction.is(IR_Dynamic_Call_Instruction) != null) {
            function_address := (instruction as @IR_Dynamic_Call_Instruction).function_address()
            file.write("call").write('(').write(function_address.variable.name).write('.').write(function_address.version)
        } else {
            abort(clone("Unsupported type: ").append(instruction.object_type.name))
        }
        call_argument_index := 0
        while (call_argument_index < instruction.arguments_size) {
            file.write(", ").write(instruction.argument(call_argument_index), true)
            call_argument_index = call_argument_index + 1
        }
        return file.write(')').end_line()
    }
    if (instruction.is(IR_Cast_Instruction)) {
        instruction := instruction as @IR_Cast_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write("cast").write('(').write(instruction.get_value(), true).write(')').end_line()
    }
    if (instruction.is(IR_Conditional_Jump_Instruction)) {
        instruction := instruction as @IR_Conditional_Jump_Instruction
        return file.write("jump").write('(').write(instruction.get_condition_value(), true).write(", block.").write(instruction.true_block.id).write(", block.").write(instruction.false_block.id).write(')').end_line()
    }
    if (instruction.is(IR_Direct_Jump_Instruction)) {
        instruction := instruction as @IR_Direct_Jump_Instruction
        return file.write("jump").write('(').write("block.").write(instruction.block.id).write(')').end_line()
    }
    if (instruction.is(IR_Divide_Instruction)) {
        instruction := instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" / ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_Equals_Comparison_Instruction)) {
        instruction := instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" == ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_Greater_Than_Comparison_Instruction)) {
        instruction := instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" > ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_Greater_Than_Or_Equals_Comparison_Instruction)) {
        instruction := instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" >= ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_Less_Than_Comparison_Instruction)) {
        instruction := instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" < ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_Less_Than_Or_Equals_Comparison_Instruction)) {
        instruction := instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" <= ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_Load_Array_Item_Instruction)) {
        instruction := instruction as @IR_Load_Array_Item_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write("load_array_item").write('(').write(instruction.get_array_value(), true).write(", ").write(instruction.get_index_value(), true).write(')').end_line()
    }
    if (instruction.is(IR_Load_Function_Address_Instruction)) {
        instruction := instruction as @IR_Load_Function_Address_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write("load_function_address").write('(').write(instruction.function.name).write('_').write(instruction.function.id).write(')').end_line()
    }
    if (instruction.is(IR_Load_Struct_Member_Instruction)) {
        instruction := instruction as @IR_Load_Struct_Member_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write("load_struct_member").write('(').write(instruction.get_struct_pointer_value(), true).write(", ").write(instruction.struct_type_member.name).write(')').end_line()
    }
    if (instruction.is(IR_Load_Variable_Instruction)) {
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write("load_variable").write('(').write((instruction as @IR_Load_Variable_Instruction).variable.name).write(')').end_line()
    }
    if (instruction.is(IR_Modulo_Instruction)) {
        instruction := instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" // ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_Multiply_Instruction)) {
        instruction := instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" * ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_New_Instruction)) {
        instruction := instruction as @IR_New_Instruction
        file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write("new").write('(').write(instruction.type.name)
        if (instruction.get_size_value() != null) {
            file.write(", ").write(instruction.get_size_value(), true)
        }
        return file.write(')').end_line()
    }
    if (instruction.is(IR_Not_Equals_Comparison_Instruction)) {
        instruction := instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" != ").write(instruction.get_right_value(), true).end_line()
    }
    if (instruction.is(IR_Phi_Instruction)) {
        instruction := instruction as @IR_Phi_Instruction
        file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write("phi").write('(')
        values := instruction.values.create_iterator()
        if (values.has_next()) {
            loop {
                value := values.next() as @IR_Value
                file.write(value, true)
                if (values.has_next()) {
                    file.write(", ")
                } else {
                    break
                }
            }
        }
        return file.write(')').end_line()
    }
    if (instruction.is(IR_Return_Instruction)) {
        instruction := instruction as @IR_Return_Instruction
        if (instruction.get_return_value() == null) {
            return file.write("return").write('(').write(')').end_line()
        }
        return file.write("return").write('(').write(instruction.get_return_value(), true).write(')').end_line()
    }
    if (instruction.is(IR_Set_Instruction)) {
        instruction := instruction as @IR_Set_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_value(), true).end_line()
    }
    if (instruction.is(IR_Store_Array_Item_Instruction)) {
        instruction := instruction as @IR_Store_Array_Item_Instruction
        return file.write("store_array_item").write('(').write(instruction.get_array_value(), true).write(", ").write(instruction.get_index_value(), true).write(", ").write(instruction.get_value(), true).write(')').end_line()
    }
    if (instruction.is(IR_Store_Struct_Member_Instruction)) {
        instruction := instruction as @IR_Store_Struct_Member_Instruction
        return file.write("store_struct_member").write('(').write(instruction.get_struct_pointer_value(), true).write(", ").write(instruction.struct_type_member.name).write(", ").write(instruction.get_value(), true).write(')').end_line()
    }
    if (instruction.is(IR_Substract_Instruction)) {
        instruction := instruction as @IR_Binary_Instruction
        return file.write(instruction.result_value, false).write(": ").write(instruction.result_value.type.name).write(" = ").write(instruction.get_left_value(), true).write(" - ").write(instruction.get_right_value(), true).end_line()
    }
    abort(clone("Unsupported type: ").append(instruction.object_type.name))
}

write :: (file: @FILE, value: @IR_Value, check_users: Boolean) -> @FILE {
    if (check_users && value.user_instructions.size == 0) {
        file.flush()
        if (value.is(IR_Variable_Value)) {
            value := value as @IR_Variable_Value
            value_version := value.version
            stderr.end_line().write(value.variable.name).write(".").write(value_version).end_line()
        }
        \ abort()
    }
    if (value.is(IR_Constant_Value)) {
        return file.write((value as @IR_Constant_Value).literal.lexeme)
    }
    if (value.is(IR_Variable_Value)) {
        return file.write((value as @IR_Variable_Value).variable.name).write('.').write((value as @IR_Variable_Value).version)
    }
    if (value.is(IR_Undefined_Value)) {
        return file.write("undefined")
    }
    abort(clone("Unsupported type: ").append(value.object_type.name))
}

include "./code/compiler/Parser.code"

abort :: (self: @Parser, unexpected_token: @Token) -> Nothing {
    stderr.write(unexpected_token.location).write(": Unexpected ").write(unexpected_token.object_type.name).write(": ").write(unexpected_token).end_line()
    abort()
}

include "./code/compiler/AST.code"

write :: (file: @FILE, compilation_unit: @Compilation_Unit) -> @FILE {
    statements := compilation_unit.statements.create_iterator()
    while (statements.has_next()) {
        statement := statements.next() as @AST_Statement
        file.write_source_line(statement.location, 0).write(statement, 0).end_line()
    }
    return file
}

write :: (file: @FILE, statement: @AST_Statement, alignment: Int) -> @FILE {
    if (statement.is(AST_Assignment_Statement)) {
        statement := statement as @AST_Assignment_Statement
        return file.write(statement.storage_expression).write(' ').write(statement.operator).write(' ').write(statement.value_expression)
    }

    if (statement.is(AST_Block_Statement)) {
        file.write('{').end_line()
        block_statements := (statement as @AST_Block_Statement).statements.create_iterator()
        while (block_statements.has_next()) {
            block_statement := block_statements.next() as @AST_Statement
            file.write_source_line(block_statement.location, alignment + 1).write(block_statement, alignment + 1).end_line()
        }
        return file.write_source_line(statement.location, alignment).write('}')
    }

    if (statement.is(AST_Break_Statement)) {
        return file.write("break")
    }

    if (statement.is(AST_Expression_Statement)) {
        return file.write((statement as @AST_Expression_Statement).expression)
    }

    if (statement.is(AST_Function_Statement)) {
        statement := statement as @AST_Function_Statement
        file.write(statement.name).write(" :: (")
        function_parameters := statement.type.parameters.create_iterator()
        if (function_parameters.has_next()) {
            loop {
                file.write(function_parameters.next() as @AST_Function_Parameter)
                if (function_parameters.has_next()) {
                    file.write(", ")
                } else {
                    break
                }
            }
        }
        file.write(") -> ").write(statement.type.return_type)
        if (statement.body == null) {
            return file
        }
        return file.write(" ").write(statement.body, alignment)
    }

    if (statement.is(AST_If_Statement)) {
        statement := statement as @AST_If_Statement
        file.write("if (").write(statement.condition_expression).write(") ").write(statement.true_statement, alignment)
        if (statement.false_statement != null) {
            file.write(" else ").write(statement.false_statement, alignment)
        }
        return file
    }

    if (statement.is(AST_Loop_Statement)) {
        statement := statement as @AST_Loop_Statement
        return file.write("loop ").write(statement.block, alignment)
    }

    if (statement.is(AST_Return_Statement)) {
        statement := statement as @AST_Return_Statement
        file.write("return")
        if (statement.value_expression != null) {
            file.write(" ").write(statement.value_expression)
        }
        return file
    }

    if (statement.is(AST_Struct_Statement)) {
        statement := statement as @AST_Struct_Statement
        file.write(statement.name).write(" :: struct")
        if (statement.base_type != null) {
            file.write(" : ").write(statement.base_type)
        }
        if (statement.members == null) {
            return file
        }
        file.write(" {").end_line()
        members := statement.members.create_iterator()
        while (members.has_next()) {
            member := members.next() as @AST_Struct_Member
            file.write_source_line(member.location, alignment + 1).write(member.name).write(": ").write(member.type).end_line()
        }
        return file.write_source_line(statement.location, alignment).write('}')
    }

    if (statement.is(AST_Variable_Statement)) {
        statement := statement as @AST_Variable_Statement
        file.write((statement as @AST_Variable_Statement).name)
        if (statement.type != null) {
            file.write(": ").write(statement.type)
            if (statement.value_expression != null) {
                file.write(" = ").write(statement.value_expression)
            }
            if (statement.is_external) {
                file.write(" = external")
            }
        } else {
            file.write(" := ").write(statement.value_expression)
        }
        return file
    }

    if (statement.is(AST_While_Statement)) {
        statement := statement as @AST_While_Statement
        return file.write("while (").write(statement.condition_expression).write(") ").write(statement.block, alignment)
    }

    file.flush()
    abort(statement.location, "Unsupported AST_Statement type: ".clone().append(statement.object_type.name))
}

write_source_line :: (file: @FILE, location: @Source_Location, alignment: Int) -> @FILE {
    file.write(location.source.file_path).write(':')
    line := location.line
    if (line < 1000) {
        file.write('0')
    }
    if (line < 100) {
        file.write('0')
    }
    if (line < 10) {
        file.write('0')
    }
    file.write(line).write(": ")

    space_count := alignment * 2
    while (space_count > 0) {
        file.write(' ')
        space_count = space_count - 1
    }

    return file
}

write :: (file: @FILE, parameter: @AST_Function_Parameter) -> @FILE {
    return file.write(parameter.name).write(": ").write(parameter.type)
}

write :: (file: @FILE, type: @AST_Type) -> @FILE {
    if (type.is(AST_Array_Type)) {
        type := type as @AST_Array_Type
        if (type.size_expression != null) {
            return file.write('[').write(type.item_type).write("; ").write(type.size_expression).write(']')
        }
        return file.write('[').write(type.item_type).write(']')
    }

    if (type.is(AST_Named_Type)) {
        return file.write((type as @AST_Named_Type).name)
    }

    if (type.is(AST_Pointer_Type)) {
        return file.write('@').write((type as @AST_Pointer_Type).pointed_type)
    }

    file.flush()
    abort(type.location, "Unsupported AST_Type type: ".clone().append(type.object_type.name))
}

write :: (file: @FILE, expression: @AST_Expression) -> @FILE {
    if (expression.is(AST_Array_Access_Expression)) {
        return file.write((expression as @AST_Array_Access_Expression).array_expression).write('[').write((expression as @AST_Array_Access_Expression).index_expression).write(']')
    }

    if (expression.is(AST_Binary_Expression)) {
        file.write('(').write((expression as @AST_Binary_Expression).left_expression)
        if (expression.is(AST_Add_Expression)) {
            return file.write(" + ").write((expression as @AST_Binary_Expression).right_expression).write(')')
        }
        if (expression.is(AST_Divide_Expression)) {
            return file.write(" / ").write((expression as @AST_Binary_Expression).right_expression).write(')')
        }
        if (expression.is(AST_Equals_Expression)) {
            return file.write(" == ").write((expression as @AST_Binary_Expression).right_expression).write(')')
        }
        if (expression.is(AST_Greater_Than_Expression)) {
            return file.write(" > ").write((expression as @AST_Binary_Expression).right_expression).write(')')
        }
        if (expression.is(AST_Greater_Than_Or_Equals_Expression)) {
            return file.write(" >= ").write((expression as @AST_Binary_Expression).right_expression).write(')')
        }
        if (expression.is(AST_Less_Than_Expression)) {
            return file.write(" < ").write((expression as @AST_Binary_Expression).right_expression).write(')')
        }
        if (expression.is(AST_Less_Than_Or_Equals_Expression)) {
            return file.write(" <= ").write((expression as @AST_Binary_Expression).right_expression).write(')')
        }
        if (expression.is(AST_Logic_And_Expression)) {
            return file.write(" && ").write((expression as @AST_Binary_Expression).right_expression).write(')')
        }
        if (expression.is(AST_Logic_Or_Expression)) {
            return file.write(" || ").write((expression as @AST_Binary_Expression).right_expression).write(')')
        }
        if (expression.is(AST_Modulo_Expression)) {
            return file.write(" // ").write((expression as @AST_Binary_Expression).right_expression).write(')')
        }
        if (expression.is(AST_Multiply_Expression)) {
            return file.write(" * ").write((expression as @AST_Binary_Expression).right_expression).write(')')
        }
        if (expression.is(AST_Not_Equals_Expression)) {
            return file.write(" != ").write((expression as @AST_Binary_Expression).right_expression).write(')')
        }
        if (expression.is(AST_Substract_Expression)) {
            return file.write(" - ").write((expression as @AST_Binary_Expression).right_expression).write(')')
        }
    }

    if (expression.is(AST_Call_Expression)) {
        file.write((expression as @AST_Call_Expression).callee_expression).write('(')
        call_arguments := (expression as @AST_Call_Expression).arguments.create_iterator()
        if (call_arguments.has_next()) {
            loop {
                file.write(call_arguments.next() as @AST_Expression)
                if (call_arguments.has_next()) {
                    file.write(", ")
                } else {
                    break
                }
            }
        }
        return file.write(')')
    }

    if (expression.is(AST_Cast_Expression)) {
        return file.write((expression as @AST_Cast_Expression).value_expression).write(" as ").write((expression as @AST_Cast_Expression).type)
    }

    if (expression.is(AST_Literal_Expression)) {
        return file.write((expression as @AST_Literal_Expression).literal)
    }

    if (expression.is(AST_New_Expression)) {
        return file.write("new ").write((expression as @AST_New_Expression).type)
    }

    if (expression.is(AST_Member_Access_Expression)) {
        return file.write((expression as @AST_Member_Access_Expression).object_expression).write('.').write((expression as @AST_Member_Access_Expression).member_name)
    }

    if (expression.is(AST_Variable_Expression)) {
        return file.write((expression as @AST_Variable_Expression).name)
    }

    file.flush()
    abort(expression.location, "Unsupported AST_Expression type: ".clone().append(expression.object_type.name))
}

include "./code/compiler/Scanner.code"

abort :: (location: @Source_Location, message: @String) -> Nothing {
    stderr.end_line().write(location).write(": ").write(message).end_line()
    abort()
}

include "./code/compiler/Token.code"

write :: (file: @FILE, token: @Token) -> @FILE {
    if (token.is(Other_Token) || token.is(Keyword_Token)) {
        file.write(27 as Int8).write("[2;37m")
    } else if (token.is(Literal_Token)) {
        file.write(27 as Int8).write("[1;33m")
    } else if (token.is(Comment_Token)) {
        file.write(27 as Int8).write("[2;33m")
    }
    file.write(token.lexeme)
    file.write(27 as Int8).write("[0m")
    return file
}

include "./code/compiler/Source.code"

write :: (self: @FILE, location: @Source_Location) -> @FILE {
    if (location == null) {
        return self.write("null")
    }
    return self.write(location.source.file_path).write(':').write(location.line).write(':').write(location.column)
}

include "./code/compiler/List.code"

write_line :: (file: @FILE, string: @String) -> @FILE {
    return file.end_line().write(string)
}

write :: (self: @FILE, number: Int) -> @FILE {
    if (number < 0) {
        return self.write('-').write(-number)
    }
    if (number >= 10) {
        self.write(number / 10)
    }
    fputc((number // 10 + '0' as Int) as Int32, self)
    return self
}

write :: (self: @FILE, string: @String) -> @FILE {
    return self.write(string.data)
}

write :: (self: @FILE, chars: @Int8) -> @FILE {
    if (fputs(chars, self) as Int < 0) {
        stderr.end_line().end_line().write("Failed to write text").end_line()
        abort()
    }
    return self
}

write :: (self: @FILE, char: Int8) -> @FILE {
    c := char as Int32
    if (fputc(c, self) != c) {
        stderr.end_line().end_line().write("Failed to write character: ").write(c as Int).end_line()
        abort()
    }
    return self
}

end_line :: (self: @FILE) -> @FILE {
    return self.write('\n')
}

flush :: (file: @FILE) -> @FILE {
    file.fflush()
    return file
}

abort :: (message: @String) -> Nothing {
    stderr.end_line().end_line().write(message).end_line()
    abort()
}

include "./code/lang/Object.code"
include "./code/lang/String.code"

include "./code/core/Platform.code"
