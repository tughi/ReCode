struct MC_Code {
    functions = make List[@MC_Function]()
}

func write(file: @FILE, code: @MC_Code) -> @FILE {
    let functions_iterator = code.functions.create_iterator()
    if functions_iterator.has_next() {
        loop {
            file.write(functions_iterator.next())
            if functions_iterator.has_next() {
                file.end_line().end_line()
            } else {
                break
            }
        }
    }
    return file
}

struct MC_Function {
    name: @String
    blocks = make List[@MC_Block]()
    prologue_block = make MC_Block(ir_block = null, function = undefined, name = "S")
    epilogue_block = make MC_Block(ir_block = null, function = undefined, name = "E")
    stack_size = 0
}

func write(file: @FILE, function: @MC_Function) -> @FILE {
    if function.name.equals("main") {
        file.write(".globl main").end_line()
    }
    file.write(function.name).write(':').end_line()
    function.blocks.for_each() {
        file.write(it)
    }
    return file
}

struct MC_Block {
    ir_block: @IR_Block
    function: @MC_Function
    name: @String
    first_instruction: @MC_Instruction = null
    last_instruction: @MC_Instruction = null
    phi_values = make List[@MC_Value]()
    live_values = make List[@MC_Value]()
    stack_size = 0
}

func append(block: @MC_Block, instruction: @MC_Instruction) -> Nothing {
    if block.last_instruction == null {
        block.first_instruction = instruction
    } else {
        block.last_instruction.next_instruction = instruction
        instruction.prev_instruction = block.last_instruction
    }
    block.last_instruction = instruction

    instruction.block = block
}

func write(file: @FILE, block: @MC_Block) -> @FILE {
    file.write_name(block).write(':').end_line()
    let instruction = block.first_instruction
    while instruction != null {
        file.write("  ").write(instruction).end_line()
        instruction = instruction.next_instruction
    }
    return file
}

func write_name(file: @FILE, block: @MC_Block) -> @FILE {
    return file.write(".L__").write(block.function.name).write("__").write(block.name)
}

\ MC_Value represents where is the IR_Value stored at the moment of execution 
struct MC_Value: Object {
    ir_value: @IR_Value
    data_size = 0

    write = func (self: @MC_Value, file: @FILE) -> @FILE {
        abort(clone("Unsupported type: ").append(self.object_type.name))
    }
}

func write(file: @FILE, value: @MC_Value) -> @FILE {
    return value.write(file)
}

func data_size(self: @MC_Value) -> i32 {
    let data_size = self.data_size
    if data_size == 0 {
        let ir_type = self.ir_value.type
        if ir_type is IR_Boolean_Type {
            data_size = 1
        } else if ir_type is IR_Int16_Type {
            data_size = 2
        } else if ir_type is IR_Int32_Type {
            data_size = 4
        } else if ir_type is IR_Int64_Type {
            data_size = 8
        } else if ir_type is IR_Int8_Type {
            data_size = 1
        } else if ir_type is IR_Pointer_Type {
            data_size = 8
        } else if ir_type is IR_UInt16_Type {
            data_size = 2
        } else if ir_type is IR_UInt32_Type {
            data_size = 4
        } else if ir_type is IR_UInt64_Type {
            data_size = 8
        } else if ir_type is IR_UInt8_Type {
            data_size = 1
        } else {
            abort(clone("Unsupported type: ").append(self.object_type.name))
        }
        self.data_size = data_size
    }
    return data_size
}

\ MC_Global_Value points to an absolute offset
struct MC_Global_Value: MC_Value(
    write = func (self: @MC_Value, file: @FILE) -> @FILE {
        return file.write(self.as(@MC_Global_Value).name)
    }
) {
    name: @String
}

\ MC_Immediate_Value is for constants
struct MC_Immediate_Value: MC_Value(
    write = func (self: @MC_Value, file: @FILE) -> @FILE {
        return file.write("$0x").write_hex(self.as(@MC_Immediate_Value).value)
    }
) {
    value: u64
}

\ MC_Local_Value points to a stack offset
struct MC_Local_Value: MC_Value(
    write = func (self: @MC_Value, file: @FILE) -> @FILE {
        let self = self.as(@MC_Local_Value)
        return file.write(self.function.stack_size - self.stack_offset).write("(%rsp)")
    }
) {
    function: @MC_Function
    stack_offset: i32
}

struct MC_Register_Value: MC_Value(
    write = func (self: @MC_Value, file: @FILE) -> @FILE {
        let self = self.as(@MC_Register_Value)
        let data_size = self.data_size()
        if data_size == 1 {
            file.write(self.register.name_b)
        } else if data_size == 2 {
            file.write(self.register.name_w)
        } else if data_size == 4 {
            file.write(self.register.name_d)
        } else if data_size == 8 {
            file.write(self.register.name_q)
        } else {
            abort(clone("Unsupported data size: ").append(data_size))
        }
        return file
    }
) {
    register: @MC_Register
}

struct MC_Instruction: Object {
    block: @MC_Block = undefined
    prev_instruction: @MC_Instruction = null
    next_instruction: @MC_Instruction = null
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        abort(clone("Unsupported type: ").append(self.object_type.name))
    }
}

func write(file: @FILE, instruction: @MC_Instruction) -> @FILE {
    return instruction.write(file)
}

struct MC_ADD_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_ADD_Instruction)
        return file.write("add").write(' ').write(instruction.source).write(", ").write(instruction.destination)
    }
) {
    source: @MC_Value
    destination: @MC_Value
}

struct MC_CALL_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        file.write("call").write(' ')
        self.as(@MC_CALL_Instruction).callee.write(file)
        return file
    }
) {
    callee: @MC_Value
}

struct MC_CLTD_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        return file.write("cltd")
    }
) {
}

struct MC_CMP_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_CMP_Instruction)
        return file.write("cmp").write(' ').write(instruction.source).write(", ").write(instruction.destination)
    }
) {
    source: @MC_Value
    destination: @MC_Value
}

struct MC_DIV_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        return file.write("div").write(' ').write(self.as(@MC_DIV_Instruction).source)
    }
) {
    source: @MC_Value
}

struct MC_IDIV_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        return file.write("idiv").write(' ').write(self.as(@MC_DIV_Instruction).source)
    }
) {
    source: @MC_Value
}

struct MC_JMP_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        return file.write("jmp").write(' ').write_name(self.as(@MC_JMP_Instruction).block)
    }
) {
    block: @MC_Block
}

struct MC_JNE_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        return file.write("jne").write(' ').write_name(self.as(@MC_JNE_Instruction).block)
    }
) {
    block: @MC_Block
}

struct MC_MOV_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_MOV_Instruction)
        let instruction_data_size = min(instruction.source.data_size(), instruction.destination.data_size())
        let suffix = ' '
        if instruction_data_size == 1 {
            suffix = 'b'
        } else if instruction_data_size == 2 {
            suffix = 'w'
        } else if instruction_data_size == 4 {
            suffix = 'l'
        } else if instruction_data_size == 8 {
            suffix = 'q'
        }
        return file.write("mov").write(suffix).write(' ').write(instruction.source).write(", ").write(instruction.destination)
    }
) {
    source: @MC_Value
    destination: @MC_Value
}

struct MC_MUL_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        return file.write("mul").write(' ').write(self.as(@MC_MUL_Instruction).source)
    }
) {
    source: @MC_Value
}

struct MC_RET_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        return file.write("ret")
    }
) {
}

struct MC_SUB_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_SUB_Instruction)
        return file.write("sub").write(' ').write(instruction.source).write(", ").write(instruction.destination)
    }
) {
    source: @MC_Value
    destination: @MC_Value
}

struct MC_XOR_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_XOR_Instruction)
        return file.write("xor").write(' ').write(instruction.source).write(", ").write(instruction.destination)
    }
) {
    source: @MC_Value
    destination: @MC_Value
}

struct MC_Register: Object {
    name_q: @String
    name_d: @String
    name_w: @String
    name_b: @String
    value: @MC_Value = null
    is_callee_saved = false
    is_caller_saved = false
    is_reserved = false
}

struct MC_Register_RAX: MC_Register(name_q = "%rax", name_d = "%eax", name_w = "%ax", name_b = "%al", is_caller_saved = true) {
}

struct MC_Register_RCX: MC_Register(name_q = "%rcx", name_d = "%ecx", name_w = "%cx", name_b = "%cl", is_caller_saved = true) {
}

struct MC_Register_RDX: MC_Register(name_q = "%rdx", name_d = "%edx", name_w = "%dx", name_b = "%dl", is_caller_saved = true) {
}

struct MC_Register_RBX: MC_Register(name_q = "%rbx", name_d = "%ebx", name_w = "%bx", name_b = "%bl", is_callee_saved = true) {
}

struct MC_Register_RSP: MC_Register(name_q = "%rsp", name_d = "%esp", name_w = "%sp", name_b = "%spl") {
}

struct MC_Register_RBP: MC_Register(name_q = "%rbp", name_d = "%ebp", name_w = "%bp", name_b = "%bpl", is_callee_saved = true) {
}

struct MC_Register_RSI: MC_Register(name_q = "%rsi", name_d = "%esi", name_w = "%si", name_b = "%sil", is_caller_saved = true) {
}

struct MC_Register_RDI: MC_Register(name_q = "%rdi", name_d = "%edi", name_w = "%di", name_b = "%dil", is_caller_saved = true) {
}

struct MC_Register_R8: MC_Register(name_q = "%r8", name_d = "%r8d", name_w = "%r8w", name_b = "%r8b", is_caller_saved = true) {
}

struct MC_Register_R9: MC_Register(name_q = "%r9", name_d = "%r9d", name_w = "%r9w", name_b = "%r9b", is_caller_saved = true) {
}

struct MC_Register_R10: MC_Register(name_q = "%r10", name_d = "%r10d", name_w = "%r10w", name_b = "%r10b", is_caller_saved = true) {
}

struct MC_Register_R11: MC_Register(name_q = "%r11", name_d = "%r11d", name_w = "%r11w", name_b = "%r11b", is_caller_saved = true) {
}

struct MC_Register_R12: MC_Register(name_q = "%r12", name_d = "%r12d", name_w = "%r12w", name_b = "%r12b", is_callee_saved = true) {
}

struct MC_Register_R13: MC_Register(name_q = "%r13", name_d = "%r13d", name_w = "%r13w", name_b = "%r13b", is_callee_saved = true) {
}

struct MC_Register_R14: MC_Register(name_q = "%r14", name_d = "%r14d", name_w = "%r14w", name_b = "%r14b", is_callee_saved = true) {
}

struct MC_Register_R15: MC_Register(name_q = "%r15", name_d = "%r15d", name_w = "%r15w", name_b = "%r15b", is_callee_saved = true) {
}
