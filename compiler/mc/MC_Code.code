struct MC_Code {
    functions = make List[@MC_Function]()
    global_values: @List[@MC_Global_Value]
}

func write(file: @FILE, code: @MC_Code) -> @FILE {
    code.global_values.for_each() {
        let global_value = it
        file.write(".extern ").write(global_value.name).end_line().end_line()
    }

    let functions_iterator = code.functions.create_iterator()
    if functions_iterator.has_next() {
        loop {
            file.write(functions_iterator.next())
            if functions_iterator.has_next() {
                file.end_line().end_line()
            } else {
                break
            }
        }
    }
    return file
}

struct MC_Function {
    name: @String
    blocks = make List[@MC_Block]()
    prologue_block = make MC_Block(
        ir_block = null
        function = undefined
        name = "S"
        global_values = undefined
    )
    epilogue_block = make MC_Block(
        ir_block = null
        function = undefined
        name = "E"
        global_values = undefined
    )
    stack_size = 0
}

func write(file: @FILE, function: @MC_Function) -> @FILE {
    if function.name.equals("main") {
        file.write(".globl main").end_line()
    }
    file.write(function.name).write(':').end_line()
    function.blocks.for_each() {
        file.write(it)
    }
    return file
}

struct MC_Block {
    ir_block: @IR_Block
    function: @MC_Function
    name: @String
    global_values: @List[@MC_Global_Value]
    first_instruction: @MC_Instruction = null
    last_instruction: @MC_Instruction = null
    phi_values = make List[@MC_Value]()
    live_values = make List[@MC_Value]()
    stack_size = 0
}

func append(block: @MC_Block, instruction: @MC_Instruction) -> Nothing {
    if block.last_instruction == null {
        block.first_instruction = instruction
    } else {
        block.last_instruction.next_instruction = instruction
        instruction.prev_instruction = block.last_instruction
    }
    block.last_instruction = instruction

    instruction.block = block
}

func write(file: @FILE, block: @MC_Block) -> @FILE {
    file.write_name(block).write(':').end_line()
    let instruction = block.first_instruction
    while instruction != null {
        file.write("  ").write(instruction).end_line()
        instruction = instruction.next_instruction
    }
    return file
}

func write_name(file: @FILE, block: @MC_Block) -> @FILE {
    return file.write(".L__").write(block.function.name).write("__").write(block.name)
}

\ MC_Value represents where is the IR_Value stored at the moment of execution 
struct MC_Value: Object {
    ir_value: @IR_Value

    has_register = func (self: @MC_Value) -> bool {
        return false
    }

    get_register = func (self: @MC_Value) -> @MC_Register {
        abort(self.object_type.name.clone().append(" does not have a register"))
    }

    write = func (self: @MC_Value, file: @FILE) -> @FILE {
        abort(clone("Unsupported type: ").append(self.object_type.name))
    }
}

func write(file: @FILE, value: @MC_Value) -> @FILE {
    return value.write(file)
}

\ MC_Global_Value points to an absolute offset
struct MC_Global_Value: MC_Value(
    write = func (self: @MC_Value, file: @FILE) -> @FILE {
        return file.write(self.as(@MC_Global_Value).name)
    }
) {
    name: @String
}

\ MC_Immediate_Value is for constants
struct MC_Immediate_Value: MC_Value(
    write = func (self: @MC_Value, file: @FILE) -> @FILE {
        return file.write("$0x").write_hex(self.as(@MC_Immediate_Value).value)
    }
) {
    value: u64
}

\ MC_Local_Value points to a stack offset
struct MC_Local_Value: MC_Value(
    write = func (self: @MC_Value, file: @FILE) -> @FILE {
        let self = self.as(@MC_Local_Value)
        return file.write(self.function.stack_size - self.stack_offset).write("(%rsp)")
    }
) {
    function: @MC_Function
    stack_offset: i32
}

struct MC_Memory_Value: MC_Value(
    has_register = func (self: @MC_Value) -> bool {
        return true
    }

    get_register = func (self: @MC_Value) -> @MC_Register {
        return self.as(@MC_Memory_Value).register
    }

    write = func (self: @MC_Value, file: @FILE) -> @FILE {
        let self = self.as(@MC_Memory_Value)
        return file.write(self.offset).write('(').write(self.register.name_q).write(')')
    }
) {
    register: @MC_Register
    offset: i32
}

struct MC_Register_Value: MC_Value(
    has_register = func (self: @MC_Value) -> bool {
        return true
    }

    get_register = func (self: @MC_Value) -> @MC_Register {
        return self.as(@MC_Register_Value).register
    }

    write = func (self: @MC_Value, file: @FILE) -> @FILE {
        let self = self.as(@MC_Register_Value)
        return file.write(self.register.name_q)
    }
) {
    register: @MC_Register
}

struct MC_Instruction: Object {
    block: @MC_Block = undefined
    prev_instruction: @MC_Instruction = null
    next_instruction: @MC_Instruction = null
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        abort(clone("Unsupported type: ").append(self.object_type.name))
    }
}

func write(file: @FILE, instruction: @MC_Instruction) -> @FILE {
    return instruction.write(file)
}

struct MC_Operand: Object {
    size: i32

    write = func (self: @MC_Operand, file: @FILE) -> @FILE {
        abort(clone("Unsupported type: ").append(self.object_type.name))
    }
}

func write(file: @FILE, operand: @MC_Operand) -> @FILE {
    return operand.write(file)
}

struct MC_Immediate_Operand: MC_Operand(
    write = func (self: @MC_Operand, file: @FILE) -> @FILE {
        return file.write("$0x").write_hex(self.as(@MC_Immediate_Operand).value)
    }
) {
    value: u64
}

struct MC_Register_Operand: MC_Operand(
    write = func (self: @MC_Operand, file: @FILE) -> @FILE {
        let self = self.as(@MC_Register_Operand)
        if self.size == 1 {
            return file.write(self.register.name_b)
        } else if self.size == 2 {
            return file.write(self.register.name_w)
        } else if self.size == 4 {
            return file.write(self.register.name_d)
        } else if self.size == 8 {
            return file.write(self.register.name_q)
        }
        abort(clone("Unsupported size: ").append(self.size))
    }
) {
    register: @MC_Register
}

struct MC_Label_Operand: MC_Operand(
    write = func (self: @MC_Operand, file: @FILE) -> @FILE {
        let self = self.as(@MC_Label_Operand)
        return file.write(self.label)
    }
) {
    label: @String
}

struct MC_Memory_Operand: MC_Operand(
    write = func (self: @MC_Operand, file: @FILE) -> @FILE {
        let self = self.as(@MC_Memory_Operand)
        return file.write(self.offset).write('(').write(self.base.name_q).write(')')
    }
) {
    base: @MC_Register
    offset: i32
}

struct MC_Stack_Operand: MC_Operand(
    write = func (self: @MC_Operand, file: @FILE) -> @FILE {
        let self = self.as(@MC_Stack_Operand)
        return file.write(self.function.stack_size - self.stack_offset).write("(%rsp)")
    }
) {
    function: @MC_Function
    stack_offset: i32
}

struct MC_Instruction_Comment: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let self = self.as(@MC_Instruction_Comment)
        file.write("# ")
        if self.ir_instruction.result_value != null {
            file.write(self.ir_instruction.result_value).write(": ").write(self.ir_instruction.result_value.type.name).write(" = ")
        }
        self.ir_instruction.print(file)
        return file
    }
) {
    ir_instruction: @IR_Instruction
}

struct MC_Line_Comment: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        return file.write("# ").write(self.as(@MC_Line_Comment).text)
    }
) {
    text: @String
}

struct MC_ADD_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_ADD_Instruction)
        return file.write("add").write(' ').write(instruction.source).write(", ").write(instruction.destination)
    }
) {
    source: @MC_Operand
    destination: @MC_Operand
}

struct MC_CALL_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let self = self.as(@MC_CALL_Instruction)
        file.write("call").write(' ')
        if self.indirect {
            file.write('*')
        }
        self.callee.write(file)
        return file
    }
) {
    callee: @MC_Operand
    indirect = false
}

struct MC_CLTD_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        return file.write("cltd")
    }
) {
}

struct MC_CMP_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_CMP_Instruction)
        return file.write("cmp").write(' ').write(instruction.source).write(", ").write(instruction.destination)
    }
) {
    source: @MC_Operand
    destination: @MC_Operand
}

struct MC_CQO_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        return file.write("cqo")
    }
) {
}

struct MC_DIV_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let self = self.as(@MC_DIV_Instruction)
        return file.write("div").write_size_suffix(self.source.size).write(' ').write(self.source)
    }
) {
    source: @MC_Operand
}

struct MC_IDIV_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let self = self.as(@MC_IDIV_Instruction)
        return file.write("idiv").write_size_suffix(self.source.size).write(' ').write(self.source)
    }
) {
    source: @MC_Operand
}

struct MC_IMUL_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let self = self.as(@MC_IMUL_Instruction)
        return file.write("imul").write_size_suffix(self.source.size).write(' ').write(self.source).write(", ").write(self.destination)
    }
) {
    source: @MC_Operand
    destination: @MC_Operand
}

struct MC_JMP_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        return file.write("jmp").write(' ').write_name(self.as(@MC_JMP_Instruction).block)
    }
) {
    block: @MC_Block
}

struct MC_JNE_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        return file.write("jne").write(' ').write_name(self.as(@MC_JNE_Instruction).block)
    }
) {
    block: @MC_Block
}

struct MC_LEA_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_LEA_Instruction)
        return file.write("lea").write(' ').write(instruction.source).write(", ").write(instruction.destination)
    }
) {
    source: @MC_Operand
    destination: @MC_Operand
}

struct MC_MOV_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_MOV_Instruction)
        if instruction.source == null {
            abort("Illegal state: source is null")
        }
        if instruction.destination == null {
            abort("Illegal state: destination is null")
        }
        let instruction_data_size = min(instruction.source.size, instruction.destination.size)
        return file.write("mov").write_size_suffix(instruction_data_size).write(' ').write(instruction.source).write(", ").write(instruction.destination)
    }
) {
    source: @MC_Operand
    destination: @MC_Operand
}

struct MC_MOVSX_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_MOVSX_Instruction)
        return file.write("movs").write_size_suffix(instruction.source.size).write_size_suffix(instruction.destination.size).write(' ').write(instruction.source).write(", ").write(instruction.destination)
    }
) {
    source: @MC_Operand
    destination: @MC_Operand
}

struct MC_MOVZX_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_MOVZX_Instruction)
        return file.write("movz").write_size_suffix(instruction.source.size).write_size_suffix(instruction.destination.size).write(' ').write(instruction.source).write(", ").write(instruction.destination)
    }
) {
    source: @MC_Operand
    destination: @MC_Operand
}

struct MC_MUL_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let self = self.as(@MC_MUL_Instruction)
        return file.write("mul").write_size_suffix(self.source.size).write(' ').write(self.source)
    }
) {
    source: @MC_Operand
}

struct MC_NEG_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        return file.write("neg").write(' ').write(self.as(@MC_NEG_Instruction).destination)
    }
) {
    destination: @MC_Operand
}

struct MC_POP_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_POP_Instruction)
        return file.write("pop").write_size_suffix(instruction.destination.size).write(' ').write(instruction.destination)
    }
) {
    destination: @MC_Operand
}

struct MC_PUSH_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_PUSH_Instruction)
        return file.write("push").write_size_suffix(instruction.source.size).write(' ').write(instruction.source)
    }
) {
    source: @MC_Operand
}

struct MC_RET_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        return file.write("ret")
    }
) {
}

struct MC_SETA_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_SETA_Instruction)
        return file.write("seta").write(' ').write(instruction.destination)
    }
) {
    destination: @MC_Operand
}

struct MC_SETAE_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_SETAE_Instruction)
        return file.write("setae").write(' ').write(instruction.destination)
    }
) {
    destination: @MC_Operand
}

struct MC_SETB_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_SETB_Instruction)
        return file.write("setb").write(' ').write(instruction.destination)
    }
) {
    destination: @MC_Operand
}

struct MC_SETBE_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_SETBE_Instruction)
        return file.write("setbe").write(' ').write(instruction.destination)
    }
) {
    destination: @MC_Operand
}

struct MC_SETE_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_SETE_Instruction)
        return file.write("sete").write(' ').write(instruction.destination)
    }
) {
    destination: @MC_Operand
}

struct MC_SETG_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_SETG_Instruction)
        return file.write("setg").write(' ').write(instruction.destination)
    }
) {
    destination: @MC_Operand
}

struct MC_SETGE_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_SETGE_Instruction)
        return file.write("setge").write(' ').write(instruction.destination)
    }
) {
    destination: @MC_Operand
}

struct MC_SETL_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_SETL_Instruction)
        return file.write("setl").write(' ').write(instruction.destination)
    }
) {
    destination: @MC_Operand
}

struct MC_SETLE_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_SETLE_Instruction)
        return file.write("setle").write(' ').write(instruction.destination)
    }
) {
    destination: @MC_Operand
}

struct MC_SETNE_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_SETNE_Instruction)
        return file.write("setne").write(' ').write(instruction.destination)
    }
) {
    destination: @MC_Operand
}

struct MC_SUB_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_SUB_Instruction)
        return file.write("sub").write(' ').write(instruction.source).write(", ").write(instruction.destination)
    }
) {
    source: @MC_Operand
    destination: @MC_Operand
}

struct MC_XOR_Instruction: MC_Instruction(
    write = func (self: @MC_Instruction, file: @FILE) -> @FILE {
        let instruction = self.as(@MC_XOR_Instruction)
        return file.write("xor").write(' ').write(instruction.source).write(", ").write(instruction.destination)
    }
) {
    source: @MC_Operand
    destination: @MC_Operand
}

func write_size_suffix(file: @FILE, size: i32) -> @FILE {
    if size == 1 {
        file.write('b')
    } else if size == 2 {
        file.write('w')
    } else if size == 4 {
        file.write('l')
    } else if size == 8 {
        file.write('q')
    }
    return file
}

struct MC_Register: Object {
    name_q: @String
    name_d: @String
    name_w: @String
    name_b: @String
    is_callee_saved = false
    is_caller_saved = false
    is_reserved = false
    is_used = false
}

struct MC_Register_RAX: MC_Register(name_q = "%rax", name_d = "%eax", name_w = "%ax", name_b = "%al", is_caller_saved = true) {
}

struct MC_Register_RCX: MC_Register(name_q = "%rcx", name_d = "%ecx", name_w = "%cx", name_b = "%cl", is_caller_saved = true) {
}

struct MC_Register_RDX: MC_Register(name_q = "%rdx", name_d = "%edx", name_w = "%dx", name_b = "%dl", is_caller_saved = true) {
}

struct MC_Register_RBX: MC_Register(name_q = "%rbx", name_d = "%ebx", name_w = "%bx", name_b = "%bl", is_callee_saved = true) {
}

struct MC_Register_RSP: MC_Register(name_q = "%rsp", name_d = "%esp", name_w = "%sp", name_b = "%spl") {
}

struct MC_Register_RBP: MC_Register(name_q = "%rbp", name_d = "%ebp", name_w = "%bp", name_b = "%bpl", is_callee_saved = true) {
}

struct MC_Register_RSI: MC_Register(name_q = "%rsi", name_d = "%esi", name_w = "%si", name_b = "%sil", is_caller_saved = true) {
}

struct MC_Register_RDI: MC_Register(name_q = "%rdi", name_d = "%edi", name_w = "%di", name_b = "%dil", is_caller_saved = true) {
}

struct MC_Register_R8: MC_Register(name_q = "%r8", name_d = "%r8d", name_w = "%r8w", name_b = "%r8b", is_caller_saved = true) {
}

struct MC_Register_R9: MC_Register(name_q = "%r9", name_d = "%r9d", name_w = "%r9w", name_b = "%r9b", is_caller_saved = true) {
}

struct MC_Register_R10: MC_Register(name_q = "%r10", name_d = "%r10d", name_w = "%r10w", name_b = "%r10b", is_caller_saved = true) {
}

struct MC_Register_R11: MC_Register(name_q = "%r11", name_d = "%r11d", name_w = "%r11w", name_b = "%r11b", is_caller_saved = true) {
}

struct MC_Register_R12: MC_Register(name_q = "%r12", name_d = "%r12d", name_w = "%r12w", name_b = "%r12b", is_callee_saved = true) {
}

struct MC_Register_R13: MC_Register(name_q = "%r13", name_d = "%r13d", name_w = "%r13w", name_b = "%r13b", is_callee_saved = true) {
}

struct MC_Register_R14: MC_Register(name_q = "%r14", name_d = "%r14d", name_w = "%r14w", name_b = "%r14b", is_callee_saved = true) {
}

struct MC_Register_R15: MC_Register(name_q = "%r15", name_d = "%r15d", name_w = "%r15w", name_b = "%r15b", is_callee_saved = true) {
}
