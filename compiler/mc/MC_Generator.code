func convert(code: @IR_Code, file: @FILE) -> @MC_Code {
    let generator = make MC_Generator(file = file)
    return generator.convert(code)
}

struct MC_Generator {
    file: @FILE

    register_rax = make @MC_Register_RAX()
    register_rcx = make @MC_Register_RCX()
    register_rdx = make @MC_Register_RDX()
    register_rbx = make @MC_Register_RBX()
    register_rsp = make @MC_Register_RSP()
    register_rbp = make @MC_Register_RBP()
    register_rsi = make @MC_Register_RSI()
    register_rdi = make @MC_Register_RDI()
    register_r8 = make @MC_Register_R8()
    register_r9 = make @MC_Register_R9()
    register_r10 = make @MC_Register_R10()
    register_r11 = make @MC_Register_R11()
    register_r12 = make @MC_Register_R12()
    register_r13 = make @MC_Register_R13()
    register_r14 = make @MC_Register_R14()
    register_r15 = make @MC_Register_R15()

    current_function: @MC_Function = null
}

func parameter_register(self: @MC_Generator, index: i32) -> @MC_Register {
    let register: @MC_Register
    if index == 0 {
        register = self.register_rdi
    } else if index == 1 {
        register = self.register_rsi
    } else if index == 2 {
        register = self.register_rdx
    } else if index == 3 {
        register = self.register_rcx
    } else if index == 4 {
        register = self.register_r8
    } else if index == 5 {
        register = self.register_r9
    } else {
        register = null
    }
    return register
}

func convert(self: @MC_Generator, ir_code: @IR_Code) -> @MC_Code {
    ir_code.compute_live_values()

    let mc_code = make @MC_Code()
    ir_code.global_symbols.for_each() {
        let symbol = it
        if symbol is IR_Function {
            let function = self.convert_function(symbol.as(@IR_Function))
            mc_code.functions.append(function)
        }
    }
    return mc_code
}

func convert_function(self: @MC_Generator, ir_function: @IR_Function) -> @MC_Function {
    let function = make @MC_Function(
        name = ir_function.name
    )
    self.current_function = function

    \ TODO: spill test
    \   - the spill check has to take into account caller and callee saved registers
    \   - check if we have enough callee saved registers to store all live values after all calls
    \   - values that are live after a call are stored in two places to be avaiable before and after the call
    \   - max live values after all calls give the required number of callee saved registers
    \   - if spilling is required, the stack size is increased and the live values are stored in the stack
    \   - constant values and stack slots are not spilled, nor moved to callee saved registers
    \   - spilling is calculated for each live value based on spill cost formula:
    \       (sum of ((block_uses + block_defs) * 10 ^ loop_depth) for each block in the function) / interference_degree
    \   - interference degree is the number of neighbors in the interference graph
    \   - the spill cost is calculated for each live value and the live value with the lowest spill cost is spilled

    \ TODO: stack size - calculate stack size

    \ TODO: map each live value to a register, stack slot or memory location

    \ reset processed flag
    ir_function.blocks.for_each() {
        it.processed = false
    }

    \ convert blocks via forward traversal
    self.convert_block(ir_function.blocks.first(), null)

    return function
}

func convert_block(self: @MC_Generator, ir_block: @IR_Block, predecessor_block_values: @List[@MC_Value]) -> Nothing {
    if ir_block.processed {
        abort("Block already processed")
    }

    let mc_block = make @MC_Block(
        function = self.current_function
        name = ir_block.name
    )
    self.current_function.blocks.append(mc_block)

    \ init block's live values
    if predecessor_block_values != null {
        \ merge live values from predecessor block
        predecessor_block_values.for_each() {
            mc_block.live_values.append(it)
        }
    } else {
        \ this must be the first block
        if ir_block.function.parameters.size > 0 {
            \ create live values from function parameters
            ir_block.function.parameters.for_each_indexed() {
                let ir_parameter = it
                let mc_parameter = make @MC_Register_Value(
                    ir_value = ir_parameter.value
                    register = self.parameter_register(it_index.as(i32))
                )
                mc_block.live_values.append(mc_parameter)
            }
        }
    }

    ir_block.for_each_instruction() {
        self.convert_instruction(it, mc_block)
    }

    \ mark block as processed
    ir_block.processed = true

    \ convert successors
    if ir_block.last_instruction is IR_Branch_Instruction {
        let ir_branch_instruction = ir_block.last_instruction.as(@IR_Branch_Instruction)
        self.convert_block(ir_branch_instruction.true_block, mc_block.live_values)
        self.convert_block(ir_branch_instruction.false_block, mc_block.live_values)
    } else if ir_block.last_instruction is IR_Jump_Instruction {
        let ir_jump_instruction = ir_block.last_instruction.as(@IR_Jump_Instruction)
        self.convert_block(ir_jump_instruction.block, mc_block.live_values)
    }
}

func convert_instruction(self: @MC_Generator, ir_instruction: @IR_Instruction, mc_block: @MC_Block) -> Nothing {
    if ir_instruction is IR_Add_Instruction {
        self.convert_add_instruction(ir_instruction.as(@IR_Add_Instruction), mc_block)
    } else if ir_instruction is IR_Constant_Instruction {
        let literal = ir_instruction.as(@IR_Constant_Instruction).literal
        if literal is Integer_Token {
            mc_block.live_values.append(make @MC_Immediate_Value(
                ir_value = ir_instruction.result_value
                literal = literal.as(@Integer_Token)
            ))
        } else {
            abort(literal.object_type)
        }
    } else if ir_instruction is IR_Direct_Call_Instruction {
        self.convert_direct_call_instruction(ir_instruction.as(@IR_Direct_Call_Instruction), mc_block)
    } else if ir_instruction is IR_Divide_Instruction {
        self.convert_divide_instruction(ir_instruction.as(@IR_Divide_Instruction), mc_block)
    } else if ir_instruction is IR_Modulo_Instruction {
        self.convert_modulo_instruction(ir_instruction.as(@IR_Modulo_Instruction), mc_block)
    } else if ir_instruction is IR_Multiply_Instruction {
        self.convert_multiply_instruction(ir_instruction.as(@IR_Multiply_Instruction), mc_block)
    } else if ir_instruction is IR_Return_Instruction {
        self.convert_return_instruction(ir_instruction.as(@IR_Return_Instruction), mc_block)
    } else if ir_instruction is IR_Substract_Instruction {
        self.convert_substract_instruction(ir_instruction.as(@IR_Substract_Instruction), mc_block)
    } else {
        stderr.write(self.current_function).end_line()
        abort(ir_instruction.object_type)
    }

    \ cleanup live values
    if ir_instruction.next_instruction != null {
        mc_block.live_values.for_each() {
            if not ir_instruction.live_out_values.contains(it.ir_value) {
                mc_block.live_values.remove(it)
            }
        }
        mc_block.live_values.prune()
    }
}

func convert_add_instruction(self: @MC_Generator, ir_add_instruction: @IR_Add_Instruction, mc_block: @MC_Block) -> Nothing {
    let mc_register_value = self.make_register_value(
        mc_block
        ir_add_instruction.result_value
        self.find_free_caller_saved_register(mc_block)
    )
    mc_block.append(make @MC_MOV_Instruction(
        source = mc_block.find_value(ir_add_instruction.get_left_value())
        destination = mc_register_value
    ))
    mc_block.append(make @MC_ADD_Instruction(
        source = mc_block.find_value(ir_add_instruction.get_right_value())
        destination = mc_register_value
    ))
}

func convert_direct_call_instruction(self: @MC_Generator, ir_direct_call_instruction: @IR_Direct_Call_Instruction, mc_block: @MC_Block) -> Nothing {
    \ move live values to callee saved registers or stack slots
    ir_direct_call_instruction.next_instruction.live_in_values.for_each() {
        let ir_value = it
        if ir_value != ir_direct_call_instruction.result_value {
            let mc_register_value = mc_block.find_register_value(it)
            if mc_register_value != null and mc_register_value.register.is_caller_saved {
                \ move value to callee saved register
                let mc_register = self.find_free_callee_saved_register(mc_block)
                self.make_register_value(mc_block, ir_value, mc_register)
            }
        }
    }

    \ map arguments to registers
    if ir_direct_call_instruction.arguments_size > 0 {
        let argument_index = 0
        while argument_index < ir_direct_call_instruction.arguments_size {
            self.make_register_value(
                mc_block
                ir_direct_call_instruction.get_argument_value(argument_index)
                self.parameter_register(argument_index)
            )
            argument_index = argument_index + 1
        }
    }

    \ create call instruction
    let ir_function = ir_direct_call_instruction.function
    mc_block.append(make @MC_CALL_Instruction(
        callee = make @MC_Global_Value(
            ir_value = null
            name = ir_function.name
        )
    ))

    \ remove all caller-saved register values
    mc_block.live_values.for_each() {
        let mc_value = it
        if mc_value is MC_Register_Value {
            let mc_register_value = mc_value.as(@MC_Register_Value)
            if mc_register_value.register.is_caller_saved {
                mc_block.live_values.remove(mc_register_value)
            }
        }
    }
    mc_block.live_values.prune()

    \ map return value to rax
    if ir_function.return_type != null {
        let return_value = make @MC_Register_Value(
            ir_value = ir_direct_call_instruction.result_value
            register = self.register_rax
        )
        mc_block.live_values.append(return_value)
    }
}

func convert_divide_instruction(self: @MC_Generator, ir_divide_instruction: @IR_Divide_Instruction, mc_block: @MC_Block) -> Nothing {
    self.make_division(mc_block, ir_divide_instruction.get_left_value(), ir_divide_instruction.get_right_value())
    mc_block.live_values.prepend(make @MC_Register_Value(
        ir_value = ir_divide_instruction.result_value
        register = self.register_rax
    ))
}

func make_division(self: @MC_Generator, mc_block: @MC_Block, left_ir_value: @IR_Value, right_ir_value: @IR_Value) -> Nothing {
    \ reserve rax and rdx
    self.release_register(mc_block, self.register_rax)
    self.register_rax.is_reserved = true
    self.release_register(mc_block, self.register_rdx)
    self.register_rdx.is_reserved = true

    let left_mc_value = mc_block.find_value(left_ir_value)
    let right_mc_value = mc_block.find_value(right_ir_value)
    mc_block.append(make @MC_MOV_Instruction(
        source = left_mc_value
        destination = make @MC_Register_Value(
            ir_value = null
            data_size = left_mc_value.data_size()
            register = self.register_rax
        )
    ))
    mc_block.append(make @MC_CLTD_Instruction())
    mc_block.append(make @MC_IDIV_Instruction(
        source = right_mc_value
    ))

    \ unreserve rax and rdx
    self.register_rdx.is_reserved = false
    self.register_rax.is_reserved = false
}

func convert_modulo_instruction(self: @MC_Generator, ir_modulo_instruction: @IR_Modulo_Instruction, mc_block: @MC_Block) -> Nothing {
    self.make_division(mc_block, ir_modulo_instruction.get_left_value(), ir_modulo_instruction.get_right_value())
    mc_block.live_values.prepend(make @MC_Register_Value(
        ir_value = ir_modulo_instruction.result_value
        register = self.register_rdx
    ))
}

func convert_multiply_instruction(self: @MC_Generator, ir_multiply_instruction: @IR_Multiply_Instruction, mc_block: @MC_Block) -> Nothing {
    let mc_register_value = self.make_register_value(
        mc_block
        ir_multiply_instruction.result_value
        self.register_rax
    )
    mc_block.append(make @MC_MOV_Instruction(
        source = mc_block.find_value(ir_multiply_instruction.get_left_value())
        destination = mc_register_value
    ))
    mc_block.append(make @MC_MUL_Instruction(
        source = mc_block.find_value(ir_multiply_instruction.get_right_value())
    ))
}

func convert_return_instruction(self: @MC_Generator, ir_return_instruction: @IR_Return_Instruction, mc_block: @MC_Block) -> Nothing {
    let ir_return_value = ir_return_instruction.get_return_value()
    if ir_return_value != null {
        self.make_register_value(mc_block, ir_return_value, self.register_rax)
    }

    mc_block.append(make @MC_RET_Instruction())
}

func convert_substract_instruction(self: @MC_Generator, ir_substract_instruction: @IR_Substract_Instruction, mc_block: @MC_Block) -> Nothing {
    let mc_register_value = self.make_register_value(
        mc_block
        ir_substract_instruction.result_value
        self.find_free_caller_saved_register(mc_block)
    )
    mc_block.append(make @MC_MOV_Instruction(
        source = mc_block.find_value(ir_substract_instruction.get_left_value())
        destination = mc_register_value
    ))
    mc_block.append(make @MC_SUB_Instruction(
        source = mc_block.find_value(ir_substract_instruction.get_right_value())
        destination = mc_register_value
    ))
}

func find_free_callee_saved_register(self: @MC_Generator, mc_block: @MC_Block) -> @MC_Register {
    if self.register_rbx.is_free(mc_block) {
        return self.register_rbx
    }
    if self.register_rbp.is_free(mc_block) {
        return self.register_rbp
    }
    if self.register_r12.is_free(mc_block) {
        return self.register_r12
    }
    if self.register_r13.is_free(mc_block) {
        return self.register_r13
    }
    if self.register_r14.is_free(mc_block) {
        return self.register_r14
    }
    if self.register_r15.is_free(mc_block) {
        return self.register_r15
    }
    abort("No free callee saved register")
}

func find_free_caller_saved_register(self: @MC_Generator, mc_block: @MC_Block) -> @MC_Register {
    if self.register_r11.is_free(mc_block) {
        return self.register_r11
    }
    if self.register_r10.is_free(mc_block) {
        return self.register_r10
    }
    if self.register_r9.is_free(mc_block) {
        return self.register_r9
    }
    if self.register_r8.is_free(mc_block) {
        return self.register_r8
    }
    if self.register_rax.is_free(mc_block) {
        return self.register_rax
    }
    if self.register_rdi.is_free(mc_block) {
        return self.register_rdi
    }
    if self.register_rsi.is_free(mc_block) {
        return self.register_rsi
    }
    if self.register_rdx.is_free(mc_block) {
        return self.register_rdx
    }
    if self.register_rcx.is_free(mc_block) {
        return self.register_rcx
    }
    abort("No free caller saved register")
}

func is_free(self: @MC_Register, mc_block: @MC_Block) -> bool {
    if self.is_reserved {
        return false
    }
    mc_block.live_values.for_each() {
        let mc_value = it
        if mc_value is MC_Register_Value {
            let mc_register_value = mc_value.as(@MC_Register_Value)
            if mc_register_value.register == self {
                return false
            }
        }
    }
    return true
}

func find_value(self: @MC_Block, ir_value: @IR_Value) -> @MC_Value {
    self.live_values.for_each() {
        let mc_value = it
        if mc_value.ir_value == ir_value {
            return mc_value
        }
    }
    return null
}

func find_register_value(self: @MC_Block, ir_value: @IR_Value) -> @MC_Register_Value {
    self.live_values.for_each() {
        let mc_value = it
        if mc_value is MC_Register_Value {
            let mc_value = mc_value.as(@MC_Register_Value)
            if mc_value.ir_value == ir_value {
                return mc_value
            }
        }
    }
    return null
}

func find_register_value(self: @MC_Block, register: @MC_Register) -> @MC_Register_Value {
    self.live_values.for_each() {
        let mc_value = it
        if mc_value is MC_Register_Value {
            let mc_value = mc_value.as(@MC_Register_Value)
            if mc_value.register == register {
                return mc_value
            }
        }
    }
    return null
}

func release_register(self: @MC_Generator, block: @MC_Block, register: @MC_Register) -> Nothing {
    let value = block.find_register_value(register)
    if value != null {
        \ move value to another free register
        let new_value = make @MC_Register_Value(
            ir_value = value.ir_value
            register = self.find_free_caller_saved_register(block)
        )
        block.append(make @MC_MOV_Instruction(
            source = value
            destination = new_value
        ))
        block.live_values.prepend(new_value)
        block.live_values.remove(value)
        block.live_values.prune()
    }
}

func make_register_value(self: @MC_Generator, mc_block: @MC_Block, ir_value: @IR_Value, mc_register: @MC_Register) -> @MC_Register_Value {
    \ check if register is already mapped to another live value
    let mc_value = mc_block.find_register_value(mc_register)
    if mc_value != null {
        if mc_value.ir_value == ir_value {
            \ mapping already exists
            return mc_value
        }
        stderr.write(mc_block).end_line()
        mc_block.live_values.for_each() {
            stderr.write(it.ir_value).write(": ").write(it).end_line()
        }
        abort("Register ".clone().append(mc_register.name_q).append(" is mapped to value ").append(mc_value.ir_value.name))
    }

    \ check if live value is already mapped
    mc_block.live_values.for_each() {
        let mc_value = it
        if mc_value.ir_value == ir_value {
            if mc_value is MC_Register_Value {
                let old_mc_register_value = mc_value.as(@MC_Register_Value)
                if old_mc_register_value.register != mc_register {
                    \ move value to other register
                    let new_mc_register_value = make @MC_Register_Value(
                        ir_value = ir_value
                        register = mc_register
                    )
                    mc_block.append(make @MC_MOV_Instruction(
                        source = old_mc_register_value
                        destination = new_mc_register_value
                    ))

                    \ replace old register value with new one
                    mc_block.live_values.prepend(new_mc_register_value)
                    mc_block.live_values.remove(old_mc_register_value)
                    mc_block.live_values.prune()

                    return new_mc_register_value
                }
                return old_mc_register_value
            } else if mc_value is MC_Immediate_Value {
                \ move value to register
                let mc_immediate_value = mc_value.as(@MC_Immediate_Value)
                let mc_register_value = make @MC_Register_Value(
                    ir_value = mc_immediate_value.ir_value
                    register = mc_register
                )
                mc_block.append(make @MC_MOV_Instruction(
                    source = mc_immediate_value
                    destination = mc_register_value
                ))
                mc_block.live_values.prepend(mc_register_value)
                return mc_register_value
            } else {
                abort(mc_value.object_type)
            }
        }
    }

    \ value not assigned yet
    let mc_register_value = make @MC_Register_Value(
        ir_value = ir_value
        register = mc_register
    )
    mc_block.live_values.prepend(mc_register_value)
    return mc_register_value
}
