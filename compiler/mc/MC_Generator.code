func convert(code: @IR_Code, file: @FILE) -> @MC_Code {
    let generator = make MC_Generator(file = file)
    return generator.convert(code)
}

struct MC_Generator {
    file: @FILE

    register_rax = make @MC_Register_RAX()
    register_rcx = make @MC_Register_RCX()
    register_rdx = make @MC_Register_RDX()
    register_rbx = make @MC_Register_RBX()
    register_rsp = make @MC_Register_RSP()
    register_rbp = make @MC_Register_RBP()
    register_rsi = make @MC_Register_RSI()
    register_rdi = make @MC_Register_RDI()
    register_r8 = make @MC_Register_R8()
    register_r9 = make @MC_Register_R9()
    register_r10 = make @MC_Register_R10()
    register_r11 = make @MC_Register_R11()
    register_r12 = make @MC_Register_R12()
    register_r13 = make @MC_Register_R13()
    register_r14 = make @MC_Register_R14()
    register_r15 = make @MC_Register_R15()

    current_function: @MC_Function = null
}

func parameter_register(self: @MC_Generator, index: i32) -> @MC_Register {
    let register: @MC_Register
    if index == 0 {
        register = self.register_rdi
    } else if index == 1 {
        register = self.register_rsi
    } else if index == 2 {
        register = self.register_rdx
    } else if index == 3 {
        register = self.register_rcx
    } else if index == 4 {
        register = self.register_r8
    } else if index == 5 {
        register = self.register_r9
    } else {
        register = null
    }
    return register
}

func convert(self: @MC_Generator, ir_code: @IR_Code) -> @MC_Code {
    let mc_code = make @MC_Code()
    ir_code.global_symbols.for_each() {
        let symbol = it
        if symbol is IR_Function {
            let function = self.convert_function(symbol.as(@IR_Function))
            mc_code.functions.append(function)
        }
    }
    return mc_code
}

func convert_function(self: @MC_Generator, ir_function: @IR_Function) -> @MC_Function {
    let function = make @MC_Function(
        name = ir_function.name
    )
    self.current_function = function

    \ TODO: spill test
    \   - the spill check has to take into account caller and callee saved registers
    \   - check if we have enough callee saved registers to store all live values after all calls
    \   - values that are live after a call are stored in two places to be avaiable before and after the call
    \   - max live values after all calls give the required number of callee saved registers
    \   - if spilling is required, the stack size is increased and the live values are stored in the stack
    \   - constant values and stack slots are not spilled, nor moved to callee saved registers
    \   - spilling is calculated for each live value based on spill cost formula:
    \       (sum of ((block_uses + block_defs) * 10 ^ loop_depth) for each block in the function) / interference_degree
    \   - interference degree is the number of neighbors in the interference graph
    \   - the spill cost is calculated for each live value and the live value with the lowest spill cost is spilled

    \ TODO: stack size - calculate stack size

    \ TODO: map each live value to a register, stack slot or memory location

    \ reset processed flag
    ir_function.blocks.for_each() {
        it.processed = false
    }

    \ convert blocks via forward traversal
    self.convert_block(ir_function.blocks.first(), null)

    return function
}

func convert_block(self: @MC_Generator, ir_block: @IR_Block, predecessor_block_values: @List[@MC_Value]) -> Nothing {
    if ir_block.processed {
        abort("Block already processed")
    }

    let mc_block = make @MC_Block(
        function = self.current_function
        name = ir_block.name
    )
    self.current_function.blocks.append(mc_block)

    \ init block's live values
    if predecessor_block_values != null {
        \ merge live values from predecessor block
        predecessor_block_values.for_each() {
            mc_block.live_values.append(it)
        }
    } else {
        \ this must be the first block
        if ir_block.function.parameters.size > 0 {
            \ create live values from function parameters
            ir_block.function.parameters.for_each_indexed() {
                let ir_parameter = it
                let mc_parameter = make @MC_Register_Value(
                    ir_value = ir_parameter.value
                    register = self.parameter_register(it_index.as(i32))
                )
                mc_block.live_values.append(mc_parameter)
            }
        }
    }

    ir_block.for_each_instruction() {
        self.convert_instruction(it, mc_block)
    }

    \ mark block as processed
    ir_block.processed = true

    \ convert successors
    if ir_block.last_instruction is IR_Branch_Instruction {
        let ir_branch_instruction = ir_block.last_instruction.as(@IR_Branch_Instruction)
        self.convert_block(ir_branch_instruction.true_block, mc_block.live_values)
        self.convert_block(ir_branch_instruction.false_block, mc_block.live_values)
    } else if ir_block.last_instruction is IR_Jump_Instruction {
        let ir_jump_instruction = ir_block.last_instruction.as(@IR_Jump_Instruction)
        self.convert_block(ir_jump_instruction.block, mc_block.live_values)
    }
}

func convert_instruction(self: @MC_Generator, ir_instruction: @IR_Instruction, mc_block: @MC_Block) -> Nothing {
    if ir_instruction is IR_Constant_Instruction {
        let literal = ir_instruction.as(@IR_Constant_Instruction).literal
        if literal is Integer_Token {
            mc_block.live_values.append(make @MC_Immediate_Value(
                ir_value = ir_instruction.result_value
                literal = literal.as(@Integer_Token)
            ))
        } else {
            abort(literal.object_type)
        }
    } else if ir_instruction is IR_Direct_Call_Instruction {
        self.convert_direct_call_instruction(ir_instruction.as(@IR_Direct_Call_Instruction), mc_block)
    } else if ir_instruction is IR_Return_Instruction {
        self.convert_return_instruction(ir_instruction.as(@IR_Return_Instruction), mc_block)
    } else {
        abort(ir_instruction.object_type)
    }
    \ TODO: cleanup live values
}

func convert_direct_call_instruction(self: @MC_Generator, ir_direct_call_instruction: @IR_Direct_Call_Instruction, mc_block: @MC_Block) -> Nothing {
    let ir_function = ir_direct_call_instruction.function

    if ir_direct_call_instruction.arguments_size > 0 {
        let argument_index = 0
        while argument_index < ir_direct_call_instruction.arguments_size {
            self.make_register_value(
                mc_block
                ir_direct_call_instruction.get_argument_value(argument_index)
                self.parameter_register(argument_index)
            )
            argument_index = argument_index + 1
        }

        \ TODO: move live values to callee saved registers or stack slots
    }

    let mc_call_instruction = make @MC_CALL_Instruction(
        callee = make @MC_Global_Value(
            ir_value = null
            name = ir_function.name
        )
    )
    mc_block.append(mc_call_instruction)

    if ir_function.return_type != null {
        \ map return value to rax
        let return_value = make @MC_Register_Value(
            ir_value = ir_direct_call_instruction.result_value
            register = self.register_rax
        )
        mc_block.live_values.append(return_value)
    }
}

func convert_return_instruction(self: @MC_Generator, ir_return_instruction: @IR_Return_Instruction, mc_block: @MC_Block) -> Nothing {
    let ir_return_value = ir_return_instruction.get_return_value()
    if ir_return_value != null {
        self.make_register_value(mc_block, ir_return_value, self.register_rax)
    }

    mc_block.append(make @MC_RET_Instruction())
}

func make_register_value(self: @MC_Generator, mc_block: @MC_Block, ir_value: @IR_Value, mc_register: @MC_Register) -> Nothing {
    \ check if register is already mapped to another live value
    mc_block.live_values.for_each() {
        let mc_value = it
        if mc_value is MC_Register_Value {
            let mc_value = mc_value.as(@MC_Register_Value)
            if mc_value.register == mc_register {
                if mc_value.ir_value == ir_value {
                    \ mapping already exists
                    return
                }
                stderr.write(mc_block).end_line()
                abort("Register ".clone().append(mc_register.name_q).append(" is mapped to value ").append(mc_value.ir_value.name))
            }
        }
    }

    \ check if live value is already mapped
    mc_block.live_values.for_each() {
        let mc_value = it
        if mc_value.ir_value == ir_value {
            if mc_value is MC_Register_Value {
                let old_mc_register_value = mc_value.as(@MC_Register_Value)
                if old_mc_register_value.register != mc_register {
                    \ move value to other register
                    let new_mc_register_value = make @MC_Register_Value(
                        ir_value = ir_value
                        register = mc_register
                    )
                    mc_block.append(make @MC_MOV_Instruction(
                        source = old_mc_register_value
                        destination = new_mc_register_value
                    ))

                    \ replace old register value with new one
                    mc_block.live_values.prepend(new_mc_register_value)
                    mc_block.live_values.remove(old_mc_register_value)
                    mc_block.live_values.prune()
                }
                return
            } else if mc_value is MC_Immediate_Value {
                \ move value to register
                let mc_immediate_value = mc_value.as(@MC_Immediate_Value)
                let mc_register_value = make @MC_Register_Value(
                    ir_value = mc_immediate_value.ir_value
                    register = mc_register
                )
                mc_block.append(make @MC_MOV_Instruction(
                    source = mc_immediate_value
                    destination = mc_register_value
                ))
                mc_block.live_values.prepend(mc_register_value)
                return
            } else {
                abort(mc_value.object_type)
            }
        }
    }

    \ value not assigned yet
    abort("TODO: Assign value ".clone().append(ir_value.name).append(" to register ").append(mc_register.name_q))
}
