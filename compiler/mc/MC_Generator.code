func convert(code: @IR_Code, file: @FILE) -> @MC_Code {
    let generator = make_mc_generator(file)
    return generator.convert(code)
}

struct MC_Generator {
    file: @FILE

    register_rax = make @MC_Register_RAX()
    register_rcx = make @MC_Register_RCX()
    register_rdx = make @MC_Register_RDX()
    register_rbx = make @MC_Register_RBX()
    register_rsp = make @MC_Register_RSP()
    register_rbp = make @MC_Register_RBP()
    register_rsi = make @MC_Register_RSI()
    register_rdi = make @MC_Register_RDI()
    register_r8 = make @MC_Register_R8()
    register_r9 = make @MC_Register_R9()
    register_r10 = make @MC_Register_R10()
    register_r11 = make @MC_Register_R11()
    register_r12 = make @MC_Register_R12()
    register_r13 = make @MC_Register_R13()
    register_r14 = make @MC_Register_R14()
    register_r15 = make @MC_Register_R15()
    registers = make List[@MC_Register]()

    current_function: @MC_Function = null
}

func make_mc_generator(file: @FILE) -> @MC_Generator {
    let self = make @MC_Generator(file = file)
    self.registers.append(self.register_rax)
    self.registers.append(self.register_rcx)
    self.registers.append(self.register_rdx)
    self.registers.append(self.register_rbx)
    self.registers.append(self.register_rsp)
    self.registers.append(self.register_rbp)
    self.registers.append(self.register_rsi)
    self.registers.append(self.register_rdi)
    self.registers.append(self.register_r8)
    self.registers.append(self.register_r9)
    self.registers.append(self.register_r10)
    self.registers.append(self.register_r11)
    self.registers.append(self.register_r12)
    self.registers.append(self.register_r13)
    self.registers.append(self.register_r14)
    self.registers.append(self.register_r15)
    return self
}

func parameter_register(self: @MC_Generator, index: i32) -> @MC_Register {
    let register: @MC_Register
    if index == 0 {
        register = self.register_rdi
    } else if index == 1 {
        register = self.register_rsi
    } else if index == 2 {
        register = self.register_rdx
    } else if index == 3 {
        register = self.register_rcx
    } else if index == 4 {
        register = self.register_r8
    } else if index == 5 {
        register = self.register_r9
    } else {
        register = null
    }
    return register
}

func convert(self: @MC_Generator, ir_code: @IR_Code) -> @MC_Code {
    ir_code.compute_live_values()

    let mc_code = make @MC_Code()
    ir_code.global_symbols.for_each() {
        let symbol = it
        if symbol is IR_Function {
            let function = self.convert_function(symbol.as(@IR_Function))
            mc_code.functions.append(function)
        }
    }
    return mc_code
}

func convert_function(self: @MC_Generator, ir_function: @IR_Function) -> @MC_Function {
    let function = make @MC_Function(
        name = ir_function.name
    )
    function.prologue_block.function = function
    function.epilogue_block.function = function

    self.current_function = function

    \ TODO: spill test
    \   - the spill check has to take into account caller and callee saved registers
    \   - check if we have enough callee saved registers to store all live values after all calls
    \   - values that are live after a call are stored in two places to be avaiable before and after the call
    \   - max live values after all calls give the required number of callee saved registers
    \   - if spilling is required, the stack size is increased and the live values are stored in the stack
    \   - constant values and stack slots are not spilled, nor moved to callee saved registers
    \   - spilling is calculated for each live value based on spill cost formula:
    \       (sum of ((block_uses + block_defs) * 10 ^ loop_depth) for each block in the function) / interference_degree
    \   - interference degree is the number of neighbors in the interference graph
    \   - the spill cost is calculated for each live value and the live value with the lowest spill cost is spilled

    \ reset processed flag
    ir_function.blocks.for_each() {
        it.processed = false
    }


    \ convert blocks via forward traversal
    self.convert_block(ir_function.blocks.first(), null, 0)

    \ determine stack size
    function.blocks.for_each() {
        let block = it
        if block.stack_size > function.stack_size {
            function.stack_size = block.stack_size
        }
    }
    if function.stack_size > 0 {
        \ align stack size to 16 bytes
        function.stack_size = (function.stack_size / 16 + 1) * 16
    }

    \ update prologue block
    function.blocks.prepend(function.prologue_block)
    if function.stack_size > 0 {
        function.prologue_block.append(make @MC_SUB_Instruction(
            source = make @MC_Immediate_Value(
                ir_value = null
                data_size = 8
                value = function.stack_size.as(u64)
            )
            destination = make @MC_Register_Value(
                ir_value = null
                data_size = 8
                register = self.register_rsp
            )
        ))
    }

    \ update epilogue block
    function.blocks.append(function.epilogue_block)
    if function.stack_size > 0 {
        function.epilogue_block.append(make @MC_ADD_Instruction(
            source = make @MC_Immediate_Value(
                ir_value = null
                data_size = 8
                value = function.stack_size.as(u64)
            )
            destination = make @MC_Register_Value(
                ir_value = null
                data_size = 8
                register = self.register_rsp
            )
        ))
    }
    function.epilogue_block.append(make @MC_RET_Instruction())

    return function
}

func convert_block(self: @MC_Generator, ir_block: @IR_Block, predecessor_block_values: @List[@MC_Value], stack_size: i32) -> Nothing {
    if ir_block.processed {
        return
    }

    let mc_block = self.current_function.get_block(ir_block)
    mc_block.stack_size = stack_size

    \ init block's live values
    if predecessor_block_values != null {
        \ merge live values from predecessor block
        predecessor_block_values.for_each() {
            mc_block.live_values.prepend(it)
        }
    } else {
        \ this must be the first block
        if ir_block.function.parameters.size > 0 {
            \ create live values from function parameters
            ir_block.function.parameters.for_each_indexed() {
                let ir_parameter = it
                let mc_parameter = self.make_register_value(
                    mc_block = mc_block
                    ir_value = ir_parameter.value
                    register = self.parameter_register(it_index.as(i32))
                    load_value = false
                )
                mc_block.live_values.prepend(mc_parameter)
            }
        }
    }

    ir_block.for_each_instruction() {
        self.convert_instruction(it, mc_block)
    }

    \ mark block as processed
    ir_block.processed = true

    \ convert successors
    if ir_block.last_instruction is IR_Branch_Instruction {
        let ir_branch_instruction = ir_block.last_instruction.as(@IR_Branch_Instruction)
        self.convert_block(ir_branch_instruction.true_block, mc_block.live_values, mc_block.stack_size)
        self.convert_block(ir_branch_instruction.false_block, mc_block.live_values, mc_block.stack_size)
    } else if ir_block.last_instruction is IR_Jump_Instruction {
        let ir_jump_instruction = ir_block.last_instruction.as(@IR_Jump_Instruction)
        self.convert_block(ir_jump_instruction.block, mc_block.live_values, mc_block.stack_size)
    }
}

func convert_instruction(self: @MC_Generator, ir_instruction: @IR_Instruction, mc_block: @MC_Block) -> Nothing {
    if ir_instruction is IR_Add_Instruction {
        self.convert_add_instruction(ir_instruction.as(@IR_Add_Instruction), mc_block)
    } else if ir_instruction is IR_Alloc_Instruction {
        self.convert_alloc_instruction(ir_instruction.as(@IR_Alloc_Instruction), mc_block)
    } else if ir_instruction is IR_Branch_Instruction {
        self.convert_branch_instruction(ir_instruction.as(@IR_Branch_Instruction), mc_block)
    } else if ir_instruction is IR_Constant_Instruction {
        self.convert_constant_instruction(ir_instruction.as(@IR_Constant_Instruction), mc_block)
    } else if ir_instruction is IR_Direct_Call_Instruction {
        self.convert_direct_call_instruction(ir_instruction.as(@IR_Direct_Call_Instruction), mc_block)
    } else if ir_instruction is IR_Divide_Instruction {
        self.convert_divide_instruction(ir_instruction.as(@IR_Divide_Instruction), mc_block)
    } else if ir_instruction is IR_Jump_Instruction {
        self.convert_jump_instruction(ir_instruction.as(@IR_Jump_Instruction), mc_block)
    } else if ir_instruction is IR_Load_Instruction {
        self.convert_load_instruction(ir_instruction.as(@IR_Load_Instruction), mc_block)
    } else if ir_instruction is IR_Modulo_Instruction {
        self.convert_modulo_instruction(ir_instruction.as(@IR_Modulo_Instruction), mc_block)
    } else if ir_instruction is IR_Multiply_Instruction {
        self.convert_multiply_instruction(ir_instruction.as(@IR_Multiply_Instruction), mc_block)
    } else if ir_instruction is IR_Return_Instruction {
        self.convert_return_instruction(ir_instruction.as(@IR_Return_Instruction), mc_block)
    } else if ir_instruction is IR_Store_Instruction {
        self.convert_store_instruction(ir_instruction.as(@IR_Store_Instruction), mc_block)
    } else if ir_instruction is IR_Substract_Instruction {
        self.convert_substract_instruction(ir_instruction.as(@IR_Substract_Instruction), mc_block)
    } else {
        stderr.write(self.current_function).end_line()
        abort(ir_instruction.object_type)
    }

    \ cleanup live values
    if ir_instruction.next_instruction != null {
        mc_block.live_values.for_each() {
            if not ir_instruction.live_out_values.contains(it.ir_value) {
                mc_block.live_values.remove(it)
            }
        }
        mc_block.live_values.prune()
    }
}

func convert_add_instruction(self: @MC_Generator, ir_add_instruction: @IR_Add_Instruction, mc_block: @MC_Block) -> Nothing {
    let mc_register_value = self.make_register_value(
        mc_block = mc_block
        ir_value = ir_add_instruction.result_value
        register = self.find_free_caller_saved_register(mc_block)
        load_value = false
    )
    mc_block.append(make @MC_MOV_Instruction(
        source = mc_block.find_value(ir_add_instruction.get_left_value())
        destination = mc_register_value
    ))
    mc_block.append(make @MC_ADD_Instruction(
        source = mc_block.find_value(ir_add_instruction.get_right_value())
        destination = mc_register_value
    ))
}

func convert_alloc_instruction(self: @MC_Generator, ir_alloc_instruction: @IR_Alloc_Instruction, mc_block: @MC_Block) -> Nothing {
    mc_block.stack_size = mc_block.stack_size + ir_alloc_instruction.type.get_size() \ TODO: align stack size
    let mc_stack_value = make @MC_Local_Value(
        ir_value = ir_alloc_instruction.result_value
        function = mc_block.function
        stack_offset = mc_block.stack_size
    )
    mc_block.live_values.prepend(mc_stack_value)
}

func convert_branch_instruction(self: @MC_Generator, ir_branch_instruction: @IR_Branch_Instruction, mc_block: @MC_Block) -> Nothing {
    let mc_value = mc_block.find_value(ir_branch_instruction.get_condition())
    if mc_value is not MC_Register_Value {
        mc_value = self.make_register_value(
            mc_block = mc_block
            ir_value = ir_branch_instruction.get_condition()
            mc_register = self.find_free_caller_saved_register(mc_block)
            load_value = true
        )
    }
    mc_block.append(make @MC_CMP_Instruction(
        source = make @MC_Immediate_Value(
            ir_value = null
            value = 0u64
        )
        destination = mc_value
    ))
    mc_block.append(make @MC_JNE_Instruction(
        block = mc_block.function.get_block(ir_branch_instruction.true_block)
    ))
    mc_block.append(make @MC_JMP_Instruction(
        block = mc_block.function.get_block(ir_branch_instruction.false_block)
    ))
}

func convert_constant_instruction(self: @MC_Generator, ir_instruction: @IR_Constant_Instruction, mc_block: @MC_Block) -> Nothing {
    let literal = ir_instruction.literal
    if literal is Boolean_Token {
        let value = 0u64
        if literal.as(@Boolean_Token).value {
            value = 1u64
        }
        mc_block.live_values.prepend(make @MC_Immediate_Value(
            ir_value = ir_instruction.result_value
            value = value
        ))
    } else if literal is Integer_Token {
        let literal = literal.as(@Integer_Token)
        let value = literal.value
        if literal.negative {
            value = -value
        }
        mc_block.live_values.prepend(make @MC_Immediate_Value(
            ir_value = ir_instruction.result_value
            value = value
        ))
    } else {
        abort(literal.object_type)
    }
}

func convert_direct_call_instruction(self: @MC_Generator, ir_direct_call_instruction: @IR_Direct_Call_Instruction, mc_block: @MC_Block) -> Nothing {
    \ move live values to callee saved registers or stack slots
    ir_direct_call_instruction.next_instruction.live_in_values.for_each() {
        let ir_value = it
        if ir_value != ir_direct_call_instruction.result_value {
            let mc_register_value = mc_block.find_register_value(it)
            if mc_register_value != null and mc_register_value.register.is_caller_saved {
                \ move value to callee saved register
                self.make_register_value(
                    mc_block = mc_block
                    ir_value = ir_value
                    mc_register = self.find_free_callee_saved_register(mc_block)
                    load_value = true
                )
            }
        }
    }

    \ map arguments to registers
    if ir_direct_call_instruction.arguments_size > 0 {
        let argument_index = 0
        while argument_index < ir_direct_call_instruction.arguments_size {
            let parameter_register = self.parameter_register(argument_index)
            if not parameter_register.is_free(mc_block) {
                abort("Release parameter register: ".clone().append(parameter_register.name_q))
            }
            self.make_register_value(
                mc_block = mc_block
                ir_value = ir_direct_call_instruction.get_argument_value(argument_index)
                mc_register = self.parameter_register(argument_index)
                load_value = true
            )
            argument_index = argument_index + 1
        }
    }

    \ create call instruction
    let ir_function = ir_direct_call_instruction.function
    mc_block.append(make @MC_CALL_Instruction(
        callee = make @MC_Global_Value(
            ir_value = null
            name = ir_function.name
        )
    ))

    \ remove all caller-saved register values
    mc_block.live_values.for_each() {
        let mc_value = it
        if mc_value is MC_Register_Value {
            let mc_register_value = mc_value.as(@MC_Register_Value)
            if mc_register_value.register.is_caller_saved {
                mc_block.live_values.remove(mc_register_value)
            }
        }
    }
    mc_block.live_values.prune()

    \ map return value to rax
    if ir_function.return_type != null {
        let return_value = self.make_register_value(
            mc_block = mc_block
            ir_value = ir_direct_call_instruction.result_value
            register = self.register_rax
            load_value = false
        )
    }
}

func convert_divide_instruction(self: @MC_Generator, ir_divide_instruction: @IR_Divide_Instruction, mc_block: @MC_Block) -> Nothing {
    self.make_division(mc_block, ir_divide_instruction.get_left_value(), ir_divide_instruction.get_right_value())
    self.make_register_value(
        mc_block = mc_block
        ir_value = ir_divide_instruction.result_value
        register = self.register_rax
        load_value = false
    )
}

func make_division(self: @MC_Generator, mc_block: @MC_Block, left_ir_value: @IR_Value, right_ir_value: @IR_Value) -> Nothing {
    \ reserve rax and rdx
    self.release_register(mc_block, self.register_rax)
    self.register_rax.is_reserved = true
    self.release_register(mc_block, self.register_rdx)
    self.register_rdx.is_reserved = true

    let left_mc_value = mc_block.find_value(left_ir_value)
    let right_mc_value = mc_block.find_value(right_ir_value)
    mc_block.append(make @MC_MOV_Instruction(
        source = left_mc_value
        destination = make @MC_Register_Value(
            ir_value = null
            data_size = left_mc_value.data_size()
            register = self.register_rax
        )
    ))
    mc_block.append(make @MC_CLTD_Instruction())
    mc_block.append(make @MC_IDIV_Instruction(
        source = right_mc_value
    ))

    \ unreserve rax and rdx
    self.register_rdx.is_reserved = false
    self.register_rax.is_reserved = false
}

func convert_jump_instruction(self: @MC_Generator, ir_jump_instruction: @IR_Jump_Instruction, mc_block: @MC_Block) -> Nothing {
    mc_block.append(make @MC_JMP_Instruction(
        block = mc_block.function.get_block(ir_jump_instruction.block)
    ))
}

func convert_load_instruction(self: @MC_Generator, ir_load_instruction: @IR_Load_Instruction, mc_block: @MC_Block) -> Nothing {
    let mc_register_value = self.make_register_value(
        mc_block = mc_block
        ir_value = ir_load_instruction.result_value
        mc_register = self.find_free_caller_saved_register(mc_block)
        load_value = false
    )
    mc_block.append(make @MC_MOV_Instruction(
        source = mc_block.find_value(ir_load_instruction.get_value_pointer())
        destination = mc_register_value
    ))
}

func convert_modulo_instruction(self: @MC_Generator, ir_modulo_instruction: @IR_Modulo_Instruction, mc_block: @MC_Block) -> Nothing {
    self.make_division(mc_block, ir_modulo_instruction.get_left_value(), ir_modulo_instruction.get_right_value())
    self.make_register_value(
        mc_block = mc_block
        ir_value = ir_modulo_instruction.result_value
        register = self.register_rdx
        load_value = false
    )
}

func convert_multiply_instruction(self: @MC_Generator, ir_multiply_instruction: @IR_Multiply_Instruction, mc_block: @MC_Block) -> Nothing {
    let mc_register_value = self.make_register_value(
        mc_block = mc_block
        ir_value = ir_multiply_instruction.result_value
        mc_register = self.register_rax
        load_value = false
    )
    mc_block.append(make @MC_MOV_Instruction(
        source = mc_block.find_value(ir_multiply_instruction.get_left_value())
        destination = mc_register_value
    ))
    mc_block.append(make @MC_MUL_Instruction(
        source = mc_block.find_value(ir_multiply_instruction.get_right_value())
    ))
}

func convert_return_instruction(self: @MC_Generator, ir_return_instruction: @IR_Return_Instruction, mc_block: @MC_Block) -> Nothing {
    let ir_return_value = ir_return_instruction.get_return_value()
    if ir_return_value != null {
        self.make_register_value(
            mc_block = mc_block
            ir_value = ir_return_value
            mc_register = self.register_rax
            load_value = true
        )
    }

    mc_block.append(make @MC_JMP_Instruction(
        block = mc_block.function.epilogue_block
    ))
}

func convert_store_instruction(self: @MC_Generator, ir_store_instruction: @IR_Store_Instruction, mc_block: @MC_Block) -> Nothing {
    mc_block.append(make @MC_MOV_Instruction(
        source = mc_block.find_value(ir_store_instruction.get_value())
        destination = mc_block.find_value(ir_store_instruction.get_value_pointer())
    ))
}

func convert_substract_instruction(self: @MC_Generator, ir_substract_instruction: @IR_Substract_Instruction, mc_block: @MC_Block) -> Nothing {
    let mc_register_value = self.make_register_value(
        mc_block = mc_block
        ir_value = ir_substract_instruction.result_value
        mc_register = self.find_free_caller_saved_register(mc_block)
        load_value = false
    )
    mc_block.append(make @MC_MOV_Instruction(
        source = mc_block.find_value(ir_substract_instruction.get_left_value())
        destination = mc_register_value
    ))
    mc_block.append(make @MC_SUB_Instruction(
        source = mc_block.find_value(ir_substract_instruction.get_right_value())
        destination = mc_register_value
    ))
}

func find_free_callee_saved_register(self: @MC_Generator, mc_block: @MC_Block) -> @MC_Register {
    self.registers.for_each() {
        let register = it
        if register.is_callee_saved and register.is_free(mc_block) {
            return register
        }
    }
    abort("No free callee saved register")
}

func find_free_caller_saved_register(self: @MC_Generator, mc_block: @MC_Block) -> @MC_Register {
    self.registers.for_each() {
        let register = it
        if register.is_caller_saved and register.is_free(mc_block) {
            return register
        }
    }
    abort("No free caller saved register")
}

func is_free(self: @MC_Register, mc_block: @MC_Block) -> bool {
    if self.is_reserved {
        return false
    }
    let mc_register_value = mc_block.find_register_value(self)
    return mc_register_value == null
}

func find_value(self: @MC_Block, ir_value: @IR_Value) -> @MC_Value {
    self.live_values.for_each() {
        let mc_value = it
        if mc_value.ir_value == ir_value {
            return mc_value
        }
    }
    return null
}

func find_register_value(self: @MC_Block, ir_value: @IR_Value) -> @MC_Register_Value {
    self.live_values.for_each() {
        let mc_value = it
        if mc_value is MC_Register_Value {
            let mc_value = mc_value.as(@MC_Register_Value)
            if mc_value.ir_value == ir_value {
                return mc_value
            }
        }
    }
    return null
}

func find_register_value(self: @MC_Block, register: @MC_Register) -> @MC_Register_Value {
    self.live_values.for_each() {
        let mc_value = it
        if mc_value is MC_Register_Value {
            let mc_value = mc_value.as(@MC_Register_Value)
            if mc_value.register == register {
                return mc_value
            }
        }
    }
    return null
}

func release_register(self: @MC_Generator, block: @MC_Block, register: @MC_Register) -> Nothing {
    let value = block.find_register_value(register)
    if value != null {
        \ move value to another free register
        let new_value = self.make_register_value(
            mc_block = block
            ir_value = value.ir_value
            register = self.find_free_caller_saved_register(block)
            load_value = true
        )
        block.live_values.remove(value)
        block.live_values.prune()
    }
}

func make_register_value(self: @MC_Generator, mc_block: @MC_Block, ir_value: @IR_Value, mc_register: @MC_Register, load_value: bool) -> @MC_Register_Value {
    \ make sure register is free
    let mc_register_value = mc_block.find_register_value(mc_register)
    if mc_register_value != null {
        if mc_register_value.ir_value == ir_value {
            \ register is already loaded
            return mc_register_value
        }

        stderr.write(self.current_function).end_line()
        abort("Register ".clone().append(mc_register.name_q).append(" is not free"))
    }

    \ create register value
    let mc_register_value = make @MC_Register_Value(
        ir_value = ir_value
        register = mc_register
    )

    \ load value to register
    if load_value {
        let mc_value = mc_block.find_value(ir_value)
        mc_block.append(make @MC_MOV_Instruction(
            source = mc_value
            destination = mc_register_value
        ))
    }

    \ add register value to live values
    mc_block.live_values.prepend(mc_register_value)

    return mc_register_value
}
