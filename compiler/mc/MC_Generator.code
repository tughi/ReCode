func convert(code: @IR_Code, file: @FILE) -> @MC_Code {
    let generator = make_mc_generator(file)
    return generator.convert(code)
}

struct MC_Generator {
    file: @FILE

    register_rax = make @MC_Register_RAX()
    register_rcx = make @MC_Register_RCX()
    register_rdx = make @MC_Register_RDX()
    register_rbx = make @MC_Register_RBX()
    register_rsp = make @MC_Register_RSP()
    register_rbp = make @MC_Register_RBP()
    register_rsi = make @MC_Register_RSI()
    register_rdi = make @MC_Register_RDI()
    register_r8 = make @MC_Register_R8()
    register_r9 = make @MC_Register_R9()
    register_r10 = make @MC_Register_R10()
    register_r11 = make @MC_Register_R11()
    register_r12 = make @MC_Register_R12()
    register_r13 = make @MC_Register_R13()
    register_r14 = make @MC_Register_R14()
    register_r15 = make @MC_Register_R15()
    registers = make List[@MC_Register]()

    global_values = make @List[@MC_Global_Value]()

    current_function: @MC_Function = null
    predecessor_block: @MC_Block = null
}

func make_mc_generator(file: @FILE) -> @MC_Generator {
    let self = make @MC_Generator(file = file)
    self.registers.append(self.register_rax)
    self.registers.append(self.register_rcx)
    self.registers.append(self.register_rdx)
    self.registers.append(self.register_rbx)
    self.registers.append(self.register_rsp)
    self.registers.append(self.register_rbp)
    self.registers.append(self.register_rsi)
    self.registers.append(self.register_rdi)
    self.registers.append(self.register_r8)
    self.registers.append(self.register_r9)
    self.registers.append(self.register_r10)
    self.registers.append(self.register_r11)
    self.registers.append(self.register_r12)
    self.registers.append(self.register_r13)
    self.registers.append(self.register_r14)
    self.registers.append(self.register_r15)
    return self
}

func parameter_register(self: @MC_Generator, index: i32) -> @MC_Register {
    let register: @MC_Register
    if index == 0 {
        register = self.register_rdi
    } else if index == 1 {
        register = self.register_rsi
    } else if index == 2 {
        register = self.register_rdx
    } else if index == 3 {
        register = self.register_rcx
    } else if index == 4 {
        register = self.register_r8
    } else if index == 5 {
        register = self.register_r9
    } else {
        register = null
    }
    return register
}

func convert(self: @MC_Generator, ir_code: @IR_Code) -> @MC_Code {
    ir_code.compute_live_values()

    let mc_code = make @MC_Code(
        global_values = self.global_values
    )

    ir_code.global_symbols.for_each() {
        let symbol = it
        if symbol is IR_Global_Variable {
            let ir_global_variable = symbol.as(@IR_Global_Variable)
            let global_value = make @MC_Global_Value(
                name = ir_global_variable.name
                ir_value = ir_global_variable.value_pointer
                data_size = ir_global_variable.type.get_size()
            )
            mc_code.global_values.append(global_value)
        }
    }

    ir_code.global_symbols.for_each() {
        let symbol = it
        if symbol is IR_Function {
            let ir_function = symbol.as(@IR_Function)
            if ir_function.blocks != null {
                let function = self.convert_function(ir_function)
                mc_code.functions.append(function)
            }
        }
    }

    return mc_code
}

func convert_function(self: @MC_Generator, ir_function: @IR_Function) -> @MC_Function {
    \ reset register state
    self.registers.for_each() {
        it.is_used = false
    }

    let function = make @MC_Function(
        name = ir_function.name
    )
    function.epilogue_block.function = function
    function.epilogue_block.global_values = self.global_values
    function.prologue_block.function = function
    function.prologue_block.global_values = self.global_values

    self.current_function = function

    \ TODO: spill test
    \   - the spill check has to take into account caller and callee saved registers
    \   - check if we have enough callee saved registers to store all live values after all calls
    \   - values that are live after a call are stored in two places to be avaiable before and after the call
    \   - max live values after all calls give the required number of callee saved registers
    \   - if spilling is required, the stack size is increased and the live values are stored in the stack
    \   - constant values and stack slots are not spilled, nor moved to callee saved registers
    \   - spilling is calculated for each live value based on spill cost formula:
    \       (sum of ((block_uses + block_defs) * 10 ^ loop_depth) for each block in the function) / interference_degree
    \   - interference degree is the number of neighbors in the interference graph
    \   - the spill cost is calculated for each live value and the live value with the lowest spill cost is spilled

    \ reset processed flag
    ir_function.blocks.for_each() {
        it.processed = false
    }


    \ convert blocks via forward traversal
    self.convert_block(ir_function.blocks.first(), null, 0)

    \ determine stack size
    function.blocks.for_each() {
        let block = it
        if block.stack_size > function.stack_size {
            function.stack_size = block.stack_size
        }
    }
    if function.stack_size // 16 > 0 {
        \ align stack size to 16 bytes
        function.stack_size = function.stack_size + 16 - function.stack_size // 16
    }

    \ update prologue block
    function.blocks.prepend(function.prologue_block)
    self.save_callee_saved_registers(function.prologue_block)
    if function.stack_size > 0 {
        function.prologue_block.append(make @MC_SUB_Instruction(
            source = make @MC_Immediate_Value(
                ir_value = null
                data_size = 8
                value = function.stack_size.as(u64)
            )
            destination = make @MC_Register_Value(
                ir_value = null
                data_size = 8
                register = self.register_rsp
            )
        ))
    }

    \ update epilogue block
    function.blocks.append(function.epilogue_block)
    if function.stack_size > 0 {
        function.epilogue_block.append(make @MC_ADD_Instruction(
            source = make @MC_Immediate_Value(
                ir_value = null
                data_size = 8
                value = function.stack_size.as(u64)
            )
            destination = make @MC_Register_Value(
                ir_value = null
                data_size = 8
                register = self.register_rsp
            )
        ))
    }
    self.restore_callee_saved_registers(function.epilogue_block)
    if ir_function.return_type is IR_Nothing_Type and ir_function.name.equals("main") {
        function.epilogue_block.append(make @MC_XOR_Instruction(
            source = make @MC_Register_Value(
                ir_value = null
                data_size = 8
                register = self.register_rax
            )
            destination = make @MC_Register_Value(
                ir_value = null
                data_size = 8
                register = self.register_rax
            )
        ))
    }
    function.epilogue_block.append(make @MC_RET_Instruction())

    return function
}

func save_callee_saved_registers(self: @MC_Generator, mc_block: @MC_Block) -> Nothing {
    let mc_register_item = self.registers.first_item
    while mc_register_item != null {
        let mc_register = mc_register_item.data
        if mc_register.is_callee_saved and mc_register.is_used {
            mc_block.append(make @MC_PUSH_Instruction(
                source = make @MC_Register_Value(
                    ir_value = null
                    data_size = 8
                    register = mc_register
                )
            ))
        }
        mc_register_item = mc_register_item.next_item
    }
}

func restore_callee_saved_registers(self: @MC_Generator, mc_block: @MC_Block) -> Nothing {
    let mc_register_item = self.registers.last_item
    while mc_register_item != null {
        let mc_register = mc_register_item.data
        if mc_register.is_callee_saved and mc_register.is_used {
            mc_block.append(make @MC_POP_Instruction(
                destination = make @MC_Register_Value(
                    ir_value = null
                    data_size = 8
                    register = mc_register
                )
            ))
        }
        mc_register_item = mc_register_item.prev_item
    }
}

func convert_block(self: @MC_Generator, ir_block: @IR_Block, predecessor_block: @MC_Block, stack_size: i32) -> Nothing {
    \ make sure block is not processed multiple times
    if ir_block.processed {
        return
    }
    ir_block.processed = true

    stderr.write("Converting block ").write_name(ir_block).end_line()

    let mc_block = self.get_block(ir_block)
    mc_block.stack_size = stack_size

    \ init block's live values
    if predecessor_block != null {
        \ merge live values from predecessor block
        predecessor_block.live_values.for_each() {
            mc_block.live_values.prepend(it)
        }
    } else {
        \ this must be the first block
        if ir_block.function.parameters.size > 0 {
            \ create live values from function parameters
            ir_block.function.parameters.for_each_indexed() {
                let ir_parameter = it
                let mc_parameter = self.make_register_value(
                    mc_block = mc_block
                    ir_value = ir_parameter.value
                    register = self.parameter_register(it_index.as(i32))
                    load_value = false
                )
            }
        }
    }
    self.predecessor_block = predecessor_block

    ir_block.for_each_instruction() {
        self.convert_instruction(it, mc_block)
    }

    \ convert successor blocks
    if ir_block.last_instruction is IR_Branch_Instruction {
        let ir_branch_instruction = ir_block.last_instruction.as(@IR_Branch_Instruction)
        self.convert_block(ir_branch_instruction.true_block, mc_block, mc_block.stack_size)
        self.convert_block(ir_branch_instruction.false_block, mc_block, mc_block.stack_size)
    } else if ir_block.last_instruction is IR_Jump_Instruction {
        let ir_jump_instruction = ir_block.last_instruction.as(@IR_Jump_Instruction)
        self.convert_block(ir_jump_instruction.block, mc_block, mc_block.stack_size)
    }
}

func get_block(self: @MC_Generator, ir_block: @IR_Block) -> @MC_Block {
    self.current_function.blocks.for_each() {
        if it.name == ir_block.name {
            return it
        }
    }
    let block = make @MC_Block(
        ir_block = ir_block
        function = self.current_function
        name = ir_block.name
        global_values = self.global_values
    )
    self.current_function.blocks.append(block)
    return block
}

func get_jump_block(self: @MC_Generator, source_mc_block: @MC_Block, target_ir_block: @IR_Block) -> @MC_Block {
    let target_mc_block = self.get_block(target_ir_block)
    if target_ir_block.first_instruction is not IR_Phi_Instruction {
        \ no need for a jump block
        return target_mc_block
    }

    let jump_mc_block = make @MC_Block(
        ir_block = null
        function = self.current_function
        name = target_ir_block.name.clone().append("_F_").append(source_mc_block.ir_block.name)
        global_values = self.global_values
    )
    self.current_function.blocks.append(jump_mc_block)

    \ copy live values from source block
    source_mc_block.live_values.for_each() {
        jump_mc_block.live_values.append(it)
    }

    \ map live values from phi instructions
    if target_mc_block.phi_values.size > 0 {
        \ move source block live values to phi values
        target_mc_block.phi_values.for_each() {
            let phi_value = it
            if phi_value.ir_value.init_instruction is not IR_Phi_Instruction {
                abort("Invalid state: phi value not initialized by a phi instruction")
            }
            if phi_value is MC_Register_Value {
                let phi_value = phi_value.as(@MC_Register_Value)

                let ir_phi_instruction = phi_value.ir_value.init_instruction.as(@IR_Phi_Instruction)
                ir_phi_instruction.value_block_mapping.for_each() {
                    if value == source_mc_block.ir_block {
                        let live_value = jump_mc_block.find_value(key)
                        if live_value == null {
                            abort("Invalid state: phi value not live")
                        }
                        if live_value is MC_Register_Value {
                            let live_value = live_value.as(@MC_Register_Value)
                            if live_value.register != phi_value.register {
                                if not phi_value.register.is_free(jump_mc_block) {
                                    self.release_register(jump_mc_block, phi_value.register)
                                }
                                let new_live_value = self.make_register_value(
                                    mc_block = jump_mc_block
                                    ir_value = phi_value.ir_value
                                    register = phi_value.register
                                    load_value = false
                                )
                                jump_mc_block.append(make @MC_MOV_Instruction(
                                    source = live_value
                                    destination = new_live_value
                                ))
                            }
                        } else {
                            abort(live_value.object_type)
                        }
                    }
                }
            } else {
                abort(phi_value.object_type)
            }
        }
    } else {
        \ map phi values to source block live values
        target_ir_block.for_each_instruction() {
            if it is IR_Phi_Instruction {
                let ir_phi_instruction = it.as(@IR_Phi_Instruction)
                ir_phi_instruction.value_block_mapping.for_each() {
                    if value == source_mc_block.ir_block {
                        let mc_value = jump_mc_block.find_value(key)
                        if mc_value == null {
                            abort("Invalid state: phi value not live")
                        }
                        if mc_value is MC_Register_Value {
                            let mc_value = mc_value.as(@MC_Register_Value)
                            target_mc_block.phi_values.prepend(make @MC_Register_Value(
                                ir_value = ir_phi_instruction.result_value
                                register = mc_value.register
                            ))
                        } else {
                            abort(mc_value.object_type)
                        }
                    }
                }
            } else {
                break
            }
        }
    }

    jump_mc_block.append(make @MC_JMP_Instruction(
        block = target_mc_block
    ))

    return jump_mc_block
}

func convert_instruction(self: @MC_Generator, ir_instruction: @IR_Instruction, mc_block: @MC_Block) -> Nothing {
    stderr.debug().write("Converting instruction: ").reset()
    if ir_instruction.result_value != null {
        stderr.write(ir_instruction.result_value).write(" = ")
    }
    ir_instruction.print(stderr)
    stderr.end_line()

    \ dump live values
    stderr.write("Live-in values: ")
    mc_block.live_values.for_each() {
        stderr.write(it.ir_value).write('(').write(it).write(") ")
    }
    stderr.end_line()

    if ir_instruction is IR_Add_Instruction {
        self.convert_add_instruction(ir_instruction.as(@IR_Add_Instruction), mc_block)
    } else if ir_instruction is IR_Alloc_Instruction {
        self.convert_alloc_instruction(ir_instruction.as(@IR_Alloc_Instruction), mc_block)
    } else if ir_instruction is IR_Branch_Instruction {
        self.convert_branch_instruction(ir_instruction.as(@IR_Branch_Instruction), mc_block)
    } else if ir_instruction is IR_Comparison_Instruction {
        self.convert_comparison_instruction(ir_instruction.as(@IR_Comparison_Instruction), mc_block)
    } else if ir_instruction is IR_Constant_Instruction {
        self.convert_constant_instruction(ir_instruction.as(@IR_Constant_Instruction), mc_block)
    } else if ir_instruction is IR_Direct_Call_Instruction {
        self.convert_direct_call_instruction(ir_instruction.as(@IR_Direct_Call_Instruction), mc_block)
    } else if ir_instruction is IR_Divide_Instruction {
        self.convert_divide_instruction(ir_instruction.as(@IR_Divide_Instruction), mc_block)
    } else if ir_instruction is IR_Jump_Instruction {
        self.convert_jump_instruction(ir_instruction.as(@IR_Jump_Instruction), mc_block)
    } else if ir_instruction is IR_Load_Instruction {
        self.convert_load_instruction(ir_instruction.as(@IR_Load_Instruction), mc_block)
    } else if ir_instruction is IR_Modulo_Instruction {
        self.convert_modulo_instruction(ir_instruction.as(@IR_Modulo_Instruction), mc_block)
    } else if ir_instruction is IR_Multiply_Instruction {
        self.convert_multiply_instruction(ir_instruction.as(@IR_Multiply_Instruction), mc_block)
    } else if ir_instruction is IR_Negate_Instruction {
        self.convert_negate_instruction(ir_instruction.as(@IR_Negate_Instruction), mc_block)
    } else if ir_instruction is IR_Not_Instruction {
        self.convert_not_instruction(ir_instruction.as(@IR_Not_Instruction), mc_block)
    } else if ir_instruction is IR_Phi_Instruction {
        self.convert_phi_instruction(ir_instruction.as(@IR_Phi_Instruction), mc_block)
    } else if ir_instruction is IR_Return_Instruction {
        self.convert_return_instruction(ir_instruction.as(@IR_Return_Instruction), mc_block)
    } else if ir_instruction is IR_Store_Instruction {
        self.convert_store_instruction(ir_instruction.as(@IR_Store_Instruction), mc_block)
    } else if ir_instruction is IR_Struct_Literal_Instruction {
        \ ignored, this is relevant for the IR only
    } else if ir_instruction is IR_Struct_Type_Member_Offset_Instruction {
        self.convert_struct_type_member_offset_instruction(ir_instruction.as(@IR_Struct_Type_Member_Offset_Instruction), mc_block)
    } else if ir_instruction is IR_Substract_Instruction {
        self.convert_substract_instruction(ir_instruction.as(@IR_Substract_Instruction), mc_block)
    } else {
        stderr.write(self.current_function).end_line()
        abort(ir_instruction.object_type)
    }

    \ cleanup live values
    mc_block.live_values.for_each() {
        if not ir_instruction.live_out_values.contains(it.ir_value) {
            mc_block.live_values.remove(it)
            stderr.write("Removed dead value ").write(it.ir_value).end_line()
        }
    }
    mc_block.live_values.prune()

    \ dump live values
    stderr.write("Live-out values: ")
    mc_block.live_values.for_each() {
        stderr.write(it.ir_value).write('(').write(it).write(") ")
    }
    stderr.end_line()
}

func convert_add_instruction(self: @MC_Generator, ir_add_instruction: @IR_Add_Instruction, mc_block: @MC_Block) -> Nothing {
    let mc_register_value = self.make_register_value(
        mc_block = mc_block
        ir_value = ir_add_instruction.result_value
        register = self.find_free_caller_saved_register(mc_block)
        load_value = false
    )
    mc_block.append(make @MC_MOV_Instruction(
        source = mc_block.find_value(ir_add_instruction.get_left_value())
        destination = mc_register_value
    ))
    mc_block.append(make @MC_ADD_Instruction(
        source = mc_block.find_value(ir_add_instruction.get_right_value())
        destination = mc_register_value
    ))
}

func convert_alloc_instruction(self: @MC_Generator, ir_alloc_instruction: @IR_Alloc_Instruction, mc_block: @MC_Block) -> Nothing {
    mc_block.stack_size = mc_block.stack_size + ir_alloc_instruction.type.get_size() \ TODO: align stack size
    let mc_stack_value = make @MC_Local_Value(
        ir_value = ir_alloc_instruction.result_value
        function = mc_block.function
        stack_offset = mc_block.stack_size
    )
    mc_block.live_values.prepend(mc_stack_value)
}

func convert_branch_instruction(self: @MC_Generator, ir_branch_instruction: @IR_Branch_Instruction, mc_block: @MC_Block) -> Nothing {
    let mc_value = mc_block.find_value(ir_branch_instruction.get_condition())
    if mc_value is not MC_Register_Value {
        mc_value = self.make_register_value(
            mc_block = mc_block
            ir_value = ir_branch_instruction.get_condition()
            mc_register = self.find_free_caller_saved_register(mc_block)
            load_value = true
        )
    }
    mc_block.append(make @MC_CMP_Instruction(
        source = make @MC_Immediate_Value(
            ir_value = null
            value = 0u64
        )
        destination = mc_value
    ))

    \ jump to true block
    mc_block.append(make @MC_JNE_Instruction(
        block = self.get_jump_block(mc_block, ir_branch_instruction.true_block)
    ))

    \ jump to false block
    mc_block.append(make @MC_JMP_Instruction(
        block = self.get_jump_block(mc_block, ir_branch_instruction.false_block)
    ))
}

func convert_comparison_instruction(self: @MC_Generator, ir_comparison_instruction: @IR_Comparison_Instruction, mc_block: @MC_Block) -> Nothing {
    let left_mc_value = mc_block.find_value(ir_comparison_instruction.get_left_value())
    if left_mc_value is not MC_Register_Value {
        left_mc_value = self.make_register_value(
            mc_block = mc_block
            ir_value = left_mc_value.ir_value
            mc_register = self.find_free_caller_saved_register(mc_block)
            load_value = true
        )
    }
    let right_mc_value = mc_block.find_value(ir_comparison_instruction.get_right_value())
    mc_block.append(make @MC_CMP_Instruction(
        source = right_mc_value
        destination = left_mc_value
    ))
    let result_mc_value = self.make_register_value(
        mc_block = mc_block
        ir_value = ir_comparison_instruction.result_value
        mc_register = self.find_free_caller_saved_register(mc_block)
        load_value = false
    )
    if ir_comparison_instruction is IR_Equality_Instruction {
        mc_block.append(make @MC_SETE_Instruction(destination = result_mc_value))
    } else if ir_comparison_instruction is IR_Greater_Than_Instruction {
        mc_block.append(make @MC_SETG_Instruction(destination = result_mc_value))
    } else if ir_comparison_instruction is IR_Greater_Than_Or_Equal_Instruction {
        mc_block.append(make @MC_SETGE_Instruction(destination = result_mc_value))
    } else if ir_comparison_instruction is IR_Inequality_Instruction {
        mc_block.append(make @MC_SETNE_Instruction(destination = result_mc_value))
    } else if ir_comparison_instruction is IR_Less_Than_Instruction {
        mc_block.append(make @MC_SETL_Instruction(destination = result_mc_value))
    } else if ir_comparison_instruction is IR_Less_Than_Or_Equal_Instruction {
        mc_block.append(make @MC_SETLE_Instruction(destination = result_mc_value))
    } else {
        abort(ir_comparison_instruction.object_type)
    }
}

func convert_constant_instruction(self: @MC_Generator, ir_instruction: @IR_Constant_Instruction, mc_block: @MC_Block) -> Nothing {
    let literal = ir_instruction.literal
    if literal is Boolean_Token {
        let value = 0u64
        if literal.as(@Boolean_Token).value {
            value = 1u64
        }
        mc_block.live_values.prepend(make @MC_Immediate_Value(
            ir_value = ir_instruction.result_value
            value = value
        ))
    } else if literal is Character_Token {
        let value = literal.as(@Character_Token).value
        mc_block.live_values.prepend(make @MC_Immediate_Value(
            ir_value = ir_instruction.result_value
            value = value.as(u64)
        ))
    } else if literal is Integer_Token {
        let literal = literal.as(@Integer_Token)
        let value = literal.value
        if literal.negative {
            value = -value
        }
        if ir_instruction.result_value.type is IR_Int32_Type {
            mc_block.live_values.prepend(make @MC_Immediate_Value(
                ir_value = ir_instruction.result_value
                value = (value.as(u32)).as(u64)
            ))
        } else {
            abort(ir_instruction.result_value.type.object_type)
        }
    } else {
        abort(literal.object_type)
    }
}

func convert_direct_call_instruction(self: @MC_Generator, ir_direct_call_instruction: @IR_Direct_Call_Instruction, mc_block: @MC_Block) -> Nothing {
    if ir_direct_call_instruction.next_instruction != null {
        \ move live values to callee saved registers or stack slots
        ir_direct_call_instruction.next_instruction.live_in_values.for_each() {
            let ir_value = it
            if ir_value != ir_direct_call_instruction.result_value {
                let mc_register_value = mc_block.find_register_value(it)
                if mc_register_value != null and mc_register_value.register.is_caller_saved {
                    \ move value to callee saved register
                    let new_mc_register_value = self.make_register_value(
                        mc_block = mc_block
                        ir_value = ir_value
                        mc_register = self.find_free_callee_saved_register(mc_block)
                        load_value = true
                    )
                    new_mc_register_value.register.is_used = true
                    mc_block.live_values.remove(mc_register_value).prune()
                }
            }
        }
    }

    \ map arguments to registers
    if ir_direct_call_instruction.arguments_size > 0 {
        let argument_index = 0
        while argument_index < ir_direct_call_instruction.arguments_size {
            let parameter_register = self.parameter_register(argument_index)
            if not parameter_register.is_free(mc_block) {
                abort("Release parameter register: ".clone().append(parameter_register.name_q))
            }
            self.make_register_value(
                mc_block = mc_block
                ir_value = ir_direct_call_instruction.get_argument_value(argument_index)
                mc_register = self.parameter_register(argument_index)
                load_value = true
            )
            argument_index = argument_index + 1
        }
    }

    \ create call instruction
    let ir_function = ir_direct_call_instruction.function
    mc_block.append(make @MC_CALL_Instruction(
        callee = make @MC_Global_Value(
            ir_value = null
            name = ir_function.name
        )
    ))

    \ remove all caller-saved register values
    mc_block.live_values.for_each() {
        let mc_value = it
        if mc_value is MC_Register_Value {
            let mc_register_value = mc_value.as(@MC_Register_Value)
            if mc_register_value.register.is_caller_saved {
                mc_block.live_values.remove(mc_register_value)
            }
        }
    }
    mc_block.live_values.prune()

    \ map return value to rax
    if ir_function.return_type is not IR_Nothing_Type {
        let return_value = self.make_register_value(
            mc_block = mc_block
            ir_value = ir_direct_call_instruction.result_value
            register = self.register_rax
            load_value = false
        )
    }
}

func convert_divide_instruction(self: @MC_Generator, ir_divide_instruction: @IR_Divide_Instruction, mc_block: @MC_Block) -> Nothing {
    self.make_division(mc_block, ir_divide_instruction.get_left_value(), ir_divide_instruction.get_right_value())
    self.make_register_value(
        mc_block = mc_block
        ir_value = ir_divide_instruction.result_value
        register = self.register_rax
        load_value = false
    )
}

func make_division(self: @MC_Generator, mc_block: @MC_Block, left_ir_value: @IR_Value, right_ir_value: @IR_Value) -> Nothing {
    \ reserve rax and rdx
    self.release_register(mc_block, self.register_rax)
    self.register_rax.is_reserved = true
    self.release_register(mc_block, self.register_rdx)
    self.register_rdx.is_reserved = true

    let left_mc_value = mc_block.find_value(left_ir_value)
    let right_mc_value = mc_block.find_value(right_ir_value)
    mc_block.append(make @MC_MOV_Instruction(
        source = left_mc_value
        destination = make @MC_Register_Value(
            ir_value = null
            data_size = left_mc_value.data_size()
            register = self.register_rax
        )
    ))
    mc_block.append(make @MC_CLTD_Instruction())
    mc_block.append(make @MC_IDIV_Instruction(
        source = right_mc_value
    ))

    \ unreserve rax and rdx
    self.register_rdx.is_reserved = false
    self.register_rax.is_reserved = false
}

func convert_jump_instruction(self: @MC_Generator, ir_jump_instruction: @IR_Jump_Instruction, mc_block: @MC_Block) -> Nothing {
    mc_block.append(make @MC_JMP_Instruction(
        block = self.get_jump_block(mc_block, ir_jump_instruction.block)
    ))
}

func convert_load_instruction(self: @MC_Generator, ir_load_instruction: @IR_Load_Instruction, mc_block: @MC_Block) -> Nothing {
    let mc_register_value = self.make_register_value(
        mc_block = mc_block
        ir_value = ir_load_instruction.result_value
        mc_register = self.find_free_caller_saved_register(mc_block)
        load_value = false
    )
    mc_block.append(make @MC_MOV_Instruction(
        source = mc_block.find_value(ir_load_instruction.get_value_pointer())
        destination = mc_register_value
    ))
}

func convert_modulo_instruction(self: @MC_Generator, ir_modulo_instruction: @IR_Modulo_Instruction, mc_block: @MC_Block) -> Nothing {
    self.make_division(mc_block, ir_modulo_instruction.get_left_value(), ir_modulo_instruction.get_right_value())
    self.make_register_value(
        mc_block = mc_block
        ir_value = ir_modulo_instruction.result_value
        register = self.register_rdx
        load_value = false
    )
}

func convert_multiply_instruction(self: @MC_Generator, ir_multiply_instruction: @IR_Multiply_Instruction, mc_block: @MC_Block) -> Nothing {
    self.release_register(mc_block, self.register_rax)
    self.register_rax.is_reserved = true
    self.release_register(mc_block, self.register_rdx)
    self.register_rdx.is_reserved = true
    let mc_register_value = self.make_register_value(
        mc_block = mc_block
        ir_value = ir_multiply_instruction.result_value
        mc_register = self.register_rax
        load_value = false
    )
    mc_block.append(make @MC_MOV_Instruction(
        source = mc_block.find_value(ir_multiply_instruction.get_left_value())
        destination = mc_register_value
    ))
    let right_value = mc_block.find_value(ir_multiply_instruction.get_right_value())
    if right_value is MC_Immediate_Value {
        \ move right value to register
        right_value = self.make_register_value(
            mc_block = mc_block
            ir_value = right_value.ir_value
            mc_register = self.find_free_caller_saved_register(mc_block)
            load_value = true
        )
    }
    mc_block.append(make @MC_MUL_Instruction(
        source = right_value
    ))
    self.register_rdx.is_reserved = false
    self.register_rax.is_reserved = false
}

func convert_negate_instruction(self: @MC_Generator, ir_negate_instruction: @IR_Negate_Instruction, mc_block: @MC_Block) -> Nothing {
    let mc_register_value = self.make_register_value(
        mc_block = mc_block
        ir_value = ir_negate_instruction.result_value
        mc_register = self.find_free_caller_saved_register(mc_block)
        load_value = false
    )
    mc_block.append(make @MC_MOV_Instruction(
        source = mc_block.find_value(ir_negate_instruction.get_value())
        destination = mc_register_value
    ))
    mc_block.append(make @MC_NEG_Instruction(
        destination = mc_register_value
    ))
}

func convert_not_instruction(self: @MC_Generator, ir_not_instruction: @IR_Not_Instruction, mc_block: @MC_Block) -> Nothing {
    let mc_register_value = self.make_register_value(
        mc_block = mc_block
        ir_value = ir_not_instruction.result_value
        mc_register = self.find_free_caller_saved_register(mc_block)
        load_value = false
    )
    mc_block.append(make @MC_MOV_Instruction(
        source = mc_block.find_value(ir_not_instruction.get_value())
        destination = mc_register_value
    ))
    if ir_not_instruction.result_value.type is IR_Boolean_Type {
        mc_block.append(make @MC_XOR_Instruction(
            source = make @MC_Immediate_Value(
                ir_value = null
                data_size = 1
                value = 1u64
            )
            destination = mc_register_value
        ))
    } else {
        abort(ir_not_instruction.result_value.type.object_type)
    }
}

func convert_phi_instruction(self: @MC_Generator, ir_phi_instruction: @IR_Phi_Instruction, mc_block: @MC_Block) -> Nothing {
    \ validate that phi value is properly mapped
    mc_block.phi_values.for_each() {
        if it.ir_value == ir_phi_instruction.result_value {
            \ mark phi value as live
            mc_block.live_values.prepend(it)
            return
        }
    }

    stderr.write(self.current_function).end_line()
    abort("Invalid state: unmapped phi value: ".clone().append(ir_phi_instruction.result_value.name))
}

func convert_return_instruction(self: @MC_Generator, ir_return_instruction: @IR_Return_Instruction, mc_block: @MC_Block) -> Nothing {
    let return_ir_value = ir_return_instruction.get_return_value()
    if return_ir_value != null {
        let return_mc_value = mc_block.find_value(return_ir_value)
        if return_mc_value is MC_Register_Value {
            let return_mc_value = return_mc_value.as(@MC_Register_Value)
            if return_mc_value.register is not MC_Register_RAX {
                return_mc_value = self.make_register_value(
                    mc_block = mc_block
                    ir_value = return_mc_value.ir_value
                    mc_register = self.register_rax
                    load_value = true
                )
            }
        } else {
            return_mc_value = self.make_register_value(
                mc_block = mc_block
                ir_value = return_mc_value.ir_value
                mc_register = self.register_rax
                load_value = true
            )
        }
    }

    mc_block.append(make @MC_JMP_Instruction(
        block = mc_block.function.epilogue_block
    ))
}

func convert_store_instruction(self: @MC_Generator, ir_store_instruction: @IR_Store_Instruction, mc_block: @MC_Block) -> Nothing {
    mc_block.append(make @MC_MOV_Instruction(
        source = mc_block.find_value(ir_store_instruction.get_value())
        destination = mc_block.find_value(ir_store_instruction.get_value_pointer())
    ))
}

func convert_struct_type_member_offset_instruction(self: @MC_Generator, ir_struct_type_member_offset_instruction: @IR_Struct_Type_Member_Offset_Instruction, mc_block: @MC_Block) -> Nothing {
    let mc_struct_pointer_value = mc_block.find_value(ir_struct_type_member_offset_instruction.get_value_pointer())
    let ir_struct_type_member = ir_struct_type_member_offset_instruction.struct_type_member

    if mc_struct_pointer_value is MC_Local_Value {
        let mc_struct_pointer_value = mc_struct_pointer_value.as(@MC_Local_Value)
        let mc_struct_member_pointer_value = make @MC_Local_Value(
            ir_value = ir_struct_type_member_offset_instruction.result_value
            function = mc_block.function
            stack_offset = mc_struct_pointer_value.stack_offset - ir_struct_type_member.offset
        )
        mc_block.live_values.prepend(mc_struct_member_pointer_value)
    } else {
        abort(mc_struct_pointer_value.object_type)
    }
}

func convert_substract_instruction(self: @MC_Generator, ir_substract_instruction: @IR_Substract_Instruction, mc_block: @MC_Block) -> Nothing {
    let mc_register_value = self.make_register_value(
        mc_block = mc_block
        ir_value = ir_substract_instruction.result_value
        mc_register = self.find_free_caller_saved_register(mc_block)
        load_value = false
    )
    mc_block.append(make @MC_MOV_Instruction(
        source = mc_block.find_value(ir_substract_instruction.get_left_value())
        destination = mc_register_value
    ))
    mc_block.append(make @MC_SUB_Instruction(
        source = mc_block.find_value(ir_substract_instruction.get_right_value())
        destination = mc_register_value
    ))
}

func find_free_callee_saved_register(self: @MC_Generator, mc_block: @MC_Block) -> @MC_Register {
    self.registers.for_each() {
        let register = it
        if register.is_callee_saved and register.is_free(mc_block) {
            return register
        }
    }
    abort("No free callee saved register")
}

func find_free_caller_saved_register(self: @MC_Generator, mc_block: @MC_Block) -> @MC_Register {
    self.registers.for_each() {
        let register = it
        if register.is_caller_saved and register.is_free(mc_block) {
            return register
        }
    }
    abort("No free caller saved register")
}

func is_free(self: @MC_Register, mc_block: @MC_Block) -> bool {
    if self.is_reserved {
        return false
    }
    let mc_register_value = mc_block.find_register_value(self)
    return mc_register_value == null
}

func find_value(self: @MC_Block, ir_value: @IR_Value) -> @MC_Value {
    self.live_values.for_each() {
        let mc_value = it
        if mc_value.ir_value == ir_value {
            return mc_value
        }
    }

    self.global_values.for_each() {
        let mc_global_value = it
        if mc_global_value.ir_value == ir_value {
            return mc_global_value
        }
    }

    abort("Value not found: ".clone().append(ir_value.name))
}

func find_register_value(self: @MC_Block, ir_value: @IR_Value) -> @MC_Register_Value {
    self.live_values.for_each() {
        let mc_value = it
        if mc_value is MC_Register_Value {
            let mc_value = mc_value.as(@MC_Register_Value)
            if mc_value.ir_value == ir_value {
                return mc_value
            }
        }
    }
    return null
}

func find_register_value(self: @MC_Block, register: @MC_Register) -> @MC_Register_Value {
    self.live_values.for_each() {
        let mc_value = it
        if mc_value is MC_Register_Value {
            let mc_value = mc_value.as(@MC_Register_Value)
            if mc_value.register == register {
                return mc_value
            }
        }
    }
    return null
}

func release_register(self: @MC_Generator, block: @MC_Block, register: @MC_Register) -> Nothing {
    let value = block.find_register_value(register)
    if value != null {
        \ move value to another free register
        let new_value = self.make_register_value(
            mc_block = block
            ir_value = value.ir_value
            register = self.find_free_caller_saved_register(block)
            load_value = true
        )
        block.live_values.remove(value).prune()
    }
}

func make_register_value(self: @MC_Generator, mc_block: @MC_Block, ir_value: @IR_Value, mc_register: @MC_Register, load_value: bool) -> @MC_Register_Value {
    \ make sure register is free
    let mc_register_value = mc_block.find_register_value(mc_register)
    if mc_register_value != null {
        if mc_register_value.ir_value == ir_value {
            \ register is already loaded
            return mc_register_value
        }

        stderr.write(self.current_function).end_line()
        abort("Register ".clone().append(mc_register.name_q).append(" is not free"))
    }

    \ create register value
    let mc_register_value = make @MC_Register_Value(
        ir_value = ir_value
        register = mc_register
    )

    \ load value to register
    if load_value {
        let mc_value = mc_block.find_value(ir_value)
        mc_block.append(make @MC_MOV_Instruction(
            source = mc_value
            destination = mc_register_value
        ))
    }

    \ add register value to live values
    mc_block.live_values.prepend(mc_register_value)

    return mc_register_value
}
