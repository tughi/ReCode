let DEBUG: bool

struct Checked_Code {
    sources: @List[@Source]
    global_symbols = make Map[@String, @Checked_Symbol]()
    functions = make List[@Checked_Function_Symbol]()
}

struct Checked_Type: Object {
    name: @String
    is_checked_type = true
}

func accepts(self: @Checked_Type, other: @Checked_Type) -> bool {
    let result = self._accepts(other)
    if DEBUG {
        if result {
            stderr.debug().write(self.name).write(" accepts ").write(other.name).reset().end_line()
        } else {
            stderr.debug().write(self.name).write(" doesn't accept ").write(other.name).reset().end_line()
        }
    }
    return result
}

func _accepts(self: @Checked_Type, other: @Checked_Type) -> bool {
    if self == other or other is Checked_Undefined_Type {
        return true
    }
    if self is Checked_Callable_Type {
        if other is Checked_Callable_Type {
            return self.as(@Checked_Callable_Type).accepts(other.as(@Checked_Callable_Type).parameters)
        }
        if self is Checked_Macro_Type {
            if other is Checked_Lazy_Macro_Type {
                return true
            }
            if other is Checked_Macro_Type {
                return self.as(@Checked_Macro_Type).accepts(other.as(@Checked_Macro_Type).parameters)
            }
        }
    } else if self is Checked_Placeholder_Type {
        let self = self.as(@Checked_Placeholder_Type)
        if self.solved_type != null {
            return self.solved_type.accepts(other)
        }
        self.solved_type = other
        return true
    } else if self is Checked_Pointer_Type {
        if other is Checked_Pointer_Type {
            let self_pointed_type = self.as(@Checked_Pointer_Type).pointed_type
            let other_pointed_type = other.as(@Checked_Pointer_Type).pointed_type
            if self_pointed_type == other_pointed_type {
                return true
            }
            if self_pointed_type is Checked_Any_Type {
                return true
            }
            if self_pointed_type is Checked_Function_Type and other_pointed_type is Checked_Function_Type {
                let self_pointed_funtion_type = self_pointed_type.as(@Checked_Function_Type)
                let other_pointed_funtion_type = other_pointed_type.as(@Checked_Function_Type)
                return other_pointed_funtion_type.accepts(self_pointed_funtion_type.parameters) and other_pointed_funtion_type.return_type.accepts(self_pointed_funtion_type.return_type)
            }
            if self_pointed_type is Checked_Struct_Type and other_pointed_type is Checked_Struct_Type {
                return other_pointed_type.as(@Checked_Struct_Type).has_super_type(self_pointed_type.as(@Checked_Struct_Type))
            }
            if self_pointed_type is Checked_Specialized_Placeholder_Type and other_pointed_type is Checked_Struct_Type {
                \ check if other_pointed_type is a derivate from the same generic struct as self_pointed_type
                let placeholder_type = self_pointed_type.as(@Checked_Specialized_Placeholder_Type)
                let struct_type = other_pointed_type.as(@Checked_Struct_Type)
                loop {
                    if struct_type is Checked_Specialized_Struct_Type {
                        let struct_type = struct_type.as(@Checked_Specialized_Struct_Type)
                        if struct_type.generic_struct_name == placeholder_type.generic_struct_name {
                            \ found specialized type
                            \ check if specialization types are compatible
                            placeholder_type.specialization_symbols.for_each() {
                                if not it.type.accepts(struct_type.specialization_symbols.find_type_symbol(it.name).type) {
                                    return false
                                }
                            }
                            \ accepted
                            return true
                        }
                    }
                    struct_type = struct_type.super_type
                    if struct_type == null {
                        return false
                    }
                }
            }
            if self_pointed_type is Checked_Placeholder_Type {
                return self_pointed_type.accepts(other_pointed_type)
            }
        }
        if other is Checked_Null_Type {
            return true
        }
    } else if self is Checked_Unchecked_Array_Type {
        let self = self.as(@Checked_Unchecked_Array_Type)
        if other is Checked_Unchecked_Array_Type {
            let other = other.as(@Checked_Unchecked_Array_Type)
            return self.item_type.accepts(other.item_type)
        }
    }
    return false
}

func equals(self: @Checked_Type, other: @Checked_Type) -> bool {
    if self.object_type != other.object_type {
        return false
    }
    if self is Checked_Pointer_Type {
        return self.as(@Checked_Pointer_Type).pointed_type.equals(other.as(@Checked_Pointer_Type).pointed_type)
    }
    if self is Checked_Function_Type {
        let self = self.as(@Checked_Function_Type)
        let other = other.as(@Checked_Function_Type)
        if not self.return_type.equals(other.return_type) {
            return false
        }
        let self_parameters_item = self.parameters.first_item
        let other_parameters_item = other.parameters.first_item
        while self_parameters_item != null and other_parameters_item != null {
            if not self_parameters_item.data.type.equals(other_parameters_item.data.type) {
                return false
            }
            self_parameters_item = self_parameters_item.next_item
            other_parameters_item = other_parameters_item.next_item
        }
        if self_parameters_item != null or other_parameters_item != null {
            return false
        }
        return true
    }
    return self == other
}

struct Checked_Any_Type: Checked_Builtin_Type(name = "Any") {
}

struct Checked_Array_Type: Checked_Type {
    item_type: @Checked_Type
}

struct Checked_Bool_Type: Checked_Builtin_Type(name = "bool") {
}

struct Checked_Builtin_Type: Checked_Named_Type {
}

struct Checked_Callable_Type: Checked_Type {
    parameters = make List[@Checked_Callable_Parameter]()
}

struct Checked_Callable_Parameter {
    location: @Source_Location
    name: @String
    type: @Checked_Type
}

func accepts(self: @Checked_Callable_Type, call_arguments: @List[@Checked_Call_Argument]) -> bool {
    let result = self._accepts(call_arguments)
    if DEBUG {
        if result {
            stderr.debug().write(self.name).write(" accepts ").write(call_arguments).reset().end_line()
        } else {
            stderr.debug().write(self.name).write(" doesn't accept ").write(call_arguments).reset().end_line()
        }
    }
    return result
}

func write(out: @FILE, checked_call_arguments: @List[@Checked_Call_Argument]) -> @FILE {
    out.write("arguments (")
    checked_call_arguments.for_each_indexed() {
        if it_index > 0 {
            out.write(", ")
        }
        out.write(it.expression.type.name)
    }
    out.write(")")
    return out
}

func _accepts(self: @Checked_Callable_Type, call_arguments: @List[@Checked_Call_Argument]) -> bool {
    \ Check each argument
    let parameter_item = self.parameters.first_item
    let argument_item = call_arguments.first_item
    while parameter_item != null and argument_item != null {
        if not parameter_item.data.type.accepts(argument_item.data.expression.type) {
            return false
        }
        if argument_item.data.name != null and not parameter_item.data.name.equals(argument_item.data.name) {
            return false
        }
        parameter_item = parameter_item.next_item
        argument_item = argument_item.next_item
    }

    if argument_item != null or parameter_item != null {
        \ Arguments number differs from parameters number 
        return false
    }

    return true
}

func accepts(self: @Checked_Callable_Type, other_parameters: @List[@Checked_Callable_Parameter]) -> bool {
    let result = self._accepts(other_parameters)
    if DEBUG {
        if result {
            stderr.debug().write(self.name).write(" accepts ").write(other_parameters).reset().end_line()
        } else {
            stderr.debug().write(self.name).write(" doesn't accept ").write(other_parameters).reset().end_line()
        }
    }
    return result
}

func write(out: @FILE, checked_callable_parameters: @List[@Checked_Callable_Parameter]) -> @FILE {
    out.write("arguments (")
    checked_callable_parameters.for_each_indexed() {
        if it_index > 0 {
            out.write(", ")
        }
        out.write(it.type.name)
    }
    out.write(")")
    return out
}

func _accepts(self: @Checked_Callable_Type, other_parameters: @List[@Checked_Callable_Parameter]) -> bool {
    \ Check each argument
    let self_parameter_item = self.parameters.first_item
    let other_parameter_item = other_parameters.first_item
    while self_parameter_item != null and other_parameter_item != null {
        if not self_parameter_item.data.type.accepts(other_parameter_item.data.type) {
            return false
        }
        self_parameter_item = self_parameter_item.next_item
        other_parameter_item = other_parameter_item.next_item
    }

    if other_parameter_item != null or self_parameter_item != null {
        \ Arguments number differs from parameters number 
        return false
    }

    return true
}

struct Checked_Fixed_Array_Type: Checked_Array_Type {
    size: u64
    size_expression: @Checked_Expression
}

struct Checked_Function_Type: Checked_Callable_Type {
    return_type: @Checked_Type
}

struct Checked_Function_Pointer_Type: Checked_Pointer_Type {
    function_type: @Checked_Function_Type
}

struct Checked_Int_Type: Checked_Integer_Type {
}

struct Checked_Integer_Type: Checked_Builtin_Type {
}

struct Checked_IntMax_Type: Checked_Int_Type(name = "isize") {
}

struct Checked_Int16_Type: Checked_Int_Type(name = "i16") {
}

struct Checked_Int32_Type: Checked_Int_Type(name = "i32") {
}

struct Checked_Int64_Type: Checked_Int_Type(name = "i64") {
}

struct Checked_Int8_Type: Checked_Int_Type(name = "i8") {
}

struct Checked_Lazy_Macro_Type: Checked_Type(name = "macro (...)") {
}

struct Checked_Macro_Type: Checked_Callable_Type {
}

struct Checked_Named_Type: Checked_Type {
}

struct Checked_Nothing_Type: Checked_Builtin_Type(name = "Nothing") {
}

struct Checked_Null_Type: Checked_Builtin_Type(name = "Null") {
}

struct Checked_Opaque_Type: Checked_Named_Type {
}

struct Checked_Placeholder_Type: Checked_Named_Type {
    solved_type: @Checked_Type = null
}

struct Checked_Specialized_Placeholder_Type: Checked_Named_Type {
    generic_struct_name: @String
    specialization_symbols: @Checked_Symbols \ contains at least one Checked_Placeholder_Type
}

struct Checked_Pointer_Type: Checked_Type {
    pointed_type: @Checked_Type
}

struct Checked_Specialized_Struct_Type: Checked_Struct_Type {
    generic_struct_name: @String
    specialization_symbols: @Checked_Symbols
}

struct Checked_Struct_Type: Checked_Named_Type {
    super_type: @Checked_Struct_Type = null
    derived_types = make List[@Checked_Struct_Type]()
    members = make List[@Checked_Struct_Type_Member]()
    default_values = make @Map[@Checked_Struct_Type_Member, @Checked_Expression]()
}

struct Checked_Struct_Type_Member {
    location: @Source_Location
    name: @String
    type: @Checked_Type
    struct_type: @Checked_Struct_Type
}

func add_member(self: @Checked_Struct_Type, location: @Source_Location, name: @String, type: @Checked_Type, default_value_expression: @Checked_Expression) -> @Checked_Struct_Type_Member {
    let member = make @Checked_Struct_Type_Member(
        location = location
        name = name
        type = type
        struct_type = self
    )
    self.members.append(member)
    if default_value_expression != null {
        self.default_values.put(member, default_value_expression)
    }
    return member
}

func get_member(self: @Checked_Struct_Type, name: @String) -> @Checked_Struct_Type_Member {
    let struct_type = self
    loop {
        struct_type.members.for_each() {
            if name.equals(it.name) {
                return it
            }
        }
        struct_type = struct_type.super_type
        if struct_type == null {
            return null
        }
    }
}

func has_super_type(self: @Checked_Struct_Type, other: @Checked_Struct_Type) -> bool {
    let struct_type = self
    while struct_type.super_type != null {
        if struct_type.super_type == other {
            return true
        }
        struct_type = struct_type.super_type
    }
    return false
}

struct Checked_UInt_Type: Checked_Integer_Type {
}

struct Checked_UIntMax_Type: Checked_UInt_Type(name = "usize") {
}

struct Checked_UInt16_Type: Checked_UInt_Type(name = "u16") {
}

struct Checked_UInt32_Type: Checked_UInt_Type(name = "u32") {
}

struct Checked_UInt64_Type: Checked_UInt_Type(name = "u64") {
}

struct Checked_UInt8_Type: Checked_UInt_Type(name = "u8") {
}

struct Checked_Unchecked_Array_Type: Checked_Array_Type {
}

struct Checked_Undefined_Type: Checked_Builtin_Type(name = "Undefined") {
}

struct Checked_Symbols: List[@Checked_Symbol] {
    parent: @Checked_Symbols
}

func find_symbol(self: @Checked_Symbols, name: @String) -> @Checked_Symbol {
    let list_item = self.last_item
    while list_item != null {
        if list_item.data.name.equals(name) {
            return list_item.data
        }
        list_item = list_item.prev_item
    }
    if self.parent != null {
        return self.parent.find_symbol(name)
    }
    return null
}

func find_type_symbol(self: @Checked_Symbols, name: @String) -> @Checked_Type_Symbol {
    let list_item = self.last_item
    while list_item != null {
        if list_item.data is Checked_Type_Symbol and list_item.data.name.equals(name) {
            return list_item.data.as(@Checked_Type_Symbol)
        }
        list_item = list_item.prev_item
    }
    if self.parent != null {
        return self.parent.find_type_symbol(name)
    }
    return null
}

struct Checked_Symbol: Object {
    location: @Source_Location
    name: @String
    type: @Checked_Type
}

struct Checked_Builtin_Type_Symbol: Checked_Type_Symbol {
}

struct Checked_Constant_Symbol: Checked_Symbol {
    parsed_constant_statement: @Parsed_Constant_Statement
    value_expression: @Checked_Expression
}

struct Checked_Function_Symbol: Checked_Symbol {
    function_type: @Checked_Function_Type
    parsed_function_statement: @Parsed_Function_Statement
    specialization_symbols: @Checked_Symbols
    parameters = make List[@Checked_Parameter_Symbol]()
    body: @Checked_Block_Statement
}

struct Checked_Macro_Symbol: Checked_Symbol {
    parsed_macro_statement: @Parsed_Macro_Statement
}

struct Checked_Macro_Parameter_Symbol: Checked_Symbol {
    parsed_macro_type: @Parsed_Macro_Type
    parsed_macro_body: @Parsed_Statement
    local_symbols: @Checked_Symbols
}

struct Checked_Opaque_Type_Symbol: Checked_Type_Symbol {
}

struct Checked_Parameter_Symbol: Checked_Symbol {
}

struct Checked_Type_Symbol: Checked_Symbol {
}

struct Checked_Specialization_Type_Symbol: Checked_Type_Symbol {
}

struct Checked_Struct_Type_Symbol: Checked_Type_Symbol {
    parsed_struct_statement: @Parsed_Struct_Statement
}

struct Checked_Variable_Symbol: Checked_Symbol {
    expression: @Checked_Expression
    is_external: bool
}

struct Checked_Statement: Object {
    location: @Source_Location
}

struct Checked_Assignment_Statement: Checked_Statement {
    destination_expression: @Checked_Expression
    value_expression: @Checked_Expression
}

struct Checked_Block_Statement: Checked_Statement {
    local_symbols: @Checked_Symbols
    statements = make List[@Checked_Statement]()
}

struct Checked_Break_Statement: Checked_Statement {
}

struct Checked_Expression_Statement: Checked_Statement {
    expression: @Checked_Expression
}

struct Checked_If_Statement: Checked_Statement {
    condition_expression: @Checked_Expression
    true_statement: @Checked_Statement
    false_statement: @Checked_Statement
}

struct Checked_Loop_Statement: Checked_Statement {
    body_statement: @Checked_Statement
}

struct Checked_Ignored_Statement: Checked_Statement {
}

struct Checked_Return_Statement: Checked_Statement {
    expression: @Checked_Expression
}

struct Checked_Variable_Statement: Checked_Statement {
    variable: @Checked_Variable_Symbol
}

struct Checked_While_Statement: Checked_Statement {
    condition_expression: @Checked_Expression
    body_statement: @Checked_Statement
}

struct Checked_Expression: Object {
    location: @Source_Location
    type: @Checked_Type
}

func is_constant(self: @Checked_Expression) -> bool {
    if self is Checked_Literal_Expression {
        return true
    }
    if self is Checked_Symbol_Expression {
        let checked_symbol = self.as(@Checked_Symbol_Expression).symbol
        return checked_symbol is Checked_Constant_Symbol
    }
    return false
}

struct Checked_Add_Expression: Checked_Binary_Expression {
}

struct Checked_Access_Expression: Checked_Expression {
}

struct Checked_Array_Access_Expression: Checked_Expression {
    array_expression: @Checked_Expression
    index_expression: @Checked_Expression
}

struct Checked_Binary_Expression: Checked_Expression {
    left_expression: @Checked_Expression
    right_expression: @Checked_Expression
}

struct Checked_Boolean_Literal_Expression: Checked_Literal_Expression {
    literal: @Boolean_Token
}

struct Checked_Call_Expression: Checked_Expression {
    call_arguments: @List[@Checked_Call_Argument]
}

struct Checked_Call_Argument {
    location: @Source_Location
    name: @String
    expression: @Checked_Expression
}

struct Checked_Cast_Expression: Checked_Expression {
    expression: @Checked_Expression
}

struct Checked_Character_Literal_Expression: Checked_Literal_Expression {
    literal: @Character_Token
}

struct Checked_Divide_Expression: Checked_Binary_Expression {
}

struct Checked_Dynamic_Call_Expression: Checked_Call_Expression {
    callee_expression: @Checked_Expression
}

struct Checked_Equals_Expression: Checked_Binary_Expression {
}

struct Checked_Function_Call_Expression: Checked_Call_Expression {
    function_symbol: @Checked_Function_Symbol
}

struct Checked_Greater_Than_Expression: Checked_Binary_Expression {
}

struct Checked_Greater_Than_Or_Equals_Expression: Checked_Binary_Expression {
}

struct Checked_Integer_Literal_Expression: Checked_Literal_Expression {
    literal: @Integer_Token
}

struct Checked_Is_Expression: Checked_Expression {
    value_expression: @Checked_Expression
    object_type: @Checked_Struct_Type
}

struct Checked_Less_Than_Expression: Checked_Binary_Expression {
}

struct Checked_Less_Than_Or_Equals_Expression: Checked_Binary_Expression {
}

struct Checked_Literal_Expression: Checked_Expression {
}

struct Checked_Logic_And_Expression: Checked_Binary_Expression {
}

struct Checked_Logic_Not_Expression: Checked_Expression {
    expression: @Checked_Expression
}

struct Checked_Logic_Or_Expression: Checked_Binary_Expression {
}

struct Checked_Macro_Body: Checked_Expression {
    parsed_macro_body: @Parsed_Macro_Body
}

struct Checked_Make_Expression: Checked_Expression {
    values = make Map[@Checked_Struct_Type_Member, @Checked_Expression]()
}

struct Checked_Member_Access_Expression: Checked_Access_Expression {
    object_expression: @Checked_Expression
    struct_member: @Checked_Struct_Type_Member
}

struct Checked_Modulo_Expression: Checked_Binary_Expression {
}

struct Checked_Multiply_Expression: Checked_Binary_Expression {
}

struct Checked_Negate_Expression: Checked_Expression {
    expression: @Checked_Expression
}

struct Checked_Not_Equals_Expression: Checked_Binary_Expression {
}

struct Checked_Null_Literal_Expression: Checked_Literal_Expression {
    literal: @Null_Token
}

struct Checked_Reference_Expression: Checked_Expression {
    object_expression: @Checked_Expression
}

struct Checked_String_Literal_Expression: Checked_Literal_Expression {
    literal: @String_Token
}

struct Checked_Substract_Expression: Checked_Binary_Expression {
}

struct Checked_Super_Access_Expression: Checked_Access_Expression {
    object_expression: @Checked_Expression
}

struct Checked_Symbol_Expression: Checked_Expression {
    symbol: @Checked_Symbol
}

struct Checked_Undefined_Literal_Expression: Checked_Literal_Expression {
    literal: @Undefined_Token
}
