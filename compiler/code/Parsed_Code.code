struct Parsed_Code {
    sources = make @List[@Source]()
    function_statements = make @List[@Parsed_Function_Statement]()
    macro_statements = make @List[@Parsed_Macro_Statement]()
    statements = make @List[@Parsed_Statement]()
    named_statements = make @Map[@String, @List[@Parsed_Statement]]()
}

func get_named_statements(self: @Parsed_Code, name: @String) -> @List[@Parsed_Statement] {
    for_each(self.named_statements) {
        if name.equals(key) {
            return value
        }
    }
    return null
}

func get_type_statement(self: @Parsed_Code, name: @String) -> @Parsed_Type_Statement {
    let type_statement: @Parsed_Type_Statement = null
    for_each(self.statements) {
        if it is Parsed_Type_Statement {
            let statement = it.as(@Parsed_Type_Statement)
            if statement.name.lexeme.equals(name) {
                if type_statement != null {
                    stderr.end_line().write(type_statement.location).write(": First ").write(name).write(" declaration").end_line()
                    abort(statement.location, clone("Duplicate ").append(name).append(" declaration"))
                }
                type_statement = statement
            }
        }
    }
    return type_statement
}

func get_generic_struct_statement(self: @Parsed_Code, name: @String) -> @Parsed_Generic_Struct_Statement {
    let struct_statement: @Parsed_Generic_Struct_Statement = null
    for_each(self.statements) {
        if it is Parsed_Generic_Struct_Statement {
            let statement = it.as(@Parsed_Generic_Struct_Statement)
            if statement.name.lexeme.equals(name) {
                if struct_statement != null {
                    stderr.end_line().write(struct_statement.location).write(": First ").write(name).write(" declaration").end_line()
                    abort(statement.location, clone("Duplicate ").append(name).append(" declaration"))
                }
                struct_statement = statement
            }
        }
    }
    return struct_statement
}

func put_named_statement(self: @Parsed_Code, name: @String, statement: @Parsed_Statement) -> Nothing {
    let named_statements = self.get_named_statements(name)
    if named_statements == null {
        named_statements = make @List[@Parsed_Statement]()
        self.named_statements.put(name, named_statements)
    }
    named_statements.append(statement)
}

struct Parsed_Statement: Object {
    location: @Source_Location
}

struct Parsed_Include_Statement: Parsed_Statement {
    file_path: @String
}

struct Parsed_Function_Statement: Parsed_Statement {
    name: @Identifier_Token
    receiver_type: @Parsed_Type
    type: @Parsed_Function_Type
    body: @Parsed_Block_Statement
    is_anonymous: bool
}

func is_duplicate(self: @Parsed_Function_Statement, other: @Parsed_Function_Statement) -> bool {
    if not self.name.lexeme.equals(other.name.lexeme) {
        \ different name
        return false
    }

    let self_type = self.type
    let other_type = other.type

    \ check number of type parameters
    if self_type.type_parameters != null {
        if other_type.type_parameters == null {
            return false
        }
        if self_type.type_parameters.size != other_type.type_parameters.size {
            return false
        }
    } else if other_type.type_parameters != null {
        return false
    }

    \ check number of parameters
    if self_type.parameters.size != other_type.parameters.size {
        return false
    }

    \ check each parameter
    self_type.parameters.for_each_indexed() {
        let self_parameter = it
        let other_parameter = other_type.parameters.get(it_index.as(i64))
        if not same_types(self_parameter.type, self_type.type_parameters, other_parameter.type, other_type.type_parameters) {
            return false
        }
    }

    return true
}

func same_types(self: @Parsed_Type, self_context: @List[@Parsed_Type_Parameter], other: @Parsed_Type, other_context: @List[@Parsed_Type_Parameter]) -> bool {
    if self.object_type != other.object_type {
        return false
    }
    if self is Parsed_Array_Type {
        let self = self.as(@Parsed_Array_Type)
        let other = other.as(@Parsed_Array_Type)
        if self.is_checked != other.is_checked {
            return false
        }
        if not self.size_expression.same_expressions(other.size_expression) {
            return false
        }
        return same_types(self.item_type, self_context, other.item_type, other_context)
    }
    if self is Parsed_Function_Type {
        let self = self.as(@Parsed_Function_Type)
        let other = other.as(@Parsed_Function_Type)
        if self.parameters.size != other.parameters.size {
            return false
        }
        self.parameters.for_each_indexed() {
            let self_parameter = it
            let other_parameter = other.parameters.get(it_index.as(i64))
            if not same_types(self_parameter.type, self_context, other_parameter.type, other_context) {
                return false
            }
        }
        return same_types(self.return_type, self_context, other.return_type, other_context)
    }
    if self is Parsed_Named_Type {
        let self = self.as(@Parsed_Named_Type)
        let other = other.as(@Parsed_Named_Type)
        if self_context != null {
            self_context.for_each_indexed() {
                let self_type_parameter = it
                let other_type_parameter = other_context.get(it_index.as(i64))
                if self.name.lexeme.equals(self_type_parameter.name.lexeme) {
                    if other.name.lexeme.equals(other_type_parameter.name.lexeme) {
                        return true
                    }
                    return false
                } else if other.name.lexeme.equals(other_type_parameter.name.lexeme) {
                    return false
                }
            }
        }
        return self.name.lexeme.equals(other.name.lexeme)
    }
    if self is Parsed_Pointer_Type {
        return same_types(self.as(@Parsed_Pointer_Type).pointed_type, self_context, other.as(@Parsed_Pointer_Type).pointed_type, other_context)
    }
    abort(self.location, self.object_type)
}

func same_expressions(self: @Parsed_Expression, other: @Parsed_Expression) -> bool {
    if self == null {
        return other == null
    }
    if self.object_type != other.object_type {
        return false
    }
    if self is Parsed_Literal_Expression {
        return same_literals(self.as(@Parsed_Literal_Expression).literal, other.as(@Parsed_Literal_Expression).literal)
    }
    abort(self.location, self.object_type)
}

func same_literals(self: @Literal_Token, other: @Literal_Token) -> bool {
    if self.object_type != other.object_type {
        return false
    }
    return self.lexeme.equals(other.lexeme)
}

struct Parsed_Macro_Statement: Parsed_Statement {
    name: @Identifier_Token
    receiver_type: @Parsed_Type
    type: @Parsed_Macro_Type
    body: @Parsed_Block_Statement
}

struct Parsed_Block_Statement: Parsed_Statement {
    statements: @List[@Parsed_Statement]
}

struct Parsed_Constant_Statement: Parsed_Statement {
    name: @Identifier_Token
    expression: @Parsed_Expression
}

struct Parsed_Expression_Statement: Parsed_Statement {
    expression: @Parsed_Expression
}

struct Parsed_If_Statement: Parsed_Statement {
    condition_expression: @Parsed_Expression
    true_statement: @Parsed_Statement
    false_statement: @Parsed_Statement
}

struct Parsed_Loop_Statement: Parsed_Statement {
    body_statement: @Parsed_Block_Statement
}

struct Parsed_While_Statement: Parsed_Statement {
    condition_expression: @Parsed_Expression
    body_statement: @Parsed_Block_Statement
}

struct Parsed_Break_Statement: Parsed_Statement {
}

struct Parsed_Return_Statement: Parsed_Statement {
    value_expression: @Parsed_Expression
}

struct Parsed_Variable_Statement: Parsed_Statement {
    name: @Identifier_Token
    type: @Parsed_Type
    value_expression: @Parsed_Expression = null
    is_external = false
}

struct Parsed_Type_Statement: Parsed_Statement {
    name: @Identifier_Token
}

struct Parsed_External_Type_Statement: Parsed_Type_Statement {
}

struct Parsed_Struct_Statement: Parsed_Type_Statement {
    super_type: @Parsed_Type
    super_arguments: @List[@Parsed_Call_Argument]
    members: @List[@Parsed_Struct_Member]
    functions: @List[@Parsed_Function_Statement]
}

struct Parsed_Generic_Struct_Statement: Parsed_Type_Statement {
    type_parameters: @List[@Parsed_Type_Parameter]
    struct_statement: @Parsed_Struct_Statement
}

struct Parsed_Type_Parameter {
    name: @Identifier_Token
}

struct Parsed_Struct_Member {
    location: @Source_Location
    name: @Identifier_Token
    type: @Parsed_Type
    default_value_expression: @Parsed_Expression
}

struct Parsed_Trait_Statement: Parsed_Type_Statement {
    functions: @List[@Parsed_Function_Statement]
}

struct Parsed_Assignment_Statement: Parsed_Statement {
    storage_expression: @Parsed_Expression
    operator: @Other_Token
    value_expression: @Parsed_Expression
}

struct Parsed_Type: Object {
    location: @Source_Location = null
}

struct Parsed_Named_Type: Parsed_Type {
    name: @Identifier_Token
}

struct Parsed_Placeholder_Type: Parsed_Type {
    name: @String
}

struct Parsed_Pointer_Type: Parsed_Type {
    pointed_type: @Parsed_Type
}

struct Parsed_Receiver_Type: Parsed_Type {
}

struct Parsed_Specialized_Type: Parsed_Type {
    name: @Identifier_Token
    type_arguments: @List[@Parsed_Type_Argument]
}

struct Parsed_Type_Argument {
    name: @String = null
    type: @Parsed_Type
}

struct Parsed_Array_Type: Parsed_Type {
    item_type: @Parsed_Type
    size_expression: @Parsed_Expression
    is_checked: bool
}

struct Parsed_Callable_Type: Parsed_Type {
    type_parameters: @List[@Parsed_Type_Parameter]
    parameters: @List[@Parsed_Callable_Parameter]
}

struct Parsed_Function_Type: Parsed_Callable_Type {
    return_type: @Parsed_Type
}

struct Parsed_Macro_Type: Parsed_Callable_Type {
}

struct Parsed_Callable_Parameter {
    location: @Source_Location
    label: @Identifier_Token
    name: @Identifier_Token
    type: @Parsed_Type
}

struct Parsed_Expression: Object {
    location: @Source_Location
}

struct Parsed_Paren_Expression: Parsed_Expression {
    expression: @Parsed_Expression
}

struct Parsed_Literal_Expression: Parsed_Expression {
    literal: @Literal_Token
}

struct Parsed_Symbol_Expression: Parsed_Expression {
    name: @Identifier_Token
}

struct Parsed_Dereference_Expression: Parsed_Expression {
    target_expression: @Parsed_Expression
}

struct Parsed_Reference_Expression: Parsed_Expression {
    target_expression: @Parsed_Expression
}

struct Parsed_Binary_Expression: Parsed_Expression {
    left_expression: @Parsed_Expression
    right_expression: @Parsed_Expression
}

struct Parsed_Add_Expression: Parsed_Binary_Expression {
}

struct Parsed_Divide_Expression: Parsed_Binary_Expression {
}

struct Parsed_Equals_Expression: Parsed_Binary_Expression {
}

struct Parsed_Greater_Than_Expression: Parsed_Binary_Expression {
}

struct Parsed_Greater_Than_Or_Equals_Expression: Parsed_Binary_Expression {
}

struct Parsed_Less_Than_Expression: Parsed_Binary_Expression {
}

struct Parsed_Less_Than_Or_Equals_Expression: Parsed_Binary_Expression {
}

struct Parsed_Logic_And_Expression: Parsed_Binary_Expression {
}

struct Parsed_Logic_Not_Expression: Parsed_Unary_Expression {
}

struct Parsed_Logic_Or_Expression: Parsed_Binary_Expression {
}

struct Parsed_Modulo_Expression: Parsed_Binary_Expression {
}

struct Parsed_Multiply_Expression: Parsed_Binary_Expression {
}

struct Parsed_Not_Equals_Expression: Parsed_Binary_Expression {
}

struct Parsed_Substract_Expression: Parsed_Binary_Expression {
}

struct Parsed_Unary_Expression: Parsed_Expression {
    expression: @Parsed_Expression
}

struct Parsed_Negate_Expression: Parsed_Unary_Expression {
}

struct Parsed_Cast_Expression: Parsed_Expression {
    value_expression: @Parsed_Expression
    type: @Parsed_Type
}

struct Parsed_Is_Expression: Parsed_Expression {
    value_expression: @Parsed_Expression
    type: @Parsed_Type
}

struct Parsed_Make_Expression: Parsed_Expression {
    type: @Parsed_Type
    init_arguments: @List[@Parsed_Call_Argument]
}

struct Parsed_Function_Expression: Parsed_Expression {
    function_statement: @Parsed_Function_Statement
}

struct Parsed_Call_Expression: Parsed_Expression {
    callee_expression: @Parsed_Expression
    arguments: @List[@Parsed_Call_Argument]
}

struct Parsed_Call_Argument {
    location: @Source_Location
    name: @Identifier_Token
    value_expression: @Parsed_Expression
}

struct Parsed_Access_Expression: Parsed_Expression {
}

struct Parsed_Member_Access_Expression: Parsed_Access_Expression {
    object_expression: @Parsed_Expression
    member_name: @Identifier_Token
}

struct Parsed_Array_Access_Expression: Parsed_Access_Expression {
    array_expression: @Parsed_Expression
    index_expression: @Parsed_Expression
}

struct Parsed_Wrapped_Expression: Parsed_Expression {
    expression: @Parsed_Expression
}

struct Parsed_Macro_Body: Parsed_Expression {
    statement: @Parsed_Block_Statement
}

func write(file: @FILE, parsed_code: @Parsed_Code) -> @FILE {
    let statements = parsed_code.statements.create_iterator()
    while statements.has_next() {
        let statement = statements.next()
        file.write_source_line(statement.location, 0i64).write(statement, 0i64).end_line()
    }
    return file
}

func write(file: @FILE, statement: @Parsed_Statement, alignment: i64) -> @FILE {
    if statement is Parsed_Assignment_Statement {
        let statement = statement.as(@Parsed_Assignment_Statement)
        return file.write(statement.storage_expression).write(' ').write(statement.operator).write(' ').write(statement.value_expression)
    }

    if statement is Parsed_Block_Statement {
        file.write('{').end_line()
        let block_statements = statement.as(@Parsed_Block_Statement).statements.create_iterator()
        while block_statements.has_next() {
            let block_statement = block_statements.next()
            file.write_source_line(block_statement.location, alignment + 1).write(block_statement, alignment + 1).end_line()
        }
        return file.write_source_line(statement.location, alignment).write('}')
    }

    if statement is Parsed_Break_Statement {
        return file.write("break")
    }

    if statement is Parsed_Constant_Statement {
        let statement = statement.as(@Parsed_Constant_Statement)
        return file.write("define ").write(statement.name).write(" = ").write(statement.expression)
    }

    if statement is Parsed_Expression_Statement {
        return file.write(statement.as(@Parsed_Expression_Statement).expression)
    }

    if statement is Parsed_Function_Statement {
        let statement = statement.as(@Parsed_Function_Statement)
        file.write("define ").write(statement.name).write(" = func (")
        let parameters = statement.type.parameters.create_iterator()
        if parameters.has_next() {
            loop {
                file.write(parameters.next())
                if parameters.has_next() {
                    file.write(", ")
                } else {
                    break
                }
            }
        }
        file.write(") -> ").write(statement.type.return_type)
        if statement.body == null {
            return file
        }
        return file.write(" ").write(statement.body, alignment)
    }

    if statement is Parsed_If_Statement {
        let statement = statement.as(@Parsed_If_Statement)
        file.write("if (").write(statement.condition_expression).write(") ").write(statement.true_statement, alignment)
        if statement.false_statement != null {
            file.write(" else ").write(statement.false_statement, alignment)
        }
        return file
    }

    if statement is Parsed_Loop_Statement {
        let statement = statement.as(@Parsed_Loop_Statement)
        return file.write("loop ").write(statement.body_statement, alignment)
    }

    if statement is Parsed_Macro_Statement {
        let statement = statement.as(@Parsed_Macro_Statement)
        file.write("define ").write(statement.name).write(" = func (")
        let parameters = statement.type.parameters.create_iterator()
        if parameters.has_next() {
            loop {
                file.write(parameters.next())
                if parameters.has_next() {
                    file.write(", ")
                } else {
                    break
                }
            }
        }
        return file.write(") ").write(statement.body, alignment)
    }

    if statement is Parsed_Return_Statement {
        let statement = statement.as(@Parsed_Return_Statement)
        file.write("return")
        if statement.value_expression != null {
            file.write(" ").write(statement.value_expression)
        }
        return file
    }

    if statement is Parsed_Struct_Statement {
        let statement = statement.as(@Parsed_Struct_Statement)
        file.write("define ").write(statement.name).write(" = struct")
        if statement.members == null {
            return file
        }
        file.write(" {").end_line()
        if statement.super_type != null {
            file.write_source_line(statement.super_type.location, alignment + 1).write("extends ").write(statement.super_type).end_line()
        }
        let members = statement.members.create_iterator()
        while members.has_next() {
            let member = members.next()
            file.write_source_line(member.location, alignment + 1).write(member.name).write(": ").write(member.type).end_line()
        }
        return file.write_source_line(statement.location, alignment).write('}')
    }

    if statement is Parsed_Variable_Statement {
        let statement = statement.as(@Parsed_Variable_Statement)
        file.write(statement.name)
        if statement.type != null {
            file.write(": ").write(statement.type)
            if statement.value_expression != null {
                file.write(" = ").write(statement.value_expression)
            }
            if statement.is_external {
                file.write(" = external")
            }
        } else {
            file.write(" := ").write(statement.value_expression)
        }
        return file
    }

    if statement is Parsed_While_Statement {
        let statement = statement.as(@Parsed_While_Statement)
        return file.write("while (").write(statement.condition_expression).write(") ").write(statement.body_statement, alignment)
    }

    file.flush()
    abort(statement.location, "Unsupported Parsed_Statement type: ".clone().append(statement.object_type.name))
}

func write_source_line(file: @FILE, location: @Source_Location, alignment: i64) -> @FILE {
    file.write(location.source.file_path).write(':')
    let line = location.line
    if line < 1000 {
        file.write('0')
    }
    if line < 100 {
        file.write('0')
    }
    if line < 10 {
        file.write('0')
    }
    file.write(line).write(": ")

    let space_count = alignment * 2
    while space_count > 0 {
        file.write(' ')
        space_count = space_count - 1
    }

    return file
}

func write(file: @FILE, parameter: @Parsed_Callable_Parameter) -> @FILE {
    return file.write(parameter.name).write(": ").write(parameter.type)
}

func write(file: @FILE, type: @Parsed_Type) -> @FILE {
    if type is Parsed_Array_Type {
        let type = type.as(@Parsed_Array_Type)
        if type.size_expression != null {
            return file.write('[').write(type.item_type).write("; ").write(type.size_expression).write(']')
        }
        return file.write('[').write(type.item_type).write(']')
    }

    if type is Parsed_Function_Type {
        let type = type.as(@Parsed_Function_Type)
        file.write("func ")
        if type.type_parameters != null {
            file.write('[')
            type.type_parameters.for_each_list_item() {
                let type_parameter = list_item.data
                file.write(type_parameter.name)
                if list_item.next_item != null {
                    file.write(", ")
                }
            }
            file.write("] ")
        }
        file.write('(')
        let parameters_item = type.parameters.first_item
        while parameters_item != null {
            let parameter = parameters_item.data
            file.write(parameter.name).write(": ").write(parameter.type)
            parameters_item = parameters_item.next_item
            if parameters_item != null {
                file.write(", ")
            }
        }
        return file.write(") -> ").write(type.return_type)
    }

    if type is Parsed_Named_Type {
        return file.write(type.as(@Parsed_Named_Type).name)
    }

    if type is Parsed_Pointer_Type {
        return file.write('@').write(type.as(@Parsed_Pointer_Type).pointed_type)
    }

    if type is Parsed_Specialized_Type {
        let type = type.as(@Parsed_Specialized_Type)
        file.write(type.name).write('[')
        type.type_arguments.for_each_list_item() {
            let type_argument = list_item.data
            file.write(type_argument.type)
            if list_item.next_item != null {
                file.write(", ")
            }
        }
        return file.write(']')
    }

    if type is Parsed_Placeholder_Type {
        return file.write(type.as(@Parsed_Placeholder_Type).name)
    }

    if type is Parsed_Macro_Type {
        let type = type.as(@Parsed_Macro_Type)
        file.write("macro ")
        if type.type_parameters != null {
            file.write('[')
            type.type_parameters.for_each_list_item() {
                let type_parameter = list_item.data
                file.write(type_parameter.name)
                if list_item.next_item != null {
                    file.write(", ")
                }
            }
            file.write("] ")
        }
        file.write('(')
        let parameters_item = type.parameters.first_item
        while parameters_item != null {
            let parameter = parameters_item.data
            file.write(parameter.name).write(": ").write(parameter.type)
            parameters_item = parameters_item.next_item
            if parameters_item != null {
                file.write(", ")
            }
        }
        return file.write(")")
    }

    file.flush()
    abort(type.location, "Unsupported Parsed_Type type: ".clone().append(type.object_type.name))
}

func write(file: @FILE, expression: @Parsed_Expression) -> @FILE {
    if expression is Parsed_Array_Access_Expression {
        return file.write(expression.as(@Parsed_Array_Access_Expression).array_expression).write('[').write(expression.as(@Parsed_Array_Access_Expression).index_expression).write(']')
    }

    if expression is Parsed_Binary_Expression {
        file.write('(').write(expression.as(@Parsed_Binary_Expression).left_expression)
        if expression is Parsed_Add_Expression {
            return file.write(" + ").write(expression.as(@Parsed_Binary_Expression).right_expression).write(')')
        }
        if expression is Parsed_Divide_Expression {
            return file.write(" / ").write(expression.as(@Parsed_Binary_Expression).right_expression).write(')')
        }
        if expression is Parsed_Equals_Expression {
            return file.write(" == ").write(expression.as(@Parsed_Binary_Expression).right_expression).write(')')
        }
        if expression is Parsed_Greater_Than_Expression {
            return file.write(" > ").write(expression.as(@Parsed_Binary_Expression).right_expression).write(')')
        }
        if expression is Parsed_Greater_Than_Or_Equals_Expression {
            return file.write(" >= ").write(expression.as(@Parsed_Binary_Expression).right_expression).write(')')
        }
        if expression is Parsed_Less_Than_Expression {
            return file.write(" < ").write(expression.as(@Parsed_Binary_Expression).right_expression).write(')')
        }
        if expression is Parsed_Less_Than_Or_Equals_Expression {
            return file.write(" <= ").write(expression.as(@Parsed_Binary_Expression).right_expression).write(')')
        }
        if expression is Parsed_Logic_And_Expression {
            return file.write(" and ").write(expression.as(@Parsed_Binary_Expression).right_expression).write(')')
        }
        if expression is Parsed_Logic_Or_Expression {
            return file.write(" or ").write(expression.as(@Parsed_Binary_Expression).right_expression).write(')')
        }
        if expression is Parsed_Modulo_Expression {
            return file.write(" // ").write(expression.as(@Parsed_Binary_Expression).right_expression).write(')')
        }
        if expression is Parsed_Multiply_Expression {
            return file.write(" * ").write(expression.as(@Parsed_Binary_Expression).right_expression).write(')')
        }
        if expression is Parsed_Not_Equals_Expression {
            return file.write(" != ").write(expression.as(@Parsed_Binary_Expression).right_expression).write(')')
        }
        if expression is Parsed_Substract_Expression {
            return file.write(" - ").write(expression.as(@Parsed_Binary_Expression).right_expression).write(')')
        }
    }

    if expression is Parsed_Call_Expression {
        file.write(expression.as(@Parsed_Call_Expression).callee_expression).write('(')
        let call_arguments_item = expression.as(@Parsed_Call_Expression).arguments.first_item
        while call_arguments_item != null {
            let call_argument = call_arguments_item.data
            if call_argument.name != null {
                file.write(call_argument.name).write(" = ")
            }
            file.write(call_argument.value_expression)
            call_arguments_item = call_arguments_item.next_item
            if call_arguments_item != null {
                file.write(", ")
            }
        }
        return file.write(')')
    }

    if expression is Parsed_Cast_Expression {
        return file.write(expression.as(@Parsed_Cast_Expression).value_expression).write(" as ").write(expression.as(@Parsed_Cast_Expression).type)
    }

    if expression is Parsed_Literal_Expression {
        return file.write(expression.as(@Parsed_Literal_Expression).literal)
    }

    if expression is Parsed_Make_Expression {
        let expression = expression.as(@Parsed_Make_Expression)
        file.write("make ").write(expression.type)
        for_each_list_item(expression.init_arguments) {
            let call_argument = list_item.data
            if call_argument.name != null {
                file.write(call_argument.name).write(" = ")
            }
            file.write(call_argument.value_expression)
            if list_item.next_item != null {
                file.write(", ")
            }
        }
        return file.write(')')
    }

    if expression is Parsed_Negate_Expression {
        return file.write("- ").write(expression.as(@Parsed_Negate_Expression).expression)
    }

    if expression is Parsed_Member_Access_Expression {
        return file.write(expression.as(@Parsed_Member_Access_Expression).object_expression).write('.').write(expression.as(@Parsed_Member_Access_Expression).member_name)
    }

    if expression is Parsed_Paren_Expression {
        return file.write('(').write(expression.as(@Parsed_Paren_Expression).expression).write(')')
    }

    if expression is Parsed_Symbol_Expression {
        return file.write(expression.as(@Parsed_Symbol_Expression).name)
    }

    if expression is Parsed_Wrapped_Expression {
        return file.write(expression.as(@Parsed_Wrapped_Expression).expression)
    }

    file.flush()
    abort(expression.location, "Unsupported Parsed_Expression type: ".clone().append(expression.object_type.name))
}
