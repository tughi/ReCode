\ Copyright (c) 2020, Stefan Selariu

generate :: (build: @IR_Build, output_file_path: @String) -> Nothing {
    generator := create_mc_generator(output_file_path)

    build_sources_item := build.sources.first_item
    while (build_sources_item != null) {
        build_source := build_sources_item.data as @Source
        generator.output_file.write("  .file ").write(build_source.id).write(" \"").write(build_source.file_path).write("\"").end_line()
        build_sources_item = build_sources_item.next_item
    }

    generator.output_file.write_line("  .intel_syntax noprefix").end_line()

    functions := build.named_functions.create_iterator()
    while (functions.has_next()) {
        function := functions.next() as @IR_Function
        if (function.is_external == false) {
            generator.generate_function(function)
        }
    }

    generator.generate_strings()

    generator.generate_object_types(build.named_types)

    generator.output_file.fclose()
}

generate_function :: (self: @MC_Generator, function: @IR_Function) -> Nothing {
    self.output_file.end_line()
    self.output_file.write("  .loc ").write(function.location.source.id).write(' ').write(function.location.line).write(' ').write(function.location.column).end_line()
    self.output_file.write("  .text").end_line()
    if (function.name.equals("main")) {
        self.output_file.write("  .globl main").end_line()
        self.output_file.write("main:").end_line()
    }
    self.output_file.write_function_label(function).write(':').end_line()
    self.output_file.write("  push rbp").end_line()
    self.output_file.write("  mov rbp, rsp").end_line()
    self.output_file.write("  movsx rax, WORD PTR ").write_function_label(function).write("__stack_frame_size").write("[rip]").end_line()
    self.output_file.write("  sub rsp, rax").end_line()

    blocks := function.blocks.create_iterator()
    while (blocks.has_next()) {
        block := blocks.next() as @IR_Block
        block_instruction := block.first_instruction
        while (block_instruction != null) {
            if (block_instruction.result_value != null) {
                self.create_mc_value(block_instruction)
            }
            block_instruction = block_instruction.next_instruction
        }
    }

    self.generate_block(function.blocks.first() as @IR_Block)

    self.output_unreached_ir_instructions()

    self.output_file.write_function_end_label(function).write(":").end_line()
    self.output_file.write("  mov rsp, rbp").end_line()
    self.output_file.write("  pop rbp").end_line()
    self.output_file.write("  ret").end_line().end_line()

    stack_frame_size := self.stack_frame_size
    if (stack_frame_size // 16 != 0) {
        stack_frame_size = stack_frame_size + 16 - stack_frame_size // 16
    }
    self.output_file.write_function_label(function).write("__stack_frame_size").write(": .word ").write(stack_frame_size).end_line()

    self.reset()
}

write_function_label :: (file: @FILE, function: @IR_Function) -> @FILE {
    file.write(function.name)
    if (function.is_external == false) {
        file.write('_').write(function.id)
    }
    return file
}

write_function_end_label :: (file: @FILE, function: @IR_Function) -> @FILE {
    return file.write(".LABEL__").write_function_label(function).write("__").write("end")
}

output_unreached_ir_instructions :: (self: @MC_Generator) -> Nothing {
    if (self.output_debug_comments == false) {
        return
    }
    mc_value := self.first_value
    while (mc_value != null) {
        ir_instruction_item := mc_value.ir_variable_value.user_instructions.first_item
        while (ir_instruction_item != null) {
            ir_instruction := ir_instruction_item.data as @IR_Instruction
            if (ir_instruction.is_generated == false) {
                ir_instruction.dump(self.output_file, "  # [unreachable instruction]: ")
            }
            ir_instruction_item = ir_instruction_item.next_item
        }
        mc_value = mc_value.next_value
    }
}

generate_block :: (self: @MC_Generator, block: @IR_Block) -> Nothing {
    block.is_being_generated = true
    self.output_file.write_block_label(block).write(':').end_line()
    block_instruction := block.first_instruction
    while (block_instruction != null) {
        if (self.output_debug_comments) {
            block_instruction.dump(self.output_file, "  # ")
        }
        self.generate_instruction(block_instruction)
        if (block_instruction.is(IR_Load_Variable_Instruction) == false && block_instruction.result_value != null && block_instruction.result_value.variable.is(IR_Global_Variable)) {
            self.spill_global_variable(self.get_value(block_instruction.result_value))
        }
        self.discard_used_values()
        self.output_live_values()
        self.output_used_registers()
        block_instruction = block_instruction.next_instruction
    }
    block.is_generated = true
    if (self.discard_used_values() > 0) {
        self.output_live_values()
        self.output_used_registers()
    }
}

write_block_label :: (file: @FILE, block: @IR_Block) -> @FILE {
    return file.write(".LABEL__").write(block.function.name).write('_').write(block.function.id).write("__").write(block.id)
}

generate_instruction :: (self: @MC_Generator, instruction: @IR_Instruction) -> Nothing {
    instruction.is_generated = true
    if (instruction.location != null) {
        self.output_file.write("  .loc ").write(instruction.location.source.id).write(' ').write(instruction.location.line).write(' ').write(instruction.location.column).end_line()
    }
    if (instruction.is(IR_Add_Instruction)) {
        self.generate_add_instruction(instruction as @IR_Add_Instruction)
    } else if (instruction.is(IR_Call_Instruction)) {
        self.generate_call_instruction(instruction as @IR_Call_Instruction)
    } else if (instruction.is(IR_Cast_Instruction)) {
        self.generate_cast_instruction(instruction as @IR_Cast_Instruction)
    } else if (instruction.is(IR_Conditional_Jump_Instruction)) {
        self.generate_conditional_jump_instruction(instruction as @IR_Conditional_Jump_Instruction)
    } else if (instruction.is(IR_Comparison_Instruction)) {
        self.generate_comparison_instruction(instruction as @IR_Comparison_Instruction)
    } else if (instruction.is(IR_Direct_Jump_Instruction)) {
        self.generate_direct_jump_instruction(instruction as @IR_Direct_Jump_Instruction)
    } else if (instruction.is(IR_Divide_Instruction)) {
        self.generate_divide_instruction(instruction as @IR_Divide_Instruction)
    } else if (instruction.is(IR_Load_Array_Item_Instruction)) {
        self.generate_load_array_item_instruction(instruction as @IR_Load_Array_Item_Instruction)
    } else if (instruction.is(IR_Load_Function_Address_Instruction)) {
        self.generate_load_function_address_instruction(instruction as @IR_Load_Function_Address_Instruction)
    } else if (instruction.is(IR_Load_Struct_Member_Instruction)) {
        self.generate_load_struct_member_instruction(instruction as @IR_Load_Struct_Member_Instruction)
    } else if (instruction.is(IR_Load_Variable_Instruction)) {
        self.generate_load_variable_instruction(instruction as @IR_Load_Variable_Instruction)
    } else if (instruction.is(IR_Modulo_Instruction)) {
        self.generate_modulo_instruction(instruction as @IR_Modulo_Instruction)
    } else if (instruction.is(IR_Multiply_Instruction)) {
        self.generate_multiply_instruction(instruction as @IR_Multiply_Instruction)
    } else if (instruction.is(IR_New_Instruction)) {
        self.generate_new_instruction(instruction as @IR_New_Instruction)
    } else if (instruction.is(IR_Phi_Instruction)) {
        self.generate_phi_instruction(instruction as @IR_Phi_Instruction)
    } else if (instruction.is(IR_Return_Instruction)) {
        self.generate_return_instruction(instruction as @IR_Return_Instruction)
    } else if (instruction.is(IR_Set_Instruction)) {
        self.generate_set_instruction(instruction as @IR_Set_Instruction)
    } else if (instruction.is(IR_Store_Array_Item_Instruction)) {
        self.generate_store_array_item_instruction(instruction as @IR_Store_Array_Item_Instruction)
    } else if (instruction.is(IR_Store_Struct_Member_Instruction)) {
        self.generate_store_struct_member_instruction(instruction as @IR_Store_Struct_Member_Instruction)
    } else if (instruction.is(IR_Substract_Instruction)) {
        self.generate_substract_instruction(instruction as @IR_Substract_Instruction)
    } else {
        self.abort(clone("Unsupported instruction: ").append(instruction.object_type.name))
    }
}

generate_add_instruction :: (self: @MC_Generator, instruction: @IR_Add_Instruction) -> Nothing {
    result_register := self.find_unused_register()
    self.generate_load_value(result_register, instruction.get_left_value())
    self.map_variable_value(instruction.result_value, result_register)
    self.output_file.write("  add ").write(result_register.name_q).write(", ").write_operand(self, instruction.get_right_value()).end_line()
}

generate_call_instruction :: (self: @MC_Generator, instruction: @IR_Call_Instruction) -> Nothing {
    if (instruction.arguments_size > 0) {
        self.generate_load_value(self.register_rdi, instruction.argument(0))
        if (instruction.arguments_size > 1) {
            self.generate_load_value(self.register_rsi, instruction.argument(1))
            if (instruction.arguments_size > 2) {
                self.generate_load_value(self.register_rdx, instruction.argument(2))
                if (instruction.arguments_size > 3) {
                    self.generate_load_value(self.register_rcx, instruction.argument(3))
                    if (instruction.arguments_size > 4) {
                        self.generate_load_value(self.register_r8, instruction.argument(4))
                        if (instruction.arguments_size > 5) {
                            self.generate_load_value(self.register_r9, instruction.argument(5))
                        }
                    }
                }
            }
        }
    }
    if (instruction.is(IR_Direct_Call_Instruction)) {
        self.release_all_registers()
        self.output_file.write("  call ").write_function_label((instruction as @IR_Direct_Call_Instruction).function).end_line()
    } else if (instruction.is(IR_Dynamic_Call_Instruction)) {
        self.generate_load_value(self.register_rax, (instruction as @IR_Dynamic_Call_Instruction).function_address())
        self.release_all_registers()
        self.output_file.write("  call ").write(self.register_rax.name_q).end_line()
    } else {
        abort(instruction.location, instruction.object_type)
    }
    if (instruction.result_value != null) {
        self.map_variable_value(instruction.result_value, self.register_rax)
    }
}

generate_cast_instruction :: (self: @MC_Generator, instruction: @IR_Cast_Instruction) -> Nothing {
    ir_value := instruction.get_value()
    result_register := self.find_unused_register()
    self.generate_load_value(result_register, ir_value)
    self.map_variable_value(instruction.result_value, result_register)
    if (instruction.result_value.type.is(IR_Int_Type)) {
        if (ir_value.type.is(IR_Int32_Type)) {
            self.output_file.write("  movsx ").write(result_register.name_q).write(", ").write(result_register.name_d).end_line()
            return
        }
        if (ir_value.type.is(IR_Int8_Type)) {
            self.output_file.write("  movsx ").write(result_register.name_q).write(", ").write(result_register.name_b).end_line()
            return
        }
    }
    if (instruction.result_value.type.is(IR_Int32_Type)) {
        if (ir_value.type.is(IR_Int_Type)) {
            return
        }
        if (ir_value.type.is(IR_Int8_Type)) {
            self.output_file.write("  movsx ").write(result_register.name_d).write(", ").write(result_register.name_b).end_line()
            return
        }
    }
    if (instruction.result_value.type.is(IR_Int8_Type)) {
        if (ir_value.type.is(IR_Int_Type)) {
            return
        }
        if (ir_value.type.is(IR_Int32_Type)) {
            return
        }
    }
    self.abort(clone("Cannot cast ").append(ir_value.type.object_type.name).append(" to ").append(instruction.result_value.type.object_type.name))
}

generate_conditional_jump_instruction :: (self: @MC_Generator, instruction: @IR_Conditional_Jump_Instruction) -> Nothing {
    condition_value := instruction.get_condition_value()
    if (condition_value.type.is(IR_Boolean_Type) == false) {
        self.abort("Unsupported value type")
    }
    condition_register: @MC_Register
    if (condition_value.is(IR_Variable_Value)) {
        condition_value := condition_value as @IR_Variable_Value
        mc_value := self.get_value(condition_value)
        if (mc_value == null) {
            self.abort("Invalid state")
        }
        condition_register = mc_value.register
        if (condition_register == null) {
            condition_register = self.find_unused_register()
            self.generate_load_value(condition_register, condition_value)
        }
    } else {
        condition_register = self.find_unused_register()
        self.generate_load_value(condition_register, condition_value)
    }
    self.output_file.write("  test ").write(condition_register.name_b).write(", ").write(condition_register.name_b).end_line()
    self.release_all_registers()
    if (instruction.true_block.is_being_generated) {
        self.output_file.write("  jnz ").write_block_label(instruction.true_block).end_line()
        if (instruction.false_block.is_being_generated) {
            self.abort("Invalid state")
        }
        self.generate_block(instruction.false_block)
    } else {
        self.output_file.write("  jz ").write_block_label(instruction.false_block).end_line()
        self.generate_block(instruction.true_block)
        if (instruction.false_block.is_being_generated == false) {
            self.generate_block(instruction.false_block)
        }
    }
}

generate_comparison_instruction :: (self: @MC_Generator, instruction: @IR_Comparison_Instruction) -> Nothing {
    left_value := instruction.get_left_value()
    right_value := instruction.get_right_value()
    if (left_value.is(IR_Variable_Value) && right_value.is(IR_Variable_Value)) {
        mc_left_value := self.get_value(left_value as @IR_Variable_Value)
        if (mc_left_value.register == null) {
            mc_right_value := self.get_value(right_value as @IR_Variable_Value)
            if (mc_right_value.register == null) {
                register := self.find_unused_register()
                self.generate_load_value(register, left_value)
                self.map_variable_value(left_value as @IR_Variable_Value, register)
            }
        }
    }
    self.output_file.write("  cmp ").write_operand(self, left_value).write(", ").write_operand(self, right_value).end_line()
    register := self.find_unused_register()
    if (instruction.is(IR_Equals_Comparison_Instruction)) {
        self.output_file.write("  sete ").write(register.name_b).end_line()
        self.map_variable_value(instruction.result_value, register)
    } else if (instruction.is(IR_Greater_Than_Comparison_Instruction)) {
        self.output_file.write("  setg ").write(register.name_b).end_line()
        self.map_variable_value(instruction.result_value, register)
    } else if (instruction.is(IR_Greater_Than_Or_Equals_Comparison_Instruction)) {
        self.output_file.write("  setge ").write(register.name_b).end_line()
        self.map_variable_value(instruction.result_value, register)
    } else if (instruction.is(IR_Less_Than_Comparison_Instruction)) {
        self.output_file.write("  setl ").write(register.name_b).end_line()
        self.map_variable_value(instruction.result_value, register)
    } else if (instruction.is(IR_Less_Than_Or_Equals_Comparison_Instruction)) {
        self.output_file.write("  setle ").write(register.name_b).end_line()
        self.map_variable_value(instruction.result_value, register)
    } else if (instruction.is(IR_Not_Equals_Comparison_Instruction)) {
        self.output_file.write("  setne ").write(register.name_b).end_line()
        self.map_variable_value(instruction.result_value, register)
    } else {
        self.abort(clone("Unsupported comparison instruction type: ").append(instruction.object_type.name))
    }
}

generate_direct_jump_instruction :: (self: @MC_Generator, instruction: @IR_Direct_Jump_Instruction) -> Nothing {
    self.release_all_registers()
    if (instruction.block.is_being_generated) {
        self.output_file.write("  jmp ").write_block_label(instruction.block).end_line()
    } else {
        self.generate_block(instruction.block)
    }
}

generate_divide_instruction :: (self: @MC_Generator, instruction: @IR_Divide_Instruction) -> Nothing {
    self.release_register(self.register_rax)
    self.generate_load_value(self.register_rax, instruction.get_left_value())
    self.register_rax.is_reserved = true
    self.release_register(self.register_rdx)
    self.register_rdx.is_reserved = true
    self.output_file.write("  cqto").end_line()
    right_value := instruction.get_right_value()
    if (right_value.is(IR_Constant_Value)) {
        register := self.find_unused_register()
        register.is_reserved = true
        self.generate_load_value(register, right_value)
        self.output_file.write("  idiv ").write(register.name_q).end_line()
        register.is_reserved = false
    } else {
        self.output_file.write("  idiv ").write_operand(self, right_value).end_line()
    }
    self.register_rdx.is_reserved = false
    self.register_rax.is_reserved = false
    self.map_variable_value(instruction.result_value, self.register_rax)
}

generate_load_array_item_instruction :: (self: @MC_Generator, instruction: @IR_Load_Array_Item_Instruction) -> Nothing {
    result_register := self.find_unused_register()
    self.generate_load_value(result_register, instruction.get_array_value())
    self.map_variable_value(instruction.result_value, result_register)
    result_value_type_size := self.get_type_size(instruction.result_value.type)

    index_value := instruction.get_index_value()
    if (index_value.is(IR_Constant_Value)) {
        index_value := index_value as @IR_Constant_Value
        if (index_value.literal.is(Integer_Token) == false) {
            self.abort("Invalid state")
        }
        index_value := (index_value.literal as @Integer_Token).value
        if (index_value != 0) {
            if (index_value < 0) {
                self.abort("Invalid state")
            }
            self.output_file.write("  add ").write(result_register.name_q).write(", ").write(index_value * result_value_type_size).end_line()
        }
    } else {
        index_register := self.find_unused_register()
        self.generate_load_value(index_register, instruction.get_index_value())
        if (result_value_type_size > 1) {
            self.output_file.write("  imul ").write(index_register.name_q).write(", ").write(result_value_type_size).end_line()
        }
        self.output_file.write("  add ").write(result_register.name_q).write(", ").write(index_register.name_q).end_line()
    }

    if (result_value_type_size == 8) {
        self.output_file.write("  mov ").write(result_register.name_q).write(", [").write(result_register.name_q).write(']').end_line()
    } else if (result_value_type_size == 4) {
        self.output_file.write("  mov ").write(result_register.name_d).write(", [").write(result_register.name_q).write(']').end_line()
    } else if (result_value_type_size == 2) {
        self.output_file.write("  mov ").write(result_register.name_w).write(", [").write(result_register.name_q).write(']').end_line()
    } else {
        self.output_file.write("  mov ").write(result_register.name_b).write(", [").write(result_register.name_q).write(']').end_line()
    }
}

generate_load_function_address_instruction :: (self: @MC_Generator, instruction: @IR_Load_Function_Address_Instruction) -> Nothing {
    result_register := self.find_unused_register()
    self.output_file.write("  lea ").write(result_register.name_q).write(", ").write_function_label(instruction.function).write("[rip]").end_line()
    self.map_variable_value(instruction.result_value, result_register)
}

generate_load_variable_instruction :: (self: @MC_Generator, instruction: @IR_Load_Variable_Instruction) -> Nothing {
    if (instruction.variable.is(IR_Function_Parameter)) {
        parameter := instruction.variable as @IR_Function_Parameter
        parameter_index := instruction.parent_block.function.parameters.index_of(parameter)
        if (parameter_index < 0) {
            self.abort("Invalid state")
        }
        if (parameter_index == 0) {
            self.map_variable_value(instruction.result_value, self.register_rdi)
        } else if (parameter_index == 1) {
            self.map_variable_value(instruction.result_value, self.register_rsi)
        } else if (parameter_index == 2) {
            self.map_variable_value(instruction.result_value, self.register_rdx)
        } else if (parameter_index == 3) {
            self.map_variable_value(instruction.result_value, self.register_rcx)
        } else if (parameter_index == 4) {
            self.map_variable_value(instruction.result_value, self.register_r8)
        } else if (parameter_index == 5) {
            self.map_variable_value(instruction.result_value, self.register_r9)
        } else {
            self.abort(clone("Invalid state"))
        }
    } else if (instruction.variable.is(IR_Global_Variable)) {
        ir_variable_value := instruction.result_value
        mc_value := self.get_value(ir_variable_value)
        if (mc_value == null) {
            self.abort("Invalid state")
        }
        address := mc_value.address
        if (address != null) {
            if (address.is(MC_Global_Variable_Address) == false) {
                self.abort("Invalid state")
            }
            address := address as @MC_Global_Variable_Address
            if (address.ir_variable != ir_variable_value.variable) {
                self.abort("Invalid state")
            }
            return
        }
        ir_variable := instruction.variable as @IR_Global_Variable
        if (ir_variable.is_external) {
            \ map external variable to global variable address
            self.map_variable_value(instruction.result_value, create_mc_global_variable_address(ir_variable))
            return
        }
        if (ir_variable.type.is(IR_Pointer_Type)) {
            pointed_type := (ir_variable.type as @IR_Pointer_Type).pointed_type
            if (pointed_type.name.equals("Object_Type")) {
                result_register := self.find_unused_register()
                self.output_file.write("  lea ").write(result_register.name_q).write(", ").write(ir_variable.name).write("[rip]").end_line()
                self.map_variable_value(instruction.result_value, result_register)
                return
            }
        }
        self.abort("Unsupported non-external variable")
    } else {
        self.abort(clone("Unsupported variable type: ").append(instruction.variable.object_type.name))
    }
}

generate_load_struct_member_instruction :: (self: @MC_Generator, instruction: @IR_Load_Struct_Member_Instruction) -> Nothing {
    result_register := self.find_unused_register()
    self.generate_load_value(result_register, instruction.get_struct_pointer_value())
    self.map_variable_value(instruction.result_value, result_register)
    struct_type_member_offset := self.get_offset(instruction.struct_type_member)
    if (struct_type_member_offset > 0) {
        self.output_file.write("  add ").write(result_register.name_q).write(", ").write(struct_type_member_offset).end_line()
    }
    if (instruction.load_address) {
        return
    }
    result_value_type_size := self.get_type_size(instruction.result_value.type)
    self.output_file.write("  mov ")
    if (result_value_type_size == 8) {
        self.output_file.write(result_register.name_q)
    } else if (result_value_type_size == 4) {
        self.output_file.write(result_register.name_d)
    } else if (result_value_type_size == 2) {
        self.output_file.write(result_register.name_w)
    } else if (result_value_type_size == 1) {
        self.output_file.write(result_register.name_b)
    } else {
        self.abort("Invalid state")
    }
    self.output_file.write(", ").write('[').write(result_register.name_q).write(']').end_line()
}

generate_modulo_instruction :: (self: @MC_Generator, instruction: @IR_Modulo_Instruction) -> Nothing {
    self.release_register(self.register_rax)
    self.generate_load_value(self.register_rax, instruction.get_left_value())
    self.register_rax.is_reserved = true
    self.release_register(self.register_rdx)
    self.register_rdx.is_reserved = true
    self.output_file.write("  cqto").end_line()
    right_value := instruction.get_right_value()
    if (right_value.is(IR_Constant_Value)) {
        register := self.find_unused_register()
        register.is_reserved = true
        self.generate_load_value(register, right_value)
        self.output_file.write("  idiv ").write(register.name_q).end_line()
        register.is_reserved = false
    } else {
        self.output_file.write("  idiv ").write_operand(self, right_value).end_line()
    }
    self.register_rdx.is_reserved = false
    self.register_rax.is_reserved = false
    self.map_variable_value(instruction.result_value, self.register_rdx)
}

generate_multiply_instruction :: (self: @MC_Generator, instruction: @IR_Multiply_Instruction) -> Nothing {
    result_register := self.find_unused_register()
    self.generate_load_value(result_register, instruction.get_left_value())
    self.map_variable_value(instruction.result_value, result_register)
    self.output_file.write("  imul ").write(result_register.name_q).write(", ").write_operand(self, instruction.get_right_value()).end_line()
}

generate_new_instruction :: (self: @MC_Generator, instruction: @IR_New_Instruction) -> Nothing {
    self.release_all_registers()
    self.output_file.write("  mov ").write(self.register_rdi.name_q).write(", ").write(self.get_type_size(instruction.type)).end_line()
    if (instruction.get_size_value() != null) {
        self.abort("TODO: compute array size")
    }
    self.output_file.write("  call ").write("malloc").end_line()
    self.map_variable_value(instruction.result_value, self.register_rax)

    if (instruction.type.is(IR_Struct_Type) && (instruction.type as @IR_Struct_Type).is_object_type()) {
        register := self.find_unused_register()
        self.output_file.write("  lea ").write(register.name_q).write(", ").write_type_label(instruction.type).write("[rip]").end_line()
        self.output_file.write("  mov ").write('[').write(self.register_rax.name_q).write(']').write(", ").write(register.name_q).end_line()
    }
}

generate_phi_instruction :: (self: @MC_Generator, instruction: @IR_Phi_Instruction) -> Nothing {
    result_variable := instruction.result_value.variable
    instruction_value_item := instruction.values.first_item
    while (instruction_value_item != null) {
        instruction_value := instruction_value_item.data as @IR_Variable_Value
        if (result_variable != instruction_value.variable) {
            result_register := self.find_unused_register()
            self.generate_load_value(result_register, instruction_value)
            self.map_variable_value(instruction.result_value, result_register)
            return
        }
        instruction_value_item = instruction_value_item.next_item
    }
}

generate_return_instruction :: (self: @MC_Generator, instruction: @IR_Return_Instruction) -> Nothing {
    return_value := instruction.get_return_value()
    if (return_value != null) {
        self.generate_load_value(self.register_rax, return_value)
    }
    self.release_all_registers()
    self.output_file.write("  jmp ").write_function_end_label(instruction.parent_block.function).end_line()
}

generate_set_instruction :: (self: @MC_Generator, instruction: @IR_Set_Instruction) -> Nothing {
    result_register := self.find_unused_register()
    result_value := instruction.get_value()
    if (result_value.is(IR_Undefined_Value)) {
        self.abort(clone("Looks like ").append(instruction.result_value.variable.name).append(" is not properly initialized"))
    }
    self.generate_load_value(result_register, result_value)
    self.map_variable_value(instruction.result_value, result_register)
}

generate_store_array_item_instruction :: (self: @MC_Generator, instruction: @IR_Store_Array_Item_Instruction) -> Nothing {
    address_register := self.find_unused_register()
    address_register.is_reserved = true
    self.generate_load_value(address_register, instruction.get_array_value())

    ir_value := instruction.get_value()
    ir_value_type_size := self.get_type_size(ir_value.type)

    index_value := instruction.get_index_value()
    if (index_value.is(IR_Constant_Value)) {
        index_value := index_value as @IR_Constant_Value
        if (index_value.literal.is(Integer_Token) == false) {
            self.abort("Invalid state")
        }
        index_value := (index_value.literal as @Integer_Token).value
        if (index_value != 0) {
            if (index_value < 0) {
                self.abort("Invalid state")
            }
            self.output_file.write("  add ").write(address_register.name_q).write(", ").write(index_value * ir_value_type_size).end_line()
        }
    } else {
        index_register := self.find_unused_register()
        index_register.is_reserved = true
        self.generate_load_value(index_register, instruction.get_index_value())
        if (ir_value_type_size > 1) {
            self.output_file.write("  imul ").write(index_register.name_q).write(", ").write(ir_value_type_size).end_line()
        }
        self.output_file.write("  add ").write(address_register.name_q).write(", ").write(index_register.name_q).end_line()
        index_register.is_reserved = false
    }

    if (ir_value.is(IR_Variable_Value)) {
        ir_value := ir_value as @IR_Variable_Value
        mc_value := self.get_value(ir_value)
        if (mc_value.register == null) {
            register := self.find_unused_register()
            self.generate_load_value(register, ir_value)
            self.map_variable_value(ir_value, register)
        }
    }

    self.output_file.write("  mov ")
    if (ir_value_type_size == 8) {
        self.output_file.write("QWORD PTR ")
    } else if (ir_value_type_size == 4) {
        self.output_file.write("DWORD PTR ")
    } else if (ir_value_type_size == 2) {
        self.output_file.write("WORD PTR ")
    } else if (ir_value_type_size == 1) {
        self.output_file.write("BYTE PTR ")
    } else {
        self.abort("Invalid state")
    }
    self.output_file.write('[').write(address_register.name_q).write(']').write(", ").write_operand(self, ir_value).end_line()
    address_register.is_reserved = false
}

generate_store_struct_member_instruction :: (self: @MC_Generator, instruction: @IR_Store_Struct_Member_Instruction) -> Nothing {
    address_register := self.find_unused_register()
    address_register.is_reserved = true
    self.generate_load_value(address_register, instruction.get_struct_pointer_value())
    struct_type_member_offset := self.get_offset(instruction.struct_type_member)
    if (struct_type_member_offset > 0) {
        self.output_file.write("  add ").write(address_register.name_q).write(", ").write(struct_type_member_offset).end_line()
    }
    ir_value := instruction.get_value()
    if (ir_value.is(IR_Variable_Value)) {
        ir_value := ir_value as @IR_Variable_Value
        mc_value := self.get_value(ir_value)
        if (mc_value.register == null) {
            register := self.find_unused_register()
            self.generate_load_value(register, ir_value)
            self.map_variable_value(ir_value, register)
        }
    }
    if (ir_value.is(IR_Constant_Value) && (ir_value as @IR_Constant_Value).literal.is(String_Token)) {
        register := self.find_unused_register()
        self.generate_load_value(register, ir_value)
        self.output_file.write("  mov [").write(address_register.name_q).write("], ").write(register.name_q).end_line()
    } else {
        ir_value_type_size := self.get_type_size(ir_value.type)
        self.output_file.write("  mov ")
        if (ir_value_type_size == 8) {
            self.output_file.write("QWORD PTR ")
        } else if (ir_value_type_size == 4) {
            self.output_file.write("DWORD PTR ")
        } else if (ir_value_type_size == 2) {
            self.output_file.write("WORD PTR ")
        } else if (ir_value_type_size == 1) {
            self.output_file.write("BYTE PTR ")
        } else {
            self.abort("Invalid state")
        }
        self.output_file.write('[').write(address_register.name_q).write("], ").write_operand(self, ir_value).end_line()
    }
    address_register.is_reserved = false
}

generate_substract_instruction :: (self: @MC_Generator, instruction: @IR_Substract_Instruction) -> Nothing {
    result_register := self.find_unused_register()
    left_value := instruction.get_left_value()
    right_value := instruction.get_right_value()
    if (left_value.is(IR_Constant_Value)) {
        left_value := left_value as @IR_Constant_Value
        if ((left_value.literal as @Integer_Token).value == 0) {
            self.generate_load_value(result_register, right_value)
            self.output_file.write("  neg ").write(result_register.name_q).end_line()
            self.map_variable_value(instruction.result_value, result_register)
            return
        }
    }
    self.generate_load_value(result_register, left_value)
    self.map_variable_value(instruction.result_value, result_register)
    if (right_value.is(IR_Constant_Value)) {
        right_value := right_value as @IR_Constant_Value
        if ((right_value.literal as @Integer_Token).value == 1) {
            self.output_file.write("  dec ").write(result_register.name_q).end_line()
            return
        }
    }
    self.output_file.write("  sub ").write(result_register.name_q).write(", ").write_operand(self, right_value).end_line()
}

generate_load_value :: (self: @MC_Generator, register: @MC_Register, ir_value: @IR_Value) -> Nothing {
    if (register.value != null) {
        if (ir_value.is(IR_Variable_Value)) {
            ir_value := ir_value as @IR_Variable_Value
            if (ir_value == register.value.ir_variable_value) {
                return
            }
        }
        self.release_register(register)
    }
    if (ir_value.is(IR_Constant_Value)) {
        ir_value := ir_value as @IR_Constant_Value
        if (ir_value.literal.is(Boolean_Token)) {
            literal := ir_value.literal as @Boolean_Token
            if (literal.value) {
                self.output_file.write("  mov ").write(register.name_b).write(", ").write(1).end_line()
            } else {
                self.output_file.write("  mov ").write(register.name_b).write(", ").write(0).end_line()
            }
        } else if (ir_value.literal.is(Character_Token)) {
            self.output_file.write("  mov ").write(register.name_b).write(", ").write((ir_value.literal as @Character_Token).value as Int).end_line()
        } else if (ir_value.literal.is(Integer_Token)) {
            literal := ir_value.literal as @Integer_Token
            if (literal.value == 0) {
                self.output_file.write("  xor ").write(register.name_q).write(", ").write(register.name_q).end_line()
            } else {
                self.output_file.write("  mov ").write(register.name_q).write(", ").write(literal.value).end_line()
            }
        } else if (ir_value.literal.is(Null_Token)) {
            self.output_file.write("  xor ").write(register.name_q).write(", ").write(register.name_q).end_line()
        } else if (ir_value.literal.is(String_Token)) {
            mc_string := self.convert_string(ir_value.literal as @String_Token)
            self.output_file.write("  lea ").write(register.name_q).write(", ").write_string_label(mc_string).write("[rip]").write(" # ").write(mc_string.literal.lexeme).end_line()
        } else {
            self.abort(clone("Unsupported literal type: ").append(ir_value.literal.object_type.name))
        }
    } else if (ir_value.is(IR_Variable_Value)) {
        ir_value := ir_value as @IR_Variable_Value
        ir_value_type := ir_value.type
        mc_value := self.get_value(ir_value)
        if (mc_value == null) {
            self.abort("Invalid state")
        }
        if (mc_value.register != null) {
            if (ir_value_type.is(IR_Boolean_Type)) {
                self.output_file.write("  mov ").write(register.name_b).write(", ").write(mc_value.register.name_b).end_line()
            } else if (ir_value_type.is(IR_Function_Type)) {
                self.output_file.write("  mov ").write(register.name_q).write(", ").write(mc_value.register.name_q).end_line()
            } else if (ir_value_type.is(IR_Int_Type)) {
                self.output_file.write("  mov ").write(register.name_q).write(", ").write(mc_value.register.name_q).end_line()
            } else if (ir_value_type.is(IR_Int32_Type)) {
                self.output_file.write("  mov ").write(register.name_d).write(", ").write(mc_value.register.name_d).end_line()
            } else if (ir_value_type.is(IR_Int8_Type)) {
                self.output_file.write("  mov ").write(register.name_b).write(", ").write(mc_value.register.name_b).end_line()
            } else if (ir_value_type.is(IR_Pointer_Type)) {
                self.output_file.write("  mov ").write(register.name_q).write(", ").write(mc_value.register.name_q).end_line()
            } else {
                self.abort(clone("Unsupported value type: ").append(ir_value_type.object_type.name))
            }
        } else if (ir_value_type.is(IR_Boolean_Type)) {
            self.output_file.write("  mov ").write(register.name_b).write(", ").write(mc_value.address).end_line()
        } else if (ir_value_type.is(IR_Function_Type)) {
            self.output_file.write("  mov ").write(register.name_q).write(", ").write(mc_value.address).end_line()
        } else if (ir_value_type.is(IR_Int_Type)) {
            self.output_file.write("  mov ").write(register.name_q).write(", ").write(mc_value.address).end_line()
        } else if (ir_value_type.is(IR_Int32_Type)) {
            self.output_file.write("  mov ").write(register.name_d).write(", ").write(mc_value.address).end_line()
        } else if (ir_value_type.is(IR_Int8_Type)) {
            self.output_file.write("  mov ").write(register.name_b).write(", ").write(mc_value.address).end_line()
        } else if (ir_value_type.is(IR_Pointer_Type)) {
            self.output_file.write("  mov ").write(register.name_q).write(", ").write(mc_value.address).end_line()
        } else {
            self.abort(clone("Unsupported value type: ").append(ir_value_type.object_type.name))
        }
    } else {
        self.abort(clone("Unsupported value type: ").append(ir_value.object_type.name))
    }
}

get_offset :: (self: @MC_Generator, struct_type_member: @IR_Struct_Type_Member) -> Int {
    offset := 0
    struct_type := struct_type_member.struct_type
    if (struct_type.base_type != null) {
        offset = self.get_type_size(struct_type.base_type)
    }
    current_struct_type_member_item := struct_type.members.first_item
    while (current_struct_type_member_item != null) {
        current_struct_type_member := current_struct_type_member_item.data as @IR_Struct_Type_Member
        if (current_struct_type_member == struct_type_member) {
            return offset
        }
        offset = offset + self.get_type_size(current_struct_type_member.type)
        current_struct_type_member_item = current_struct_type_member_item.next_item
    }
    self.abort("Invalid state")
}

write_operand :: (file: @FILE, generator: @MC_Generator, ir_value: @IR_Value) -> @FILE {
    if (ir_value.is(IR_Constant_Value)) {
        ir_value := ir_value as @IR_Constant_Value
        if (ir_value.literal.is(Boolean_Token)) {
            if ((ir_value.literal as @Boolean_Token).value) {
                return file.write(1)
            }
            return file.write(0)
        }
        if (ir_value.literal.is(Character_Token)) {
            return file.write((ir_value.literal as @Character_Token).value as Int)
        }
        if (ir_value.literal.is(Integer_Token)) {
            return file.write((ir_value.literal as @Integer_Token).value)
        }
        if (ir_value.literal.is(Null_Token)) {
            return file.write(0)
        }
        generator.abort(clone("Unsupported constant literal: ").append(ir_value.literal.object_type.name))
    }
    if (ir_value.is(IR_Variable_Value)) {
        ir_value := ir_value as @IR_Variable_Value
        mc_value := generator.get_value(ir_value)
        if (mc_value == null) {
            generator.abort("Invalid state")
        }
        value_type_size := generator.get_type_size(ir_value.type)
        if (mc_value.register != null) {
            if (value_type_size == 8) {
                return file.write(mc_value.register.name_q)
            }
            if (value_type_size == 4) {
                return file.write(mc_value.register.name_d)
            }
            if (value_type_size == 2) {
                return file.write(mc_value.register.name_w)
            }
            if (value_type_size == 1) {
                return file.write(mc_value.register.name_b)
            }
            generator.abort(clone("Unsupported type size: ").append(value_type_size))
        }
        if (mc_value.address != null) {
            if (value_type_size == 8) {
                return file.write("QWORD PTR ").write(mc_value.address)
            }
            if (value_type_size == 4) {
                return file.write("DWORD PTR ").write(mc_value.address)
            }
            if (value_type_size == 2) {
                return file.write("WORD PTR ").write(mc_value.address)
            }
            if (value_type_size == 1) {
                return file.write("BYTE PTR ").write(mc_value.address)
            }
            generator.abort(clone("Unsupported type size: ").append(value_type_size))
        }
        generator.abort("Invalid state")
    }
    generator.abort(clone("Unsupported value: ").append(ir_value.object_type.name))
}

abort :: (self: @MC_Generator, message: @String) -> Nothing {
    self.output_file.flush()
    abort(clone("[Generator] ").append(message))
}

MC_Generator :: struct {
    output_file_path: @String
    output_file: @FILE
    output_debug_comments: Boolean
    registers: @List
    register_rax: @MC_Register
    register_rcx: @MC_Register
    register_rdx: @MC_Register
    register_rbx: @MC_Register
    register_rsi: @MC_Register
    register_rdi: @MC_Register
    register_r8: @MC_Register
    register_r9: @MC_Register
    register_r10: @MC_Register
    register_r11: @MC_Register
    register_r12: @MC_Register
    register_r13: @MC_Register
    register_r14: @MC_Register
    register_r15: @MC_Register
    first_value: @MC_Value
    last_value: @MC_Value
    stack_frame_size: Int
    strings: @List
}

create_mc_generator :: (output_file_path: @String) -> @MC_Generator {
    generator := new MC_Generator
    generator.output_file_path = output_file_path
    generator.output_file = fopen(output_file_path.data, "w".data)
    generator.output_debug_comments = true
    generator.register_rax = new MC_Register_RAX.init("rax", "eax", "ax", "al")
    generator.register_rcx = new MC_Register_RCX.init("rcx", "ecx", "cx", "cl")
    generator.register_rdx = new MC_Register_RDX.init("rdx", "edx", "dx", "dl")
    generator.register_rbx = new MC_Register_RBX.init("rbx", "ebx", "bx", "bl")
    generator.register_rsi = new MC_Register_RSI.init("rsi", "esi", "si", "sil")
    generator.register_rdi = new MC_Register_RDI.init("rdi", "edi", "di", "dil")
    generator.register_r8 = new MC_Register_R8.init("r8", "r8d", "r8w", "r8b")
    generator.register_r9 = new MC_Register_R9.init("r9", "r9d", "r9w", "r9b")
    generator.register_r10 = new MC_Register_R10.init("r10", "r10d", "r10w", "r10b")
    generator.register_r11 = new MC_Register_R11.init("r11", "r11d", "r11w", "r11b")
    generator.register_r12 = new MC_Register_R12.init("r12", "r12d", "r12w", "r12b")
    generator.register_r13 = new MC_Register_R13.init("r13", "r13d", "r13w", "r13b")
    generator.register_r14 = new MC_Register_R14.init("r14", "r14d", "r14w", "r14b")
    generator.register_r15 = new MC_Register_R15.init("r15", "r15d", "r15w", "r15b")
    generator.first_value = null
    generator.last_value = null
    generator.stack_frame_size = 0
    generator.strings = create_list()
    return generator
}

reset :: (self: @MC_Generator) -> Nothing {
    while (self.first_value != null) {
        value := self.first_value
        self.first_value = value.next_value
        value.prev_value = null
        value.next_value = null
        if (value.register != null) {
            self.abort("Invalid state")
        }
    }
    self.last_value = null
    self.stack_frame_size = 0
}

find_unused_register :: (self: @MC_Generator) -> @MC_Register {
    if (self.register_rax.is_reserved == false && self.register_rax.value == null) {
        return self.register_rax
    }
    if (self.register_rbx.is_reserved == false && self.register_rbx.value == null) {
        return self.register_rbx
    }
    if (self.register_r15.is_reserved == false && self.register_r15.value == null) {
        return self.register_r15
    }
    if (self.register_r14.is_reserved == false && self.register_r14.value == null) {
        return self.register_r14
    }
    if (self.register_r13.is_reserved == false && self.register_r13.value == null) {
        return self.register_r13
    }
    if (self.register_r12.is_reserved == false && self.register_r12.value == null) {
        return self.register_r12
    }
    if (self.register_r11.is_reserved == false && self.register_r11.value == null) {
        return self.register_r11
    }
    if (self.register_r10.is_reserved == false && self.register_r10.value == null) {
        return self.register_r10
    }
    if (self.register_r9.is_reserved == false && self.register_r9.value == null) {
        return self.register_r9
    }
    if (self.register_r8.is_reserved == false && self.register_r8.value == null) {
        return self.register_r8
    }
    if (self.register_rcx.is_reserved == false && self.register_rcx.value == null) {
        return self.register_rcx
    }
    if (self.register_rdx.is_reserved == false && self.register_rdx.value == null) {
        return self.register_rdx
    }
    if (self.register_rsi.is_reserved == false && self.register_rsi.value == null) {
        return self.register_rsi
    }
    if (self.register_rdi.is_reserved == false && self.register_rdi.value == null) {
        return self.register_rdi
    }
    self.abort("All registered are used")
}

create_mc_value :: (self: @MC_Generator, ir_instruction: @IR_Instruction) -> Nothing {
    mc_value := new MC_Value
    mc_value.ir_variable_value = ir_instruction.result_value
    mc_value.ir_instruction = ir_instruction
    mc_value.register = null
    mc_value.address = null
    mc_value.next_value = null
    mc_value.prev_value = self.last_value
    if (self.first_value == null) {
        self.first_value = mc_value
    } else {
        self.last_value.next_value = mc_value
    }
    self.last_value = mc_value
}

map_variable_value :: (self: @MC_Generator, ir_variable_value: @IR_Variable_Value, address: @MC_Address) -> Nothing {
    if (address == null) {
        self.abort("Invalid state")
    }
    mc_value := self.first_value
    while (mc_value != null) {
        if (mc_value.ir_variable_value.variable == ir_variable_value.variable) {
            if (mc_value.address != null) {
                self.abort("Invalid state")
            }
            mc_value.address = address
        }
        mc_value = mc_value.next_value
    }
}

map_variable_value :: (self: @MC_Generator, ir_variable_value: @IR_Variable_Value, register: @MC_Register) -> @MC_Value {
    mc_value := self.first_value
    while (mc_value != null && mc_value.ir_variable_value != ir_variable_value) {
        mc_value = mc_value.next_value
    }
    if (mc_value == null) {
        self.abort("Invalid state")
    }
    if (register.value != null) {
        self.abort(clone("Register ").append(register.name_q).append(" already mapped to variable: ").append(register.value.ir_variable_value.variable.name))
    }
    mc_value.register = register
    register.value = mc_value
    return mc_value
}

get_value :: (self: @MC_Generator, ir_variable_value: @IR_Variable_Value) -> @MC_Value {
    mc_value := self.first_value
    while (mc_value != null && mc_value.ir_variable_value != ir_variable_value) {
        mc_value = mc_value.next_value
    }
    return mc_value
}

spill_local_variable :: (self: @MC_Generator, mc_value: @MC_Value) -> Nothing {
    if (mc_value.ir_variable_value.variable.is(IR_Global_Variable)) {
        \ global variables are spilled after each instruction
        self.abort("Invalid state")
    }
    variable_type_size := self.get_type_size(mc_value.ir_variable_value.type)
    if (mc_value.address == null) {
        offset := 0
        other_mc_value := self.first_value
        while (other_mc_value != null) {
            other_mc_value_address := other_mc_value.address
            if (other_mc_value_address != null && other_mc_value_address.is(MC_Local_Variable_Address)) {
                other_mc_value_address := other_mc_value_address as @MC_Local_Variable_Address
                if (offset < other_mc_value_address.offset) {
                    offset = other_mc_value_address.offset
                }
            }
            other_mc_value = other_mc_value.next_value
        }
        offset = offset + variable_type_size
        if (offset > self.stack_frame_size) {
            self.stack_frame_size = offset
        }
        self.map_variable_value(mc_value.ir_variable_value, create_mc_local_variable_address(offset))
    }
    if (variable_type_size == 8) {
        self.output_file.write("  mov ").write(mc_value.address).write(", ").write(mc_value.register.name_q).end_line()
    } else if (variable_type_size == 4) {
        self.output_file.write("  mov ").write(mc_value.address).write(", ").write(mc_value.register.name_d).end_line()
    } else if (variable_type_size == 2) {
        self.output_file.write("  mov ").write(mc_value.address).write(", ").write(mc_value.register.name_w).end_line()
    } else if (variable_type_size == 1) {
        self.output_file.write("  mov ").write(mc_value.address).write(", ").write(mc_value.register.name_b).end_line()
    }
}

spill_global_variable :: (self: @MC_Generator, mc_value: @MC_Value) -> Nothing {
    self.abort(clone("TODO: spill global variable ").append(mc_value.ir_variable_value.variable.name))
}

release_all_registers :: (self: @MC_Generator) -> Nothing {
    self.release_register(self.register_rax)
    self.release_register(self.register_rcx)
    self.release_register(self.register_rdx)
    self.release_register(self.register_rbx)
    self.release_register(self.register_rsi)
    self.release_register(self.register_rdi)
    self.release_register(self.register_r8)
    self.release_register(self.register_r9)
    self.release_register(self.register_r10)
    self.release_register(self.register_r11)
    self.release_register(self.register_r12)
    self.release_register(self.register_r13)
    self.release_register(self.register_r14)
    self.release_register(self.register_r15)
}

release_register :: (self: @MC_Generator, register: @MC_Register) -> Nothing {
    mc_value := register.value
    if (mc_value != null) {
        persist_value := false

        ir_value_user_instruction_item := mc_value.ir_variable_value.user_instructions.first_item
        while (ir_value_user_instruction_item != null) {
            ir_value_user_instruction := ir_value_user_instruction_item.data as @IR_Instruction
            if (ir_value_user_instruction.is_generated == false || ir_value_user_instruction.is(IR_Phi_Instruction)) {
                persist_value = true
                break
            }
            ir_value_user_instruction_item = ir_value_user_instruction_item.next_item
        }

        if (persist_value) {
            self.spill_local_variable(mc_value)
        }

        mc_value.register = null
        register.value = null
    }
}

discard_used_values :: (self: @MC_Generator) -> Int {
    removed_values := 0

    mc_value := self.first_value
    while (mc_value != null) {
        if (mc_value.ir_instruction.is_generated && mc_value.ir_instruction.parent_block.is_being_generated) {
            discard_value := true

            user_instruction_item := mc_value.ir_variable_value.user_instructions.first_item
            while (user_instruction_item != null) {
                user_instruction := user_instruction_item.data as @IR_Instruction
                if (user_instruction.is_generated == false) {
                    \ there is at least one more user instruction that requires this value
                    discard_value = false
                    break
                }
                user_instruction_item = user_instruction_item.next_item
            }

            if (discard_value) {
                user_instruction_item = mc_value.ir_variable_value.user_instructions.first_item
                while (user_instruction_item != null) {
                    user_instruction := user_instruction_item.data as @IR_Instruction
                    if (user_instruction.parent_block != mc_value.ir_instruction.parent_block && mc_value.ir_instruction.parent_block.is_generated == false) {
                        \ there is at least one user instruction in another block that requires this value and the value's parent block hasn't been generated yet
                        discard_value = false
                        break
                    }
                    user_instruction_item = user_instruction_item.next_item
                }
            }

            if (discard_value) {
                if (mc_value.register != null) {
                    mc_value.register.value = null
                    mc_value.register = null
                }

                \ remove
                if (mc_value.prev_value != null) {
                    mc_value.prev_value.next_value = mc_value.next_value
                } else {
                    self.first_value = mc_value.next_value
                }
                if (mc_value.next_value != null) {
                    mc_value.next_value.prev_value = mc_value.prev_value
                } else {
                    self.last_value = mc_value.prev_value
                }
                removed_values = removed_values + 1

                if (self.output_debug_comments) {
                    self.output_file.write("  # [discarded value]: ").write(mc_value.ir_variable_value.variable.name).write('.').write(mc_value.ir_variable_value.version).end_line()
                }
            }
        }

        mc_value = mc_value.next_value
    }

    return removed_values
}

output_live_values :: (self: @MC_Generator) -> Nothing {
    if (self.output_debug_comments == false) {
        return
    }
    self.output_file.write("  # [live values]: ")
    mc_value := self.first_value
    while (mc_value != null) {
        if (mc_value.ir_instruction.is_generated) {
            self.output_file.write(mc_value.ir_variable_value.variable.name).write('.').write(mc_value.ir_variable_value.version).write(':')
            if (mc_value.register != null) {
                self.output_file.write(mc_value.register.name_q)
            }
            if (mc_value.address != null) {
                self.output_file.write(mc_value.address)
            }
            self.output_file.write(' ')
        }
        mc_value = mc_value.next_value
    }
    self.output_file.end_line()
}

output_used_registers :: (self: @MC_Generator) -> Nothing {
    if (true) {
        return
    }
    self.output_file.write("  # [used registers]: ")
    self.output_used_register(self.register_rax)
    self.output_used_register(self.register_rcx)
    self.output_used_register(self.register_rdx)
    self.output_used_register(self.register_rbx)
    self.output_used_register(self.register_rsi)
    self.output_used_register(self.register_rdi)
    self.output_used_register(self.register_r8)
    self.output_used_register(self.register_r9)
    self.output_used_register(self.register_r10)
    self.output_used_register(self.register_r11)
    self.output_used_register(self.register_r12)
    self.output_used_register(self.register_r13)
    self.output_used_register(self.register_r14)
    self.output_used_register(self.register_r15)
    self.output_file.end_line()
}

output_used_register :: (self: @MC_Generator, register: @MC_Register) -> Nothing {
    if (register.value != null) {
        self.output_file.write(register.name_q).write(':').write(register.value.ir_variable_value.variable.name).write('.').write(register.value.ir_variable_value.version).write(' ')
    }
}

MC_Value :: struct {
    prev_value: @MC_Value
    next_value: @MC_Value
    ir_instruction: @IR_Instruction
    ir_variable_value: @IR_Variable_Value
    register: @MC_Register
    address: @MC_Address
}

MC_Register :: struct : Object {
    name_q: @String
    name_d: @String
    name_w: @String
    name_b: @String
    is_reserved: Boolean
    value: @MC_Value
}

init :: (self: @MC_Register, name_q: @String, name_d: @String, name_w: @String, name_b: @String) -> @MC_Register {
    self.name_q = name_q
    self.name_d = name_d
    self.name_w = name_w
    self.name_b = name_b
    self.is_reserved = false
    self.value = null
    return self
}

MC_Register_RAX :: struct : MC_Register {
}

MC_Register_RCX :: struct : MC_Register {
}

MC_Register_RDX :: struct : MC_Register {
}

MC_Register_RBX :: struct : MC_Register {
}

MC_Register_RSI :: struct : MC_Register {
}

MC_Register_RDI :: struct : MC_Register {
}

MC_Register_R8 :: struct : MC_Register {
}

MC_Register_R9 :: struct : MC_Register {
}

MC_Register_R10 :: struct : MC_Register {
}

MC_Register_R11 :: struct : MC_Register {
}

MC_Register_R12 :: struct : MC_Register {
}

MC_Register_R13 :: struct : MC_Register {
}

MC_Register_R14 :: struct : MC_Register {
}

MC_Register_R15 :: struct : MC_Register {
}

MC_Address :: struct : Object {
}

write :: (file: @FILE, address: @MC_Address) -> @FILE {
    if (address.is(MC_Global_Variable_Address)) {
        address := address as @MC_Global_Variable_Address
        return file.write(address.ir_variable.name).write("[rip]")
    }
    if (address.is(MC_Local_Variable_Address)) {
        address := address as @MC_Local_Variable_Address
        return file.write("[rbp-").write(address.offset).write(']')
    }
    abort(clone("Unsupported type: ").append(address.object_type.name))
}

MC_Global_Variable_Address :: struct : MC_Address {
    ir_variable: @IR_Variable
}

create_mc_global_variable_address :: (ir_variable: @IR_Variable) -> @MC_Global_Variable_Address {
    address := new MC_Global_Variable_Address
    address.ir_variable = ir_variable
    return address
}

MC_Local_Variable_Address :: struct : MC_Address {
    offset: Int
}

create_mc_local_variable_address :: (offset: Int) -> @MC_Local_Variable_Address {
    address := new MC_Local_Variable_Address
    address.offset = offset
    return address
}

get_type_size :: (self: @MC_Generator, ir_type: @IR_Type) -> Int {
    if (ir_type.is(IR_Boolean_Type)) {
        return 1
    }
    if (ir_type.is(IR_Function_Type)) {
        return 8
    }
    if (ir_type.is(IR_Int_Type)) {
        return 8
    }
    if (ir_type.is(IR_Int16_Type)) {
        return 2
    }
    if (ir_type.is(IR_Int32_Type)) {
        return 4
    }
    if (ir_type.is(IR_Int8_Type)) {
        return 1
    }
    if (ir_type.is(IR_Null_Type)) {
        return 8
    }
    if (ir_type.is(IR_Pointer_Type)) {
        return 8
    }
    if (ir_type.is(IR_Struct_Type)) {
        ir_type := ir_type as @IR_Struct_Type
        size := 0
        if (ir_type.base_type != null) {
            size = size + self.get_type_size(ir_type.base_type)
        }
        struct_type_members := ir_type.members.create_iterator()
        while (struct_type_members.has_next()) {
            struct_type_member := struct_type_members.next() as @IR_Struct_Type_Member
            size = size + self.get_type_size(struct_type_member.type)
        }
        return size
    }
    self.abort(clone("Unsupported type: ").append(ir_type.object_type.name))
}

MC_String :: struct {
    id: Int
    literal: @String_Token
}

convert_string :: (self: @MC_Generator, literal: @String_Token) -> @MC_String {
    string_item := self.strings.first_item
    while (string_item != null) {
        string := string_item.data as @MC_String
        if (string.literal.lexeme.equals(literal.lexeme)) {
            return string
        }
        string_item = string_item.next_item
    }
    string := new MC_String
    string.id = self.strings.size
    string.literal = literal
    self.strings.append(string)
    return string
}

generate_strings :: (self: @MC_Generator) -> Nothing {
    self.output_file.end_line().write("  .section .rodata").end_line()
    string_item := self.strings.first_item
    while (string_item != null) {
        string := string_item.data as @MC_String

        self.output_file.end_line()
        self.output_file.write("  .align 8").end_line()
        self.output_file.write_string_label(string).write(':').end_line()
        self.output_file.write("  .quad ").write_string_label(string).write("__data").end_line()
        self.output_file.write("  .quad ").write(string.literal.value.length + 1).end_line()
        self.output_file.write("  .quad ").write(string.literal.value.length).end_line()
        self.output_file.write_string_label(string).write("__data: .string ").write(string.literal.lexeme).end_line()

        string_item = string_item.next_item
    }
}

write_string_label :: (file: @FILE, string: @MC_String) -> @FILE {
    return file.write(".LABEL__string_").write(string.id)
}

generate_object_types :: (self: @MC_Generator, types: @List) -> Nothing {
    self.output_file.end_line().write("  .section .rodata").end_line()
    type_item := types.first_item
    while (type_item != null) {
        type := type_item.data as @IR_Type
        if (type.is(IR_Struct_Type)) {
            type := type as @IR_Struct_Type
            if (type.is_object_type()) {
                self.output_file.end_line()
                self.output_file.write("  .align 8").end_line()
                self.output_file.write_type_label(type).write(':').end_line()
                self.output_file.write("  .quad ").write(0).end_line() \ CHECK: Why isn't there a type.id? Isn't it needed anymore?
                self.output_file.write("  .quad .LABEL__").write(type.name).write("__type_name__data").end_line()
                self.output_file.write("  .quad ").write(type.name.length + 1).end_line()
                self.output_file.write("  .quad ").write(type.name.length).end_line()
                if (type.base_type != null) {
                    self.output_file.write("  .quad ").write(type.base_type.name).end_line()
                } else {
                    self.output_file.write("  .quad 0").end_line()
                }
                self.output_file.write(".LABEL__").write(type.name).write("__type_name__data: .string \"").write(type.name).write('"').end_line()
            }
        }
        type_item = type_item.next_item
    }
}

write_type_label :: (file: @FILE, type: @IR_Type) -> @FILE {
    return file.write(type.name)
}
