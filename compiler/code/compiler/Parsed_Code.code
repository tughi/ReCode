struct Parsed_Code {
    sources = make @List[@Source]()
    function_statements = make @List[@Parsed_Function_Statement]()
    macro_statements = make @List[@Parsed_Macro_Statement]()
    statements = make @List[@Parsed_Statement]()
    named_statements = make @Map[@String, @List[@Parsed_Statement]]()
}

func get_named_statements(self: @Parsed_Code, name: @String) -> @List[@Parsed_Statement] {
    for_each(self.named_statements) {
        if name.equals(key) {
            return value
        }
    }
    return null
}

func get_type_statement(self: @Parsed_Code, name: @String) -> @Parsed_Type_Statement {
    let type_statement: @Parsed_Type_Statement = null
    for_each(self.statements) {
        if it is Parsed_Type_Statement and (it is not Parsed_Generic_Struct_Statement) {
            let statement = it.as(@Parsed_Type_Statement)
            if statement.name.lexeme.equals(name) {
                if type_statement != null {
                    stderr.end_line().write(type_statement.location).write(": First ").write(name).write(" declaration").end_line()
                    abort(statement.location, clone("Duplicate ").append(name).append(" declaration"))
                }
                type_statement = statement
            }
        }
    }
    return type_statement
}

func get_generic_struct_statement(self: @Parsed_Code, name: @String) -> @Parsed_Generic_Struct_Statement {
    let struct_statement: @Parsed_Generic_Struct_Statement = null
    for_each(self.statements) {
        if it is Parsed_Generic_Struct_Statement {
            let statement = it.as(@Parsed_Generic_Struct_Statement)
            if statement.name.lexeme.equals(name) {
                if struct_statement != null {
                    stderr.end_line().write(struct_statement.location).write(": First ").write(name).write(" declaration").end_line()
                    abort(statement.location, clone("Duplicate ").append(name).append(" declaration"))
                }
                struct_statement = statement
            }
        }
    }
    return struct_statement
}

func put_named_statement(self: @Parsed_Code, name: @String, statement: @Parsed_Statement) -> Nothing {
    let named_statements = self.get_named_statements(name)
    if named_statements == null {
        named_statements = make @List[@Parsed_Statement]()
        self.named_statements.put(name, named_statements)
    }
    named_statements.append(statement)
}

struct Parsed_Statement: Object {
    location: @Source_Location
}

struct Parsed_Include_Statement: Parsed_Statement {
    file_path: @String
}

struct Parsed_Function_Statement: Parsed_Statement {
    name: @Identifier_Token
    type: @Parsed_Function_Type
    body: @Parsed_Block_Statement
    is_anonymous: bool
}

struct Parsed_Macro_Statement: Parsed_Statement {
    name: @Identifier_Token
    type: @Parsed_Macro_Type
    body: @Parsed_Block_Statement
}

struct Parsed_Block_Statement: Parsed_Statement {
    statements: @List[@Parsed_Statement]
}

struct Parsed_Constant_Statement: Parsed_Statement {
    name: @Identifier_Token
    expression: @Parsed_Expression
}

struct Parsed_Expression_Statement: Parsed_Statement {
    expression: @Parsed_Expression
}

struct Parsed_If_Statement: Parsed_Statement {
    condition_expression: @Parsed_Expression
    true_statement: @Parsed_Statement
    false_statement: @Parsed_Statement
}

struct Parsed_Loop_Statement: Parsed_Statement {
    body_statement: @Parsed_Block_Statement
}

struct Parsed_While_Statement: Parsed_Statement {
    condition_expression: @Parsed_Expression
    body_statement: @Parsed_Block_Statement
}

struct Parsed_Break_Statement: Parsed_Statement {
}

struct Parsed_Return_Statement: Parsed_Statement {
    value_expression: @Parsed_Expression
}

struct Parsed_Variable_Statement: Parsed_Statement {
    name: @Identifier_Token
    type: @Parsed_Type
    value_expression: @Parsed_Expression = null
    is_external = false
}

struct Parsed_Type_Statement: Parsed_Statement {
    name: @Identifier_Token
}

struct Parsed_External_Type_Statement: Parsed_Type_Statement {
}

struct Parsed_Struct_Statement: Parsed_Type_Statement {
    super_type: @Parsed_Type
    super_arguments: @List[@Parsed_Call_Argument]
    members: @List[@Parsed_Struct_Member]
}

struct Parsed_Generic_Struct_Statement: Parsed_Type_Statement {
    type_parameters: @List[@Parsed_Type_Parameter]
    struct_statement: @Parsed_Struct_Statement
}

struct Parsed_Type_Parameter {
    name: @Identifier_Token
}

struct Parsed_Struct_Member {
    location: @Source_Location
    name: @Identifier_Token
    type: @Parsed_Type
    default_value_expression: @Parsed_Expression
}

struct Parsed_Assignment_Statement: Parsed_Statement {
    storage_expression: @Parsed_Expression
    operator: @Other_Token
    value_expression: @Parsed_Expression
}

struct Parsed_Type: Object {
    location: @Source_Location = null
}

struct Parsed_Named_Type: Parsed_Type {
    name: @Identifier_Token
}

struct Parsed_Placeholder_Type: Parsed_Type {
    name: @String
}

struct Parsed_Pointer_Type: Parsed_Type {
    pointed_type: @Parsed_Type
}

struct Parsed_Specialized_Type: Parsed_Type {
    name: @Identifier_Token
    type_arguments: @List[@Parsed_Type_Argument]
}

struct Parsed_Type_Argument {
    name: @String = null
    type: @Parsed_Type
}

struct Parsed_Array_Type: Parsed_Type {
    item_type: @Parsed_Type
    size_expression: @Parsed_Expression
    is_checked: bool
}

struct Parsed_Callable_Type: Parsed_Type {
    type_parameters: @List[@Parsed_Type_Parameter]
    parameters: @List[@Parsed_Callable_Parameter]
}

struct Parsed_Function_Type: Parsed_Callable_Type {
    return_type: @Parsed_Type
}

struct Parsed_Macro_Type: Parsed_Callable_Type {
}

struct Parsed_Callable_Parameter {
    location: @Source_Location
    name: @Identifier_Token
    type: @Parsed_Type
}

struct Parsed_Expression: Object {
    location: @Source_Location
}

struct Parsed_Paren_Expression: Parsed_Expression {
    expression: @Parsed_Expression
}

struct Parsed_Literal_Expression: Parsed_Expression {
    literal: @Literal_Token
}

struct Parsed_Symbol_Expression: Parsed_Expression {
    name: @Identifier_Token
}

struct Parsed_Variable_Reference_Expression: Parsed_Expression {
    variable_expression: @Parsed_Symbol_Expression
}

struct Parsed_Binary_Expression: Parsed_Expression {
    left_expression: @Parsed_Expression
    right_expression: @Parsed_Expression
}

struct Parsed_Add_Expression: Parsed_Binary_Expression {
}

struct Parsed_Divide_Expression: Parsed_Binary_Expression {
}

struct Parsed_Equals_Expression: Parsed_Binary_Expression {
}

struct Parsed_Greater_Than_Expression: Parsed_Binary_Expression {
}

struct Parsed_Greater_Than_Or_Equals_Expression: Parsed_Binary_Expression {
}

struct Parsed_Less_Than_Expression: Parsed_Binary_Expression {
}

struct Parsed_Less_Than_Or_Equals_Expression: Parsed_Binary_Expression {
}

struct Parsed_Logic_And_Expression: Parsed_Binary_Expression {
}

struct Parsed_Logic_Not_Expression: Parsed_Unary_Expression {
}

struct Parsed_Logic_Or_Expression: Parsed_Binary_Expression {
}

struct Parsed_Modulo_Expression: Parsed_Binary_Expression {
}

struct Parsed_Multiply_Expression: Parsed_Binary_Expression {
}

struct Parsed_Not_Equals_Expression: Parsed_Binary_Expression {
}

struct Parsed_Substract_Expression: Parsed_Binary_Expression {
}

struct Parsed_Unary_Expression: Parsed_Expression {
    expression: @Parsed_Expression
}

struct Parsed_Negate_Expression: Parsed_Unary_Expression {
}

struct Parsed_Cast_Expression: Parsed_Expression {
    value_expression: @Parsed_Expression
    type: @Parsed_Type
}

struct Parsed_Is_Expression: Parsed_Expression {
    value_expression: @Parsed_Expression
    type: @Parsed_Type
}

struct Parsed_Make_Expression: Parsed_Expression {
    type: @Parsed_Type
    init_arguments: @List[@Parsed_Call_Argument]
}

struct Parsed_Function_Expression: Parsed_Expression {
    function_statement: @Parsed_Function_Statement
}

struct Parsed_Call_Expression: Parsed_Expression {
    callee_expression: @Parsed_Expression
    arguments: @List[@Parsed_Call_Argument]
}

struct Parsed_Call_Argument {
    location: @Source_Location
    name: @Identifier_Token
    value_expression: @Parsed_Expression
}

struct Parsed_Access_Expression: Parsed_Expression {
}

struct Parsed_Member_Access_Expression: Parsed_Access_Expression {
    object_expression: @Parsed_Expression
    member_name: @Identifier_Token
}

struct Parsed_Array_Access_Expression: Parsed_Access_Expression {
    array_expression: @Parsed_Expression
    index_expression: @Parsed_Expression
}

struct Parsed_Wrapped_Expression: Parsed_Expression {
    expression: @Parsed_Expression
}

struct Parsed_Macro_Body: Parsed_Expression {
    statement: @Parsed_Block_Statement
}
