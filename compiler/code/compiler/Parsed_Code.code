struct Parsed_Code {
    sources = make @List[@Source]()
    function_statements = make @List[@Parsed_Function_Statement]()
    macro_statements = make @List[@Parsed_Macro_Statement]()
    statements = make @List[@Parsed_Statement]()
    named_statements = make @Map[@String, @List[@Parsed_Statement]]()
}

func get_named_statements(self: @Parsed_Code, name: @String) -> @List[@Parsed_Statement] {
    for_each(self.named_statements) {
        if name.equals(key) {
            return value
        }
    }
    return null
}

func get_type_statement(self: @Parsed_Code, name: @String) -> @Parsed_Type_Statement {
    let type_statement: @Parsed_Type_Statement = null
    for_each(self.statements) {
        if it is Parsed_Type_Statement and (it is not Parsed_Generic_Struct_Statement) {
            let statement = it.as(@Parsed_Type_Statement)
            if statement.name.lexeme.equals(name) {
                if type_statement != null {
                    stderr.end_line().write(type_statement.location).write(": First ").write(name).write(" declaration").end_line()
                    abort(statement.location, clone("Duplicate ").append(name).append(" declaration"))
                }
                type_statement = statement
            }
        }
    }
    return type_statement
}

func get_generic_struct_statement(self: @Parsed_Code, name: @String) -> @Parsed_Generic_Struct_Statement {
    let struct_statement: @Parsed_Generic_Struct_Statement = null
    for_each(self.statements) {
        if it is Parsed_Generic_Struct_Statement {
            let statement = it.as(@Parsed_Generic_Struct_Statement)
            if statement.name.lexeme.equals(name) {
                if struct_statement != null {
                    stderr.end_line().write(struct_statement.location).write(": First ").write(name).write(" declaration").end_line()
                    abort(statement.location, clone("Duplicate ").append(name).append(" declaration"))
                }
                struct_statement = statement
            }
        }
    }
    return struct_statement
}

func put_named_statement(self: @Parsed_Code, name: @String, statement: @Parsed_Statement) -> Nothing {
    let named_statements = self.get_named_statements(name)
    if named_statements == null {
        named_statements = make @List[@Parsed_Statement]()
        self.named_statements.put(name, named_statements)
    }
    named_statements.append(statement)
}

struct Parsed_Statement: Object {
    location: @Source_Location
}

struct Parsed_Include_Statement: Parsed_Statement {
    file_path: @String
}

struct Parsed_Function_Statement: Parsed_Statement {
    name: @Identifier_Token
    type: @Parsed_Function_Type
    body: @Parsed_Block_Statement
    is_anonymous: bool
}

func is_duplicate(self: @Parsed_Function_Statement, other: @Parsed_Function_Statement) -> bool {
    if not self.name.lexeme.equals(other.name.lexeme) {
        \ different name
        return false
    }

    let self_type = self.type
    let other_type = other.type

    \ check number of type parameters
    if self_type.type_parameters != null {
        if other_type.type_parameters == null {
            return false
        }
        if self_type.type_parameters.size != other_type.type_parameters.size {
            return false
        }
    } else if other_type.type_parameters != null {
        return false
    }

    \ check number of parameters
    if self_type.parameters.size != other_type.parameters.size {
        return false
    }

    \ check each parameter
    self_type.parameters.for_each_indexed() {
        let self_parameter = it
        let other_parameter = other_type.parameters.get(it_index.as(i64))
        if not same_types(self_parameter.type, self_type.type_parameters, other_parameter.type, other_type.type_parameters) {
            return false
        }
    }

    return true
}

func same_types(self: @Parsed_Type, self_context: @List[@Parsed_Type_Parameter], other: @Parsed_Type, other_context: @List[@Parsed_Type_Parameter]) -> bool {
    if self.object_type != other.object_type {
        return false
    }
    if self is Parsed_Array_Type {
        let self = self.as(@Parsed_Array_Type)
        let other = other.as(@Parsed_Array_Type)
        if self.is_checked != other.is_checked {
            return false
        }
        if not self.size_expression.same_expressions(other.size_expression) {
            return false
        }
        return same_types(self.item_type, self_context, other.item_type, other_context)
    }
    if self is Parsed_Function_Type {
        let self = self.as(@Parsed_Function_Type)
        let other = other.as(@Parsed_Function_Type)
        if self.parameters.size != other.parameters.size {
            return false
        }
        self.parameters.for_each_indexed() {
            let self_parameter = it
            let other_parameter = other.parameters.get(it_index.as(i64))
            if not same_types(self_parameter.type, self_context, other_parameter.type, other_context) {
                return false
            }
        }
        return same_types(self.return_type, self_context, other.return_type, other_context)
    }
    if self is Parsed_Named_Type {
        let self = self.as(@Parsed_Named_Type)
        let other = other.as(@Parsed_Named_Type)
        if self_context != null {
            self_context.for_each_indexed() {
                let self_type_parameter = it
                let other_type_parameter = other_context.get(it_index.as(i64))
                if self.name.lexeme.equals(self_type_parameter.name.lexeme) {
                    if other.name.lexeme.equals(other_type_parameter.name.lexeme) {
                        return true
                    }
                    return false
                } else if other.name.lexeme.equals(other_type_parameter.name.lexeme) {
                    return false
                }
            }
        }
        return self.name.lexeme.equals(other.name.lexeme)
    }
    if self is Parsed_Pointer_Type {
        return same_types(self.as(@Parsed_Pointer_Type).pointed_type, self_context, other.as(@Parsed_Pointer_Type).pointed_type, other_context)
    }
    abort(self.location, self.object_type)
}

func same_expressions(self: @Parsed_Expression, other: @Parsed_Expression) -> bool {
    if self == null {
        return other == null
    }
    if self.object_type != other.object_type {
        return false
    }
    if self is Parsed_Literal_Expression {
        return same_literals(self.as(@Parsed_Literal_Expression).literal, other.as(@Parsed_Literal_Expression).literal)
    }
    abort(self.location, self.object_type)
}

func same_literals(self: @Literal_Token, other: @Literal_Token) -> bool {
    if self.object_type != other.object_type {
        return false
    }
    return self.lexeme.equals(other.lexeme)
}

struct Parsed_Macro_Statement: Parsed_Statement {
    name: @Identifier_Token
    type: @Parsed_Macro_Type
    body: @Parsed_Block_Statement
}

struct Parsed_Block_Statement: Parsed_Statement {
    statements: @List[@Parsed_Statement]
}

struct Parsed_Constant_Statement: Parsed_Statement {
    name: @Identifier_Token
    expression: @Parsed_Expression
}

struct Parsed_Expression_Statement: Parsed_Statement {
    expression: @Parsed_Expression
}

struct Parsed_If_Statement: Parsed_Statement {
    condition_expression: @Parsed_Expression
    true_statement: @Parsed_Statement
    false_statement: @Parsed_Statement
}

struct Parsed_Loop_Statement: Parsed_Statement {
    body_statement: @Parsed_Block_Statement
}

struct Parsed_While_Statement: Parsed_Statement {
    condition_expression: @Parsed_Expression
    body_statement: @Parsed_Block_Statement
}

struct Parsed_Break_Statement: Parsed_Statement {
}

struct Parsed_Return_Statement: Parsed_Statement {
    value_expression: @Parsed_Expression
}

struct Parsed_Variable_Statement: Parsed_Statement {
    name: @Identifier_Token
    type: @Parsed_Type
    value_expression: @Parsed_Expression = null
    is_external = false
}

struct Parsed_Type_Statement: Parsed_Statement {
    name: @Identifier_Token
}

struct Parsed_External_Type_Statement: Parsed_Type_Statement {
}

struct Parsed_Struct_Statement: Parsed_Type_Statement {
    super_type: @Parsed_Type
    super_arguments: @List[@Parsed_Call_Argument]
    members: @List[@Parsed_Struct_Member]
}

struct Parsed_Generic_Struct_Statement: Parsed_Type_Statement {
    type_parameters: @List[@Parsed_Type_Parameter]
    struct_statement: @Parsed_Struct_Statement
}

struct Parsed_Type_Parameter {
    name: @Identifier_Token
}

struct Parsed_Struct_Member {
    location: @Source_Location
    name: @Identifier_Token
    type: @Parsed_Type
    default_value_expression: @Parsed_Expression
}

struct Parsed_Assignment_Statement: Parsed_Statement {
    storage_expression: @Parsed_Expression
    operator: @Other_Token
    value_expression: @Parsed_Expression
}

struct Parsed_Type: Object {
    location: @Source_Location = null
}

struct Parsed_Named_Type: Parsed_Type {
    name: @Identifier_Token
}

struct Parsed_Placeholder_Type: Parsed_Type {
    name: @String
}

struct Parsed_Pointer_Type: Parsed_Type {
    pointed_type: @Parsed_Type
}

struct Parsed_Specialized_Type: Parsed_Type {
    name: @Identifier_Token
    type_arguments: @List[@Parsed_Type_Argument]
}

struct Parsed_Type_Argument {
    name: @String = null
    type: @Parsed_Type
}

struct Parsed_Array_Type: Parsed_Type {
    item_type: @Parsed_Type
    size_expression: @Parsed_Expression
    is_checked: bool
}

struct Parsed_Callable_Type: Parsed_Type {
    type_parameters: @List[@Parsed_Type_Parameter]
    parameters: @List[@Parsed_Callable_Parameter]
}

struct Parsed_Function_Type: Parsed_Callable_Type {
    return_type: @Parsed_Type
}

struct Parsed_Macro_Type: Parsed_Callable_Type {
}

struct Parsed_Callable_Parameter {
    location: @Source_Location
    name: @Identifier_Token
    type: @Parsed_Type
}

struct Parsed_Expression: Object {
    location: @Source_Location
}

struct Parsed_Paren_Expression: Parsed_Expression {
    expression: @Parsed_Expression
}

struct Parsed_Literal_Expression: Parsed_Expression {
    literal: @Literal_Token
}

struct Parsed_Symbol_Expression: Parsed_Expression {
    name: @Identifier_Token
}

struct Parsed_Variable_Reference_Expression: Parsed_Expression {
    variable_expression: @Parsed_Symbol_Expression
}

struct Parsed_Binary_Expression: Parsed_Expression {
    left_expression: @Parsed_Expression
    right_expression: @Parsed_Expression
}

struct Parsed_Add_Expression: Parsed_Binary_Expression {
}

struct Parsed_Divide_Expression: Parsed_Binary_Expression {
}

struct Parsed_Equals_Expression: Parsed_Binary_Expression {
}

struct Parsed_Greater_Than_Expression: Parsed_Binary_Expression {
}

struct Parsed_Greater_Than_Or_Equals_Expression: Parsed_Binary_Expression {
}

struct Parsed_Less_Than_Expression: Parsed_Binary_Expression {
}

struct Parsed_Less_Than_Or_Equals_Expression: Parsed_Binary_Expression {
}

struct Parsed_Logic_And_Expression: Parsed_Binary_Expression {
}

struct Parsed_Logic_Not_Expression: Parsed_Unary_Expression {
}

struct Parsed_Logic_Or_Expression: Parsed_Binary_Expression {
}

struct Parsed_Modulo_Expression: Parsed_Binary_Expression {
}

struct Parsed_Multiply_Expression: Parsed_Binary_Expression {
}

struct Parsed_Not_Equals_Expression: Parsed_Binary_Expression {
}

struct Parsed_Substract_Expression: Parsed_Binary_Expression {
}

struct Parsed_Unary_Expression: Parsed_Expression {
    expression: @Parsed_Expression
}

struct Parsed_Negate_Expression: Parsed_Unary_Expression {
}

struct Parsed_Cast_Expression: Parsed_Expression {
    value_expression: @Parsed_Expression
    type: @Parsed_Type
}

struct Parsed_Is_Expression: Parsed_Expression {
    value_expression: @Parsed_Expression
    type: @Parsed_Type
}

struct Parsed_Make_Expression: Parsed_Expression {
    type: @Parsed_Type
    init_arguments: @List[@Parsed_Call_Argument]
}

struct Parsed_Function_Expression: Parsed_Expression {
    function_statement: @Parsed_Function_Statement
}

struct Parsed_Call_Expression: Parsed_Expression {
    callee_expression: @Parsed_Expression
    arguments: @List[@Parsed_Call_Argument]
}

struct Parsed_Call_Argument {
    location: @Source_Location
    name: @Identifier_Token
    value_expression: @Parsed_Expression
}

struct Parsed_Access_Expression: Parsed_Expression {
}

struct Parsed_Member_Access_Expression: Parsed_Access_Expression {
    object_expression: @Parsed_Expression
    member_name: @Identifier_Token
}

struct Parsed_Array_Access_Expression: Parsed_Access_Expression {
    array_expression: @Parsed_Expression
    index_expression: @Parsed_Expression
}

struct Parsed_Wrapped_Expression: Parsed_Expression {
    expression: @Parsed_Expression
}

struct Parsed_Macro_Body: Parsed_Expression {
    statement: @Parsed_Block_Statement
}
