include "./List.code"

struct Checked_Code {
    globals = make Map[@String, @Checked_Symbol]()
    functions = make List[@Checked_Function_Symbol]()
}

struct Checked_Type: Object {
    name: @String
}

func accepts(self: @Checked_Type, other: @Checked_Type) -> bool {
    if self == other {
        return true
    }
    if self is Checked_Pointer_Type {
        if other is Checked_Pointer_Type {
            let self_pointed_type = self.as(@Checked_Pointer_Type).pointed_type
            let other_pointed_type = other.as(@Checked_Pointer_Type).pointed_type
            if self_pointed_type == other_pointed_type {
                return true
            }
            if self_pointed_type is Checked_Function_Type and other_pointed_type is Checked_Function_Type {
                let self_pointed_funtion_type = self_pointed_type.as(@Checked_Function_Type)
                let other_pointed_funtion_type = other_pointed_type.as(@Checked_Function_Type)
                return other_pointed_funtion_type.accepts(self_pointed_funtion_type.parameters) and other_pointed_funtion_type.return_type.accepts(self_pointed_funtion_type.return_type)
            }
            if self_pointed_type is Checked_Struct_Type and other_pointed_type is Checked_Struct_Type {
                return other_pointed_type.as(@Checked_Struct_Type).has_super_type(self_pointed_type.as(@Checked_Struct_Type))
            }
        }
        return false
    }
    abort("TOOD: Check if ".clone().append(self.object_type.name).append(" accepts ").append(other.object_type.name))
}

func equals(self: @Checked_Type, other: @Checked_Type) -> bool {
    if self.object_type != other.object_type {
        return false
    }
    if self is Checked_Pointer_Type {
        return self.as(@Checked_Pointer_Type).pointed_type.equals(other.as(@Checked_Pointer_Type).pointed_type)
    }
    if self is Checked_Function_Type {
        let self = self.as(@Checked_Function_Type)
        let other = other.as(@Checked_Function_Type)
        if not self.return_type.equals(other.return_type) {
            return false
        }
        let self_parameters_item = self.parameters.first_item
        let other_parameters_item = other.parameters.first_item
        while self_parameters_item != null and other_parameters_item != null {
            if not self_parameters_item.data.type.equals(other_parameters_item.data.type) {
                return false
            }
            self_parameters_item = self_parameters_item.next_item
            other_parameters_item = other_parameters_item.next_item
        }
        if self_parameters_item != null or other_parameters_item != null {
            return false
        }
        return true
    }
    return self == other
}

struct Checked_Any_Type: Checked_Builtin_Type(name = "Any") {
}

struct Checked_Bool_Type: Checked_Builtin_Type(name = "bool") {
}

struct Checked_Builtin_Type: Checked_Named_Type {
}

struct Checked_Fixed_Array_Type: Checked_Type {
    item_type: @Checked_Type
    size: u64
}

struct Checked_Function_Type: Checked_Type {
    parameters = make List[@Checked_Function_Parameter]()
    return_type: @Checked_Type
}

struct Checked_Function_Parameter {
    location: @Source_Location
    name: @String
    type: @Checked_Type
}

func accepts(self: @Checked_Function_Type, call_arguments: @List[@Checked_Call_Argument]) -> bool {
    \ Check each argument
    let parameter_item = self.parameters.first_item
    let argument_item = call_arguments.first_item
    while parameter_item != null and argument_item != null {
        if not parameter_item.data.type.accepts(argument_item.data.expression.type) {
            return false
        }
        parameter_item = parameter_item.next_item
        argument_item = argument_item.next_item
    }

    if argument_item != null or parameter_item != null {
        \ Arguments number differs from parameters number 
        return false
    }

    return true
}

func accepts(self: @Checked_Function_Type, other_parameters: @List[@Checked_Function_Parameter]) -> bool {
    \ Check each argument
    let self_parameter_item = self.parameters.first_item
    let other_parameter_item = other_parameters.first_item
    while self_parameter_item != null and other_parameter_item != null {
        if not self_parameter_item.data.type.accepts(other_parameter_item.data.type) {
            return false
        }
        self_parameter_item = self_parameter_item.next_item
        other_parameter_item = other_parameter_item.next_item
    }

    if other_parameter_item != null or self_parameter_item != null {
        \ Arguments number differs from parameters number 
        return false
    }

    return true
}

struct Checked_Int_Type: Checked_Integer_Type {
}

struct Checked_Integer_Type: Checked_Builtin_Type {
}

struct Checked_IntMax_Type: Checked_Int_Type(name = "isize") {
}

struct Checked_Int16_Type: Checked_Int_Type(name = "i16") {
}

struct Checked_Int32_Type: Checked_Int_Type(name = "i32") {
}

struct Checked_Int64_Type: Checked_Int_Type(name = "i64") {
}

struct Checked_Int8_Type: Checked_Int_Type(name = "i8") {
}

struct Checked_Named_Type: Checked_Type {
}

struct Checked_Nothing_Type: Checked_Builtin_Type(name = "Nothing") {
}

struct Checked_Null_Type: Checked_Builtin_Type(name = "Null") {
}

struct Checked_Opaque_Type: Checked_Named_Type {
}

struct Checked_Pointer_Type: Checked_Type {
    pointed_type: @Checked_Type
}

struct Checked_Struct_Type: Checked_Named_Type {
    super_type: @Checked_Struct_Type = null
    derived_types = make List[@Checked_Struct_Type]()
    members = make List[@Checked_Struct_Type_Member]()
}

struct Checked_Struct_Type_Member {
    struct_type: @Checked_Struct_Type
    name: @String
    type: @Checked_Type
    default_value_expression: @Checked_Expression
}

func add_member(self: @Checked_Struct_Type, name: @String, type: @Checked_Type, default_value_expression: @Checked_Expression) -> @Checked_Struct_Type_Member {
    let member = make @Checked_Struct_Type_Member(struct_type = self, name = name, type = type, default_value_expression = default_value_expression)
    self.members.append(member)
    return member
}

func get_member(self: @Checked_Struct_Type, name: @String) -> @Checked_Struct_Type_Member {
    let struct_type = self
    loop {
        struct_type.members.for_each() {
            if name.equals(it.name) {
                return it
            }
        }
        struct_type = struct_type.super_type
        if struct_type == null {
            return null
        }
    }
}

func has_super_type(self: @Checked_Struct_Type, other: @Checked_Struct_Type) -> bool {
    let struct_type = self
    while struct_type.super_type != null {
        if struct_type.super_type == other {
            return true
        }
        struct_type = struct_type.super_type
    }
    return false
}

struct Checked_UInt_Type: Checked_Integer_Type {
}

struct Checked_UIntMax_Type: Checked_UInt_Type(name = "usize") {
}

struct Checked_UInt16_Type: Checked_UInt_Type(name = "u16") {
}

struct Checked_UInt32_Type: Checked_UInt_Type(name = "u32") {
}

struct Checked_UInt64_Type: Checked_UInt_Type(name = "u64") {
}

struct Checked_UInt8_Type: Checked_UInt_Type(name = "u8") {
}

struct Checked_Unchecked_Array_Type: Checked_Type {
    item_type: @Checked_Type
}

struct Checked_Undefined_Type: Checked_Builtin_Type(name = "Undefined") {
}

struct Checked_Symbol: Object {
    location: @Source_Location
    name: @String
    type: @Checked_Type
}

struct Checked_Function_Symbol: Checked_Symbol {
    function_type: @Checked_Function_Type
    parsed_function_statement: @Parsed_Function_Statement
    _is_match = false \ flag used while searching for matching functions
}

struct Checked_Parameter_Symbol: Checked_Symbol {
}

struct Checked_Struct_Symbol: Checked_Symbol {
    parsed_struct_statement: @Parsed_Struct_Statement
}

struct Checked_Variable_Symbol: Checked_Symbol {
    expression: @Checked_Expression
}

struct Checked_Statement: Object {
    location: @Source_Location
}

struct Checked_Block_Statement: Checked_Statement {
    statements = make List[@Checked_Statement]()
}

struct Checked_If_Statement: Checked_Statement {
    condition_expression: @Checked_Expression
    true_statement: @Checked_Statement
    false_statement: @Checked_Statement
}

struct Checked_Return_Statement: Checked_Statement {
    expression: @Checked_Expression
}

struct Checked_Variable_Statement: Checked_Statement {
    variable: @Checked_Variable_Symbol
}

struct Checked_Expression: Object {
    location: @Source_Location
    type: @Checked_Type
}

struct Checked_Access_Expression: Checked_Expression {
}

struct Checked_Binary_Expression: Checked_Expression {
    left_expression: @Checked_Expression
    right_expression: @Checked_Expression
}

struct Checked_Boolean_Literal_Expression: Checked_Literal_Expression {
    literal: @Boolean_Token
}

struct Checked_Call_Expression: Checked_Expression {
    call_arguments: @List[@Checked_Call_Argument]
}

struct Checked_Call_Argument {
    location: @Source_Location
    name: @String
    expression: @Checked_Expression
}

struct Checked_Cast_Expression: Checked_Expression {
    expression: @Checked_Expression
}

struct Checked_Character_Literal_Expression: Checked_Literal_Expression {
    literal: @Character_Token
}

struct Checked_Dynamic_Call_Expression: Checked_Call_Expression {
    callee_expression: @Checked_Expression
}

struct Checked_Equals_Expression: Checked_Binary_Expression {
}

struct Checked_Function_Call_Expression: Checked_Call_Expression {
    function_symbol: @Checked_Function_Symbol
}

struct Checked_Integer_Literal_Expression: Checked_Literal_Expression {
    literal: @Integer_Token
}

struct Checked_Literal_Expression: Checked_Expression {
}

struct Checked_Logic_Not_Expression: Checked_Expression {
    expression: @Checked_Expression
}

struct Checked_Member_Access_Expression: Checked_Access_Expression {
    object_expression: @Checked_Expression
    struct_member: @Checked_Struct_Type_Member
}

struct Checked_Modulo_Expression: Checked_Binary_Expression {
}

struct Checked_Not_Equals_Expression: Checked_Binary_Expression {
}

struct Checked_String_Literal_Expression: Checked_Literal_Expression {
    literal: @String_Token
}

struct Checked_Symbol_Expression: Checked_Expression {
    symbol: @Checked_Symbol
}
