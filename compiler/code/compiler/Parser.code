include "./Counter.code"
include "./Parsed_Code.code"

struct Parser {
    scanner: @Scanner = null
    parsed_code = make @Parsed_Code()
    current_alignment = 0
    anonymous_functions_counter = make Counter[i64]()
}

func abort(self: @Parser, unexpected_token: @Token) -> Nothing {
    stderr.write(unexpected_token.location).write(": ").error().write("Unexpected ").write(unexpected_token.object_type.name).write(": ").write(unexpected_token).reset().end_line()
    abort()
}

func parse(source: @Source) -> @Parsed_Code {
    let parser = make @Parser()
    parser.parse(source, null)
    return parser.parsed_code
}

func parse(self: @Parser, source: @Source, location: @Source_Location) -> Nothing {
    self.parsed_code.sources.append(source)
    source.id = self.parsed_code.sources.size

    let other_scanner = self.scanner
    self.scanner = create_scanner(source)
    self.parse_statements(self.parsed_code.statements, true)

    let token = self.scanner.current_token
    if token is not End_Of_File_Token {
        abort(self, self.scanner.current_token)
    }
    let token = token.as(@End_Of_File_Token)
    if token.location.column != 1 {
        stderr.write(token.location).write(": ").warning().write("File doesn't end with a new line").reset().end_line()
    }

    self.scanner = other_scanner
}

\ statements
\   | ( statement <EOL> )*
func parse_statements(self: @Parser, statements: @List[@Parsed_Statement], is_global: bool) -> Nothing {
    loop {
        let statement = self.parse_statement(is_global)
        if statement == null {
            break
        }
        self.consume_end_of_line()
        if is_global and statement is Parsed_Include_Statement {
            let statement = statement.as(@Parsed_Include_Statement)

            let source_file_path = statement.file_path.make_relative_path(statement.location.source.file_path)
            if source_file_path == null {
                abort(statement.location, clone("Unsupported file path: ").append(statement.file_path))
            }

            let parsed_code_sources_item = self.parsed_code.sources.first_item
            while parsed_code_sources_item != null {
                if parsed_code_sources_item.data.file_path.equals(source_file_path) {
                    break
                }
                parsed_code_sources_item = parsed_code_sources_item.next_item
            }

            if parsed_code_sources_item == null {
                let source_file = fopen(source_file_path.data, "r".data)
                if source_file == null {
                    abort(statement.location, clone("Failed to open file: ").append(source_file_path))
                }
                let source = create_source(source_file, source_file_path)
                self.parse(source, statement.location)
            }
        } else {
            if is_global {
                if statement is Parsed_Constant_Statement {
                    self.parsed_code.put_named_statement(statement.as(@Parsed_Constant_Statement).name.lexeme, statement)
                } else if statement is Parsed_External_Type_Statement {
                    self.parsed_code.put_named_statement(statement.as(@Parsed_External_Type_Statement).name.lexeme, statement)
                } else if statement is Parsed_Function_Statement {
                    self.parsed_code.put_named_statement(statement.as(@Parsed_Function_Statement).name.lexeme, statement)
                } else if statement is Parsed_Generic_Struct_Statement {
                    self.parsed_code.put_named_statement(statement.as(@Parsed_Generic_Struct_Statement).name.lexeme, statement)
                } else if statement is Parsed_Macro_Statement {
                    self.parsed_code.put_named_statement(statement.as(@Parsed_Macro_Statement).name.lexeme, statement)
                } else if statement is Parsed_Struct_Statement {
                    self.parsed_code.put_named_statement(statement.as(@Parsed_Struct_Statement).name.lexeme, statement)
                } else if statement is Parsed_Variable_Statement {
                    self.parsed_code.put_named_statement(statement.as(@Parsed_Variable_Statement).name.lexeme, statement)
                } else {
                    abort(statement.location, clone("Unexpected global statement: ").append(statement.object_type.name))
                }
            }

            statements.append(statement)
        }
    }
}

func make_relative_path(file_path: @String, base_file_path: @String) -> @String {
    if file_path.starts_with("./") {
        let relative_path = clone(base_file_path).append(file_path).remove(base_file_path.last_index_of('/') + 1, base_file_path.length + 2)
        return relative_path
    }
    if file_path.starts_with("../") {
        let relative_path = clone(base_file_path).append(file_path).remove(base_file_path.last_index_of('/') + 1, base_file_path.length)
        loop {
            let index = relative_path.index_of("/../")
            if index <= 0 {
                break
            }
            relative_path.remove(relative_path.last_index_of('/', index - 1), index + 3)
        }
        return relative_path
    }
    return file_path
}

\ statement
\   | define
\   | function
\   | if
\   | include
\   | let
\   | loop
\   | macro
\   | macro_call
\   | while
\   | break
\   | return
\   | struct
\   | expression "=" expression
\   | expression
func parse_statement(self: @Parser, is_global: bool) -> @Parsed_Statement {
    while self.consume_empty_line() {
    }

    if self.matches(optional_space, required_close_brace) or self.matches(required_end_of_file) {
        return null
    }

    self.consume_space(self.current_alignment * 4)

    if is_global {
        if self.matches(required_define) {
            return self.parse_define()
        }
        if self.matches(required_external) {
            return self.parse_external()
        }
        if self.matches(required_func) {
            return self.parse_function()
        }
        if self.matches(required_include) {
            return self.parse_include()
        }
        if self.matches(required_let) {
            return self.parse_let()
        }
        if self.matches(required_macro) {
            return self.parse_macro()
        }
        if self.matches(required_struct) {
            return self.parse_struct()
        }
    } else {
        if self.matches(required_break) {
            let token = self.consume(required_break)
            return make @Parsed_Break_Statement(location = token.location)
        }
        if self.matches(required_define) {
            return self.parse_define()
        }
        if self.matches(required_if) {
            return self.parse_if()
        }
        if self.matches(required_let) {
            return self.parse_let()
        }
        if self.matches(required_loop) {
            return self.parse_loop()
        }
        if self.matches(required_return) {
            let token = self.consume(required_return)
            let value_expression: @Parsed_Expression = null
            if not self.matches_end_of_line() {
                self.consume_space(1)
                value_expression = self.parse_expression()
            }
            return make @Parsed_Return_Statement(location = token.location, value_expression = value_expression)
        }
        if self.matches(required_while) {
            return self.parse_while()
        }

        let expression = self.parse_expression()

        if self.matches(optional_space, required_equals) {
            self.consume_space(1)
            let operator = self.consume(required_equals).as(@Other_Token)
            self.consume_space(1)
            return make @Parsed_Assignment_Statement(
                location = expression.location
                storage_expression = expression
                operator = operator
                value_expression = self.parse_expression()
            )
        }

        if self.matches(optional_space, required_open_brace) {
            if expression is Parsed_Call_Expression {
                let expression = expression.as(@Parsed_Call_Expression)
                self.consume_space(1)
                let block_statement = self.parse_block()
                expression.arguments.append(
                    make @Parsed_Call_Argument(
                        location = block_statement.location
                        name = null
                        value_expression = make @Parsed_Macro_Body(location = block_statement.location, statement = block_statement)
                    )
                )
            } else {
                self.consume_end_of_line()
            }
        }

        return make @Parsed_Expression_Statement(
            location = expression.location
            expression = expression
        )
    }

    return null
}

\ include
\   | "include" STRING
func parse_include(self: @Parser) -> @Parsed_Include_Statement {
    let location = self.consume(required_include).location
    self.consume_space(1)
    let file_path = self.consume(required_string_literal).as(@String_Token).value
    return make @Parsed_Include_Statement(location = location, file_path = file_path)
}

\ define
\   | "define" IDENTIFIER "=" expression
func parse_define(self: @Parser) -> @Parsed_Statement {
    self.consume(required_define)
    self.consume_space(1)
    let name = self.consume(required_identifier).as(@Identifier_Token)
    self.consume_space(1)
    self.consume(required_equals)
    self.consume_space(1)
    let expression = self.parse_expression()
    return make @Parsed_Constant_Statement(location = name.location, name = name, expression = expression)
}

\ external
\   | "external" ( external_function | external_type | external_variable )
func parse_external(self: @Parser) -> @Parsed_Statement {
    let location = self.consume(required_external).location
    self.consume_space(1)
    if self.matches(required_type) {
        return self.parse_external_type()
    }
    if self.matches(required_func) {
        return self.parse_external_function()
    }
    return self.parse_external_variable()
}

\ external_variable
\   | IDENTIFIER ":" type
func parse_external_variable(self: @Parser) -> @Parsed_Variable_Statement {
    let variable_name = self.consume(required_identifier).as(@Identifier_Token)
    self.consume_space(0)
    self.consume(required_colon)
    self.consume_space(1)
    let variable_value_type = self.parse_type()
    return make @Parsed_Variable_Statement(
        location = variable_name.location
        name = variable_name
        type = variable_value_type
        value_expression = null
        is_external = true
    )
}

\ external_type
\   | "type" IDENTIFIER
func parse_external_type(self: @Parser) -> @Parsed_External_Type_Statement {
    self.consume(required_type)
    self.consume_space(1)
    let name = self.consume(required_identifier).as(@Identifier_Token)
    return make @Parsed_External_Type_Statement(
        location = name.location
        name = name
    )
}

\ struct
\   | "struct" IDENTIFIER type_parameters? ( ":" type ( "(" call_arguments? ")" )? )? "{" <EOL> ( IDENTIFIER ( ":" type ( "=" expression )? | "=" expression )? <EOL> )* "}"
func parse_struct(self: @Parser) -> @Parsed_Type_Statement {
    self.consume(required_struct)
    self.consume_space(1)
    let struct_name = self.consume(required_identifier).as(@Identifier_Token)
    let struct_type_parameters: @List[@Parsed_Type_Parameter] = null
    if self.matches(optional_space, required_open_bracket) {
        self.consume_space(0)
        struct_type_parameters = self.parse_type_parameters()
    }
    let struct_super_type: @Parsed_Type = null
    let struct_super_arguments = make @List[@Parsed_Call_Argument]()
    if self.matches(optional_space, required_colon) {
        self.consume_space(0)
        self.consume(required_colon)
        self.consume_space(1)
        struct_super_type = self.parse_type()
        if self.matches(optional_space, required_open_paren) {
            self.consume_space(0)
            self.consume(required_open_paren)
            self.parse_call_arguments(struct_super_arguments)
            self.consume_space(0)
            self.consume(required_close_paren)
        }
    }
    self.consume_space(1)
    self.consume(required_open_brace)
    self.consume_end_of_line()
    self.current_alignment = self.current_alignment + 1
    let struct_members = make @List[@Parsed_Struct_Member]()
    while not self.matches(optional_space, required_close_brace) {
        if not self.consume_empty_line() {
            self.consume_space(self.current_alignment * 4)
            let struct_member_name = self.consume(required_identifier).as(@Identifier_Token)
            let struct_member_value_type: @Parsed_Type = null
            if self.matches(optional_space, required_colon) {
                self.consume_space(0)
                self.consume(required_colon)
                self.consume_space(1)
                struct_member_value_type = self.parse_type()
            }
            let struct_member_value_expression: @Parsed_Expression = null
            if self.matches(optional_space, required_equals) {
                self.consume_space(1)
                self.consume(required_equals)
                self.consume_space(1)
                struct_member_value_expression = self.parse_expression()
            }
            self.consume_end_of_line()
            struct_members.append(make @Parsed_Struct_Member(
                location = struct_member_name.location
                name = struct_member_name
                type = struct_member_value_type
                default_value_expression = struct_member_value_expression
            ))
        }
    }
    self.current_alignment = self.current_alignment - 1
    self.consume_space(self.current_alignment * 4)
    self.consume(required_close_brace)
    let struct_statement = make @Parsed_Struct_Statement(
        location = struct_name.location
        name = struct_name
        members = struct_members
        super_type = struct_super_type
        super_arguments = struct_super_arguments
    )
    if struct_type_parameters != null {
        return make @Parsed_Generic_Struct_Statement(
            location = struct_name.location
            name = struct_name
            type_parameters = struct_type_parameters
            struct_statement = struct_statement
        )
    }
    return struct_statement
}

\ type_parameters
\   | "[" IDENTIFIER ( "," IDENTIFIER )* "]"
func parse_type_parameters(self: @Parser) -> @List[@Parsed_Type_Parameter] {
    let type_parameters = make @List[@Parsed_Type_Parameter]()
    self.consume(required_open_bracket)
    self.consume_space(0)
    loop {
        let type_parameter_name = self.consume(required_identifier).as(@Identifier_Token)
        type_parameters.append(make @Parsed_Type_Parameter(name = type_parameter_name))
        self.consume_space(0)
        if not self.matches(required_comma) {
            break
        }
        self.consume(required_comma)
        self.consume_space(1)
    }
    self.consume(required_close_bracket)
    return type_parameters
}

\ external_function
\   | "func" IDENTIFIER function_signature
func parse_external_function(self: @Parser) -> @Parsed_Function_Statement {
    self.consume(required_func)
    self.consume_space(1)
    let function_name = self.consume(required_identifier).as(@Identifier_Token)
    self.consume_space(0)
    let function_signature = self.parse_function_signature()
    if self.matches(optional_space, required_open_brace) == true {
        abort(self.scanner.current_token.location, "External function with function body")
    }
    let function_statement = make @Parsed_Function_Statement(
        location = function_name.location
        name = function_name
        type = make @Parsed_Function_Type(
            location = function_name.location
            type_parameters = null
            parameters = function_signature.parameters
            return_type = function_signature.return_type
        )
        body = null
        is_anonymous = false
    )
    self.parsed_code.function_statements.append(function_statement)
    return function_statement
}

\ function
\   | "func" IDENTIFIER type_parameters? function_signature block
func parse_function(self: @Parser) -> @Parsed_Function_Statement {
    self.consume(required_func)
    self.consume_space(1)
    let function_name = self.consume(required_identifier).as(@Identifier_Token)
    self.consume_space(0)
    let function_type_parameters: @List[@Parsed_Type_Parameter] = null
    if self.matches(required_open_bracket) {
        function_type_parameters = self.parse_type_parameters()
        self.consume_space(0)
    }
    let function_signature = self.parse_function_signature()
    if not self.matches(optional_space, required_open_brace) {
        abort(self.scanner.current_token.location, "Missing function body")
    }
    self.consume_space(1)
    let function_body = self.parse_block()
    let function_statement = make @Parsed_Function_Statement(
        location = function_name.location
        name = function_name
        type = make @Parsed_Function_Type(
            location = function_name.location
            type_parameters = function_type_parameters
            parameters = function_signature.parameters
            return_type = function_signature.return_type
        )
        body = function_body
        is_anonymous = false
    )
    self.parsed_code.function_statements.append(function_statement)
    return function_statement
}

\ function
\   | "func" function_signature block
func parse_anonymous_function(self: @Parser, function_name: @Identifier_Token) -> @Parsed_Function_Statement {
    self.consume(required_func)
    self.consume_space(1)
    let function_signature = self.parse_function_signature()
    if not self.matches(optional_space, required_open_brace) {
        abort(function_name.location, "Anonymous function without body")
    }
    self.consume_space(1)
    let function_body = self.parse_block()
    let function_statement = make @Parsed_Function_Statement(
        location = function_name.location
        name = function_name
        type = make @Parsed_Function_Type(
            location = function_name.location
            type_parameters = null
            parameters = function_signature.parameters
            return_type = function_signature.return_type
        )
        body = function_body
        is_anonymous = true
    )
    self.parsed_code.function_statements.append(function_statement)
    return function_statement
}

struct Parsed_Function_Signature {
    parameters: @List[@Parsed_Callable_Parameter]
    return_type: @Parsed_Type
}

\ function_signature
\   | parameters "->" type
func parse_function_signature(self: @Parser) -> @Parsed_Function_Signature {
    let function_parameters = self.parse_parameters()
    self.consume_space(1)
    self.consume(required_hyphen, required_greater_than)
    self.consume_space(1)
    let function_return_type = self.parse_type()
    return make @Parsed_Function_Signature(parameters = function_parameters, return_type = function_return_type)
}

\ function_type
\   | "func" function_signature
func parse_function_type(self: @Parser) -> @Parsed_Function_Type {
    let location = self.consume(required_func).location
    self.consume_space(1)
    let function_signature = self.parse_function_signature()
    return make @Parsed_Function_Type(
        location = location
        type_parameters = null
        parameters = function_signature.parameters
        return_type = function_signature.return_type
    )
}

\ parameters
\   | "(" ( parameter ( "," parameter )* )? ")"
func parse_parameters(self: @Parser) -> @List[@Parsed_Callable_Parameter] {
    let parameters = make @List[@Parsed_Callable_Parameter]()
    self.consume(required_open_paren)
    self.consume_space(0)
    if not self.matches(required_close_paren) {
        parameters.append(self.parse_parameter())
        while not self.matches(optional_space, required_close_paren) {
            self.consume_space(0)
            self.consume(required_comma)
            self.consume_space(1)
            parameters.append(self.parse_parameter())
        }
    }
    self.consume(required_close_paren)
    return parameters
}

\ parameter
\   | IDENTIFIER ":" type
func parse_parameter(self: @Parser) -> @Parsed_Callable_Parameter {
    let parameter_name = self.consume(required_identifier).as(@Identifier_Token)
    self.consume_space(0)
    self.consume(required_colon)
    self.consume_space(1)
    let parameter_type = self.parse_type()
    return make @Parsed_Callable_Parameter(location = parameter_name.location, name = parameter_name, type = parameter_type)
}

\ macro
\   | "macro" IDENTIFIER type_parameters? parameters block
func parse_macro(self: @Parser) -> @Parsed_Macro_Statement {
    self.consume(required_macro)
    self.consume_space(1)
    let macro_name = self.consume(required_identifier).as(@Identifier_Token)
    self.consume_space(0)
    let macro_type_parameters: @List[@Parsed_Type_Parameter] = null
    if self.matches(required_open_bracket) {
        macro_type_parameters = self.parse_type_parameters()
        self.consume_space(0)
    }
    let macro_parameters = self.parse_parameters()
    if not self.matches(optional_space, required_open_brace) {
        abort(self.scanner.current_token.location, "Missing macro body")
    }
    self.consume_space(1)
    let macro_body = self.parse_block()
    let macro_statement = make @Parsed_Macro_Statement(
        location = macro_name.location
        name = macro_name
        type = make @Parsed_Macro_Type(
            type_parameters = macro_type_parameters
            parameters = macro_parameters
        )
        body = macro_body
    )
    self.parsed_code.macro_statements.append(macro_statement)
    return macro_statement
}

\ macro_type
\   | "macro" parameters
func parse_macro_type(self: @Parser) -> @Parsed_Macro_Type {
    let location = self.consume(required_macro).location
    self.consume_space(1)
    let macro_parameters = self.parse_parameters()
    return make @Parsed_Macro_Type(location = location, type_parameters = null, parameters = macro_parameters)
}

\ block
\   | "{" statements "}"
func parse_block(self: @Parser) -> @Parsed_Block_Statement {
    let location = self.consume(required_open_brace).location
    self.consume_end_of_line()
    self.current_alignment = self.current_alignment + 1
    let statements = make @List[@Parsed_Statement]()
    self.parse_statements(statements, false)
    self.current_alignment = self.current_alignment - 1
    self.consume_space(self.current_alignment * 4)
    self.consume(required_close_brace)
    return make @Parsed_Block_Statement(location = location, statements = statements)
}

\ let
\   | "let" IDENTIFIER ( ":" type ( "=" expression )? | "=" expression )
func parse_let(self: @Parser) -> @Parsed_Variable_Statement {
    let location = self.consume(required_let).location
    self.consume_space(1)
    let variable_name = self.consume(required_identifier).as(@Identifier_Token)
    let variable_value_type: @Parsed_Type = null
    let variable_value_expression: @Parsed_Expression = null
    let variable_is_global = self.current_alignment == 0
    if self.matches(optional_space, required_colon) {
        self.consume_space(0)
        self.consume(required_colon)
        self.consume_space(1)
        variable_value_type = self.parse_type()
    }
    if self.matches(optional_space, required_equals) {
        self.consume_space(1)
        self.consume(required_equals)
        self.consume_space(1)
        variable_value_expression = self.parse_expression()
    }
    return make @Parsed_Variable_Statement(
        location = variable_name.location
        name = variable_name
        type = variable_value_type
        value_expression = variable_value_expression
        is_external = false
    )
}

\ if
\   | "if" expression block ( "else" ( block | if ) )?
func parse_if(self: @Parser) -> @Parsed_Statement {
    let location = self.consume(required_if).location
    self.consume_space(1)
    let condition_expression = self.parse_expression()
    if condition_expression is Parsed_Paren_Expression {
        stderr.write(condition_expression.location).write(": ").warning().write("Redundant parentheses").reset().end_line()
    }
    self.consume_space(1)
    let true_statement = self.parse_block()
    let false_statement: @Parsed_Statement = null
    if self.matches(optional_space, required_else) {
        self.consume_space(1)
        self.consume(required_else)
        self.consume_space(1)
        if self.matches(required_if) {
            false_statement = self.parse_if()
        } else {
            false_statement = self.parse_block()
        }
    }
    return make @Parsed_If_Statement(location = location, condition_expression = condition_expression, true_statement = true_statement, false_statement = false_statement)
}

\ loop
\   | "loop" block
func parse_loop(self: @Parser) -> @Parsed_Statement {
    let location = self.consume(required_loop).location
    self.consume_space(1)
    let loop_block = self.parse_block()
    return make @Parsed_Loop_Statement(location = location, body_statement = loop_block)
}

\ while
\   | "while" expression block
func parse_while(self: @Parser) -> @Parsed_Statement {
    let location = self.consume(required_while).location
    self.consume_space(1)
    let condition_expression = self.parse_expression()
    if condition_expression is Parsed_Paren_Expression {
        stderr.write(condition_expression.location).write(": ").warning().write("Redundant parentheses").reset().end_line()
    }
    self.consume_space(1)
    let loop_block = self.parse_block()
    return make @Parsed_While_Statement(location = location, condition_expression = condition_expression, body_statement = loop_block)
}

\ type
\   | "@" type
\   | IDENTIFIER ( "[" type ( "," type )* "]" )?
\   | "[" type ( ";" expression )? "]"
\   | function_type
\   | macro_type
func parse_type(self: @Parser) -> @Parsed_Type {
    if self.matches(required_at) {
        let location = self.consume(required_at).location
        self.consume_space(0)
        let pointed_type = self.parse_type()
        return make @Parsed_Pointer_Type(location = location, pointed_type = pointed_type)
    }

    if self.matches(required_open_bracket) {
        let token = self.consume(required_open_bracket)
        self.consume_space(0)
        let array_item_type = self.parse_type()
        let array_is_checked = true
        let array_size_expression: @Parsed_Expression = null
        if self.matches(optional_space, required_column) {
            self.consume_space(0)
            self.consume(required_column)
            self.consume_space(1)
            if self.matches(required_question_mark) {
                self.consume(required_question_mark)
                array_is_checked = false
            } else {
                array_size_expression = self.parse_expression()
            }
        }
        self.consume_space(0)
        self.consume(required_close_bracket)
        return make @Parsed_Array_Type(location = token.location, item_type = array_item_type, is_checked = array_is_checked, size_expression = array_size_expression)
    }

    if self.matches(required_func) {
        return self.parse_function_type()
    }

    if self.matches(required_macro) {
        return self.parse_macro_type()
    }

    let type_name = self.consume(required_identifier).as(@Identifier_Token)
    if self.matches(optional_space, required_open_bracket) {
        self.consume_space(0)
        self.consume(required_open_bracket)
        self.consume_space(0)
        let type_arguments = make @List[@Parsed_Type_Argument]()
        loop {
            type_arguments.append(make @Parsed_Type_Argument(type = self.parse_type()))
            self.consume_space(0)
            if not self.matches(required_comma) {
                break
            }
            self.consume(required_comma)
            self.consume_space(1)
        }
        self.consume(required_close_bracket)
        return make @Parsed_Specialized_Type(location = type_name.location, name = type_name, type_arguments = type_arguments)
    }

    return make @Parsed_Named_Type(location = type_name.location, name = type_name)
}

func parse_expression(self: @Parser) -> @Parsed_Expression {
    return self.parse_logic_or_expression()
}

\ logic_or_expression
\   | logic_and_expression ( "or" logic_and_expression )*
func parse_logic_or_expression(self: @Parser) -> @Parsed_Expression {
    let expression = self.parse_logic_and_expression()
    while self.matches(optional_space, required_or) {
        self.consume_space(1)
        self.consume(required_or)
        self.consume_space(1)
        expression = make @Parsed_Logic_Or_Expression(
            location = expression.location
            left_expression = expression
            right_expression = self.parse_logic_and_expression()
        )
    }
    return expression
}

\ logic_and_expression
\   | logic_not_expression ( "and" logic_not_expression )*
func parse_logic_and_expression(self: @Parser) -> @Parsed_Expression {
    let expression = self.parse_logic_not_expression()
    while self.matches(optional_space, required_and) {
        self.consume_space(1)
        self.consume(required_and)
        self.consume_space(1)
        expression = make @Parsed_Logic_And_Expression(
            location = expression.location
            left_expression = expression
            right_expression = self.parse_logic_not_expression()
        )
    }
    return expression
}

\ logic_not_expression
\   | "not" logic_not_expression
\   | comparison_expression
func parse_logic_not_expression(self: @Parser) -> @Parsed_Expression {
    if self.matches(required_not) {
        let location = self.consume(required_not).location
        self.consume_space(1)
        let expression = self.parse_logic_not_expression()
        return make @Parsed_Logic_Not_Expression(location = expression.location, expression = expression)
    }
    return self.parse_comparison_expression()
}

\ comparison_expression
\   | addition_expression ( ( "==" | "!=" | ">" | ">=" | "<" | "<=" ) addition_expression )?
\   | addition_expression ( "is" "not"? type )?
func parse_comparison_expression(self: @Parser) -> @Parsed_Expression {
    let expression = self.parse_addition_expression()
    if self.matches(optional_space, required_equals, required_equals) {
        self.consume_space(1)
        self.consume(required_equals, required_equals)
        self.consume_space(1)
        expression = make @Parsed_Equals_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_addition_expression())
    } else if self.matches(optional_space, required_exclamation_mark, required_equals) {
        self.consume_space(1)
        self.consume(required_exclamation_mark, required_equals)
        self.consume_space(1)
        expression = make @Parsed_Not_Equals_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_addition_expression())
    } else if self.matches(optional_space, required_greater_than) {
        self.consume_space(1)
        self.consume(required_greater_than)
        if self.matches(required_equals) {
            self.consume(required_equals)
            self.consume_space(1)
            expression = make @Parsed_Greater_Than_Or_Equals_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_addition_expression())
        } else {
            self.consume_space(1)
            expression = make @Parsed_Greater_Than_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_addition_expression())
        }
    } else if self.matches(optional_space, required_less_than) {
        self.consume_space(1)
        self.consume(required_less_than)
        if self.matches(required_equals) {
            self.consume(required_equals)
            self.consume_space(1)
            expression = make @Parsed_Less_Than_Or_Equals_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_addition_expression())
        } else {
            self.consume_space(1)
            expression = make @Parsed_Less_Than_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_addition_expression())
        }
    } else if self.matches(optional_space, required_is) {
        self.consume_space(1)
        self.consume(required_is)
        self.consume_space(1)
        if self.matches(optional_space, required_not) {
            self.consume(required_not)
            self.consume_space(1)
            expression = make @Parsed_Logic_Not_Expression(
                location = expression.location
                expression = make @Parsed_Is_Expression(
                    location = expression.location
                    value_expression = expression
                    type = self.parse_type()
                )
            )
        } else {
            expression = make @Parsed_Is_Expression(
                location = expression.location
                value_expression = expression
                type = self.parse_type()
            )
        }
    }
    return expression
}

\ addition_expression
\   | multiplication_expression ( ( "+" | "-" ) multiplication_expression )*
func parse_addition_expression(self: @Parser) -> @Parsed_Expression {
    let expression = self.parse_multiplication_expression()
    while self.matches(optional_space, required_plus) or self.matches(optional_space, required_hyphen) {
        self.consume_space(1)
        let binary_expression: @Parsed_Binary_Expression
        if self.matches(required_plus) {
            self.consume(required_plus)
            self.consume_space(1)
            expression = make @Parsed_Add_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_multiplication_expression())
        } else {
            self.consume(required_hyphen)
            self.consume_space(1)
            expression = make @Parsed_Substract_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_multiplication_expression())
        }
    }
    return expression
}

\ multiplication_expression
\   | unary_expression ( ( "*" | "/" | "//" ) unary_expression )*
func parse_multiplication_expression(self: @Parser) -> @Parsed_Expression {
    let expression = self.parse_unary_expression()
    while self.matches(optional_space, required_asterisk) or self.matches(optional_space, required_slash) {
        self.consume_space(1)
        if self.matches(required_slash) {
            self.consume(required_slash)
            if self.matches(required_slash) {
                self.consume(required_slash)
                self.consume_space(1)
                expression = make @Parsed_Modulo_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_unary_expression())
            } else {
                self.consume_space(1)
                expression = make @Parsed_Divide_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_unary_expression())
            }
        } else {
            self.consume(required_asterisk)
            self.consume_space(1)
            expression = make @Parsed_Multiply_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_unary_expression())
        }
    }
    return expression
}

\ unary_expression
\   | "-" unary_expression
\   | access_expression
func parse_unary_expression(self: @Parser) -> @Parsed_Expression {
    if self.matches(required_hyphen) {
        let location = self.consume(required_hyphen).location
        self.consume_space(0)
        let expression = self.parse_unary_expression()
        if expression is Parsed_Literal_Expression and expression.as(@Parsed_Literal_Expression).literal is Integer_Token {
            let old_literal = expression.as(@Parsed_Literal_Expression).literal.as(@Integer_Token)
            let new_literal = make @Integer_Token(location = location, lexeme = clone("-").append(old_literal.lexeme), value = old_literal.value, negative = not old_literal.negative, type = old_literal.type)
            return make @Parsed_Wrapped_Expression(
                location = location
                expression = make @Parsed_Literal_Expression(
                    location = location
                    literal = new_literal
                )
            )
        }
        return make @Parsed_Negate_Expression(location = location, expression = expression)
    }
    return self.parse_access_expression()
}

\ access_expression
\   | primary_expression ( "." IDENTIFIER | "." "as" "(" type ")" | "(" call_arguments? ")" | "[" expression "]" )*
func parse_access_expression(self: @Parser) -> @Parsed_Expression {
    let expression = self.parse_primary_expression()
    if expression != null {
        loop {
            let old_expression = expression
            if self.matches(optional_space, required_dot) {
                self.consume_space(0)
                self.consume(required_dot)
                self.consume_space(0)
                if self.matches(required_as) {
                    self.consume(required_as)
                    self.consume_space(0)
                    self.consume(required_open_paren)
                    self.consume_space(0)
                    let type = self.parse_type()
                    self.consume_space(0)
                    self.consume(required_close_paren)
                    expression = make @Parsed_Cast_Expression(location = expression.location, value_expression = expression, type = type)
                } else {
                    expression = make @Parsed_Member_Access_Expression(location = expression.location, object_expression = expression, member_name = self.consume(required_identifier).as(@Identifier_Token))
                }
            }
            if self.matches(optional_space, required_open_paren) {
                self.consume_space(0)
                self.consume(required_open_paren)
                self.consume_space(0)
                let call_arguments = make @List[@Parsed_Call_Argument]()
                if not self.matches(optional_space, required_close_paren) {
                    self.parse_call_arguments(call_arguments)
                }
                self.consume_space(0)
                self.consume(required_close_paren)
                expression = make @Parsed_Call_Expression(location = expression.location, callee_expression = expression, arguments = call_arguments)
            }
            if self.matches(optional_space, required_open_bracket) {
                self.consume_space(0)
                self.consume(required_open_bracket)
                self.consume_space(0)
                let index_expression = self.parse_expression()
                self.consume_space(0)
                self.consume(required_close_bracket)
                expression = make @Parsed_Array_Access_Expression(location = expression.location, array_expression = expression, index_expression = index_expression)
            }
            if expression == old_expression {
                break
            }
        }
    }
    return expression
}

\ call_arguments
\   | call_argument ( ("," | END_OF_LINE) call_argument )*
func parse_call_arguments(self: @Parser, call_arguments: @List[@Parsed_Call_Argument]) -> Nothing {
    let multiline = false
    let space_before_argument_list = 0

    if self.matches_end_of_line() {
        self.consume_end_of_line()
        multiline = true
        self.current_alignment = self.current_alignment + 1
        space_before_argument_list = self.current_alignment * 4

        while self.consume_empty_line() {
            \ continue
        }
    }

    while not self.matches(optional_space, required_close_paren) {
        self.consume_space(space_before_argument_list)
        call_arguments.append(self.parse_call_argument())
        while self.matches(optional_space, required_comma) {
            self.consume_space(0)
            let comma_token = self.consume(required_comma)
            if self.matches_end_of_line() {
                self.abort(comma_token)
            } else {
                self.consume_space(1)
                if self.matches(required_close_paren) {
                    self.abort(self.scanner.current_token)
                }
                call_arguments.append(self.parse_call_argument())
            }
        }

        if self.matches_end_of_line() {
            self.consume_end_of_line()

            if not multiline {
                stderr.write(call_arguments.get(0i64).location).write(": ").warning().write("Multi-line argument list must start on a new line").reset().end_line()

                multiline = true
                self.current_alignment = self.current_alignment + 1
                space_before_argument_list = self.current_alignment * 4
            }
        } else if multiline and self.matches(optional_space, required_close_paren) {
            stderr.write(self.scanner.current_token.location).write(": ").warning().write("Multi-line argument list must end on a new line").reset().end_line()

            multiline = false
            self.current_alignment = self.current_alignment - 1
        }

        if multiline {
            while self.consume_empty_line() {
                \ continue
            }
        }
    }

    if multiline {
        self.current_alignment = self.current_alignment - 1
        self.consume_space(self.current_alignment * 4)
    }
}

\ call_argument
\   | ( IDENTIFIER "=" )? expression
func parse_call_argument(self: @Parser) -> @Parsed_Call_Argument {
    if self.matches(required_identifier, optional_space, required_equals) {
        let name = self.consume(required_identifier).as(@Identifier_Token)
        self.consume_space(1)
        self.consume(required_equals)
        self.consume_space(1)
        let value_expression = self.parse_expression()
        if value_expression == null {
            self.abort(self.scanner.current_token)
        }
        return make @Parsed_Call_Argument(location = name.location, name = name, value_expression = value_expression)
    }
    let value_expression = self.parse_expression()
    if value_expression == null {
        self.abort(self.scanner.current_token)
    }
    return make @Parsed_Call_Argument(location = value_expression.location, name = null, value_expression = value_expression)
}

\ primary_expression
\   | "@"? IDENTIFIER
\   | INTEGER
\   | STRING
\   | CHARACTER
\   | "null"
\   | "false"
\   | "true"
\   | "undefined"
\   | "(" expression ")"
\   | "make" type "(" call_arguments? ")"
\   | anonymous_function
func parse_primary_expression(self: @Parser) -> @Parsed_Expression {
    if self.matches(required_make) {
        let location = self.consume(required_make).location
        self.consume_space(1)
        let type = self.parse_type()
        self.consume_space(0)
        self.consume(required_open_paren)
        let call_arguments = make @List[@Parsed_Call_Argument]()
        if not self.matches(optional_space, required_close_paren) {
            self.parse_call_arguments(call_arguments)
        }
        self.consume_space(0)
        self.consume(required_close_paren)
        return make @Parsed_Make_Expression(location = location, type = type, init_arguments = call_arguments)
    }
    if self.matches(required_literal) {
        let token = self.consume(required_literal).as(@Literal_Token)
        return make @Parsed_Literal_Expression(location = token.location, literal = token)
    }
    if self.matches(required_func) {
        let function_name = clone("anonymous_function_").append(self.anonymous_functions_counter.next())
        let function_statement = self.parse_anonymous_function(make @Generated_Identifier_Token(location = self.scanner.current_token.location, lexeme = function_name))
        return make @Parsed_Function_Expression(location = function_statement.location, function_statement = function_statement)
    }
    if self.matches(required_at) {
        let location = self.consume(required_at).location
        self.consume_space(0)
        let identifier = self.consume(required_identifier).as(@Identifier_Token)
        return make @Parsed_Variable_Reference_Expression(
            location = location
            variable_expression = make @Parsed_Symbol_Expression(location = identifier.location, name = identifier)
        )
    }
    if self.matches(required_identifier) {
        let identifier = self.consume(required_identifier).as(@Identifier_Token)
        return make @Parsed_Symbol_Expression(location = identifier.location, name = identifier)
    }
    if self.matches(required_open_paren) {
        let location = self.consume(required_open_paren).location
        self.consume_space(0)
        let expression = self.parse_expression()
        self.consume_space(0)
        self.consume(required_close_paren)
        return make @Parsed_Paren_Expression(location = location, expression = expression)
    }
    return null
}

struct Generated_Identifier_Token: Identifier_Token {
}

func consume_end_of_line(self: @Parser) -> Nothing {
    if self.matches(optional_space, required_comment) {
        self.consume_space(1)
        self.consume(required_comment)
    } else {
        self.consume_space(0)
    }
    if not self.matches(required_end_of_file) {
        self.consume(required_end_of_line)
    }
}

func consume_empty_line(self: @Parser) -> bool {
    if self.matches(optional_space, optional_comment, required_end_of_line) {
        if self.matches(optional_space, required_comment) {
            self.consume_space(self.current_alignment * 4)
            self.consume(required_comment)
        } else {
            self.consume_space(0)
        }
        self.consume(required_end_of_line)
        return true
    }
    return false
}

func consume_space(self: @Parser, expected_space_count: i32) -> Nothing {
    let space_count: i32
    let token = self.scanner.current_token
    if token is Space_Token {
        self.scanner.next_token()
        let space = token.as(@Space_Token)
        space_count = space.count
    } else {
        space_count = 0
    }
    if space_count != expected_space_count {
        stderr.write(token.location).write(": ").warning().write("Consumed ").write(space_count).write(" spaces where ").write(expected_space_count).write(" are expected").reset().end_line()
    }
}

func consume(self: @Parser, first_matcher: @Matcher) -> @Token {
    return self.consume(first_matcher, null)
}

func consume(self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher) -> @Token {
    return self.consume(first_matcher, second_matcher, null)
}

func consume(self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher, third_matcher: @Matcher) -> @Token {
    let token = self.scanner.current_token
    let first_token = token
    if first_matcher.accepts(token) {
        token = self.scanner.next_token()
    } else {
        if first_matcher.is_required {
            self.abort(token)
        }
    }
    if second_matcher != null {
        if second_matcher.accepts(token) {
            token = self.scanner.next_token()
        } else {
            if second_matcher.is_required {
                self.abort(token)
            }
        }
    }
    if third_matcher != null {
        if third_matcher.accepts(token) {
            token = self.scanner.next_token()
        } else {
            if third_matcher.is_required {
                self.abort(token)
            }
        }
    }
    return first_token
}

func matches_end_of_line(self: @Parser) -> bool {
    return self.matches(optional_space, optional_comment, required_end_of_line)
}

func matches(self: @Parser, first_matcher: @Matcher) -> bool {
    return self.matches(first_matcher, null)
}

func matches(self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher) -> bool {
    return self.matches(first_matcher, second_matcher, null)
}

func matches(self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher, third_matcher: @Matcher) -> bool {
    let token = self.scanner.current_token
    let peek_offset = 0i64
    if first_matcher.accepts(token) {
        token = self.scanner.peek_token(peek_offset)
        peek_offset = peek_offset + 1
    } else if first_matcher.is_required {
        return false
    }
    if second_matcher != null {
        if second_matcher.accepts(token) {
            token = self.scanner.peek_token(peek_offset)
            peek_offset = peek_offset + 1
        } else if second_matcher.is_required {
            return false
        }
    }
    if third_matcher != null {
        if third_matcher.accepts(token) {
            token = self.scanner.peek_token(peek_offset)
            peek_offset = peek_offset + 1
        } else if third_matcher.is_required {
            return false
        }
    }
    return true
}

struct Matcher: Object {
    is_required: bool
    accepts = func (self: @Matcher, token: @Token) -> bool {
        abort(token.location, "Invalid state")
    }
}

struct Comment_Matcher: Matcher(
    accepts = func (self: @Matcher, token: @Token) -> bool {
        return token is Comment_Token
    }
) {
}

struct End_Of_File_Matcher: Matcher(
    accepts = func (self: @Matcher, token: @Token) -> bool {
        return token is End_Of_File_Token
    }
) {
}

struct End_Of_Line_Matcher: Matcher(
    accepts = func (self: @Matcher, token: @Token) -> bool {
        return token is End_Of_Line_Token
    }
) {
}

struct Identifier_Matcher: Matcher(
    accepts = func (self: @Matcher, token: @Token) -> bool {
        return token is Identifier_Token
    }
) {
}

struct Keyword_Matcher: Matcher(
    accepts = func (self: @Matcher, token: @Token) -> bool {
        if token is Identifier_Token {
            return token.lexeme.equals(self.as(@Keyword_Matcher).lexeme)
        }
        return false
    }
) {
    lexeme: @String
}

struct Literal_Matcher: Matcher(
    accepts = func (self: @Matcher, token: @Token) -> bool {
        return token is Integer_Token or token is String_Token or token is Character_Token or token is Boolean_Token or token is Null_Token or token is Undefined_Token
    }
) {
}

struct Other_Matcher: Matcher(
    accepts = func (self: @Matcher, token: @Token) -> bool {
        if token is Other_Token {
            return token.lexeme.equals(self.as(@Other_Matcher).lexeme)
        }
        return false
    }
) {
    lexeme: @String
}

struct Space_Matcher: Matcher(
    accepts = func (self: @Matcher, token: @Token) -> bool {
        return token is Space_Token
    }
) {
}

struct String_Literal_Matcher: Matcher(
    accepts = func (self: @Matcher, token: @Token) -> bool {
        return token is String_Token
    }
) {
}

let optional_comment: @Matcher = undefined
let optional_space: @Matcher = undefined
let required_ampersand: @Matcher = undefined
let required_and: @Matcher = undefined
let required_as: @Matcher = undefined
let required_asterisk: @Matcher = undefined
let required_at: @Matcher = undefined
let required_break: @Matcher = undefined
let required_close_brace: @Matcher = undefined
let required_close_bracket: @Matcher = undefined
let required_close_paren: @Matcher = undefined
let required_colon: @Matcher = undefined
let required_column: @Matcher = undefined
let required_comma: @Matcher = undefined
let required_comment: @Matcher = undefined
let required_define: @Matcher = undefined
let required_dot: @Matcher = undefined
let required_else: @Matcher = undefined
let required_end_of_file: @Matcher = undefined
let required_end_of_line: @Matcher = undefined
let required_equals: @Matcher = undefined
let required_exclamation_mark: @Matcher = undefined
let required_extends: @Matcher = undefined
let required_external: @Matcher = undefined
let required_func: @Matcher = undefined
let required_greater_than: @Matcher = undefined
let required_hyphen: @Matcher = undefined
let required_identifier: @Matcher = undefined
let required_if: @Matcher = undefined
let required_include: @Matcher = undefined
let required_is: @Matcher = undefined
let required_less_than: @Matcher = undefined
let required_let: @Matcher = undefined
let required_literal: @Matcher = undefined
let required_loop: @Matcher = undefined
let required_macro: @Matcher = undefined
let required_make: @Matcher = undefined
let required_not: @Matcher = undefined
let required_open_brace: @Matcher = undefined
let required_open_bracket: @Matcher = undefined
let required_open_paren: @Matcher = undefined
let required_or: @Matcher = undefined
let required_plus: @Matcher = undefined
let required_question_mark: @Matcher = undefined
let required_return: @Matcher = undefined
let required_slash: @Matcher = undefined
let required_string_literal: @Matcher = undefined
let required_struct: @Matcher = undefined
let required_type: @Matcher = undefined
let required_vertical_bar: @Matcher = undefined
let required_while: @Matcher = undefined

func init_matchers() -> Nothing {
    optional_comment = make @Comment_Matcher(is_required = false)
    optional_space = make @Space_Matcher(is_required = false)
    required_ampersand = make @Other_Matcher(is_required = true, lexeme = "&")
    required_and = make @Keyword_Matcher(is_required = true, lexeme = "and")
    required_as = make @Keyword_Matcher(is_required = true, lexeme = "as")
    required_asterisk = make @Other_Matcher(is_required = true, lexeme = "*")
    required_at = make @Other_Matcher(is_required = true, lexeme = "@")
    required_break = make @Keyword_Matcher(is_required = true, lexeme = "break")
    required_close_brace = make @Other_Matcher(is_required = true, lexeme = "}")
    required_close_bracket = make @Other_Matcher(is_required = true, lexeme = "]")
    required_close_paren = make @Other_Matcher(is_required = true, lexeme = ")")
    required_colon = make @Other_Matcher(is_required = true, lexeme = ":")
    required_column = make @Other_Matcher(is_required = true, lexeme = ";")
    required_comma = make @Other_Matcher(is_required = true, lexeme = ",")
    required_comment = make @Comment_Matcher(is_required = true)
    required_define = make @Keyword_Matcher(is_required = true, lexeme = "define")
    required_dot = make @Other_Matcher(is_required = true, lexeme = ".")
    required_else = make @Keyword_Matcher(is_required = true, lexeme = "else")
    required_end_of_file = make @End_Of_File_Matcher(is_required = true)
    required_end_of_line = make @End_Of_Line_Matcher(is_required = true)
    required_equals = make @Other_Matcher(is_required = true, lexeme = "=")
    required_exclamation_mark = make @Other_Matcher(is_required = true, lexeme = "!")
    required_extends = make @Keyword_Matcher(is_required = true, lexeme = "extends")
    required_external = make @Keyword_Matcher(is_required = true, lexeme = "external")
    required_func = make @Keyword_Matcher(is_required = true, lexeme = "func")
    required_greater_than = make @Other_Matcher(is_required = true, lexeme = ">")
    required_hyphen = make @Other_Matcher(is_required = true, lexeme = "-")
    required_identifier = make @Identifier_Matcher(is_required = true)
    required_if = make @Keyword_Matcher(is_required = true, lexeme = "if")
    required_include = make @Keyword_Matcher(is_required = true, lexeme = "include")
    required_is = make @Keyword_Matcher(is_required = true, lexeme = "is")
    required_less_than = make @Other_Matcher(is_required = true, lexeme = "<")
    required_let = make @Keyword_Matcher(is_required = true, lexeme = "let")
    required_literal = make @Literal_Matcher(is_required = true)
    required_loop = make @Keyword_Matcher(is_required = true, lexeme = "loop")
    required_macro = make @Keyword_Matcher(is_required = true, lexeme = "macro")
    required_make = make @Keyword_Matcher(is_required = true, lexeme = "make")
    required_not = make @Keyword_Matcher(is_required = true, lexeme = "not")
    required_open_brace = make @Other_Matcher(is_required = true, lexeme = "{")
    required_open_bracket = make @Other_Matcher(is_required = true, lexeme = "[")
    required_open_paren = make @Other_Matcher(is_required = true, lexeme = "(")
    required_or = make @Keyword_Matcher(is_required = true, lexeme = "or")
    required_plus = make @Other_Matcher(is_required = true, lexeme = "+")
    required_question_mark = make @Other_Matcher(is_required = true, lexeme = "?")
    required_return = make @Keyword_Matcher(is_required = true, lexeme = "return")
    required_slash = make @Other_Matcher(is_required = true, lexeme = "/")
    required_string_literal = make @String_Literal_Matcher(is_required = true)
    required_struct = make @Keyword_Matcher(is_required = true, lexeme = "struct")
    required_type = make @Keyword_Matcher(is_required = true, lexeme = "type")
    required_vertical_bar = make @Other_Matcher(is_required = true, lexeme = "|")
    required_while = make @Keyword_Matcher(is_required = true, lexeme = "while")
}
