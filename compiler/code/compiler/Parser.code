\ Copyright (c) 2020, Stefan Selariu

define Parser = struct {
    scanner: Scanner = null
    compilation_unit: Compilation_Unit = new Compilation_Unit()
    current_alignment: i64 = 0
    anonymous_functions_counter: !Counter = Counter()
}

define parse = func (file_path: String) -> Compilation_Unit {
    let parser = new Parser()
    parser.parse(file_path, null)
    return parser.compilation_unit
}

define parse = func (self: Parser, file_path: String, location: Source_Location) -> Nothing {
    let source = create_source(file_path)
    if (source == null) {
        let message = clone("Failed to open file: ").append(file_path)
        if (location != null) {
            abort(location, message)
        }
        abort(message)
    }

    self.compilation_unit.sources.append(source)
    source.id = self.compilation_unit.sources.size

    let other_scanner = self.scanner
    self.scanner = create_scanner(source)
    self.parse_statements(self.compilation_unit.statements)

    let token = self.scanner.current_token
    if (token.is(End_Of_File_Token) == false) {
        abort(self, self.scanner.current_token)
    }
    let token = token as End_Of_File_Token
    if (token.location.column != 1 as i64) {
        stderr.write(token.location).write(": File doesn't end with a new line").end_line()
    }

    self.scanner = other_scanner
}

\ statements
\   : ( statement <EOL> )*
define parse_statements = func (self: Parser, statements: List) -> Nothing {
    loop {
        let statement = self.parse_statement()
        if (statement == null) {
            break
        }
        self.consume_end_of_line()
        if (statement.is(AST_Include_Statement)) {
            let statement = statement as AST_Include_Statement

            let statement_file_path = statement.file_path.make_relative_path(statement.location.source.file_path)
            if (statement_file_path == null) {
                abort(statement.location, clone("Unsupported file path: ").append(statement.file_path))
            }

            let compilation_unit_sources_item = self.compilation_unit.sources.first_item
            while (compilation_unit_sources_item != null) {
                if ((compilation_unit_sources_item.data as Source).file_path.equals(statement_file_path)) {
                    break
                }
                compilation_unit_sources_item = compilation_unit_sources_item.next_item
            }

            if (compilation_unit_sources_item == null) {
                self.parse(statement_file_path, statement.location)
            }
        } else {
            statements.append(statement)
        }
    }
}

define make_relative_path = func (file_path: String, base_file_path: String) -> String {
    if (file_path.starts_with("./")) {
        let relative_path = clone(base_file_path).append(file_path).remove(base_file_path.last_index_of('/') + 1, base_file_path.length + 2)
        return relative_path
    }
    if (file_path.starts_with("../")) {
        let relative_path = clone(base_file_path).append(file_path).remove(base_file_path.last_index_of('/') + 1, base_file_path.length)
        loop {
            let index = relative_path.index_of("/../")
            if (index <= 0) {
                break
            }
            relative_path.remove(relative_path.last_index_of('/', index - 1), index + 3)
        }
        return relative_path
    }
    return file_path
}

\ statement
\   : define
\   | let
\   | if
\   | loop
\   | while
\   | break
\   | return
\   | expression ( "=" expression )?
define parse_statement = func (self: Parser) -> AST_Statement {
    while (self.consume_empty_line()) {
    }

    if (self.matches(optional_space, required_close_brace) || self.matches(required_end_of_file)) {
        return null
    }

    self.consume_space(self.current_alignment * 4)

    if (self.matches(required_define)) {
        return self.parse_define()
    }
    if (self.matches(required_let)) {
        return self.parse_let()
    }
    if (self.matches(required_if)) {
        return self.parse_if()
    }
    if (self.matches(required_return)) {
        let token = self.consume(required_return)
        let value_expression: AST_Expression = null
        if (self.matches_end_of_line() == false) {
            self.consume_space(1 as i64)
            value_expression = self.parse_expression()
        }
        return new AST_Return_Statement(location = token.location, value_expression = value_expression)
    }
    if (self.matches(required_loop)) {
        return self.parse_loop()
    }
    if (self.matches(required_while)) {
        return self.parse_while()
    }
    if (self.matches(required_break)) {
        let token = self.consume(required_break)
        return new AST_Break_Statement(location = token.location)
    }
    if (self.matches(required_include)) {
        return self.parse_include()
    }

    let expression = self.parse_expression()

    if (self.matches(optional_space, optional_comment, required_end_of_line)) {
        return new AST_Expression_Statement(location = expression.location, expression = expression)
    }

    if (self.matches(optional_space, required_equals)) {
        self.consume_space(1 as i64)
        let operator = self.consume(required_equals) as Other_Token
        self.consume_space(1 as i64)
        return new AST_Assignment_Statement(location = expression.location, storage_expression = expression, operator = operator, value_expression = self.parse_expression())
    }

    return null
}

\ include
\   : "include" STRING
define parse_include = func (self: Parser) -> AST_Include_Statement {
    let location = self.consume(required_include).location
    self.consume_space(1 as i64)
    let file_path = (self.consume(required_string_literal) as String_Token).value
    return new AST_Include_Statement(location = location, file_path = file_path)
}

\ define
\   : "define" IDENTIFIER "=" ( struct | function | expression )
define parse_define = func (self: Parser) -> AST_Statement {
    self.consume(required_define)
    self.consume_space(1 as i64)
    let name = self.consume(required_identifier) as Identifier_Token
    self.consume_space(1 as i64)
    self.consume(required_equals)
    self.consume_space(1 as i64)
    if (self.matches(required_unknown, optional_space, required_struct)) {
        self.consume(required_unknown)
        self.consume_space(1 as i64)
        self.consume(required_struct)
        return new AST_Struct_Statement(location = name.location, name = name, base_type = null, members = null, init_arguments = null)
    }
    if (self.matches(required_struct)) {
        return self.parse_struct(name)
    }
    if (self.matches(required_func)) {
        return self.parse_function(name)
    }
    if (self.matches(required_macro)) {
        return self.parse_macro(name)
    }
    let expression = self.parse_expression()
    return new AST_Constant_Statement(location = name.location, name = name, expression = expression)
}

\ struct
\   : "struct" "{" <EOL> ( "extends" IDENTIFIER ( "(" call_arguments ")" )? <EOL> )? ( IDENTIFIER ( ":" type ( "=" expression )? | "=" expression )? <EOL> )* "}"
define parse_struct = func (self: Parser, struct_name: Identifier_Token) -> AST_Struct_Statement {
    let struct_init_arguments = new List()
    self.consume(required_struct)
    self.consume_space(1 as i64)
    self.consume(required_open_brace)
    self.consume_end_of_line()
    self.current_alignment = self.current_alignment + 1
    let base_type: AST_Type = null
    if (self.matches(optional_space, required_extends)) {
        self.consume_space(self.current_alignment * 4)
        self.consume(required_extends)
        self.consume_space(1 as i64)
        base_type = self.parse_type()
        if (self.matches(optional_space, required_open_paren)) {
            self.consume_space(0 as i64)
            self.consume(required_open_paren)
            self.parse_call_arguments(struct_init_arguments)
            self.consume_space(0 as i64)
            self.consume(required_close_paren)
        }
        self.consume_end_of_line()
    }
    let struct_members = new List()
    while (self.matches(optional_space, required_close_brace) == false) {
        if (self.consume_empty_line() == false) {
            self.consume_space(self.current_alignment * 4)
            let struct_member_name = self.consume(required_identifier) as Identifier_Token
            self.consume_space(0 as i64)
            self.consume(required_colon)
            self.consume_space(1 as i64)
            let struct_member_value_type = self.parse_type()
            if (self.matches(optional_space, required_equals)) {
                self.consume_space(1 as i64)
                self.consume(required_equals)
                self.consume_space(1 as i64)
                let value_expression = self.parse_expression()
                struct_init_arguments.append(new AST_Call_Argument(name = struct_member_name, value_expression = value_expression))
            }
            self.consume_end_of_line()
            struct_members.append(new AST_Struct_Member(location = struct_member_name.location, name = struct_member_name, type = struct_member_value_type))
        }
    }
    self.current_alignment = self.current_alignment - 1
    self.consume_space(self.current_alignment * 4)
    self.consume(required_close_brace)
    return new AST_Struct_Statement(location = struct_name.location, name = struct_name, base_type = base_type, members = struct_members, init_arguments = struct_init_arguments)
}

\ function
\   : function_type block?
define parse_function = func (self: Parser, function_name: Identifier_Token) -> AST_Function_Statement {
    let function_is_anonymous = function_name.is(Generated_Identifier_Token)
    let function_type = self.parse_function_type()
    let function_body: AST_Block_Statement
    if (self.matches(optional_space, required_open_brace)) {
        self.consume_space(1 as i64)
        function_body = self.parse_block()
    } else {
        if (function_is_anonymous) {
            abort(function_name.location, "Anonymous function without body")
        }
        function_body = null
    }
    let function_statement = new AST_Function_Statement(location = function_name.location, name = function_name, type = function_type, body = function_body, is_anonymous = function_is_anonymous)
    self.compilation_unit.function_statements.append(function_statement)
    return function_statement
}

\ function_type
\   : "func" parameters "->" type
define parse_function_type = func (self: Parser) -> AST_Function_Type {
    let location = self.consume(required_func).location
    self.consume_space(1 as i64)
    let function_parameters = self.parse_parameters()
    self.consume_space(1 as i64)
    self.consume(required_hyphen, required_greater_than)
    self.consume_space(1 as i64)
    let function_return_type = self.parse_type()
    return new AST_Function_Type(location = location, parameters = function_parameters, return_type = function_return_type)
}

\ parameters
\   : "(" ( parameter ( "," parameter )* )? ")"
define parse_parameters = func (self: Parser) -> List {
    let parameters = new List()
    self.consume(required_open_paren)
    self.consume_space(0 as i64)
    if (self.matches(required_close_paren) == false) {
        parameters.append(self.parse_parameter())
        while (self.matches(optional_space, required_close_paren) == false) {
            self.consume_space(0 as i64)
            self.consume(required_comma)
            self.consume_space(1 as i64)
            parameters.append(self.parse_parameter())
        }
    }
    self.consume(required_close_paren)
    return parameters
}

\ parameter
\   : IDENTIFIER ":" type
define parse_parameter = func (self: Parser) -> AST_Parameter {
    let parameter_name = self.consume(required_identifier) as Identifier_Token
    self.consume_space(0 as i64)
    self.consume(required_colon)
    self.consume_space(1 as i64)
    let parameter_type = self.parse_type()
    return new AST_Parameter(location = parameter_name.location, name = parameter_name, type = parameter_type)
}

\ macro
\   : macro_type block
define parse_macro = func (self: Parser, macro_name: Identifier_Token) -> AST_Macro_Statement {
    let macro_type = self.parse_macro_type()
    self.consume_space(1 as i64)
    let macro_body = self.parse_block()
    let macro_statement = new AST_Macro_Statement(location = macro_name.location, name = macro_name, type = macro_type, body = macro_body)
    \ TODO: self.compilation_unit.macro_statements.append(macro_statement)
    return macro_statement
}

\ macro_type
\   : "macro" parameters
define parse_macro_type = func (self: Parser) -> AST_Macro_Type {
    let location = self.consume(required_macro).location
    self.consume_space(1 as i64)
    let macro_parameters = self.parse_parameters()
    return new AST_Macro_Type(location = location, parameters = macro_parameters)
}

\ block
\   : "{" statements "}"
define parse_block = func (self: Parser) -> AST_Block_Statement {
    let location = self.consume(required_open_brace).location
    self.consume_end_of_line()
    self.current_alignment = self.current_alignment + 1
    let statements = new List()
    self.parse_statements(statements)
    self.current_alignment = self.current_alignment - 1
    self.consume_space(self.current_alignment * 4)
    self.consume(required_close_brace)
    return new AST_Block_Statement(location = location, statements = statements)
}

\ let
\   : "let" IDENTIFIER ( ":" type ( "=" expression )? | "=" expression )
define parse_let = func (self: Parser) -> AST_Variable_Statement {
    let location = self.consume(required_let).location
    self.consume_space(1 as i64)
    let variable_name = self.consume(required_identifier) as Identifier_Token
    let variable_value_type: AST_Type = null
    let variable_value_expression: AST_Expression = null
    let variable_is_global = self.current_alignment == 0 as i64
    let variable_is_external = false
    if (self.matches(optional_space, required_colon)) {
        self.consume_space(0 as i64)
        self.consume(required_colon)
        self.consume_space(1 as i64)
        variable_value_type = self.parse_type()
    }
    if (self.matches(optional_space, required_equals)) {
        self.consume_space(1 as i64)
        self.consume(required_equals)
        self.consume_space(1 as i64)
        if (self.matches(required_external)) {
            self.consume(required_external)
            if (variable_is_global == false) {
                abort(location, "Only global variables can have an external value")
            }
            if (variable_value_type == null) {
                abort(location, "External variables require a type")
            }
            variable_is_external = true
        } else {
            variable_value_expression = self.parse_expression()
        }
    }
    return new AST_Variable_Statement(location = variable_name.location, name = variable_name, type = variable_value_type, value_expression = variable_value_expression, is_external = variable_is_external)
}

\ if
\   : "if" "(" expression ")" block ( "else" ( block | if ) )?
define parse_if = func (self: Parser) -> AST_Statement {
    let location = self.consume(required_if).location
    self.consume_space(1 as i64)
    self.consume(required_open_paren)
    self.consume_space(0 as i64)
    let condition_expression = self.parse_expression()
    self.consume_space(0 as i64)
    self.consume(required_close_paren)
    self.consume_space(1 as i64)
    let true_statement = self.parse_block()
    let false_statement: AST_Statement = null
    if (self.matches(optional_space, required_else)) {
        self.consume_space(1 as i64)
        self.consume(required_else)
        self.consume_space(1 as i64)
        if (self.matches(required_if)) {
            false_statement = self.parse_if()
        } else {
            false_statement = self.parse_block()
        }
    }
    return new AST_If_Statement(location = location, condition_expression = condition_expression, true_statement = true_statement, false_statement = false_statement)
}

\ loop
\   : "loop" block
define parse_loop = func (self: Parser) -> AST_Statement {
    let location = self.consume(required_loop).location
    self.consume_space(1 as i64)
    let loop_block = self.parse_block()
    return new AST_Loop_Statement(location = location, block = loop_block)
}

\ while
\   : "while" "(" expression ")" block
define parse_while = func (self: Parser) -> AST_Statement {
    let location = self.consume(required_while).location
    self.consume_space(1 as i64)
    self.consume(required_open_paren)
    self.consume_space(0 as i64)
    let condition_expression = self.parse_expression()
    self.consume_space(0 as i64)
    self.consume(required_close_paren)
    self.consume_space(1 as i64)
    let loop_block = self.parse_block()
    return new AST_While_Statement(location = location, condition_expression = condition_expression, block = loop_block)
}

\ type
\   : "!"? ( IDENTIFIER | "[" type ( ";" expression )? "]" | function_type | macro_type )
define parse_type = func (self: Parser) -> AST_Type {
    let is_embedded_type = false
    let location: Source_Location = null
    if (self.matches(required_exclamation_mark)) {
        location = self.consume(required_exclamation_mark).location
        self.consume_space(0 as i64)
        is_embedded_type = true
    }
    let type: AST_Type
    if (self.matches(required_open_bracket)) {
        let token = self.consume(required_open_bracket)
        self.consume_space(0 as i64)
        let array_item_type = self.parse_type()
        let array_is_checked = true
        let array_size_expression: AST_Expression = null
        if (self.matches(optional_space, required_column)) {
            self.consume_space(0 as i64)
            self.consume(required_column)
            self.consume_space(1 as i64)
            if (self.matches(required_question_mark)) {
                self.consume(required_question_mark)
                array_is_checked = false
            } else {
                array_size_expression = self.parse_expression()
            }
        }
        self.consume_space(0 as i64)
        self.consume(required_close_bracket)
        type = new AST_Array_Type(location = token.location, item_type = array_item_type, is_checked = array_is_checked, size_expression = array_size_expression)
    } else if (self.matches(required_func)) {
        type = self.parse_function_type()
    } else if (self.matches(required_macro)) {
        type = self.parse_macro_type()
    } else {
        let type_name = self.consume(required_identifier) as Identifier_Token
        type = new AST_Named_Type(location = type_name.location, name = type_name)
    }
    if (is_embedded_type) {
        return new AST_Embedded_Type(location = location, embedded_type = type)
    }
    return type
}

define parse_expression = func (self: Parser) -> AST_Expression {
    return self.parse_logic_or_expression()
}

\ logic_or_expression
\   : logic_and_expression ( "||" logic_and_expression )*
define parse_logic_or_expression = func (self: Parser) -> AST_Expression {
    let expression = self.parse_logic_and_expression()
    while (self.matches(optional_space, required_vertical_bar, required_vertical_bar)) {
        self.consume_space(1 as i64)
        self.consume(required_vertical_bar, required_vertical_bar)
        self.consume_space(1 as i64)
        expression = new AST_Logic_Or_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_logic_and_expression())
    }
    return expression
}

\ logic_and_expression
\   : equality_expression ( "&&" equality_expression )*
define parse_logic_and_expression = func (self: Parser) -> AST_Expression {
    let expression = self.parse_equality_expression()
    while (self.matches(optional_space, required_ampersand, required_ampersand)) {
        self.consume_space(1 as i64)
        self.consume(required_ampersand, required_ampersand)
        self.consume_space(1 as i64)
        expression = new AST_Logic_And_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_equality_expression())
    }
    return expression
}

\ equality_expression
\   : comparison_expression ( ( "==" | "!=" ) comparison_expression )?
define parse_equality_expression = func (self: Parser) -> AST_Expression {
    let expression = self.parse_comparison_expression()
    if (self.matches(optional_space, required_equals, required_equals) || self.matches(optional_space, required_exclamation_mark, required_equals)) {
        self.consume_space(1 as i64)
        if (self.matches(required_equals)) {
            self.consume(required_equals, required_equals)
            self.consume_space(1 as i64)
            expression = new AST_Equals_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_comparison_expression())
        } else {
            self.consume(required_exclamation_mark, required_equals)
            self.consume_space(1 as i64)
            expression = new AST_Not_Equals_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_comparison_expression())
        }
    }
    return expression
}

\ comparison_expression
\   : addition_expression ( ( "<" | "<=" | ">" | ">=" ) addition_expression )?
define parse_comparison_expression = func (self: Parser) -> AST_Expression {
    let expression = self.parse_addition_expression()
    if (self.matches(optional_space, required_less_than) || self.matches(optional_space, required_greater_than)) {
        self.consume_space(1 as i64)
        if (self.matches(required_less_than)) {
            self.consume(required_less_than)
            if (self.matches(required_equals)) {
                self.consume(required_equals)
                self.consume_space(1 as i64)
                expression = new AST_Less_Than_Or_Equals_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_addition_expression())
            } else {
                self.consume_space(1 as i64)
                expression = new AST_Less_Than_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_addition_expression())
            }
        } else {
            self.consume(required_greater_than)
            if (self.matches(required_equals)) {
                self.consume(required_equals)
                self.consume_space(1 as i64)
                expression = new AST_Greater_Than_Or_Equals_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_addition_expression())
            } else {
                self.consume_space(1 as i64)
                expression = new AST_Greater_Than_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_addition_expression())
            }
        }
    }
    return expression
}

\ addition_expression
\   : multiplication_expression ( ( "+" | "-" ) multiplication_expression )*
define parse_addition_expression = func (self: Parser) -> AST_Expression {
    let expression = self.parse_multiplication_expression()
    while (self.matches(optional_space, required_plus) || self.matches(optional_space, required_hyphen)) {
        self.consume_space(1 as i64)
        let binary_expression: AST_Binary_Expression
        if (self.matches(required_plus)) {
            self.consume(required_plus)
            self.consume_space(1 as i64)
            expression = new AST_Add_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_multiplication_expression())
        } else {
            self.consume(required_hyphen)
            self.consume_space(1 as i64)
            expression = new AST_Substract_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_multiplication_expression())
        }
    }
    return expression
}

\ multiplication_expression
\   : unary_expression ( ( "*" | "/" | "//" ) unary_expression )*
define parse_multiplication_expression = func (self: Parser) -> AST_Expression {
    let expression = self.parse_unary_expression()
    while (self.matches(optional_space, required_asterisk) || self.matches(optional_space, required_slash)) {
        self.consume_space(1 as i64)
        if (self.matches(required_slash)) {
            self.consume(required_slash)
            if (self.matches(required_slash)) {
                self.consume(required_slash)
                self.consume_space(1 as i64)
                expression = new AST_Modulo_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_unary_expression())
            } else {
                self.consume_space(1 as i64)
                expression = new AST_Divide_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_unary_expression())
            }
        } else {
            self.consume(required_asterisk)
            self.consume_space(1 as i64)
            expression = new AST_Multiply_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_unary_expression())
        }
    }
    return expression
}

\ unary_expression
\   : "-" unary_expression
\   | cast_expression
define parse_unary_expression = func (self: Parser) -> AST_Expression {
    if (self.matches(required_hyphen)) {
        let location = self.consume(required_hyphen).location
        self.consume_space(0 as i64)
        let expression = self.parse_unary_expression()
        if (expression.is(AST_Literal_Expression) && (expression as AST_Literal_Expression).literal.is(Integer_Token)) {
            let old_literal = (expression as AST_Literal_Expression).literal as Integer_Token
            let new_literal = new Integer_Token(location = location, lexeme = clone("-").append(old_literal.lexeme), value = -old_literal.value, type = old_literal.type)
            return new AST_Wrapped_Expression(
                location = location
                expression = new AST_Literal_Expression(
                    location = location
                    literal = new_literal
                )
            )
        }
        return new AST_Negate_Expression(location = location, expression = expression)
    }
    return self.parse_cast_expression()
}

\ cast_expression
\   : access_expression ( "as" type )?
define parse_cast_expression = func (self: Parser) -> AST_Expression {
    let expression = self.parse_access_expression()
    if (self.matches(optional_space, required_as)) {
        self.consume_space(1 as i64)
        self.consume(required_as)
        self.consume_space(1 as i64)
        let type = self.parse_type()
        return new AST_Cast_Expression(location = expression.location, value_expression = expression, type = type)
    }
    return expression
}

\ access_expression
\   : primary_expression ( "." IDENTIFIER | "(" call_arguments? ")" | "[" expression "]" )*
define parse_access_expression = func (self: Parser) -> AST_Expression {
    let expression = self.parse_primary_expression()
    if (expression != null) {
        loop {
            let old_expression = expression
            if (self.matches(optional_space, required_dot)) {
                self.consume_space(0 as i64)
                self.consume(required_dot)
                self.consume_space(0 as i64)
                expression = new AST_Member_Access_Expression(location = expression.location, object_expression = expression, member_name = self.consume(required_identifier) as Identifier_Token)
            }
            if (self.matches(optional_space, required_open_paren)) {
                self.consume_space(0 as i64)
                self.consume(required_open_paren)
                self.consume_space(0 as i64)
                let call_arguments = new List()
                if (self.matches(optional_space, required_close_paren) == false) {
                    self.parse_call_arguments(call_arguments)
                }
                self.consume_space(0 as i64)
                self.consume(required_close_paren)
                expression = new AST_Call_Expression(location = expression.location, callee_expression = expression, arguments = call_arguments)
            }
            if (self.matches(optional_space, required_open_bracket)) {
                self.consume_space(0 as i64)
                self.consume(required_open_bracket)
                self.consume_space(0 as i64)
                let index_expression = self.parse_expression()
                self.consume_space(0 as i64)
                self.consume(required_close_bracket)
                expression = new AST_Array_Access_Expression(location = expression.location, array_expression = expression, index_expression = index_expression)
            }
            if (expression == old_expression) {
                break
            }
        }
    }
    return expression
}

\ call_arguments
\   : call_argument ( "," call_argument )*
\   | END_OF_LINE call_argument ( END_OF_LINE call_argument )*
define parse_call_arguments = func (self: Parser, call_arguments: List) -> Nothing {
    if (self.matches_end_of_line()) {
        self.consume_end_of_line()
        self.current_alignment = self.current_alignment + 1
        while (self.matches(optional_space, required_close_paren) == false) {
            self.consume_space(self.current_alignment * 4)
            call_arguments.append(self.parse_call_argument())
            self.consume_end_of_line()
        }
        self.current_alignment = self.current_alignment - 1
        self.consume_space(self.current_alignment * 4)
    } else {
        call_arguments.append(self.parse_call_argument())
        while (self.matches(optional_space, required_comma)) {
            self.consume_space(0 as i64)
            self.consume(required_comma)
            self.consume_space(1 as i64)
            call_arguments.append(self.parse_call_argument())
        }
    }
}

\ call_argument
\   : ( IDENTIFIER "=" )? expression
define parse_call_argument = func (self: Parser) -> AST_Call_Argument {
    if (self.matches(required_identifier, optional_space, required_equals)) {
        let name = self.consume(required_identifier) as Identifier_Token
        self.consume_space(1 as i64)
        self.consume(required_equals)
        self.consume_space(1 as i64)
        let value = self.parse_expression()
        return new AST_Call_Argument(name = name, value_expression = value)
    }
    let value = self.parse_expression()
    return new AST_Call_Argument(name = null, value_expression = value)
}

\ primary_expression
\   : IDENTIFIER
\   | INTEGER
\   | STRING
\   | CHARACTER
\   | "null"
\   | "false"
\   | "true"
\   | "undefined"
\   | "(" expression ")"
\   | "new" type ( "(" call_arguments? ")" )?
\   | function
define parse_primary_expression = func (self: Parser) -> AST_Expression {
    if (self.matches(required_new)) {
        let token = self.consume(required_new)
        self.consume_space(1 as i64)
        let type = self.parse_type()
        let call_arguments = new List()
        if (self.matches(optional_space, required_open_paren)) {
            self.consume_space(0 as i64)
            self.consume(required_open_paren)
            if (self.matches(optional_space, required_close_paren) == false) {
                self.parse_call_arguments(call_arguments)
            }
            self.consume_space(0 as i64)
            self.consume(required_close_paren)
        }
        return new AST_New_Expression(location = token.location, type = type, init_arguments = call_arguments)
    }
    if (self.matches(required_literal)) {
        let token = self.consume(required_literal) as Literal_Token
        return new AST_Literal_Expression(location = token.location, literal = token)
    }
    if (self.matches(required_func)) {
        let function_name = clone("anonymous_function_").append(self.anonymous_functions_counter.next())
        let function_statement = self.parse_function(new Generated_Identifier_Token(location = self.scanner.current_token.location, lexeme = function_name))
        return new AST_Function_Expression(location = function_statement.location, function_statement = function_statement)
    }
    if (self.matches(required_identifier)) {
        let token = self.consume(required_identifier) as Identifier_Token
        return new AST_Variable_Expression(location = token.location, name = token)
    }
    if (self.matches(required_open_paren)) {
        let location = self.consume(required_open_paren).location
        self.consume_space(0 as i64)
        let expression = self.parse_expression()
        self.consume_space(0 as i64)
        self.consume(required_close_paren)
        return new AST_Paren_Expression(location = location, expression = expression)
    }
    return null
}

define Generated_Identifier_Token = struct {
    extends Identifier_Token
}

define consume_end_of_line = func (self: Parser) -> Nothing {
    if (self.matches(optional_space, required_comment)) {
        self.consume_space(1 as i64)
        self.consume(required_comment)
    } else {
        self.consume_space(0 as i64)
    }
    if (self.matches(required_end_of_file) == false) {
        self.consume(required_end_of_line)
    }
}

define consume_empty_line = func (self: Parser) -> bool {
    if (self.matches(optional_space, optional_comment, required_end_of_line)) {
        if (self.matches(optional_space, required_comment)) {
            self.consume_space(self.current_alignment * 4)
            self.consume(required_comment)
        } else {
            self.consume_space(0 as i64)
        }
        self.consume(required_end_of_line)
        return true
    }
    return false
}

define consume_space = func (self: Parser, expected_space_count: i64) -> Nothing {
    let space_count: i64
    let token = self.scanner.current_token
    if (token.is(Space_Token)) {
        self.scanner.next_token()
        let space = token as Space_Token
        space_count = space.count
    } else {
        space_count = 0
    }
    if (space_count != expected_space_count) {
        stderr.write(token.location).write(": Consumed ").write(space_count).write(" spaces where ").write(expected_space_count).write(" are expected").end_line()
    }
}

define consume = func (self: Parser, first_matcher: Matcher) -> Token {
    return self.consume(first_matcher, null)
}

define consume = func (self: Parser, first_matcher: Matcher, second_matcher: Matcher) -> Token {
    return self.consume(first_matcher, second_matcher, null)
}

define consume = func (self: Parser, first_matcher: Matcher, second_matcher: Matcher, third_matcher: Matcher) -> Token {
    let token = self.scanner.current_token
    let first_token = token
    if (first_matcher.accepts(token)) {
        token = self.scanner.next_token()
    } else {
        if (first_matcher.is_required) {
            self.abort(token)
        }
    }
    if (second_matcher != null) {
        if (second_matcher.accepts(token)) {
            token = self.scanner.next_token()
        } else {
            if (second_matcher.is_required) {
                self.abort(token)
            }
        }
    }
    if (third_matcher != null) {
        if (third_matcher.accepts(token)) {
            token = self.scanner.next_token()
        } else {
            if (third_matcher.is_required) {
                self.abort(token)
            }
        }
    }
    return first_token
}

define matches_end_of_line = func (self: Parser) -> bool {
    return self.matches(optional_space, optional_comment, required_end_of_line)
}

define matches = func (self: Parser, first_matcher: Matcher) -> bool {
    return self.matches(first_matcher, null)
}

define matches = func (self: Parser, first_matcher: Matcher, second_matcher: Matcher) -> bool {
    return self.matches(first_matcher, second_matcher, null)
}

define matches = func (self: Parser, first_matcher: Matcher, second_matcher: Matcher, third_matcher: Matcher) -> bool {
    let token = self.scanner.current_token
    let peek_offset = 0 as i64
    if (first_matcher.accepts(token)) {
        token = self.scanner.peek_token(peek_offset)
        peek_offset = peek_offset + 1
    } else if (first_matcher.is_required) {
        return false
    }
    if (second_matcher != null) {
        if (second_matcher.accepts(token)) {
            token = self.scanner.peek_token(peek_offset)
            peek_offset = peek_offset + 1
        } else if (second_matcher.is_required) {
            return false
        }
    }
    if (third_matcher != null) {
        if (third_matcher.accepts(token)) {
            token = self.scanner.peek_token(peek_offset)
            peek_offset = peek_offset + 1
        } else if (third_matcher.is_required) {
            return false
        }
    }
    return true
}

define Matcher = struct {
    extends Object
    is_required: bool
    accepts: func (self: Matcher, token: Token) -> bool = func (self: Matcher, token: Token) -> bool {
        abort(token.location, "Invalid state")
    }
}

define Comment_Matcher = struct {
    extends Matcher(
        accepts = func (self: Matcher, token: Token) -> bool {
            return token.is(Comment_Token)
        }
    )
}

define End_Of_File_Matcher = struct {
    extends Matcher(
        accepts = func (self: Matcher, token: Token) -> bool {
            return token.is(End_Of_File_Token)
        }
    )
}

define End_Of_Line_Matcher = struct {
    extends Matcher(
        accepts = func (self: Matcher, token: Token) -> bool {
            return token.is(End_Of_Line_Token)
        }
    )
}

define Identifier_Matcher = struct {
    extends Matcher(
        accepts = func (self: Matcher, token: Token) -> bool {
            return token.is(Identifier_Token)
        }
    )
}

define Keyword_Matcher = struct {
    extends Matcher(
        accepts = func (self: Matcher, token: Token) -> bool {
            if (token.is(Identifier_Token)) {
                return token.lexeme.equals((self as Keyword_Matcher).lexeme)
            }
            return false
        }
    )
    lexeme: String
}

define Literal_Matcher = struct {
    extends Matcher(
        accepts = func (self: Matcher, token: Token) -> bool {
            return token.is(Integer_Token) || token.is(String_Token) || token.is(Character_Token) || token.is(Boolean_Token) || token.is(Null_Token) || token.is(Undefined_Token)
        }
    )
}

define Other_Matcher = struct {
    extends Matcher(
        accepts = func (self: Matcher, token: Token) -> bool {
            if (token.is(Other_Token)) {
                return token.lexeme.equals((self as Other_Matcher).lexeme)
            }
            return false
        }
    )
    lexeme: String
}

define Space_Matcher = struct {
    extends Matcher(
        accepts = func (self: Matcher, token: Token) -> bool {
            return token.is(Space_Token)
        }
    )
}

define String_Literal_Matcher = struct {
    extends Matcher(
        accepts = func (self: Matcher, token: Token) -> bool {
            return token.is(String_Token)
        }
    )
}

let optional_comment: Matcher = undefined
let optional_space: Matcher = undefined
let required_ampersand: Matcher = undefined
let required_as: Matcher = undefined
let required_asterisk: Matcher = undefined
let required_at: Matcher = undefined
let required_break: Matcher = undefined
let required_close_brace: Matcher = undefined
let required_close_bracket: Matcher = undefined
let required_close_paren: Matcher = undefined
let required_colon: Matcher = undefined
let required_column: Matcher = undefined
let required_comma: Matcher = undefined
let required_comment: Matcher = undefined
let required_define: Matcher = undefined
let required_dot: Matcher = undefined
let required_else: Matcher = undefined
let required_end_of_file: Matcher = undefined
let required_end_of_line: Matcher = undefined
let required_equals: Matcher = undefined
let required_exclamation_mark: Matcher = undefined
let required_extends: Matcher = undefined
let required_external: Matcher = undefined
let required_func: Matcher = undefined
let required_greater_than: Matcher = undefined
let required_hyphen: Matcher = undefined
let required_identifier: Matcher = undefined
let required_if: Matcher = undefined
let required_include: Matcher = undefined
let required_less_than: Matcher = undefined
let required_let: Matcher = undefined
let required_literal: Matcher = undefined
let required_loop: Matcher = undefined
let required_macro: Matcher = undefined
let required_new: Matcher = undefined
let required_open_brace: Matcher = undefined
let required_open_bracket: Matcher = undefined
let required_open_paren: Matcher = undefined
let required_plus: Matcher = undefined
let required_question_mark: Matcher = undefined
let required_return: Matcher = undefined
let required_slash: Matcher = undefined
let required_string_literal: Matcher = undefined
let required_struct: Matcher = undefined
let required_unknown: Matcher = undefined
let required_vertical_bar: Matcher = undefined
let required_while: Matcher = undefined

define init_matchers = func () -> Nothing {
    optional_comment = new Comment_Matcher(is_required = false)
    optional_space = new Space_Matcher(is_required = false)
    required_ampersand = new Other_Matcher(is_required = true, lexeme = "&")
    required_as = new Keyword_Matcher(is_required = true, lexeme = "as")
    required_asterisk = new Other_Matcher(is_required = true, lexeme = "*")
    required_at = new Other_Matcher(is_required = true, lexeme = "@")
    required_break = new Keyword_Matcher(is_required = true, lexeme = "break")
    required_close_brace = new Other_Matcher(is_required = true, lexeme = "}")
    required_close_bracket = new Other_Matcher(is_required = true, lexeme = "]")
    required_close_paren = new Other_Matcher(is_required = true, lexeme = ")")
    required_colon = new Other_Matcher(is_required = true, lexeme = ":")
    required_column = new Other_Matcher(is_required = true, lexeme = ";")
    required_comma = new Other_Matcher(is_required = true, lexeme = ",")
    required_comment = new Comment_Matcher(is_required = true)
    required_define = new Keyword_Matcher(is_required = true, lexeme = "define")
    required_dot = new Other_Matcher(is_required = true, lexeme = ".")
    required_else = new Keyword_Matcher(is_required = true, lexeme = "else")
    required_end_of_file = new End_Of_File_Matcher(is_required = true)
    required_end_of_line = new End_Of_Line_Matcher(is_required = true)
    required_equals = new Other_Matcher(is_required = true, lexeme = "=")
    required_exclamation_mark = new Other_Matcher(is_required = true, lexeme = "!")
    required_extends = new Keyword_Matcher(is_required = true, lexeme = "extends")
    required_external = new Keyword_Matcher(is_required = true, lexeme = "external")
    required_func = new Keyword_Matcher(is_required = true, lexeme = "func")
    required_greater_than = new Other_Matcher(is_required = true, lexeme = ">")
    required_hyphen = new Other_Matcher(is_required = true, lexeme = "-")
    required_identifier = new Identifier_Matcher(is_required = true)
    required_if = new Keyword_Matcher(is_required = true, lexeme = "if")
    required_include = new Keyword_Matcher(is_required = true, lexeme = "include")
    required_less_than = new Other_Matcher(is_required = true, lexeme = "<")
    required_let = new Keyword_Matcher(is_required = true, lexeme = "let")
    required_literal = new Literal_Matcher(is_required = true)
    required_loop = new Keyword_Matcher(is_required = true, lexeme = "loop")
    required_new = new Keyword_Matcher(is_required = true, lexeme = "new")
    required_macro = new Keyword_Matcher(is_required = true, lexeme = "macro")
    required_open_brace = new Other_Matcher(is_required = true, lexeme = "{")
    required_open_bracket = new Other_Matcher(is_required = true, lexeme = "[")
    required_open_paren = new Other_Matcher(is_required = true, lexeme = "(")
    required_plus = new Other_Matcher(is_required = true, lexeme = "+")
    required_question_mark = new Other_Matcher(is_required = true, lexeme = "?")
    required_return = new Keyword_Matcher(is_required = true, lexeme = "return")
    required_slash = new Other_Matcher(is_required = true, lexeme = "/")
    required_string_literal = new String_Literal_Matcher(is_required = true)
    required_struct = new Keyword_Matcher(is_required = true, lexeme = "struct")
    required_unknown = new Keyword_Matcher(is_required = true, lexeme = "unknown")
    required_vertical_bar = new Other_Matcher(is_required = true, lexeme = "|")
    required_while = new Keyword_Matcher(is_required = true, lexeme = "while")
}
