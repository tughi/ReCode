\ Copyright (c) 2020, Stefan Selariu

define Parser = struct {
    scanner: @Scanner = null
    compilation_unit: @Compilation_Unit = new Compilation_Unit()
    current_alignment: Int = 0
    optional_comment: @Matcher = new Comment_Matcher(is_required = false)
    optional_space: @Matcher = new Space_Matcher(is_required = false)
    required_ampersand: @Matcher = new Other_Matcher(is_required = true, lexeme = "&")
    required_as: @Matcher = new Keyword_Matcher(is_required = true, lexeme = "as")
    required_asterisk: @Matcher = new Other_Matcher(is_required = true, lexeme = "*")
    required_at: @Matcher = new Other_Matcher(is_required = true, lexeme = "@")
    required_break: @Matcher = new Keyword_Matcher(is_required = true, lexeme = "break")
    required_close_brace: @Matcher = new Other_Matcher(is_required = true, lexeme = "}")
    required_close_bracket: @Matcher = new Other_Matcher(is_required = true, lexeme = "]")
    required_close_paren: @Matcher = new Other_Matcher(is_required = true, lexeme = ")")
    required_colon: @Matcher = new Other_Matcher(is_required = true, lexeme = ":")
    required_column: @Matcher = new Other_Matcher(is_required = true, lexeme = ";")
    required_comma: @Matcher = new Other_Matcher(is_required = true, lexeme = ",")
    required_comment: @Matcher = new Comment_Matcher(is_required = true)
    required_define: @Matcher = new Keyword_Matcher(is_required = true, lexeme = "define")
    required_dot: @Matcher = new Other_Matcher(is_required = true, lexeme = ".")
    required_else: @Matcher = new Keyword_Matcher(is_required = true, lexeme = "else")
    required_end_of_file: @Matcher = new End_Of_File_Matcher(is_required = true)
    required_end_of_line: @Matcher = new End_Of_Line_Matcher(is_required = true)
    required_equals: @Matcher = new Other_Matcher(is_required = true, lexeme = "=")
    required_exclamation_mark: @Matcher = new Other_Matcher(is_required = true, lexeme = "!")
    required_extends: @Matcher = new Keyword_Matcher(is_required = true, lexeme = "extends")
    required_external: @Matcher = new Keyword_Matcher(is_required = true, lexeme = "external")
    required_func: @Matcher = new Keyword_Matcher(is_required = true, lexeme = "func")
    required_greater_than: @Matcher = new Other_Matcher(is_required = true, lexeme = ">")
    required_hyphen: @Matcher = new Other_Matcher(is_required = true, lexeme = "-")
    required_identifier: @Matcher = new Identifier_Matcher(is_required = true)
    required_if: @Matcher = new Keyword_Matcher(is_required = true, lexeme = "if")
    required_include: @Matcher = new Keyword_Matcher(is_required = true, lexeme = "include")
    required_less_than: @Matcher = new Other_Matcher(is_required = true, lexeme = "<")
    required_literal: @Matcher = new Literal_Matcher(is_required = true)
    required_loop: @Matcher = new Keyword_Matcher(is_required = true, lexeme = "loop")
    required_new: @Matcher = new Keyword_Matcher(is_required = true, lexeme = "new")
    required_open_brace: @Matcher = new Other_Matcher(is_required = true, lexeme = "{")
    required_open_bracket: @Matcher = new Other_Matcher(is_required = true, lexeme = "[")
    required_open_paren: @Matcher = new Other_Matcher(is_required = true, lexeme = "(")
    required_plus: @Matcher = new Other_Matcher(is_required = true, lexeme = "+")
    required_return: @Matcher = new Keyword_Matcher(is_required = true, lexeme = "return")
    required_slash: @Matcher = new Other_Matcher(is_required = true, lexeme = "/")
    required_string_literal: @Matcher = new String_Literal_Matcher(is_required = true)
    required_struct: @Matcher = new Keyword_Matcher(is_required = true, lexeme = "struct")
    required_unknown: @Matcher = new Keyword_Matcher(is_required = true, lexeme = "unknown")
    required_vertical_bar: @Matcher = new Other_Matcher(is_required = true, lexeme = "|")
    required_while: @Matcher = new Keyword_Matcher(is_required = true, lexeme = "while")
}

define parse = func (file_path: @String) -> @Compilation_Unit {
    parser := new Parser()
    parser.parse(file_path, null)
    return parser.compilation_unit
}

define parse = func (self: @Parser, file_path: @String, location: @Source_Location) -> Nothing {
    source := create_source(file_path)
    if (source == null) {
        message := clone("Failed to open file: ").append(file_path)
        if (location != null) {
            abort(location, message)
        }
        abort(message)
    }

    self.compilation_unit.sources.append(source)
    source.id = self.compilation_unit.sources.size

    other_scanner := self.scanner
    self.scanner = create_scanner(source)
    self.parse_statements(self.compilation_unit.statements)

    token := self.scanner.current_token
    if (token.is(End_Of_File_Token) == false) {
        abort(self, self.scanner.current_token)
    }
    token := token as @End_Of_File_Token
    if (token.location.column != 1) {
        stderr.write(token.location).write(": File doesn't end with a new line").end_line()
    }

    self.scanner = other_scanner
}

\ statements
\   : ( statement <EOL> )*
define parse_statements = func (self: @Parser, statements: @List) -> Nothing {
    loop {
        statement := self.parse_statement()
        if (statement == null) {
            break
        }
        self.consume_end_of_line()
        if (statement.is(AST_Include_Statement)) {
            statement := statement as @AST_Include_Statement

            statement_file_path := statement.file_path.make_relative_path(statement.location.source.file_path)
            if (statement_file_path == null) {
                abort(statement.location, clone("Unsupported file path: ").append(statement.file_path))
            }

            compilation_unit_sources_item := self.compilation_unit.sources.first_item
            while (compilation_unit_sources_item != null) {
                if ((compilation_unit_sources_item.data as @Source).file_path.equals(statement_file_path)) {
                    break
                }
                compilation_unit_sources_item = compilation_unit_sources_item.next_item
            }

            if (compilation_unit_sources_item == null) {
                self.parse(statement_file_path, statement.location)
            }
        } else {
            statements.append(statement)
        }
    }
}

define make_relative_path = func (file_path: @String, base_file_path: @String) -> @String {
    if (file_path.starts_with("./")) {
        relative_path := clone(base_file_path).append(file_path).remove(base_file_path.last_index_of('/') + 1, base_file_path.length + 2)
        return relative_path
    }
    if (file_path.starts_with("../")) {
        relative_path := clone(base_file_path).append(file_path).remove(base_file_path.last_index_of('/') + 1, base_file_path.length)
        loop {
            index := relative_path.index_of("/../")
            if (index <= 0) {
                break
            }
            relative_path.remove(relative_path.last_index_of('/', index - 1), index + 3)
        }
        return relative_path
    }
    return file_path
}

\ statement
\   : define
\   | if
\   | "return" expression?
\   | loop
\   | while
\   | "break"
\   | expression ( "=" expression )?
define parse_statement = func (self: @Parser) -> @AST_Statement {
    while (self.consume_empty_line()) {
    }

    if (self.matches(self.optional_space, self.required_close_brace) || self.matches(self.required_end_of_file)) {
        return null
    }

    self.consume_space(self.current_alignment * 4)

    if (self.matches(self.required_define)) {
        return self.parse_define()
    }
    if (self.matches(self.required_if)) {
        return self.parse_if()
    }
    if (self.matches(self.required_return)) {
        token := self.consume(self.required_return)
        value_expression: @AST_Expression = null
        if (self.matches_end_of_line() == false) {
            self.consume_space(1)
            value_expression = self.parse_expression()
        }
        return new AST_Return_Statement(location = token.location, value_expression = value_expression)
    }
    if (self.matches(self.required_loop)) {
        return self.parse_loop()
    }
    if (self.matches(self.required_while)) {
        return self.parse_while()
    }
    if (self.matches(self.required_break)) {
        token := self.consume(self.required_break)
        return new AST_Break_Statement(location = token.location)
    }
    if (self.matches(self.required_include)) {
        return self.parse_include()
    }

    expression := self.parse_expression()

    if (self.matches(self.optional_space, self.optional_comment, self.required_end_of_line)) {
        return new AST_Expression_Statement(location = expression.location, expression = expression)
    }

    if (self.matches(self.optional_space, self.required_colon)) {
        if (expression.is(AST_Variable_Expression)) {
            expression := expression as @AST_Variable_Expression
            variable_name := expression.name
            variable_value_type: @AST_Type = null
            variable_value_expression: @AST_Expression = null
            variable_is_external := false
            if (self.matches(self.optional_space, self.required_colon, self.required_equals)) {
                self.consume_space(1)
                self.consume(self.required_colon, self.required_equals)
                self.consume_space(1)
                variable_value_expression = self.parse_expression()
            } else {
                self.consume_space(0)
                self.consume(self.required_colon)
                self.consume_space(1)
                variable_value_type = self.parse_type()
                if (self.matches(self.optional_space, self.required_equals)) {
                    self.consume_space(1)
                    self.consume(self.required_equals)
                    self.consume_space(1)
                    if (self.matches(self.required_external)) {
                        self.consume(self.required_external)
                        variable_is_external = true
                    } else {
                        variable_value_expression = self.parse_expression()
                    }
                }
            }
            variable_statement := new AST_Variable_Statement(location = variable_name.location, name = variable_name, type = variable_value_type, value_expression = variable_value_expression, is_external = variable_is_external)
            if (self.current_alignment == 0) {
                self.compilation_unit.global_variables.append(variable_statement)
            }
            return variable_statement
        }
        abort(expression.location, "Cannot use expression as variable name")
    }

    if (self.matches(self.optional_space, self.required_equals)) {
        self.consume_space(1)
        operator := self.consume(self.required_equals) as @Other_Token
        self.consume_space(1)
        return new AST_Assignment_Statement(location = expression.location, storage_expression = expression, operator = operator, value_expression = self.parse_expression())
    }

    return null
}

\ include
\   : "include" STRING
define parse_include = func (self: @Parser) -> @AST_Include_Statement {
    location := self.consume(self.required_include).location
    self.consume_space(1)
    file_path := (self.consume(self.required_string_literal) as @String_Token).value
    return new AST_Include_Statement(location = location, file_path = file_path)
}

\ define
\   : "define" IDENTIFIER "=" ( struct )
define parse_define = func (self: @Parser) -> @AST_Statement {
    self.consume(self.required_define)
    self.consume_space(1)
    name := self.consume(self.required_identifier) as @Identifier_Token
    self.consume_space(1)
    self.consume(self.required_equals)
    self.consume_space(1)
    if (self.matches(self.required_unknown, self.optional_space, self.required_struct)) {
        self.consume(self.required_unknown)
        self.consume_space(1)
        self.consume(self.required_struct)
        type_statement := new AST_Struct_Statement(location = name.location, name = name, base_type = null, members = null, init_arguments = null)
        self.compilation_unit.types.append(type_statement)
        return type_statement
    }
    if (self.matches(self.required_struct)) {
        return self.parse_struct(name)
    }
    return self.parse_function(name)
}

\ struct
\   : "struct" "{" <EOL> ( "extends" IDENTIFIER ( "(" call_arguments ")" )? <EOL> )? ( IDENTIFIER ( ":" type ( "=" expression )? | "=" expression )? <EOL> )* "}"
define parse_struct = func (self: @Parser, struct_name: @Identifier_Token) -> @AST_Statement {
    struct_init_arguments := new List()
    self.consume(self.required_struct)
    self.consume_space(1)
    self.consume(self.required_open_brace)
    self.consume_end_of_line()
    self.current_alignment = self.current_alignment + 1
    base_type: @AST_Type = null
    if (self.matches(self.optional_space, self.required_extends)) {
        self.consume_space(self.current_alignment * 4)
        self.consume(self.required_extends)
        self.consume_space(1)
        base_type = self.parse_type()
        if (self.matches(self.optional_space, self.required_open_paren)) {
            self.consume_space(0)
            self.consume(self.required_open_paren)
            self.parse_call_arguments(struct_init_arguments)
            self.consume_space(0)
            self.consume(self.required_close_paren)
        }
        self.consume_end_of_line()
    }
    struct_members: @List = new List()
    while (self.matches(self.optional_space, self.required_close_brace) == false) {
        self.consume_space(self.current_alignment * 4)
        struct_member_name := self.consume(self.required_identifier) as @Identifier_Token
        self.consume_space(0)
        self.consume(self.required_colon)
        self.consume_space(1)
        struct_member_value_type := self.parse_type()
        if (self.matches(self.optional_space, self.required_equals)) {
            self.consume_space(1)
            self.consume(self.required_equals)
            self.consume_space(1)
            value_expression := self.parse_expression()
            struct_init_arguments.append(new AST_Call_Argument(name = struct_member_name, value_expression = value_expression))
        }
        self.consume_end_of_line()
        struct_members.append(new AST_Struct_Member(location = struct_member_name.location, name = struct_member_name, type = struct_member_value_type))
    }
    self.current_alignment = self.current_alignment - 1
    self.consume_space(self.current_alignment * 4)
    self.consume(self.required_close_brace)
    struct_statement := new AST_Struct_Statement(location = struct_name.location, name = struct_name, base_type = base_type, members = struct_members, init_arguments = struct_init_arguments)
    self.compilation_unit.types.append(struct_statement)
    return struct_statement
}

\ function
\   : function_type block?
define parse_function = func (self: @Parser, function_name: @Identifier_Token) -> @AST_Statement {
    function_type := self.parse_function_type()
    function_body: @AST_Block_Statement
    if (self.matches(self.optional_space, self.required_open_brace)) {
        self.consume_space(1)
        function_body = self.parse_block()
    } else {
        function_body = null
    }
    function_statement := new AST_Function_Statement(location = function_name.location, name = function_name, type = function_type, body = function_body)
    self.compilation_unit.functions.append(function_statement)
    return function_statement
}

\ function_type
\   : "func" "(" ( function_parameter ( "," function_parameter )* )? ")" "->" type
define parse_function_type = func (self: @Parser) -> @AST_Function_Type {
    location := self.consume(self.required_func).location
    self.consume_space(1)
    self.consume(self.required_open_paren)
    self.consume_space(0)
    function_parameters := new List()
    if (self.matches(self.required_close_paren) == false) {
        function_parameters.append(self.parse_function_parameter())
        while (self.matches(self.optional_space, self.required_close_paren) == false) {
            self.consume_space(0)
            self.consume(self.required_comma)
            self.consume_space(1)
            function_parameters.append(self.parse_function_parameter())
        }
    }
    self.consume(self.required_close_paren)
    self.consume_space(1)
    self.consume(self.required_hyphen, self.required_greater_than)
    self.consume_space(1)
    function_return_type := self.parse_type()
    return new AST_Function_Type(location = location, parameters = function_parameters, return_type = function_return_type)
}

\ function_parameter
\   : IDENTIFIER ":" type
define parse_function_parameter = func (self: @Parser) -> @AST_Function_Parameter {
    parameter_name := self.consume(self.required_identifier) as @Identifier_Token
    self.consume_space(0)
    self.consume(self.required_colon)
    self.consume_space(1)
    parameter_type := self.parse_type()
    return new AST_Function_Parameter(location = parameter_name.location, name = parameter_name, type = parameter_type)
}

\ block
\   : "{" statements "}"
define parse_block = func (self: @Parser) -> @AST_Block_Statement {
    location := self.consume(self.required_open_brace).location
    self.consume_end_of_line()
    self.current_alignment = self.current_alignment + 1
    statements := new List()
    self.parse_statements(statements)
    self.current_alignment = self.current_alignment - 1
    self.consume_space(self.current_alignment * 4)
    self.consume(self.required_close_brace)
    return new AST_Block_Statement(location = location, statements = statements)
}

\ if
\   : "if" "(" expression ")" block ( "else" ( block | if ) )?
define parse_if = func (self: @Parser) -> @AST_Statement {
    location := self.consume(self.required_if).location
    self.consume_space(1)
    self.consume(self.required_open_paren)
    self.consume_space(0)
    condition_expression := self.parse_expression()
    self.consume_space(0)
    self.consume(self.required_close_paren)
    self.consume_space(1)
    true_statement := self.parse_block()
    false_statement: @AST_Statement = null
    if (self.matches(self.optional_space, self.required_else)) {
        self.consume_space(1)
        self.consume(self.required_else)
        self.consume_space(1)
        if (self.matches(self.required_if)) {
            false_statement = self.parse_if()
        } else {
            false_statement = self.parse_block()
        }
    }
    return new AST_If_Statement(location = location, condition_expression = condition_expression, true_statement = true_statement, false_statement = false_statement)
}

\ loop
\   : "loop" block
define parse_loop = func (self: @Parser) -> @AST_Statement {
    location := self.consume(self.required_loop).location
    self.consume_space(1)
    loop_block := self.parse_block()
    return new AST_Loop_Statement(location = location, block = loop_block)
}

\ while
\   : "while" "(" expression ")" block
define parse_while = func (self: @Parser) -> @AST_Statement {
    location := self.consume(self.required_while).location
    self.consume_space(1)
    self.consume(self.required_open_paren)
    self.consume_space(0)
    condition_expression := self.parse_expression()
    self.consume_space(0)
    self.consume(self.required_close_paren)
    self.consume_space(1)
    loop_block := self.parse_block()
    return new AST_While_Statement(location = location, condition_expression = condition_expression, block = loop_block)
}

\ type
\   : "@" type
\   | IDENTIFIER
\   | "[" type ( ";" expression )? "]"
\   | function_type
define parse_type = func (self: @Parser) -> @AST_Type {
    if (self.matches(self.required_at)) {
        token := self.consume(self.required_at)
        self.consume_space(0)
        type := self.parse_type()
        return new AST_Pointer_Type(location = token.location, pointed_type = type)
    }
    if (self.matches(self.required_open_bracket)) {
        token := self.consume(self.required_open_bracket)
        array_item_type := self.parse_type()
        if (self.matches(self.optional_space, self.required_column)) {
            self.consume_space(0)
            self.consume(self.required_column)
            self.consume_space(1)
            array_size_expression := self.parse_expression()
            self.consume_space(0)
            self.consume(self.required_close_bracket)
            return new AST_Array_Type(location = token.location, item_type = array_item_type, size_expression = array_size_expression)
        }
        return new AST_Array_Type(location = token.location, item_type = array_item_type, size_expression = null)
    }
    if (self.matches(self.required_func)) {
        return self.parse_function_type()
    }
    token := self.consume(self.required_identifier) as @Identifier_Token
    return new AST_Named_Type(location = token.location, name = token)
}

define parse_expression = func (self: @Parser) -> @AST_Expression {
    return self.parse_logic_or_expression()
}

\ logic_or_expression
\   : logic_and_expression ( "||" logic_and_expression )*
define parse_logic_or_expression = func (self: @Parser) -> @AST_Expression {
    expression := self.parse_logic_and_expression()
    while (self.matches(self.optional_space, self.required_vertical_bar, self.required_vertical_bar)) {
        self.consume_space(1)
        self.consume(self.required_vertical_bar, self.required_vertical_bar)
        self.consume_space(1)
        expression = new AST_Logic_Or_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_logic_and_expression())
    }
    return expression
}

\ logic_and_expression
\   : equality_expression ( "&&" equality_expression )*
define parse_logic_and_expression = func (self: @Parser) -> @AST_Expression {
    expression := self.parse_equality_expression()
    while (self.matches(self.optional_space, self.required_ampersand, self.required_ampersand)) {
        self.consume_space(1)
        self.consume(self.required_ampersand, self.required_ampersand)
        self.consume_space(1)
        expression = new AST_Logic_And_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_equality_expression())
    }
    return expression
}

\ equality_expression
\   : comparison_expression ( ( "==" | "!=" ) comparison_expression )?
define parse_equality_expression = func (self: @Parser) -> @AST_Expression {
    expression := self.parse_comparison_expression()
    if (self.matches(self.optional_space, self.required_equals, self.required_equals) || self.matches(self.optional_space, self.required_exclamation_mark, self.required_equals)) {
        self.consume_space(1)
        if (self.matches(self.required_equals)) {
            self.consume(self.required_equals, self.required_equals)
            self.consume_space(1)
            expression = new AST_Equals_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_comparison_expression())
        } else {
            self.consume(self.required_exclamation_mark, self.required_equals)
            self.consume_space(1)
            expression = new AST_Not_Equals_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_comparison_expression())
        }
    }
    return expression
}

\ comparison_expression
\   : addition_expression ( ( "<" | "<=" | ">" | ">=" ) addition_expression )?
define parse_comparison_expression = func (self: @Parser) -> @AST_Expression {
    expression := self.parse_addition_expression()
    if (self.matches(self.optional_space, self.required_less_than) || self.matches(self.optional_space, self.required_greater_than)) {
        self.consume_space(1)
        if (self.matches(self.required_less_than)) {
            self.consume(self.required_less_than)
            if (self.matches(self.required_equals)) {
                self.consume(self.required_equals)
                self.consume_space(1)
                expression = new AST_Less_Than_Or_Equals_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_addition_expression())
            } else {
                self.consume_space(1)
                expression = new AST_Less_Than_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_addition_expression())
            }
        } else {
            self.consume(self.required_greater_than)
            if (self.matches(self.required_equals)) {
                self.consume(self.required_equals)
                self.consume_space(1)
                expression = new AST_Greater_Than_Or_Equals_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_addition_expression())
            } else {
                self.consume_space(1)
                expression = new AST_Greater_Than_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_addition_expression())
            }
        }
    }
    return expression
}

\ addition_expression
\   : multiplication_expression ( ( "+" | "-" ) multiplication_expression )*
define parse_addition_expression = func (self: @Parser) -> @AST_Expression {
    expression := self.parse_multiplication_expression()
    while (self.matches(self.optional_space, self.required_plus) || self.matches(self.optional_space, self.required_hyphen)) {
        self.consume_space(1)
        binary_expression: @AST_Binary_Expression
        if (self.matches(self.required_plus)) {
            self.consume(self.required_plus)
            self.consume_space(1)
            expression = new AST_Add_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_multiplication_expression())
        } else {
            self.consume(self.required_hyphen)
            self.consume_space(1)
            expression = new AST_Substract_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_multiplication_expression())
        }
    }
    return expression
}

\ multiplication_expression
\   : unary_expression ( ( "*" | "/" | "//" ) unary_expression )*
define parse_multiplication_expression = func (self: @Parser) -> @AST_Expression {
    expression := self.parse_unary_expression()
    while (self.matches(self.optional_space, self.required_asterisk) || self.matches(self.optional_space, self.required_slash)) {
        self.consume_space(1)
        if (self.matches(self.required_slash)) {
            self.consume(self.required_slash)
            if (self.matches(self.required_slash)) {
                self.consume(self.required_slash)
                self.consume_space(1)
                expression = new AST_Modulo_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_unary_expression())
            } else {
                self.consume_space(1)
                expression = new AST_Divide_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_unary_expression())
            }
        } else {
            self.consume(self.required_asterisk)
            self.consume_space(1)
            expression = new AST_Multiply_Expression(location = expression.location, left_expression = expression, right_expression = self.parse_unary_expression())
        }
    }
    return expression
}

\ unary_expression
\   : "-"? cast_expression
define parse_unary_expression = func (self: @Parser) -> @AST_Expression {
    if (self.matches(self.required_hyphen)) {
        location := self.consume(self.required_hyphen).location
        self.consume_space(0)
        return new AST_Negate_Expression(location = location, expression = self.parse_cast_expression())
    }
    return self.parse_cast_expression()
}

\ cast_expression
\   : access_expression ( "as" type )?
define parse_cast_expression = func (self: @Parser) -> @AST_Expression {
    expression := self.parse_access_expression()
    if (self.matches(self.optional_space, self.required_as)) {
        self.consume_space(1)
        self.consume(self.required_as)
        self.consume_space(1)
        type := self.parse_type()
        return new AST_Cast_Expression(location = expression.location, value_expression = expression, type = type)
    }
    return expression
}

\ access_expression
\   : primary_expression ( "." IDENTIFIER | "(" call_arguments? ")" | "[" expression "]" )*
define parse_access_expression = func (self: @Parser) -> @AST_Expression {
    expression := self.parse_primary_expression()
    if (expression != null) {
        loop {
            old_expression := expression
            if (self.matches(self.optional_space, self.required_dot)) {
                self.consume_space(0)
                self.consume(self.required_dot)
                self.consume_space(0)
                expression = new AST_Member_Access_Expression(location = expression.location, object_expression = expression, member_name = self.consume(self.required_identifier) as @Identifier_Token)
            }
            if (self.matches(self.optional_space, self.required_open_paren)) {
                self.consume_space(0)
                self.consume(self.required_open_paren)
                self.consume_space(0)
                call_arguments := new List()
                if (self.matches(self.optional_space, self.required_close_paren) == false) {
                    self.parse_call_arguments(call_arguments)
                }
                self.consume_space(0)
                self.consume(self.required_close_paren)
                expression = new AST_Call_Expression(location = expression.location, callee_expression = expression, arguments = call_arguments)
            }
            if (self.matches(self.optional_space, self.required_open_bracket)) {
                self.consume_space(0)
                self.consume(self.required_open_bracket)
                self.consume_space(0)
                index_expression := self.parse_expression()
                self.consume_space(0)
                self.consume(self.required_close_bracket)
                expression = new AST_Array_Access_Expression(location = expression.location, array_expression = expression, index_expression = index_expression)
            }
            if (expression == old_expression) {
                break
            }
        }
    }
    return expression
}

\ call_arguments
\   : call_argument ( "," call_argument )*
\   | END_OF_LINE call_argument ( END_OF_LINE call_argument )*
define parse_call_arguments = func (self: @Parser, call_arguments: @List) -> Nothing {
    if (self.matches_end_of_line()) {
        self.consume_end_of_line()
        self.current_alignment = self.current_alignment + 1
        while (self.matches(self.optional_space, self.required_close_paren) == false) {
            self.consume_space(self.current_alignment * 4)
            call_arguments.append(self.parse_call_argument())
            self.consume_end_of_line()
        }
        self.current_alignment = self.current_alignment - 1
        self.consume_space(self.current_alignment * 4)
    } else {
        call_arguments.append(self.parse_call_argument())
        while (self.matches(self.optional_space, self.required_comma)) {
            self.consume_space(0)
            self.consume(self.required_comma)
            self.consume_space(1)
            call_arguments.append(self.parse_call_argument())
        }
    }
}

\ call_argument
\   : ( IDENTIFIER "=" )? expression
define parse_call_argument = func (self: @Parser) -> @AST_Call_Argument {
    if (self.matches(self.required_identifier, self.optional_space, self.required_equals)) {
        name := self.consume(self.required_identifier) as @Identifier_Token
        self.consume_space(1)
        self.consume(self.required_equals)
        self.consume_space(1)
        value := self.parse_expression()
        return new AST_Call_Argument(name = name, value_expression = value)
    }
    value := self.parse_expression()
    return new AST_Call_Argument(name = null, value_expression = value)
}

\ primary_expression
\   : IDENTIFIER
\   | INTEGER
\   | STRING
\   | CHARACTER
\   | "null"
\   | "false"
\   | "true"
\   | "undefined"
\   | "(" expression ")"
\   | "new" type ( "(" call_arguments? ")" )?
define parse_primary_expression = func (self: @Parser) -> @AST_Expression {
    if (self.matches(self.required_new)) {
        token := self.consume(self.required_new)
        self.consume_space(1)
        type := self.parse_type()
        call_arguments := new List()
        if (self.matches(self.optional_space, self.required_open_paren)) {
            self.consume_space(0)
            self.consume(self.required_open_paren)
            if (self.matches(self.optional_space, self.required_close_paren) == false) {
                self.parse_call_arguments(call_arguments)
            }
            self.consume_space(0)
            self.consume(self.required_close_paren)
        }
        return new AST_New_Expression(location = token.location, type = type, init_arguments = call_arguments)
    }
    if (self.matches(self.required_literal)) {
        token := self.consume(self.required_literal) as @Literal_Token
        return new AST_Literal_Expression(location = token.location, literal = token)
    }
    if (self.matches(self.required_identifier)) {
        token := self.consume(self.required_identifier) as @Identifier_Token
        return new AST_Variable_Expression(location = token.location, name = token)
    }
    if (self.matches(self.required_open_paren)) {
        location := self.consume(self.required_open_paren).location
        self.consume_space(0)
        expression := self.parse_expression()
        self.consume_space(0)
        self.consume(self.required_close_paren)
        return new AST_Atomic_Expression(location = location, expression = expression)
    }
    return null
}

define consume_end_of_line = func (self: @Parser) -> Nothing {
    if (self.matches(self.optional_space, self.required_comment)) {
        self.consume_space(1)
        self.consume(self.required_comment)
    } else {
        self.consume_space(0)
    }
    if (self.matches(self.required_end_of_file) == false) {
        self.consume(self.required_end_of_line)
    }
}

define consume_empty_line = func (self: @Parser) -> Boolean {
    if (self.matches(self.optional_space, self.optional_comment, self.required_end_of_line)) {
        if (self.matches(self.optional_space, self.required_comment)) {
            self.consume_space(self.current_alignment * 4)
            self.consume(self.required_comment)
        } else {
            self.consume_space(0)
        }
        self.consume(self.required_end_of_line)
        return true
    }
    return false
}

define consume_space = func (self: @Parser, expected_space_count: Int) -> Nothing {
    space_count: Int
    token := self.scanner.current_token
    if (token.is(Space_Token)) {
        self.scanner.next_token()
        space := token as @Space_Token
        space_count = space.count
    } else {
        space_count = 0
    }
    if (space_count != expected_space_count) {
        stderr.write(token.location).write(": Consumed ").write(space_count).write(" spaces where ").write(expected_space_count).write(" are expected").end_line()
    }
}

define consume = func (self: @Parser, first_matcher: @Matcher) -> @Token {
    return self.consume(first_matcher, null)
}

define consume = func (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher) -> @Token {
    return self.consume(first_matcher, second_matcher, null)
}

define consume = func (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher, third_matcher: @Matcher) -> @Token {
    token := self.scanner.current_token
    first_token := token
    if (first_matcher.accepts(token)) {
        token = self.scanner.next_token()
    } else {
        if (first_matcher.is_required) {
            self.abort(token)
        }
    }
    if (second_matcher != null) {
        if (second_matcher.accepts(token)) {
            token = self.scanner.next_token()
        } else {
            if (second_matcher.is_required) {
                self.abort(token)
            }
        }
    }
    if (third_matcher != null) {
        if (third_matcher.accepts(token)) {
            token = self.scanner.next_token()
        } else {
            if (third_matcher.is_required) {
                self.abort(token)
            }
        }
    }
    return first_token
}

define matches_end_of_line = func (self: @Parser) -> Boolean {
    return self.matches(self.optional_space, self.optional_comment, self.required_end_of_line)
}

define matches = func (self: @Parser, first_matcher: @Matcher) -> Boolean {
    return self.matches(first_matcher, null)
}

define matches = func (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher) -> Boolean {
    return self.matches(first_matcher, second_matcher, null)
}

define matches = func (self: @Parser, first_matcher: @Matcher, second_matcher: @Matcher, third_matcher: @Matcher) -> Boolean {
    token := self.scanner.current_token
    peek_offset := 0
    if (first_matcher.accepts(token)) {
        token = self.scanner.peek_token(peek_offset)
        peek_offset = peek_offset + 1
    } else if (first_matcher.is_required) {
        return false
    }
    if (second_matcher != null) {
        if (second_matcher.accepts(token)) {
            token = self.scanner.peek_token(peek_offset)
            peek_offset = peek_offset + 1
        } else if (second_matcher.is_required) {
            return false
        }
    }
    if (third_matcher != null) {
        if (third_matcher.accepts(token)) {
            token = self.scanner.peek_token(peek_offset)
            peek_offset = peek_offset + 1
        } else if (third_matcher.is_required) {
            return false
        }
    }
    return true
}

define Matcher = struct {
    extends Object
    is_required: Boolean
}

define Comment_Matcher = struct {
    extends Matcher
}

define End_Of_File_Matcher = struct {
    extends Matcher
}

define End_Of_Line_Matcher = struct {
    extends Matcher
}

define Identifier_Matcher = struct {
    extends Matcher
}

define Keyword_Matcher = struct {
    extends Matcher
    lexeme: @String
}

define Literal_Matcher = struct {
    extends Matcher
}

define String_Literal_Matcher = struct {
    extends Matcher
}

define Other_Matcher = struct {
    extends Matcher
    lexeme: @String
}

define Space_Matcher = struct {
    extends Matcher
}

define accepts = func (self: @Matcher, token: @Token) -> Boolean {
    if (self.is(Other_Matcher)) {
        self := self as @Other_Matcher
        if (token.is(Other_Token)) {
            return token.lexeme.equals(self.lexeme)
        }
        return false
    }
    if (self.is(Space_Matcher)) {
        return token.is(Space_Token)
    }
    if (self.is(Identifier_Matcher)) {
        return token.is(Identifier_Token)
    }
    if (self.is(Keyword_Matcher)) {
        self := self as @Keyword_Matcher
        if (token.is(Identifier_Token)) {
            return token.lexeme.equals(self.lexeme)
        }
        return false
    }
    if (self.is(String_Literal_Matcher)) {
        return token.is(String_Token)
    }
    if (self.is(Literal_Matcher)) {
        return token.is(Integer_Token) || token.is(String_Token) || token.is(Character_Token) || token.is(Boolean_Token) || token.is(Null_Token) || token.is(Undefined_Token)
    }
    if (self.is(End_Of_Line_Matcher)) {
        return token.is(End_Of_Line_Token)
    }
    if (self.is(Comment_Matcher)) {
        return token.is(Comment_Token)
    }
    if (self.is(End_Of_File_Matcher)) {
        return token.is(End_Of_File_Token)
    }
    stderr.write("Unsupported token matcher").end_line()
    abort()
}
