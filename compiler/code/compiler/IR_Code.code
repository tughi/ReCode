include "./Map.code"

struct IR_Code {
    types = make Map[@String, @IR_Type]()
    global_symbols: @List[@IR_Symbol]
}

func dump(code: @IR_Code, file: @FILE) -> Nothing {
    let symbols_iterator = code.global_symbols.create_iterator()
    if symbols_iterator.has_next() {
        loop {
            let symbol = symbols_iterator.next()
            symbol.dump(file)
            if symbols_iterator.has_next() {
                file.end_line()
            } else {
                break
            }
        }
    }
}

struct IR_Type: Object {
    name: @String
}

struct IR_Boolean_Type: IR_Type(name = "bool") {
}

struct IR_Integer_Type: IR_Type {
}

struct IR_Int_Type: IR_Integer_Type {
}

struct IR_Int16_Type: IR_Int_Type(name = "i16") {
}

struct IR_Int32_Type: IR_Int_Type(name = "i32") {
}

struct IR_Int64_Type: IR_Int_Type(name = "i64") {
}

struct IR_Int8_Type: IR_Int_Type(name = "i8") {
}

struct IR_UInt_Type: IR_Integer_Type {
}

struct IR_UInt16_Type: IR_UInt_Type(name = "u16") {
}

struct IR_UInt32_Type: IR_UInt_Type(name = "u32") {
}

struct IR_UInt64_Type: IR_UInt_Type(name = "u64") {
}

struct IR_UInt8_Type: IR_UInt_Type(name = "u8") {
}

struct IR_Null_Type: IR_Type(name = "Null") {
}

struct IR_Undefined_Type: IR_Type(name = "Undefined") {
}

struct IR_Nothing_Type: IR_Type(name = "Nothing") {
}

struct IR_Pointer_Type: IR_Type {
    pointed_type: @IR_Type
}

struct IR_Unchecked_Array_Type: IR_Type {
    item_type: @IR_Type
}

struct IR_Fixed_Array_Type: IR_Type {
    item_type: @IR_Type
    size: i64
}

struct IR_Function_Type: IR_Type {
    parameters: @List[@IR_Function_Type_Parameter]
    return_type: @IR_Type
}

struct IR_Function_Type_Parameter {
    name: @String
    type: @IR_Type
}

struct IR_Opaque_Type: IR_Type {
}

struct IR_Struct_Type: IR_Type {
    super_type: @IR_Struct_Type = null
    derived_types = make @List[@IR_Struct_Type]()
    members = make @List[@IR_Struct_Type_Member]()
    checked_struct_type: @Checked_Struct_Type
    \ object_type_variable: @IR_Global_Variable = null
    \ object_type_id = 0u32
    \ object_type_max_derivate_id = 0u32
}

struct IR_Struct_Type_Member {
    struct_type: @IR_Struct_Type
    name: @String
    type: @IR_Type
    checked_struct_type_member: @Checked_Struct_Type_Member
    default_value_expression: @Parsed_Expression
}

func add_member(self: @IR_Struct_Type, name: @String, type: @IR_Type, checked_struct_type_member: @Checked_Struct_Type_Member, default_value_expression: @Parsed_Expression) -> @IR_Struct_Type_Member {
    let member = make @IR_Struct_Type_Member(
        struct_type = self
        name = name
        type = type
        checked_struct_type_member = checked_struct_type_member
        default_value_expression = default_value_expression
    )
    self.members.append(member)
    return member
}

func is_object_type(self: @IR_Struct_Type) -> bool {
    let struct_type = self
    loop {
        if struct_type.name.equals("Object") {
            return true
        }
        struct_type = struct_type.super_type
        if struct_type == null {
            return false
        }
    }
}

struct IR_Symbol: Object {
    checked_symbol: @Checked_Symbol
    name: @String
    type: @IR_Type
}

func dump(self: @IR_Symbol, file: @FILE) -> Nothing {
    if self is IR_Function {
        self.as(@IR_Function).dump(file)
    } else {
        abort(self.object_type)
    }
}

struct IR_Function: IR_Symbol {
    function_type: @IR_Function_Type
    parameters: @List[@IR_Function_Parameter]
    return_type: @IR_Type
    blocks: @List[@IR_Block]
}

struct IR_Function_Parameter: IR_Symbol {
    value: @IR_Value
}

func create_block(self: @IR_Function) -> @IR_Block {
    let block = make @IR_Block(name = clone("@").append(self.blocks.size + 1))
    self.blocks.append(block)
    return block
}

func dump(function: @IR_Function, file: @FILE) -> Nothing {
    file.write(function.name).write("(")
    let function_type = function.function_type
    let function_parameters = function.parameters.create_iterator()
    while function_parameters.has_next() {
        let function_parameter = function_parameters.next()
        file.write(function_parameter.value.name).write(": ").write(function_parameter.type.name)
        if function_parameters.has_next() {
            file.write(", ")
        }
    }
    if function_type.return_type is IR_Nothing_Type {
        file.write(")")
    } else {
        file.write("): ").write(function_type.return_type.name)
    }
    file.write(" {").end_line()
    let block_item = function.blocks.first_item
    while block_item != null {
        block_item.data.dump(file)
        block_item = block_item.next_item
    }
    file.write('}').end_line()
}

struct IR_Local_Variable: IR_Symbol {
    value_pointer: @IR_Value
    value_counter = make Counter[i32]()
}

struct IR_Value: Object {
    name: @String
    type: @IR_Type
    init_instruction: @IR_Instruction = null
    user_instructions = make List[@IR_Instruction]()
}

func write(file: @FILE, value: @IR_Value) -> @FILE {
    return file.write(value.name)
}

struct IR_Block {
    name: @String
    instructions = make List[@IR_Instruction]()
    predecessors = make List[@IR_Block]()
}

func append(self: @IR_Block, instruction: @IR_Instruction) -> @IR_Instruction {
    instruction.block = self
    self.instructions.append(instruction)
    return instruction
}

func dump(block: @IR_Block, file: @FILE) -> @FILE {
    file.write(block.name).write(':').end_line()
    block.instructions.for_each() {
        let block_instruction = it
        file.write("   ")
        block_instruction.dump(file)
    }
    return file
}

struct IR_Instruction: Object {
    location: @Source_Location = null
    result_value: @IR_Value = null
    operand_values = make Map[@Any, @IR_Value]()
    block: @IR_Block = undefined
    dump = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        file.flush()
        abort(clone("Unsupported type: ").append(instruction.object_type.name))
    }
}

func dump_ir_instruction_result(self: @IR_Instruction, file: @FILE) -> Nothing {
    if self.result_value != null {
        file.write(self.result_value).write(": ").write(self.result_value.type.name).write(" = ")
    }
}

func is_exit_instruction(self: @IR_Instruction) -> bool {
    if self == null {
        return false
    }
    if self is IR_Branch_Instruction or self is IR_Jump_Instruction or self is IR_Return_Instruction {
        return true
    }
    if self is IR_Direct_Call_Instruction {
        let self = self.as(@IR_Direct_Call_Instruction)
        let function = self.function
        if function.name.equals("abort") and function.parameters.size == 0 {
            return true
        }
        if function.name.equals("exit") and function.parameters.size == 1 {
            let function_parameter = function.parameters.get(0i64)
            if function_parameter.type is IR_Int32_Type {
                return true
            }
        }
    }
    return false
}

func set_operand_value(self: @IR_Instruction, key: @Any, value: @IR_Value) -> Nothing {
    self.operand_values.put(key, value)
    value.user_instructions.append(self)
}

struct IR_Add_Instruction: IR_Binary_Instruction(
    dump = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        instruction.dump_ir_instruction_result(file)
        let instruction = instruction.as(@IR_Binary_Instruction)
        return file.write("add ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value()).end_line()
    }
) {
}

struct IR_Alloc_Instruction: IR_Instruction(
    dump = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        instruction.dump_ir_instruction_result(file)
        let instruction = instruction.as(@IR_Alloc_Instruction)
        return file.write("alloc ").write(instruction.type.name).end_line()
    }
) {
    type: @IR_Type
}

struct IR_Binary_Instruction: IR_Instruction {
}

func init(self: @IR_Binary_Instruction, left_value: @IR_Value, right_value: @IR_Value) -> @IR_Binary_Instruction {
    self.set_operand_value("left_value", left_value)
    self.set_operand_value("right_value", right_value)
    return self
}

func get_left_value(self: @IR_Binary_Instruction) -> @IR_Value {
    return self.operand_values.get("left_value")
}

func get_right_value(self: @IR_Binary_Instruction) -> @IR_Value {
    return self.operand_values.get("right_value")
}

struct IR_Branch_Instruction: IR_Instruction(
    dump = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Branch_Instruction)
        return file.write("br ").write(instruction.get_condition()).write(' ').write(instruction.true_block.name).write(' ').write(instruction.false_block.name).end_line()
    }
) {
    true_block: @IR_Block
    false_block: @IR_Block
}

func init(self: @IR_Branch_Instruction, condition: @IR_Value) -> @IR_Branch_Instruction {
    if condition.type is not IR_Boolean_Type {
        abort(clone("Not a boolean type: ").append(condition.type.name))
    }
    self.set_operand_value("condition", condition)
    return self
}

func get_condition(self: @IR_Branch_Instruction) -> @IR_Value {
    return self.operand_values.get("condition")
}

struct IR_Call_Instruction: IR_Instruction {
    arguments_size = 0i64
}

func dump_ir_call_instruction_arguments(instruction: @IR_Call_Instruction, file: @FILE) -> Nothing {
    let call_argument_index = 0i64
    while call_argument_index < instruction.arguments_size {
        file.write(' ').write(instruction.get_argument_value(call_argument_index))
        call_argument_index = call_argument_index + 1
    }
}

struct IR_Call_Argument {
    name: @String = null
    value: @IR_Value
}

func add_arguments(self: @IR_Call_Instruction, call_arguments: @List[@IR_Call_Argument]) -> @IR_Call_Instruction {
    let call_arguments_item = call_arguments.first_item
    while call_arguments_item != null {
        let call_argument = call_arguments_item.data
        self.set_operand_value(get_argument_key(self.arguments_size), call_argument.value)
        self.arguments_size = self.arguments_size + 1
        call_arguments_item = call_arguments_item.next_item
    }
    return self
}

func get_argument_value(self: @IR_Call_Instruction, index: i64) -> @IR_Value {
    return self.operand_values.get(get_argument_key(index))
}

func get_argument_key(index: i64) -> @String {
    if index == 0 {
        return "argument-0-value"
    } else if index == 1 {
        return "argument-1-value"
    } else if index == 2 {
        return "argument-2-value"
    } else if index == 3 {
        return "argument-3-value"
    } else if index == 4 {
        return "argument-4-value"
    } else if index == 5 {
        return "argument-5-value"
    }
    abort(clone("Missing argument index: ").append(index))
}

struct IR_Constant_Instruction: IR_Instruction(
    dump = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        instruction.dump_ir_instruction_result(file)
        let instruction = instruction.as(@IR_Constant_Instruction)
        return file.write("const ").write(instruction.literal).end_line()
    }
) {
    literal: @Literal_Token
}

func create_ir_constant_instruction(result_value: @IR_Value, literal: @Literal_Token) -> @IR_Constant_Instruction {
    let instruction = make @IR_Constant_Instruction(
        result_value = result_value
        literal = literal
    )
    result_value.init_instruction = instruction
    return instruction
}

struct IR_Direct_Call_Instruction: IR_Call_Instruction(
    dump = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        instruction.dump_ir_instruction_result(file)
        let instruction = instruction.as(@IR_Direct_Call_Instruction)
        file.write("call ").write(instruction.function.name)
        instruction.dump_ir_call_instruction_arguments(file)
        return file.end_line()
    }
) {
    function: @IR_Function
}

func create_ir_direct_call_instruction(result_value: @IR_Value, call_arguments: @List[@IR_Call_Argument], function: @IR_Function) -> @IR_Call_Instruction {
    let instruction = make @IR_Direct_Call_Instruction(result_value = result_value, function = function)
    instruction.add_arguments(call_arguments)
    if result_value != null {
        result_value.init_instruction = instruction
    }
    return instruction
}

struct IR_Jump_Instruction: IR_Instruction(
    dump = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Jump_Instruction)
        return file.write("jmp ").write(instruction.block.name).end_line()
    }
) {
    block: @IR_Block
}

struct IR_Load_Instruction: IR_Instruction(
    dump = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        instruction.dump_ir_instruction_result(file)
        let instruction = instruction.as(@IR_Load_Instruction)
        return file.write("load ").write(instruction.get_value_pointer()).end_line()
    }
) {
}

func init(self: @IR_Load_Instruction, value_pointer: @IR_Value) -> @IR_Load_Instruction {
    if value_pointer.type is not IR_Pointer_Type {
        abort(clone("Not a pointer type: ").append(value_pointer.type.name))
    }
    let pointed_type = value_pointer.type.as(@IR_Pointer_Type).pointed_type
    if pointed_type != self.result_value.type {
        abort(clone("Type mismatch: ").append(pointed_type.name).append(" != ").append(self.result_value.type.name))
    }
    self.set_operand_value("value_pointer", value_pointer)
    return self
}

func get_value_pointer(self: @IR_Load_Instruction) -> @IR_Value {
    return self.operand_values.get("value_pointer")
}

struct IR_Not_Instruction: IR_Unary_Instruction(
    dump = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        instruction.dump_ir_instruction_result(file)
        let instruction = instruction.as(@IR_Not_Instruction)
        return file.write("not ").write(instruction.get_value()).end_line()
    }
) {
}

struct IR_Phi_Instruction: IR_Instruction(
    dump = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        instruction.dump_ir_instruction_result(file)
        let instruction = instruction.as(@IR_Phi_Instruction)
        file.write("phi")
        let operand_values_entry = instruction.operand_values.first_entry
        while operand_values_entry != null {
            file.write(' ').write(operand_values_entry.value)
            operand_values_entry = operand_values_entry.next_entry
        }
        return file.end_line()
    }
) {
}

struct IR_Store_Instruction: IR_Instruction(
    dump = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Store_Instruction)
        return file.write("store ").write(instruction.get_value_pointer()).write(' ').write(instruction.get_value()).end_line()
    }
) {
}

func append(self: @IR_Phi_Instruction, value: @IR_Value) -> @IR_Phi_Instruction {
    self.set_operand_value(value, value)
    return self
}

func init(self: @IR_Store_Instruction, value_pointer: @IR_Value, value: @IR_Value) -> @IR_Store_Instruction {
    if value_pointer.type is not IR_Pointer_Type {
        abort(clone("Not a pointer type: ").append(value_pointer.type.name))
    }
    let pointed_type = value_pointer.type.as(@IR_Pointer_Type).pointed_type
    if pointed_type != value.type {
        abort(clone("Type mismatch: ").append(pointed_type.name).append(" != ").append(value.type.name))
    }
    self.set_operand_value("value_pointer", value_pointer)
    self.set_operand_value("value", value)
    return self
}

func get_value_pointer(self: @IR_Store_Instruction) -> @IR_Value {
    return self.operand_values.get("value_pointer")
}

func get_value(self: @IR_Store_Instruction) -> @IR_Value {
    return self.operand_values.get("value")
}

struct IR_Return_Instruction: IR_Instruction(
    dump = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Return_Instruction)
        if instruction.get_return_value() == null {
            return file.write("ret").end_line()
        }
        return file.write("ret ").write(instruction.get_return_value().name).end_line()
    }
) {
}

func create_ir_return_instruction(return_value: @IR_Value) -> @IR_Return_Instruction {
    let instruction = make @IR_Return_Instruction(result_value = null)
    if return_value != null {
        instruction.set_operand_value("return_value", return_value)
    }
    return instruction
}

func get_return_value(self: @IR_Return_Instruction) -> @IR_Value {
    return self.operand_values.get("return_value")
}

struct IR_Substract_Instruction: IR_Binary_Instruction(
    dump = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Binary_Instruction)
        instruction.dump_ir_instruction_result(file)
        return file.write("sub ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value()).end_line()
    }
) {
}

struct IR_Unary_Instruction: IR_Instruction {
}

func init(self: @IR_Unary_Instruction, value: @IR_Value) -> @IR_Unary_Instruction {
    self.set_operand_value("value", value)
    return self
}

func get_value(self: @IR_Unary_Instruction) -> @IR_Value {
    return self.operand_values.get("value")
}
