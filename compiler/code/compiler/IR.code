\ Copyright (c) 2020, Stefan Selariu

IR_Type :: struct : Object {
    name: @String
}

IR_Any_Type :: struct : IR_Type {
}

IR_Boolean_Type :: struct : IR_Type {
}

IR_Int_Type :: struct : IR_Type {
}

IR_Int8_Type :: struct : IR_Type {
}

IR_Int16_Type :: struct : IR_Type {
}

IR_Int32_Type :: struct : IR_Type {
}

IR_Int64_Type :: struct : IR_Type {
}

IR_Nothing_Type :: struct : IR_Type {
}

IR_Null_Type :: struct : IR_Type {
}

IR_Undefined_Type :: struct : IR_Type {
}

IR_Pointer_Type :: struct : IR_Type {
    pointed_type: @IR_Type
}

equals :: (self: @IR_Type, other: @IR_Type) -> Boolean {
    if (self.is(IR_Pointer_Type) && other.is(IR_Pointer_Type)) {
        self := self as @IR_Pointer_Type
        other := other as @IR_Pointer_Type
        return self.pointed_type.equals(other.pointed_type)
    }
    return self == other
}

create_ir_pointer_type :: (pointed_type: @IR_Type) -> @IR_Pointer_Type {
    type_name := clone("@").append(pointed_type.name)
    return new IR_Pointer_Type(name = type_name, pointed_type = pointed_type)
}

IR_Array_Type :: struct : IR_Pointer_Type {
    size_expression: @AST_Expression
}

create_ir_array_type :: (item_type: @IR_Type, size_expression: @AST_Expression) -> @IR_Type {
    type_name := clone("[").append(item_type.name).append("]")
    return new IR_Array_Type(name = type_name, pointed_type = item_type, size_expression = size_expression)
}

IR_Function_Type :: struct : IR_Type {
    parameters: @List
    return_type: @IR_Type
}

IR_Function_Type_Parameter :: struct {
    name: @String
    type: @IR_Type
}

create_ir_function_type :: (parameters: @List, return_type: @IR_Type) -> @IR_Function_Type {
    type_name := new String().append("(")
    parameters_item := parameters.first_item
    while (parameters_item != null) {
        parameter := parameters_item.data as @IR_Function_Type_Parameter
        type_name.append(parameter.name).append(": ").append(parameter.type.name)
        parameters_item = parameters_item.next_item
        if (parameters_item != null) {
            type_name.append(", ")
        }
    }
    type_name.append(") -> ").append(return_type.name)

    return new IR_Function_Type(name = type_name, parameters = parameters, return_type = return_type)
}

IR_Struct_Type :: struct : IR_Type {
    base_type: @IR_Struct_Type = null
    members: @List = new List()
    statement: @AST_Struct_Statement
}

IR_Struct_Type_Member :: struct {
    struct_type: @IR_Struct_Type
    name: @String
    type: @IR_Type
}

create_ir_struct_type :: (name: @String, statement: @AST_Struct_Statement) -> @IR_Struct_Type {
    return new IR_Struct_Type(name = name, statement = statement)
}

add_member :: (self: @IR_Struct_Type, name: @String, type: @IR_Type) -> @IR_Struct_Type_Member {
    member := new IR_Struct_Type_Member(struct_type = self, name = name, type = type)
    self.members.append(member)
    return member
}

get_member :: (self: @IR_Struct_Type, name: @String) -> @IR_Struct_Type_Member {
    struct_type := self
    loop {
        members_item := struct_type.members.first_item
        while (members_item != null) {
            member := members_item.data as @IR_Struct_Type_Member
            if (member.name.equals(name)) {
                return member
            }
            members_item = members_item.next_item
        }
        struct_type = struct_type.base_type
        if (struct_type == null) {
            return null
        }
    }
}

is_base_type :: (self: @IR_Struct_Type, other: @IR_Struct_Type) -> Boolean {
    struct_type := other
    loop {
        if (self == struct_type.base_type) {
            return true
        }
        struct_type = struct_type.base_type
        if (struct_type == null) {
            return false
        }
    }
}

is_object_type :: (self: @IR_Struct_Type) -> Boolean {
    struct_type := self
    loop {
        if (struct_type.name.equals("Object")) {
            return true
        }
        struct_type = struct_type.base_type
        if (struct_type == null) {
            return false
        }
    }
}

IR_Value :: struct : Object {
    type: @IR_Type
    creator_instruction: @IR_Instruction = null
    user_instructions: @List = new List()
    links: @List = new List()
    dump: (value: @IR_Value, file: @FILE) -> @FILE = dump_ir_value
}

dump_ir_value :: (value: @IR_Value, file: @FILE) -> @FILE {
    file.flush()
    abort(clone("Unsupported type: ").append(value.object_type.name))
}

write :: (file: @FILE, value: @IR_Value, check_users: Boolean) -> @FILE {
    if (check_users && value.user_instructions.size == 0) {
        file.flush()
        if (value.is(IR_Variable_Value)) {
            value := value as @IR_Variable_Value
            value_version := value.version
        }
        stderr.write("Found ").write(value.object_type.name).write(" without user instructions: ")
        value.dump(stderr)
        stderr.end_line()
    }
    return value.dump(file)
}

IR_Link :: struct : Object {
}

IR_Requires_Value_Link :: struct : IR_Link {
    back_link: @IR_Required_By_Value_Link
    value: @IR_Value
}

IR_Required_By_Value_Link :: struct : IR_Link {
    back_link: @IR_Requires_Value_Link
    value: @IR_Value
}

IR_Undefined_Value :: struct : IR_Value(dump = dump_ir_undefined_value) {
}

dump_ir_undefined_value :: (value: @IR_Value, file: @FILE) -> @FILE {
    return file.write("undefined")
}

IR_Constant_Value :: struct : IR_Value(dump = dump_ir_constant_value) {
    literal: @Literal_Token
}

dump_ir_constant_value :: (value: @IR_Value, file: @FILE) -> @FILE {
    return file.write((value as @IR_Constant_Value).literal.lexeme)
}

IR_Struct_Literal_Value :: struct : IR_Value(dump = dump_IR_Struct_Literal_Value) {
}

IR_Struct_Literal_Member_Value_Link :: struct : IR_Requires_Value_Link {
    struct_type_member: @IR_Struct_Type_Member
}

get_member_value :: (self: @IR_Struct_Literal_Value, struct_type_member: @IR_Struct_Type_Member) -> @IR_Value {
    links_item := self.links.first_item
    while (links_item != null) {
        link := links_item.data as @IR_Link
        if (link.is(IR_Struct_Literal_Member_Value_Link)) {
            link := link as @IR_Struct_Literal_Member_Value_Link
            if (link.struct_type_member == struct_type_member) {
                return link.value
            }
        }
        links_item = links_item.next_item
    }
    return null
}

set_member_value :: (self: @IR_Struct_Literal_Value, struct_type_member: @IR_Struct_Type_Member, value: @IR_Value) -> Nothing {
    member_value_link := new IR_Struct_Literal_Member_Value_Link(value = value, struct_type_member = struct_type_member, back_link = undefined)
    member_value_link.back_link = new IR_Required_By_Value_Link(value = self, back_link = member_value_link)
    self.links.append(member_value_link)
    value.links.append(member_value_link.back_link)
}

dump_IR_Struct_Literal_Value :: (value: @IR_Value, file: @FILE) -> @FILE {
    value := value as @IR_Struct_Literal_Value
    file.write(value.type.name).write('(')
    value_links_item := value.links.first_item
    is_first_value_link := true
    while (value_links_item != null) {
        value_link := value_links_item.data as @IR_Link
        if (value_link.is(IR_Struct_Literal_Member_Value_Link)) {
            value_link := value_link as @IR_Struct_Literal_Member_Value_Link
            if (is_first_value_link) {
                is_first_value_link = false
            } else {
                file.write(", ")
            }
            file.write(value_link.struct_type_member.name).write(" = ").write(value_link.value, false)
        }
        value_links_item = value_links_item.next_item
    }
    return file.write(')')
}

IR_Global_Variable_Value :: struct : IR_Value(dump = dump_ir_global_variable_value) {
    variable: @IR_Variable
}

dump_ir_global_variable_value :: (value: @IR_Value, file: @FILE) -> @FILE {
    value := value as @IR_Variable_Value
    return file.write(value.variable.name)
}

IR_Variable_Value :: struct : IR_Value(dump = dump_ir_variable_value) {
    variable: @IR_Variable
    version: Int
}

init :: (self: @IR_Variable_Value, variable: @IR_Variable) -> @IR_Variable_Value {
    self.variable = variable
    self.version = variable.values.size + 1
    variable.values.append(self)
    return self
}

dump_ir_variable_value :: (value: @IR_Value, file: @FILE) -> @FILE {
    value := value as @IR_Variable_Value
    return file.write(value.variable.name).write('.').write(value.version)
}

IR_Variable_Address_Value :: struct : IR_Value(dump = dump_ir_variable_address_value) {
    variable_value: @IR_Variable_Value
}

dump_ir_variable_address_value :: (value: @IR_Value, file: @FILE) -> @FILE {
    value := value as @IR_Variable_Address_Value
    return file.write(value.variable_value, true).write(".address")
}

IR_Block :: struct : Object {
    id: Int
    function: @IR_Function
    predecessors: @List = new List()
    first_instruction: @IR_Instruction = null
    last_instruction: @IR_Instruction = null
    is_being_generated: Boolean = false
    is_generated: Boolean = false
}

has_instructions :: (self: @IR_Block) -> Boolean {
    return self.first_instruction != null
}

prepend :: (self: @IR_Block, instruction: @IR_Instruction) -> @IR_Instruction {
    instruction.parent_block = self
    instruction.prev_instruction = null
    instruction.next_instruction = self.first_instruction
    if (self.first_instruction == null) {
        self.last_instruction = instruction
    } else {
        self.first_instruction.prev_instruction = instruction
    }
    self.first_instruction = instruction
    return instruction
}

append :: (self: @IR_Block, instruction: @IR_Instruction) -> @IR_Instruction {
    instruction.parent_block = self
    instruction.prev_instruction = self.last_instruction
    instruction.next_instruction = null
    if (self.last_instruction == null) {
        self.first_instruction = instruction
    } else {
        self.last_instruction.next_instruction = instruction
    }
    self.last_instruction = instruction
    return instruction
}

append_jump :: (self: @IR_Block, block: @IR_Block) -> @IR_Direct_Jump_Instruction {
    instruction := new IR_Direct_Jump_Instruction(result_value = null, block = block)
    block.predecessors.append(self)
    self.append(instruction)
    return instruction
}

append_jump :: (self: @IR_Block, condition_value: @IR_Value, true_block: @IR_Block, false_block: @IR_Block) -> @IR_Conditional_Jump_Instruction {
    instruction := new IR_Conditional_Jump_Instruction(result_value = null, true_block = true_block, false_block = false_block)
    instruction.set_operand_value("condition", condition_value)
    true_block.predecessors.append(self)
    false_block.predecessors.append(self)
    self.append(instruction)
    return instruction
}

remove :: (self: @IR_Block, instruction: @IR_Instruction) -> Nothing {
    if (instruction.parent_block != self) {
        abort("Tried to remove instruction belonging to another block")
    }
    if (instruction.prev_instruction != null) {
        instruction.prev_instruction.next_instruction = instruction.next_instruction
    }
    if (instruction.next_instruction != null) {
        instruction.next_instruction.prev_instruction = instruction.prev_instruction
    }
    if (self.first_instruction == instruction) {
        self.first_instruction = instruction.next_instruction
    }
    if (self.last_instruction == instruction) {
        self.last_instruction = instruction.prev_instruction
    }
    instruction.parent_block = null
    instruction.prev_instruction = null
    instruction.next_instruction = null
}

dump :: (block: @IR_Block, file: @FILE) -> @FILE {
    file.write("block.").write(block.id)
    block_predecessors := block.predecessors.create_iterator()
    if (block_predecessors.has_next()) {
        file.write('(')
        loop {
            block_predecessor := block_predecessors.next() as @IR_Block
            file.write("block.").write(block_predecessor.id)
            if (block_predecessors.has_next()) {
                file.write(", ")
            } else {
                break
            }
        }
        file.write(')')
    }
    file.write(':').end_line()
    block_instruction := block.first_instruction
    while (block_instruction != null) {
        block_instruction.dump(file, "   ")
        block_instruction = block_instruction.next_instruction
    }
    return file
}

IR_Function :: struct : Object {
    id: Int
    location: @Source_Location
    name: @String
    parameters: @List
    return_type: @IR_Type
    type: @IR_Function_Type
    is_external: Boolean
    blocks: @List
}

create_block :: (self: @IR_Function) -> @IR_Block {
    block := new IR_Block(id = self.blocks.size + 1, function = self)
    self.blocks.append(block)
    return block
}

dump :: (function: @IR_Function, file: @FILE) -> Nothing {
    file.write_function_label(function).write(" :: (")
    function_parameters := function.parameters.create_iterator()
    while (function_parameters.has_next()) {
        function_parameter := function_parameters.next() as @IR_Function_Parameter
        file.write(function_parameter.name).write(": ").write(function_parameter.type.name)
        if (function_parameters.has_next()) {
            file.write(", ")
        }
    }
    file.write(") -> ").write(function.return_type.name).write(" {").end_line()
    block_item := function.blocks.first_item
    while (block_item != null) {
        (block_item.data as @IR_Block).dump(file)
        block_item = block_item.next_item
    }
    file.write('}').end_line()
}

IR_Variable :: struct : Object {
    name: @String
    type: @IR_Type
    values: @List = new List()
}

IR_Global_Variable :: struct : IR_Variable {
    is_external: Boolean
}

create_ir_global_variable :: (name: @String, type: @IR_Type, is_external: Boolean) -> @IR_Global_Variable {
    variable := new IR_Global_Variable(name = name, type = type, is_external = is_external)
    return variable
}

IR_Function_Parameter :: struct : IR_Variable {
}

IR_Instruction :: struct : Object {
    location: @Source_Location = null
    result_value: @IR_Variable_Value
    operand_values: @IR_Values_Map = new IR_Values_Map()
    parent_block: @IR_Block = undefined
    prev_instruction: @IR_Instruction = null
    next_instruction: @IR_Instruction = null
    is_generated: Boolean = false
    dump: (self: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE = dump_ir_instruction
}

dump_ir_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    file.flush()
    abort(clone("Unsupported type: ").append(instruction.object_type.name))
}

dump_ir_instruction_result :: (self: @IR_Instruction, file: @FILE, prefix: @String) -> Nothing {
    file.write(prefix)
    if (self.result_value != null) {
        file.write(self.result_value, false).write(": ").write(self.result_value.type.name).write(" = ")
    }
}

is_exit_instruction :: (self: @IR_Instruction) -> Boolean {
    if (self == null) {
        return false
    }
    if (self.is(IR_Jump_Instruction) || self.is(IR_Return_Instruction)) {
        return true
    }
    if (self.is(IR_Direct_Call_Instruction)) {
        self := self as @IR_Direct_Call_Instruction
        function := self.function
        if (function.name.equals("abort")) {
            return true
        }
        if (function.name.equals("exit") && function.parameters.size == 1) {
            function_parameter := function.parameters.get(0) as @IR_Function_Parameter
            if (function_parameter.type.is(IR_Int_Type)) {
                return true
            }
        }
    }
    return false
}

set_operand_value :: (self: @IR_Instruction, key: @Any, value: @IR_Value) -> Nothing {
    self.operand_values.put(key, value)
    value.user_instructions.append(self)
}

replace_operand_value :: (self: @IR_Instruction, old_value: @IR_Value, new_value: @IR_Value) -> Nothing {
    old_value.user_instructions.remove(self).prune()
    new_value.user_instructions.append(self)
    if (self.is(IR_Phi_Instruction)) {
        self.operand_values.remove(old_value)
        self.operand_values.put(new_value, new_value)
    } else {
        self.operand_values.replace_values(old_value, new_value)
    }
}

include "./IR_Values_Map.code"

IR_Call_Instruction :: struct : IR_Instruction {
    arguments_size: Int = 0
}

dump_ir_call_instruction_arguments :: (instruction: @IR_Call_Instruction, file: @FILE) -> Nothing {
    call_argument_index := 0
    while (call_argument_index < instruction.arguments_size) {
        file.write(", ").write(instruction.get_argument_value(call_argument_index), true)
        call_argument_index = call_argument_index + 1
    }
}

IR_Call_Argument :: struct {
    name: @String = null
    value: @IR_Value
}

add_arguments :: (self: @IR_Call_Instruction, call_arguments: @List) -> @IR_Call_Instruction {
    call_arguments_item := call_arguments.first_item
    while (call_arguments_item != null) {
        call_argument := call_arguments_item.data as @IR_Call_Argument
        self.set_operand_value(get_argument_key(self.arguments_size), call_argument.value)
        self.arguments_size = self.arguments_size + 1
        call_arguments_item = call_arguments_item.next_item
    }
    return self
}

get_argument_value :: (self: @IR_Call_Instruction, index: Int) -> @IR_Value {
    return self.operand_values.get(get_argument_key(index))
}

get_argument_key :: (index: Int) -> @String {
    if (index == 0) {
        return "argument-0-value"
    } else if (index == 1) {
        return "argument-1-value"
    } else if (index == 2) {
        return "argument-2-value"
    } else if (index == 3) {
        return "argument-3-value"
    } else if (index == 4) {
        return "argument-4-value"
    } else if (index == 5) {
        return "argument-5-value"
    }
    abort(clone("Missing argument index: ").append(index))
}

IR_Direct_Call_Instruction :: struct : IR_Call_Instruction(dump = dump_ir_direct_call_instruction) {
    function: @IR_Function
}

dump_ir_direct_call_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Direct_Call_Instruction
    file.write("call").write('(').write_function_label(instruction.function)
    instruction.dump_ir_call_instruction_arguments(file)
    return file.write(')').end_line()
}

create_ir_direct_call_instruction :: (result_value: @IR_Variable_Value, call_arguments: @List, function: @IR_Function) -> @IR_Call_Instruction {
    instruction := new IR_Direct_Call_Instruction(result_value = result_value, function = function)
    instruction.add_arguments(call_arguments)
    if (result_value != null) {
        result_value.creator_instruction = instruction
    }
    return instruction
}

IR_Dynamic_Call_Instruction :: struct : IR_Call_Instruction(dump = dump_ir_dynamic_call_instruction) {
}

dump_ir_dynamic_call_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Dynamic_Call_Instruction
    function_address := instruction.get_function_address()
    file.write("call").write('(').write(function_address.variable.name).write('.').write(function_address.version)
    instruction.dump_ir_call_instruction_arguments(file)
    return file.write(')').end_line()
}

create_ir_dynamic_call_instruction :: (result_value: @IR_Variable_Value, call_arguments: @List, function_address: @IR_Variable_Value) -> @IR_Call_Instruction {
    instruction := new IR_Dynamic_Call_Instruction(result_value = result_value)
    instruction.add_arguments(call_arguments)
    instruction.set_operand_value("function_address", function_address)
    if (result_value != null) {
        result_value.creator_instruction = instruction
    }
    return instruction
}

get_function_address :: (self: @IR_Dynamic_Call_Instruction) -> @IR_Variable_Value {
    return self.operand_values.get("function_address") as @IR_Variable_Value
}

IR_Cast_Instruction :: struct : IR_Instruction(dump = dump_ir_cast_instruction) {
}

dump_ir_cast_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Cast_Instruction
    return file.write("cast").write('(').write(instruction.get_value(), true).write(')').end_line()
}

create_ir_cast_instruction :: (result_value: @IR_Variable_Value, value: @IR_Value) -> @IR_Cast_Instruction {
    instruction := new IR_Cast_Instruction(result_value = result_value)
    instruction.set_operand_value("value", value)
    result_value.creator_instruction = instruction
    return instruction
}

get_value :: (self: @IR_Cast_Instruction) -> @IR_Value {
    return self.operand_values.get("value")
}

IR_Jump_Instruction :: struct : IR_Instruction {
}

IR_Conditional_Jump_Instruction :: struct : IR_Jump_Instruction(dump = dump_ir_conditional_jump_instruction) {
    true_block: @IR_Block
    false_block: @IR_Block
}

dump_ir_conditional_jump_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Conditional_Jump_Instruction
    return file.write("jump").write('(').write(instruction.get_condition_value(), true).write(", ").write_block_label(instruction.true_block).write(", ").write_block_label(instruction.false_block).write(')').end_line()
}

get_condition_value :: (self: @IR_Conditional_Jump_Instruction) -> @IR_Value {
    return self.operand_values.get("condition")
}

IR_Direct_Jump_Instruction :: struct : IR_Jump_Instruction(dump = dump_ir_direct_jump_instruction) {
    block: @IR_Block
}

dump_ir_direct_jump_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Direct_Jump_Instruction
    return file.write("jump").write('(').write_block_label(instruction.block).write(')').end_line()
}

IR_Load_Array_Item_Instruction :: struct : IR_Instruction(dump = dump_ir_load_array_item_instruction) {
}

dump_ir_load_array_item_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Load_Array_Item_Instruction
    return file.write("load_array_item").write('(').write(instruction.get_array_value(), true).write(", ").write(instruction.get_index_value(), true).write(')').end_line()
}

create_ir_load_array_item_instruction :: (result_value: @IR_Variable_Value, array_value: @IR_Value, index_value: @IR_Value) -> @IR_Load_Array_Item_Instruction {
    instruction := new IR_Load_Array_Item_Instruction(result_value = result_value)
    instruction.set_operand_value("array_value", array_value)
    instruction.set_operand_value("index_value", index_value)
    result_value.creator_instruction = instruction
    return instruction
}

get_array_value :: (self: @IR_Load_Array_Item_Instruction) -> @IR_Value {
    return self.operand_values.get("array_value")
}

get_index_value :: (self: @IR_Load_Array_Item_Instruction) -> @IR_Value {
    return self.operand_values.get("index_value")
}

IR_Load_Function_Address_Instruction :: struct : IR_Instruction(dump = dump_ir_load_function_address_instruction) {
    function: @IR_Function
}

dump_ir_load_function_address_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Load_Function_Address_Instruction
    return file.write("load_function_address").write('(').write_function_label(instruction.function).write(')').end_line()
}

create_ir_load_function_address_instruction :: (result_value: @IR_Variable_Value, function: @IR_Function) -> @IR_Load_Function_Address_Instruction {
    instruction := new IR_Load_Function_Address_Instruction(result_value = result_value, function = function)
    result_value.creator_instruction = instruction
    return instruction
}

IR_Load_Struct_Member_Instruction :: struct : IR_Instruction(dump = dump_ir_load_struct_member_instruction) {
    struct_type_member: @IR_Struct_Type_Member
    load_address: Boolean
}

dump_ir_load_struct_member_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Load_Struct_Member_Instruction
    if (instruction.load_address) {
        file.write("load_struct_member_address")
    } else {
        file.write("load_struct_member")
    }
    return file.write('(').write(instruction.get_struct_pointer_value(), true).write(", ").write(instruction.struct_type_member.name).write(')').end_line()
}

create_ir_load_struct_member_instruction :: (result_value: @IR_Variable_Value, struct_pointer_value: @IR_Value, struct_type_member: @IR_Struct_Type_Member, load_address: Boolean) -> @IR_Load_Struct_Member_Instruction {
    instruction := new IR_Load_Struct_Member_Instruction(result_value = result_value, struct_type_member = struct_type_member, load_address = load_address)
    instruction.set_operand_value("struct_pointer_value", struct_pointer_value)
    result_value.creator_instruction = instruction

    if (struct_type_member.type.is(IR_Struct_Type)) {
        result_value_link := new IR_Requires_Value_Link(value = struct_pointer_value, back_link = undefined)
        result_value_link.back_link = new IR_Required_By_Value_Link(value = result_value, back_link = result_value_link)
        result_value.links.append(result_value_link)
        struct_pointer_value.links.append(result_value_link.back_link)
    }

    return instruction
}

get_struct_pointer_value :: (self: @IR_Load_Struct_Member_Instruction) -> @IR_Value {
    return self.operand_values.get("struct_pointer_value")
}

IR_Load_Variable_Address_Instruction :: struct : IR_Instruction(dump = dump_ir_load_variable_address_instruction) {
}

dump_ir_load_variable_address_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Load_Variable_Address_Instruction
    return file.write("load_variable_address").write('(').write(instruction.get_variable_value(), true).write(')').end_line()
}

create_ir_load_variable_address_instruction :: (result_value: @IR_Variable_Value, variable_value: @IR_Variable_Value) -> @IR_Load_Variable_Address_Instruction {
    instruction := new IR_Load_Variable_Address_Instruction(result_value = result_value)
    instruction.set_operand_value("variable_value", variable_value)
    result_value.creator_instruction = instruction

    result_value_link := new IR_Requires_Value_Link(value = variable_value, back_link = undefined)
    result_value_link.back_link = new IR_Required_By_Value_Link(value = result_value, back_link = result_value_link)
    result_value.links.append(result_value_link)
    variable_value.links.append(result_value_link.back_link)

    return instruction
}

get_variable_value :: (self: @IR_Load_Variable_Address_Instruction) -> @IR_Variable_Value {
    return self.operand_values.get("variable_value") as @IR_Variable_Value
}

IR_Load_Variable_Instruction :: struct : IR_Instruction(dump = dump_ir_load_variable_instruction) {
    variable: @IR_Variable
}

dump_ir_load_variable_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    return file.write("load_variable").write('(').write((instruction as @IR_Load_Variable_Instruction).variable.name).write(')').end_line()
}

create_ir_load_variable_instruction :: (result_value: @IR_Variable_Value) -> @IR_Load_Variable_Instruction {
    instruction := new IR_Load_Variable_Instruction(result_value = result_value, variable = result_value.variable)
    result_value.creator_instruction = instruction
    return instruction
}

IR_New_Instruction :: struct : IR_Instruction(dump = dump_ir_new_instruction) {
    type: @IR_Type
}

dump_ir_new_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_New_Instruction
    return file.write("new").write(' ').write(instruction.get_init_value(), true).end_line()
}

create_ir_new_instruction :: (result_value: @IR_Variable_Value, type: @IR_Type, init_value: @IR_Value) -> @IR_New_Instruction {
    instruction := new IR_New_Instruction(result_value = result_value, type = type)
    instruction.set_operand_value("init_value", init_value)
    result_value.creator_instruction = instruction
    return instruction
}

get_init_value :: (self: @IR_New_Instruction) -> @IR_Value {
    return self.operand_values.get("init_value")
}

IR_Return_Instruction :: struct : IR_Instruction(dump = dump_ir_return_instruction) {
}

dump_ir_return_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Return_Instruction
    if (instruction.get_return_value() == null) {
        return file.write("return").write('(').write(')').end_line()
    }
    return file.write("return").write('(').write(instruction.get_return_value(), true).write(')').end_line()
}

create_ir_return_instruction :: (return_value: @IR_Value) -> @IR_Return_Instruction {
    instruction := new IR_Return_Instruction(result_value = null)
    if (return_value != null) {
        instruction.set_operand_value("return_value", return_value)
    }
    return instruction
}

get_return_value :: (self: @IR_Return_Instruction) -> @IR_Value {
    return self.operand_values.get("return_value")
}

IR_Set_Instruction :: struct : IR_Instruction(dump = dump_ir_set_instruction) {
}

dump_ir_set_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Set_Instruction
    return file.write(instruction.get_value(), true).end_line()
}

create_ir_set_instruction :: (result_value: @IR_Variable_Value, value: @IR_Value) -> @IR_Set_Instruction {
    instruction := new IR_Set_Instruction(result_value = result_value)
    instruction.set_operand_value("value", value)
    result_value.creator_instruction = instruction
    return instruction
}

get_value :: (self: @IR_Set_Instruction) -> @IR_Value {
    return self.operand_values.get("value")
}

IR_Store_Array_Item_Instruction :: struct : IR_Instruction(dump = dump_ir_store_array_item_instruction) {
}

dump_ir_store_array_item_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Store_Array_Item_Instruction
    return file.write("store_array_item").write('(').write(instruction.get_array_value(), true).write(", ").write(instruction.get_index_value(), true).write(", ").write(instruction.get_value(), true).write(')').end_line()
}

create_ir_store_array_item_instruction :: (array_value: @IR_Value, index_value: @IR_Value, value: @IR_Value) -> @IR_Store_Array_Item_Instruction {
    instruction := new IR_Store_Array_Item_Instruction(result_value = null)
    instruction.set_operand_value("array_value", array_value)
    instruction.set_operand_value("index_value", index_value)
    instruction.set_operand_value("value", value)
    return instruction
}

get_array_value :: (self: @IR_Store_Array_Item_Instruction) -> @IR_Value {
    return self.operand_values.get("array_value")
}

get_index_value :: (self: @IR_Store_Array_Item_Instruction) -> @IR_Value {
    return self.operand_values.get("index_value")
}

get_value :: (self: @IR_Store_Array_Item_Instruction) -> @IR_Value {
    return self.operand_values.get("value")
}

IR_Store_Struct_Member_Instruction :: struct : IR_Instruction(dump = dump_ir_store_struct_member_instruction) {
    struct_type_member: @IR_Struct_Type_Member
}

dump_ir_store_struct_member_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Store_Struct_Member_Instruction
    return file.write("store_struct_member").write('(').write(instruction.get_struct_pointer_value(), true).write(", ").write(instruction.struct_type_member.name).write(", ").write(instruction.get_value(), true).write(')').end_line()
}

create_ir_store_struct_member_instruction :: (struct_pointer_value: @IR_Value, struct_type_member: @IR_Struct_Type_Member, value: @IR_Value) -> @IR_Store_Struct_Member_Instruction {
    instruction := new IR_Store_Struct_Member_Instruction(result_value = null, struct_type_member = struct_type_member)
    instruction.set_operand_value("struct_pointer_value", struct_pointer_value)
    instruction.set_operand_value("value", value)
    return instruction
}

get_struct_pointer_value :: (self: @IR_Store_Struct_Member_Instruction) -> @IR_Value {
    return self.operand_values.get("struct_pointer_value")
}

get_value :: (self: @IR_Store_Struct_Member_Instruction) -> @IR_Value {
    return self.operand_values.get("value")
}

IR_Binary_Instruction :: struct : IR_Instruction {
}

init :: (self: @IR_Binary_Instruction, left_value: @IR_Value, right_value: @IR_Value) -> @IR_Binary_Instruction {
    self.set_operand_value("left_value", left_value)
    self.set_operand_value("right_value", right_value)
    return self
}

get_left_value :: (self: @IR_Binary_Instruction) -> @IR_Value {
    return self.operand_values.get("left_value")
}

get_right_value :: (self: @IR_Binary_Instruction) -> @IR_Value {
    return self.operand_values.get("right_value")
}

IR_Add_Instruction :: struct : IR_Binary_Instruction(dump = dump_ir_add_instruction) {
}

dump_ir_add_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Binary_Instruction
    return file.write(instruction.get_left_value(), true).write(" + ").write(instruction.get_right_value(), true).end_line()
}

IR_Comparison_Instruction :: struct : IR_Binary_Instruction {
}

IR_Divide_Instruction :: struct : IR_Binary_Instruction(dump = dump_ir_divide_instruction) {
}

dump_ir_divide_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Binary_Instruction
    return file.write(instruction.get_left_value(), true).write(" / ").write(instruction.get_right_value(), true).end_line()
}

IR_Equals_Comparison_Instruction :: struct : IR_Comparison_Instruction(dump = dump_ir_equal_comparison_instruction) {
}

dump_ir_equal_comparison_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Binary_Instruction
    return file.write(instruction.get_left_value(), true).write(" == ").write(instruction.get_right_value(), true).end_line()
}

IR_Greater_Comparison_Instruction :: struct : IR_Comparison_Instruction(dump = dump_ir_greater_comparison_instruction) {
}

dump_ir_greater_comparison_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Binary_Instruction
    return file.write(instruction.get_left_value(), true).write(" > ").write(instruction.get_right_value(), true).end_line()
}

IR_Greater_Or_Equal_Comparison_Instruction :: struct : IR_Comparison_Instruction(dump = dump_ir_greater_or_equal_comparison_instruction) {
}

dump_ir_greater_or_equal_comparison_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Binary_Instruction
    return file.write(instruction.get_left_value(), true).write(" >= ").write(instruction.get_right_value(), true).end_line()
}

IR_Less_Comparison_Instruction :: struct : IR_Comparison_Instruction(dump = dump_ir_less_comparison_instruction) {
}

dump_ir_less_comparison_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Binary_Instruction
    return file.write(instruction.get_left_value(), true).write(" < ").write(instruction.get_right_value(), true).end_line()
}

IR_Less_Or_Equal_Comparison_Instruction :: struct : IR_Comparison_Instruction(dump = dump_ir_less_or_equal_comparison_instruction) {
}

dump_ir_less_or_equal_comparison_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Binary_Instruction
    return file.write(instruction.get_left_value(), true).write(" <= ").write(instruction.get_right_value(), true).end_line()
}

IR_Modulo_Instruction :: struct : IR_Binary_Instruction(dump = dump_ir_modulo_instruction) {
}

dump_ir_modulo_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Binary_Instruction
    return file.write(instruction.get_left_value(), true).write(" // ").write(instruction.get_right_value(), true).end_line()
}

IR_Multiply_Instruction :: struct : IR_Binary_Instruction(dump = dump_ir_multiply_instruction) {
}

dump_ir_multiply_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Binary_Instruction
    return file.write(instruction.get_left_value(), true).write(" * ").write(instruction.get_right_value(), true).end_line()
}

IR_Not_Equal_Comparison_Instruction :: struct : IR_Comparison_Instruction(dump = dump_ir_not_equal_comparison_instruction) {
}

dump_ir_not_equal_comparison_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Binary_Instruction
    return file.write(instruction.get_left_value(), true).write(" != ").write(instruction.get_right_value(), true).end_line()
}

IR_Substract_Instruction :: struct : IR_Binary_Instruction(dump = dump_ir_substract_instruction) {
}

dump_ir_substract_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction := instruction as @IR_Binary_Instruction
    instruction.dump_ir_instruction_result(file, prefix)
    return file.write(instruction.get_left_value(), true).write(" - ").write(instruction.get_right_value(), true).end_line()
}

IR_Phi_Instruction :: struct : IR_Instruction(dump = dump_ir_phi_instruction) {
}

dump_ir_phi_instruction :: (instruction: @IR_Instruction, file: @FILE, prefix: @String) -> @FILE {
    instruction.dump_ir_instruction_result(file, prefix)
    instruction := instruction as @IR_Phi_Instruction
    file.write("phi").write('(')
    operand_values_entry := instruction.operand_values.first_entry
    if (operand_values_entry != null) {
        loop {
            file.write(operand_values_entry.value, true)
            operand_values_entry = operand_values_entry.next_entry
            if (operand_values_entry == null) {
                break
            }
            file.write(", ")
        }
    }
    return file.write(')').end_line()
}

create_ir_phi_instruction :: (result_value: @IR_Variable_Value) -> @IR_Phi_Instruction {
    instruction := new IR_Phi_Instruction(result_value = result_value)
    result_value.creator_instruction = instruction
    return instruction
}

append :: (self: @IR_Phi_Instruction, value: @IR_Value) -> Nothing {
    self.set_operand_value(value, value)
}

is_redundant :: (self: @IR_Phi_Instruction) -> Boolean {
    \ redundant phi instruction:
    \   v.1 = phi(v.2)

    operand_values_entry := self.operand_values.first_entry
    if (operand_values_entry == null) {
        abort()
    }
    other_value := operand_values_entry.value
    operand_values_entry = operand_values_entry.next_entry
    while (operand_values_entry != null) {
        if (operand_values_entry.value != other_value) {
            return false
        }
        operand_values_entry = operand_values_entry.next_entry
    }
    return true
}

is_trivial :: (self: @IR_Phi_Instruction) -> Boolean {
    \ trivial phi instructions:
    \   v.1 = phi(v.1)
    \   v.1 = phi(v.1, v.2)

    operand_values_entry := self.operand_values.first_entry
    if (operand_values_entry == null) {
        abort()
    }
    result_value: @IR_Value = self.result_value
    other_value: @IR_Value = null
    while (operand_values_entry != null) {
        value := operand_values_entry.value
        if (value != result_value) {
            if (value != other_value) {
                if (other_value != null) {
                    return false
                }
                other_value = value
            }
        }
        operand_values_entry = operand_values_entry.next_entry
    }
    return true
}
