include "./Checked_Code.code"

func check(parsed_code: @Parsed_Code) -> @Checked_Code {
    let checker = make Checker(
        parsed_code = parsed_code
        checked_code = make @Checked_Code(
            sources = parsed_code.sources
        )
        local_symbols = undefined
    )
    checker.local_symbols = @checker.global_symbols

    \ add builtin types
    checker.any_type = checker.create_builtin_type_symbol(make @Checked_Any_Type()).type
    checker.bool_type = checker.create_builtin_type_symbol(make @Checked_Bool_Type()).type
    checker.i16_type = checker.create_builtin_type_symbol(make @Checked_Int16_Type()).type
    checker.i32_type = checker.create_builtin_type_symbol(make @Checked_Int32_Type()).type
    checker.i64_type = checker.create_builtin_type_symbol(make @Checked_Int64_Type()).type
    checker.i8_type = checker.create_builtin_type_symbol(make @Checked_Int8_Type()).type
    checker.isize_type = checker.create_builtin_type_symbol(make @Checked_IntMax_Type()).type
    checker.nothing_type = checker.create_builtin_type_symbol(make @Checked_Nothing_Type()).type
    checker.null_type = checker.create_builtin_type_symbol(make @Checked_Null_Type()).type
    checker.u16_type = checker.create_builtin_type_symbol(make @Checked_UInt16_Type()).type
    checker.u32_type = checker.create_builtin_type_symbol(make @Checked_UInt32_Type()).type
    checker.u64_type = checker.create_builtin_type_symbol(make @Checked_UInt64_Type()).type
    checker.u8_type = checker.create_builtin_type_symbol(make @Checked_UInt8_Type()).type
    checker.usize_type = checker.create_builtin_type_symbol(make @Checked_UIntMax_Type()).type
    checker.undefined_type = checker.create_builtin_type_symbol(make @Checked_Undefined_Type()).type

    checker.check(parsed_code)

    return checker.checked_code
}

struct Checker {
    parsed_code: @Parsed_Code
    checked_code: @Checked_Code

    global_symbols = make Checked_Symbols(parent = null)
    local_symbols: @Checked_Symbols

    expected_return_type: @Checked_Type = null

    generic_struct_statements = make Map[@String, @Parsed_Generic_Struct_Statement]()
    generic_function_statements = make List[@Parsed_Function_Statement]()
    macro_statements = make List[@Parsed_Macro_Statement]()

    any_type: @Checked_Type = undefined
    bool_type: @Checked_Type = undefined
    i16_type: @Checked_Type = undefined
    i32_type: @Checked_Type = undefined
    i64_type: @Checked_Type = undefined
    i8_type: @Checked_Type = undefined
    isize_type: @Checked_Type = undefined
    nothing_type: @Checked_Type = undefined
    null_type: @Checked_Type = undefined
    u16_type: @Checked_Type = undefined
    u32_type: @Checked_Type = undefined
    u64_type: @Checked_Type = undefined
    u8_type: @Checked_Type = undefined
    usize_type: @Checked_Type = undefined
    undefined_type: @Checked_Type = undefined
}

func create_builtin_type_symbol(self: @Checker, type: @Checked_Builtin_Type) -> @Checked_Builtin_Type_Symbol {
    let checked_builtin_type_symbol = make @Checked_Builtin_Type_Symbol(
        location = null
        name = type.name
        type = type
    )
    self.global_symbols.append(checked_builtin_type_symbol)
    return checked_builtin_type_symbol
}

func check(self: @Checker, parsed_code: @Parsed_Code) -> Nothing {
    DEBUG = false

    \ collect all generic struct statements
    parsed_code.statements.for_each() {
        if it is Parsed_Generic_Struct_Statement {
            \ generic structs are checked only during specialization
            let parsed_generic_struct_statement = it.as(@Parsed_Generic_Struct_Statement)
            if self.generic_struct_statements.has(parsed_generic_struct_statement.name.lexeme) {
                abort(it.location, "TODO: Report duplicate generic type error")
            }
            self.generic_struct_statements.put(parsed_generic_struct_statement.name.lexeme, parsed_generic_struct_statement)
        }
    }

    let constants = make List[@Checked_Constant_Symbol]()

    \ create root statements
    parsed_code.statements.for_each() {
        if it is Parsed_Constant_Statement {
            let checked_constant_symbol = self.create_constant_symbol(it.as(@Parsed_Constant_Statement))
            constants.append(checked_constant_symbol)
        } else if it is Parsed_External_Type_Statement {
            self.create_opaque_type_symbol(it.as(@Parsed_External_Type_Statement))
        } else if it is Parsed_Function_Statement {
            let parsed_function_statement = it.as(@Parsed_Function_Statement)
            if parsed_function_statement.type.type_parameters != null {
                \ generic functions are checked only during specialization
                self.generic_function_statements.append(parsed_function_statement)
            } else {
                self.create_function_symbol(parsed_function_statement, null)
            }
        } else if it is Parsed_Generic_Struct_Statement {
            \ already processed
        } else if it is Parsed_Macro_Statement {
            let parsed_macro_statement = it.as(@Parsed_Macro_Statement)
            self.macro_statements.append(parsed_macro_statement)
            self.global_symbols.append(make @Checked_Macro_Symbol(
                location = parsed_macro_statement.location
                name = parsed_macro_statement.name.lexeme
                type = make @Checked_Lazy_Macro_Type()
                parsed_macro_statement = parsed_macro_statement
            ))
        } else if it is Parsed_Struct_Statement {
            let parsed_struct_statement = it.as(@Parsed_Struct_Statement)
            self.create_struct_type_symbol(parsed_struct_statement, parsed_struct_statement.name.lexeme, null)
        } else if it is Parsed_Variable_Statement {
            let checked_statement = self.check_variable_statement(it.as(@Parsed_Variable_Statement))
            let variable = checked_statement.variable
            if variable.expression != null {
                if not variable.expression.is_constant() {
                    abort(variable.expression.location, "Not a constant expression")
                }
                if variable.expression.type is not Checked_Undefined_Type {
                    abort(variable.expression.location, "Initialized global variables are not yet supported")
                }
            }
            self.checked_code.global_symbols.put(variable.name, variable)
            self.global_symbols.append(variable)
        } else {
            abort(it.location, it.object_type)
        }
    }

    \ check constants
    constants.for_each() {
        if it.type == null {
            self.check_constant_symbol(it)
        }
    }

    \ check functions
    self.checked_code.functions.for_each() {
        if it.parsed_function_statement.body != null {
            self.check_function_symbol(it)
        }
    }
}

func create_constant_symbol(self: @Checker, parsed_constant_statement: @Parsed_Constant_Statement) -> @Checked_Constant_Symbol {
    let checked_constant_symbol = make @Checked_Constant_Symbol(
        location = parsed_constant_statement.name.location
        name = parsed_constant_statement.name.lexeme
        type = null
        parsed_constant_statement = parsed_constant_statement
        value_expression = null
    )
    self.local_symbols.append(checked_constant_symbol)

    return checked_constant_symbol
}

func check_constant_symbol(self: @Checker, checked_constant_symbol: @Checked_Constant_Symbol) -> Nothing {
    let checked_value_expression = self.check_expression(checked_constant_symbol.parsed_constant_statement.expression, null)
    if not checked_value_expression.is_constant() {
        abort(checked_value_expression.location, "Not a constant expression")
    }

    checked_constant_symbol.type = checked_value_expression.type
    checked_constant_symbol.value_expression = checked_value_expression
}

func create_function_symbol(self: @Checker, parsed_function_statement: @Parsed_Function_Statement, specialization_symbols: @Checked_Symbols) -> @Checked_Function_Symbol {
    \ create function type
    let parent_symbols = self.local_symbols
    if specialization_symbols != null {
        self.local_symbols = specialization_symbols
    }
    let checked_function_type = self.convert_function_type(parsed_function_statement.type)
    self.local_symbols = parent_symbols

    \ check for duplicates
    self.checked_code.functions.for_each() {
        if it.name.equals(parsed_function_statement.name) {
            abort(parsed_function_statement.location, "TODO: Compare function types")
        }
    }

    \ create function
    let checked_function_symbol = make @Checked_Function_Symbol(
        location = parsed_function_statement.location
        name = parsed_function_statement.name.lexeme
        type = make_checked_function_pointer_type(checked_function_type)
        function_type = checked_function_type

        parsed_function_statement = parsed_function_statement
        specialization_symbols = specialization_symbols
        body = null
    )

    let global_symbol_id: @String
    if parsed_function_statement.is_anonymous {
        abort(parsed_function_statement.location, "TODO: Create unique function name")
    } else {
        self.global_symbols.append(checked_function_symbol)

        global_symbol_id = checked_function_symbol.name.clone()
    }
    global_symbol_id.append(": ").append(checked_function_type.name)

    self.checked_code.global_symbols.put(global_symbol_id, checked_function_symbol)
    self.checked_code.functions.append(checked_function_symbol)

    return checked_function_symbol
}

func check_function_symbol(self: @Checker, checked_function_symbol: @Checked_Function_Symbol) -> Nothing {
    let parsed_function_statement = checked_function_symbol.parsed_function_statement

    \ remember parent symbols
    let parent_symbols = self.local_symbols
    if checked_function_symbol.specialization_symbols != null {
        self.local_symbols = checked_function_symbol.specialization_symbols
    }

    \ create function context
    self.local_symbols = make @Checked_Symbols(
        parent = self.local_symbols
    )
    let checked_function_type = checked_function_symbol.function_type
    checked_function_type.parameters.for_each() {
        self.local_symbols.append(make @Checked_Parameter_Symbol(
            location = it.location
            name = it.name
            type = it.type
        ))
    }

    \ check function body
    self.expected_return_type = checked_function_type.return_type
    checked_function_symbol.body = self.check_block_statement(parsed_function_statement.body)
    self.expected_return_type = null

    \ restore context
    self.local_symbols = parent_symbols
}

func create_struct_type_symbol(self: @Checker, parsed_struct_statement: @Parsed_Struct_Statement, checked_struct_name: @String, specialization_symbols: @Checked_Symbols) -> @Checked_Struct_Type_Symbol {
    \ check for uniqueness
    let checked_symbol = self.checked_code.global_symbols.get(checked_struct_name)
    if checked_symbol != null {
        if checked_symbol is not Checked_Struct_Type_Symbol {
            abort(parsed_struct_statement.location, clone("Duplicate declaration: ").append(checked_struct_name))
        }
        return checked_symbol.as(@Checked_Struct_Type_Symbol)
    }

    \ create struct type
    let checked_struct_type: @Checked_Struct_Type
    if specialization_symbols != null {
        checked_struct_type = make @Checked_Specialized_Struct_Type(
            name = checked_struct_name
            is_checked_type = false
            generic_struct_name = parsed_struct_statement.name.lexeme
            specialization_symbols = specialization_symbols
        )
    } else {
        checked_struct_type = make @Checked_Struct_Type(
            name = checked_struct_name
            is_checked_type = false
        )
    }

    \ create struct symbol
    let checked_struct_type_symbol = make @Checked_Struct_Type_Symbol(
        location = parsed_struct_statement.name.location
        name = checked_struct_name
        type = checked_struct_type
        parsed_struct_statement = parsed_struct_statement
    )
    self.checked_code.global_symbols.put(checked_struct_name, checked_struct_type_symbol)
    self.global_symbols.append(checked_struct_type_symbol)

    return checked_struct_type_symbol
}

func check_struct_type_symbol(self: @Checker, checked_struct_type_symbol: @Checked_Struct_Type_Symbol) -> Nothing {
    let checked_struct_type = checked_struct_type_symbol.type.as(@Checked_Struct_Type)
    let parsed_struct_statement = checked_struct_type_symbol.parsed_struct_statement

    \ create type context
    let local_symbols = self.local_symbols
    if checked_struct_type is Checked_Specialized_Struct_Type {
        \ apply specialization type
        self.local_symbols = checked_struct_type.as(@Checked_Specialized_Struct_Type).specialization_symbols
    }

    \ check super type
    if parsed_struct_statement.super_type != null {
        let checked_super_type = self.convert_type(parsed_struct_statement.super_type)
        self.check_type(checked_super_type)
        if checked_super_type is not Checked_Struct_Type {
            abort(parsed_struct_statement.super_type.location, "Not a struct type")
        }
        let checked_super_type = checked_super_type.as(@Checked_Struct_Type)
        if checked_super_type == checked_struct_type or checked_super_type.has_super_type(checked_struct_type) {
            abort(parsed_struct_statement.super_type.location, "Type recursivity")
        }

        checked_struct_type.super_type = checked_super_type
        checked_super_type.derived_types.append(checked_struct_type)

        parsed_struct_statement.super_arguments.for_each() {
            \ check super argument
            if it.name == null {
                abort(it.location, "Missing member name")
            }
            let checked_struct_member = checked_super_type.get_member(it.name.lexeme)
            if checked_struct_member == null {
                abort(it.name.location, "TODO: List super type members")
            }
            if checked_struct_type.default_values.has(checked_struct_member) {
                abort("TODO: Handle error")
            }
            let checked_expression = self.check_expression(it.value_expression, checked_struct_member.type)
            checked_struct_type.default_values.put(checked_struct_member, checked_expression)
        }
    }

    \ check struct members
    if parsed_struct_statement.members != null {
        parsed_struct_statement.members.for_each() {
            let parsed_struct_member = it
            let checked_struct_member_name = parsed_struct_member.name.lexeme
            if checked_struct_member_name.equals("super") {
                abort(parsed_struct_member.name.location, "'super' cannot be used as member name")
            }
            let checked_struct_member_type: @Checked_Type = null
            if parsed_struct_member.type != null {
                checked_struct_member_type = self.convert_type(parsed_struct_member.type)
                if checked_struct_member_type is Checked_Function_Type {
                    checked_struct_member_type = make_checked_function_pointer_type(checked_struct_member_type.as(@Checked_Function_Type))
                }
            }
            let checked_struct_member_value_expression: @Checked_Expression = null
            if parsed_struct_member.default_value_expression != null {
                checked_struct_member_value_expression = self.check_expression(parsed_struct_member.default_value_expression, checked_struct_member_type)
                if checked_struct_member_type != null {
                    if not checked_struct_member_type.accepts(checked_struct_member_value_expression.type) {
                        abort(checked_struct_member_value_expression.location, clone("Cannot assign a '").append(checked_struct_member_value_expression.type.name).append("' value to a '").append(checked_struct_member_type.name).append("' struct member"))
                    }
                    if checked_struct_member_type.equals(checked_struct_member_value_expression.type) and not self.is_specialization_type(parsed_struct_member.type) {
                        stderr.write(parsed_struct_member.type.location).write(": ").warning().write("Redundant type declaration").reset().end_line()
                    }
                } else {
                    if checked_struct_member_value_expression.type is Checked_Null_Type {
                        abort(checked_struct_member_value_expression.location, clone("Cannot infer type from a null value"))
                    }
                    if checked_struct_member_value_expression.type is Checked_Undefined_Type {
                        abort(checked_struct_member_value_expression.location, clone("Cannot infer type from an undefined value"))
                    }
                    checked_struct_member_type = checked_struct_member_value_expression.type
                }
            }
            if checked_struct_member_type == null {
                abort(parsed_struct_member.name.location, "Cannot infer type of struct member")
            }
            if checked_struct_member_type is Checked_Struct_Type {
                let checked_struct_member_type = checked_struct_member_type.as(@Checked_Struct_Type)
                if checked_struct_member_type == checked_struct_type or checked_struct_member_type.has_super_type(checked_struct_type) {
                    abort(parsed_struct_member.type.location, "Type recursivity")
                }
            }
            checked_struct_type.add_member(parsed_struct_member.location, checked_struct_member_name, checked_struct_member_type, checked_struct_member_value_expression)
        }
    }

    \ restore type context
    self.local_symbols = local_symbols
}

func create_opaque_type_symbol(self: @Checker, parsed_statement: @Parsed_External_Type_Statement) -> @Checked_Opaque_Type_Symbol {
    let checked_opaque_type_name = parsed_statement.name.lexeme

    \ check for uniqueness
    let checked_symbol = self.checked_code.global_symbols.get(checked_opaque_type_name)
    if checked_symbol != null {
        if checked_symbol.location != parsed_statement.name.location or checked_symbol is not Checked_Opaque_Type_Symbol {
            abort(parsed_statement.location, clone("Duplicate declaration: ").append(checked_opaque_type_name))
        }
        return checked_symbol.as(@Checked_Opaque_Type_Symbol)
    }

    \ create opaque type
    let checked_opaque_type = make @Checked_Opaque_Type(
        name = checked_opaque_type_name
    )

    \ create opaque type symbol
    let checked_opaque_type_symbol = make @Checked_Opaque_Type_Symbol(
        location = parsed_statement.name.location
        name = checked_opaque_type_name
        type = checked_opaque_type
    )
    self.checked_code.global_symbols.put(checked_opaque_type_name, checked_opaque_type_symbol)
    self.global_symbols.append(checked_opaque_type_symbol)

    return checked_opaque_type_symbol
}

func check_statement(self: @Checker, parsed_statement: @Parsed_Statement) -> @Checked_Statement {
    if parsed_statement is Parsed_Assignment_Statement {
        return self.check_assignment_statement(parsed_statement.as(@Parsed_Assignment_Statement))
    }
    if parsed_statement is Parsed_Block_Statement {
        return self.check_block_statement(parsed_statement.as(@Parsed_Block_Statement))
    }
    if parsed_statement is Parsed_Break_Statement {
        return self.check_break_statement(parsed_statement.as(@Parsed_Break_Statement))
    }
    if parsed_statement is Parsed_Constant_Statement {
        let checked_constant_symbol = self.create_constant_symbol(parsed_statement.as(@Parsed_Constant_Statement))
        self.check_constant_symbol(checked_constant_symbol)
        return make @Checked_Ignored_Statement(
            location = parsed_statement.location
        )
    }
    if parsed_statement is Parsed_Expression_Statement {
        return self.check_expression_statement(parsed_statement.as(@Parsed_Expression_Statement))
    }
    if parsed_statement is Parsed_If_Statement {
        return self.check_if_statement(parsed_statement.as(@Parsed_If_Statement))
    }
    if parsed_statement is Parsed_Loop_Statement {
        return self.check_loop_statement(parsed_statement.as(@Parsed_Loop_Statement))
    }
    if parsed_statement is Parsed_Return_Statement {
        return self.check_return_statement(parsed_statement.as(@Parsed_Return_Statement))
    }
    if parsed_statement is Parsed_Variable_Statement {
        return self.check_variable_statement(parsed_statement.as(@Parsed_Variable_Statement))
    }
    if parsed_statement is Parsed_While_Statement {
        return self.check_while_statement(parsed_statement.as(@Parsed_While_Statement))
    }
    abort(parsed_statement.location, parsed_statement.object_type)
}

func check_assignment_statement(self: @Checker, parsed_statement: @Parsed_Assignment_Statement) -> @Checked_Statement {
    let checked_destination_expression = self.check_expression(parsed_statement.storage_expression, null)
    if checked_destination_expression.type is Checked_Struct_Type {
        abort(parsed_statement.location, "Struct assignement is currently not supported")
    }
    if checked_destination_expression is Checked_Array_Access_Expression or checked_destination_expression is Checked_Member_Access_Expression {
        return make @Checked_Assignment_Statement(
            location = parsed_statement.location
            destination_expression = checked_destination_expression
            value_expression = self.check_expression(parsed_statement.value_expression, checked_destination_expression.type)
        )
    }
    if checked_destination_expression is Checked_Symbol_Expression {
        let checked_symbol = checked_destination_expression.as(@Checked_Symbol_Expression).symbol
        if checked_symbol is Checked_Variable_Symbol or checked_symbol is Checked_Parameter_Symbol {
            return make @Checked_Assignment_Statement(
                location = parsed_statement.location
                destination_expression = checked_destination_expression
                value_expression = self.check_expression(parsed_statement.value_expression, checked_destination_expression.type)
            )
        }
        abort(checked_destination_expression.location, checked_symbol.object_type)
    }
    abort(checked_destination_expression.location, checked_destination_expression.object_type)
}

func check_block_statement(self: @Checker, parsed_statement: @Parsed_Block_Statement) -> @Checked_Block_Statement {
    \ remember parent symbols
    let parent_symbols = self.local_symbols

    \ create block symbols
    self.local_symbols = make @Checked_Symbols(
        parent = parent_symbols
    )

    \ check block
    let checked_statement = make @Checked_Block_Statement(
        location = parsed_statement.location
        local_symbols = self.local_symbols
    )
    parsed_statement.statements.for_each() {
        checked_statement.statements.append(self.check_statement(it))
    }

    \ restore parent symbols
    self.local_symbols = parent_symbols

    return checked_statement
}

func check_break_statement(self: @Checker, parsed_statement: @Parsed_Break_Statement) -> @Checked_Statement {
    \ TODO: Check if break is inside a loop or while statement
    return make @Checked_Break_Statement(
        location = parsed_statement.location
    )
}

func check_expression_statement(self: @Checker, parsed_statement: @Parsed_Expression_Statement) -> @Checked_Statement {
    let checked_expression = self.check_expression(parsed_statement.expression, null)
    if checked_expression.type is not Checked_Nothing_Type {
        \ TODO: Report error once `discard` statement is implemented
        \ abort(checked_expression.location, "Unhandled value")
    }
    if checked_expression is Checked_Macro_Call_Expression {
        return self.inline_macro_call_expression(checked_expression.as(@Checked_Macro_Call_Expression))
    }
    return make @Checked_Expression_Statement(
        location = parsed_statement.location
        expression = checked_expression
    )
}

func check_if_statement(self: @Checker, parsed_statement: @Parsed_If_Statement) -> @Checked_Statement {
    let checked_condition_expression = self.check_expression(parsed_statement.condition_expression, self.bool_type)
    let checked_true_statement = self.check_statement(parsed_statement.true_statement)
    let checked_false_statement: @Checked_Statement = null
    if parsed_statement.false_statement != null {
        checked_false_statement = self.check_statement(parsed_statement.true_statement)
    }
    return make @Checked_If_Statement(
        location = parsed_statement.location
        condition_expression = checked_condition_expression
        true_statement = checked_true_statement
        false_statement = checked_false_statement
    )
}

func check_loop_statement(self: @Checker, parsed_statement: @Parsed_Loop_Statement) -> @Checked_Statement {
    let checked_body_statement = self.check_statement(parsed_statement.body_statement)
    return make @Checked_Loop_Statement(
        location = parsed_statement.location
        body_statement = checked_body_statement
    )
}

func check_return_statement(self: @Checker, parsed_statement: @Parsed_Return_Statement) -> @Checked_Statement {
    let checked_expression: @Checked_Expression = null
    if parsed_statement.value_expression != null {
        checked_expression = self.check_expression(parsed_statement.value_expression, self.expected_return_type)
        if checked_expression.type is Checked_Undefined_Type {
            abort(parsed_statement.value_expression.location, "Returned expression cannot be ".clone().append(checked_expression.type.name))
        }
    } else if self.expected_return_type != null {
        abort(parsed_statement.location, "Missing return expression")
    }
    return make @Checked_Return_Statement(
        location = parsed_statement.location
        expression = checked_expression
    )
}

func check_variable_statement(self: @Checker, parsed_statement: @Parsed_Variable_Statement) -> @Checked_Variable_Statement {
    \ check variable type
    let checked_type: @Checked_Type = null
    if parsed_statement.type != null {
        checked_type = self.convert_type(parsed_statement.type)
        if checked_type is Checked_Opaque_Type {
            abort(parsed_statement.type.location, "Variable cannot have an opaque type")
        }
        if checked_type is Checked_Any_Type or checked_type is Checked_Nothing_Type {
            abort(parsed_statement.type.location, "Variable cannot have the ".clone().append(checked_type.name).append(" type"))
        }
        if checked_type is Checked_Function_Type {
            \ make function pointer type
            checked_type = make_checked_function_pointer_type(checked_type.as(@Checked_Function_Type))
        }
    }

    \ check variable expression
    let checked_expression: @Checked_Expression = null
    if parsed_statement.value_expression != null {
        checked_expression = self.check_expression(parsed_statement.value_expression, checked_type)
        if checked_type == null {
            checked_type = checked_expression.type
            if checked_type is Checked_Null_Type {
                abort(checked_expression.location, "Cannot infer variable type from null value")
            }
            if checked_type is Checked_Undefined_Type {
                abort(checked_expression.location, "Cannot infer variable type from undefined value")
            }
        } else {
            if not checked_type.accepts(checked_expression.type) {
                abort(checked_expression.location, "Cannot assign a '".clone().append(checked_expression.type.name).append("' value to a '").append(checked_type.name).append("' variable"))
            }
            if checked_type.equals(checked_expression.type) and not self.is_specialization_type(parsed_statement.type) {
                stderr.write(parsed_statement.type.location).write(": ").warning().write("Redundant type declaration").reset().end_line()
            }
        }
    } else if not parsed_statement.is_external and checked_type == null {
        abort(parsed_statement.location, "Missing variable type")
    }

    \ create variable statement
    let checked_statement = make @Checked_Variable_Statement(
        location = parsed_statement.location
        variable = make @Checked_Variable_Symbol(
            location = parsed_statement.name.location
            name = parsed_statement.name.lexeme
            type = checked_type
            expression = checked_expression
        )
    )
    self.local_symbols.append(checked_statement.variable)

    return checked_statement
}

func check_while_statement(self: @Checker, parsed_statement: @Parsed_While_Statement) -> @Checked_Statement {
    let checked_condition_expression = self.check_expression(parsed_statement.condition_expression, self.bool_type)
    let checked_body_statement = self.check_statement(parsed_statement.body_statement)
    return make @Checked_While_Statement(
        location = parsed_statement.location
        condition_expression = checked_condition_expression
        body_statement = checked_body_statement
    )
}

func check_expression(self: @Checker, parsed_expression: @Parsed_Expression, expected_type: @Checked_Type) -> @Checked_Expression {
    let checked_expression: @Checked_Expression
    if parsed_expression is Parsed_Add_Expression {
        checked_expression = self.check_add_expression(parsed_expression.as(@Parsed_Add_Expression))
    } else if parsed_expression is Parsed_Array_Access_Expression {
        checked_expression = self.check_array_access_expression(parsed_expression.as(@Parsed_Array_Access_Expression))
    } else if parsed_expression is Parsed_Call_Expression {
        checked_expression = self.check_call_expression(parsed_expression.as(@Parsed_Call_Expression))
    } else if parsed_expression is Parsed_Cast_Expression {
        checked_expression = self.check_cast_expression(parsed_expression.as(@Parsed_Cast_Expression))
    } else if parsed_expression is Parsed_Divide_Expression {
        checked_expression = self.check_divide_expression(parsed_expression.as(@Parsed_Divide_Expression))
    } else if parsed_expression is Parsed_Equals_Expression {
        checked_expression = self.check_equals_expression(parsed_expression.as(@Parsed_Equals_Expression))
    } else if parsed_expression is Parsed_Function_Expression {
        checked_expression = self.check_function_expression(parsed_expression.as(@Parsed_Function_Expression))
    } else if parsed_expression is Parsed_Greater_Than_Expression {
        checked_expression = self.check_greater_than_expression(parsed_expression.as(@Parsed_Greater_Than_Expression))
    } else if parsed_expression is Parsed_Greater_Than_Or_Equals_Expression {
        checked_expression = self.check_greater_than_or_equal_expression(parsed_expression.as(@Parsed_Greater_Than_Or_Equals_Expression))
    } else if parsed_expression is Parsed_Is_Expression {
        checked_expression = self.check_is_expression(parsed_expression.as(@Parsed_Is_Expression))
    } else if parsed_expression is Parsed_Less_Than_Expression {
        checked_expression = self.check_less_than_expression(parsed_expression.as(@Parsed_Less_Than_Expression))
    } else if parsed_expression is Parsed_Less_Than_Or_Equals_Expression {
        checked_expression = self.check_less_than_or_equal_expression(parsed_expression.as(@Parsed_Less_Than_Or_Equals_Expression))
    } else if parsed_expression is Parsed_Literal_Expression {
        checked_expression = self.check_literal_expression(parsed_expression.as(@Parsed_Literal_Expression), expected_type)
    } else if parsed_expression is Parsed_Logic_And_Expression {
        checked_expression = self.check_logic_and_expression(parsed_expression.as(@Parsed_Logic_And_Expression))
    } else if parsed_expression is Parsed_Logic_Not_Expression {
        checked_expression = self.check_logic_not_expression(parsed_expression.as(@Parsed_Logic_Not_Expression))
    } else if parsed_expression is Parsed_Logic_Or_Expression {
        checked_expression = self.check_logic_or_expression(parsed_expression.as(@Parsed_Logic_Or_Expression))
    } else if parsed_expression is Parsed_Macro_Body {
        checked_expression = self.check_macro_body(parsed_expression.as(@Parsed_Macro_Body))
    } else if parsed_expression is Parsed_Make_Expression {
        checked_expression = self.check_make_expression(parsed_expression.as(@Parsed_Make_Expression))
    } else if parsed_expression is Parsed_Member_Access_Expression {
        checked_expression = self.check_member_access_expression(parsed_expression.as(@Parsed_Member_Access_Expression))
    } else if parsed_expression is Parsed_Modulo_Expression {
        checked_expression = self.check_modulo_expression(parsed_expression.as(@Parsed_Modulo_Expression))
    } else if parsed_expression is Parsed_Multiply_Expression {
        checked_expression = self.check_multiply_expression(parsed_expression.as(@Parsed_Multiply_Expression))
    } else if parsed_expression is Parsed_Negate_Expression {
        checked_expression = self.check_negate_expression(parsed_expression.as(@Parsed_Negate_Expression))
    } else if parsed_expression is Parsed_Not_Equals_Expression {
        checked_expression = self.check_not_equals_expression(parsed_expression.as(@Parsed_Not_Equals_Expression))
    } else if parsed_expression is Parsed_Paren_Expression {
        checked_expression = self.check_expression(parsed_expression.as(@Parsed_Paren_Expression).expression, expected_type)
    } else if parsed_expression is Parsed_Substract_Expression {
        checked_expression = self.check_substract_expression(parsed_expression.as(@Parsed_Substract_Expression))
    } else if parsed_expression is Parsed_Symbol_Expression {
        checked_expression = self.check_symbol_expression(parsed_expression.as(@Parsed_Symbol_Expression))
    } else if parsed_expression is Parsed_Variable_Reference_Expression {
        checked_expression = self.check_variable_reference_expression(parsed_expression.as(@Parsed_Variable_Reference_Expression))
    } else if parsed_expression is Parsed_Wrapped_Expression {
        checked_expression = self.check_expression(parsed_expression.as(@Parsed_Wrapped_Expression).expression, expected_type)
    } else {
        abort(parsed_expression.location, parsed_expression.object_type)
    }

    self.check_type(checked_expression.type)

    if expected_type != null and not expected_type.accepts(checked_expression.type) {
        abort(parsed_expression.location, "Incompatible types: got ".clone().append(checked_expression.type.name).append(" instead of ").append(expected_type.name))
    }

    return checked_expression
}

func check_type(self: @Checker, checked_type: @Checked_Type) -> Nothing {
    if checked_type.is_checked_type {
        return
    }

    checked_type.is_checked_type = true
    if checked_type is Checked_Fixed_Array_Type {
        self.check_type(checked_type.as(@Checked_Fixed_Array_Type).item_type)
    } else if checked_type is Checked_Pointer_Type {
        self.check_type(checked_type.as(@Checked_Pointer_Type).pointed_type)
    } else if checked_type is Checked_Struct_Type {
        let checked_type_symbol = self.local_symbols.find_type_symbol(checked_type.name)
        self.check_struct_type_symbol(checked_type_symbol.as(@Checked_Struct_Type_Symbol))
    } else if checked_type is Checked_Unchecked_Array_Type {
        self.check_type(checked_type.as(@Checked_Unchecked_Array_Type).item_type)
    } else {
        abort(checked_type.object_type)
    }
}

func check_add_expression(self: @Checker, parsed_expression: @Parsed_Add_Expression) -> @Checked_Expression {
    let left_expression = self.check_expression(parsed_expression.left_expression, null)
    if left_expression.type is not Checked_Integer_Type {
        abort(parsed_expression.left_expression.location, "Not an integer value")
    }
    let right_expression = self.check_expression(parsed_expression.right_expression, left_expression.type)
    return make @Checked_Add_Expression(
        location = parsed_expression.location
        type = left_expression.type
        left_expression = left_expression
        right_expression = right_expression
    )
}

func check_array_access_expression(self: @Checker, parsed_expression: @Parsed_Array_Access_Expression) -> @Checked_Expression {
    \ check array expression
    let checked_array_expression = self.check_expression(parsed_expression.array_expression, null)
    let checked_array_type = checked_array_expression.type
    if checked_array_type is not Checked_Array_Type {
        abort(checked_array_expression.location, "Not an array type")
    }
    let checked_array_type = checked_array_type.as(@Checked_Array_Type)

    \ check index expression
    let checked_index_expression = self.check_expression(parsed_expression.index_expression, null)
    if checked_index_expression.type is not Checked_Integer_Type {
        abort(checked_index_expression.location, "Not an integer expression")
    }

    if checked_array_type.item_type is Checked_Struct_Type {
        \ create reference expression
        return make @Checked_Array_Access_Expression(
            location = parsed_expression.location
            type = make_checked_pointer_type(checked_array_type.item_type)
            array_expression = checked_array_expression
            index_expression = checked_index_expression
        )
    }

    \ create value expression
    return make @Checked_Array_Access_Expression(
        location = parsed_expression.location
        type = checked_array_type.item_type
        array_expression = checked_array_expression
        index_expression = checked_index_expression
    )
}

func check_call_expression(self: @Checker, parsed_expression: @Parsed_Call_Expression) -> @Checked_Expression {
    let parsed_callee_expression = parsed_expression.callee_expression

    \ check call arguments
    let checked_call_arguments = make @List[@Checked_Call_Argument]()
    parsed_expression.arguments.for_each() {
        let parsed_call_argument = it
        let checked_call_argument_name: @String = null
        if parsed_call_argument.name != null {
            checked_call_argument_name = parsed_call_argument.name.lexeme
            \ check for duplicate named arguments
            checked_call_arguments.for_each() {
                let checked_call_argument = it
                if checked_call_argument.name != null and checked_call_argument.name.equals(checked_call_argument_name) {
                    abort(parsed_expression.location, "Duplicate argument name")
                }
            }
        }
        let checked_call_argument_expression = self.check_expression(parsed_call_argument.value_expression, null)
        checked_call_arguments.append(make @Checked_Call_Argument(
            location = parsed_call_argument.location
            name = checked_call_argument_name
            expression = checked_call_argument_expression
        ))
    }

    \ treat Parsed_Member_Access_Expression specially
    if parsed_callee_expression is Parsed_Member_Access_Expression {
        \ we have a foo.bar(...) call which needs special attention
        let parsed_member_access_expression = parsed_callee_expression.as(@Parsed_Member_Access_Expression)
        let parsed_member_name = parsed_member_access_expression.member_name.lexeme

        \ check object expression
        let checked_object_expression = self.check_expression(parsed_member_access_expression.object_expression, null)
        let checked_object_type = checked_object_expression.type
        if checked_object_type is Checked_Pointer_Type {
            checked_object_type = checked_object_type.as(@Checked_Pointer_Type).pointed_type
        }
        if checked_object_type is Checked_Struct_Type {
            \ add object reference as first call argument
            checked_call_arguments.prepend(make @Checked_Call_Argument(
                location = checked_object_expression.location
                name = null
                expression = make @Checked_Reference_Expression( \ struct objects have always an address
                    location = checked_object_expression.location
                    type = make_checked_pointer_type(checked_object_type)
                    object_expression = checked_object_expression
                )
            ))

            let checked_object_type = checked_object_type.as(@Checked_Struct_Type)
            let checked_struct_member = checked_object_type.get_member(parsed_member_name)
            if checked_struct_member != null and checked_struct_member.type is Checked_Function_Pointer_Type {
                \ create member call
                let checked_function_type = checked_struct_member.type.as(@Checked_Function_Pointer_Type).function_type
                if checked_function_type.accepts(checked_call_arguments) {
                    return make @Checked_Dynamic_Call_Expression(
                        location = parsed_expression.location
                        type = checked_function_type.return_type
                        call_arguments = checked_call_arguments
                        callee_expression = make @Checked_Member_Access_Expression(
                            location = parsed_expression.location
                            type = checked_struct_member.type
                            object_expression = checked_object_expression
                            struct_member = checked_struct_member
                        )
                    )
                }
                abort(parsed_member_access_expression.member_name.location, "Cannot call member of type: ".clone().append(checked_struct_member.type.name))
            }
        } else {
            \ add object as first call argument
            checked_call_arguments.prepend(make @Checked_Call_Argument(
                location = checked_object_expression.location
                name = null
                expression = checked_object_expression
            ))
        }

        \ treat as uniform callable call syntax
        return self.check_callable_call_expression(parsed_member_access_expression.member_name, checked_call_arguments)
    }

    \ check callee expression
    let checked_callee_expression = self.check_expression(parsed_callee_expression, null)
    if checked_callee_expression is Checked_Symbol_Expression {
        \ we have a `baz(...)` call
        let checked_callee_expression = checked_callee_expression.as(@Checked_Symbol_Expression)
        let checked_symbol = checked_callee_expression.symbol

        \ dynamic calls have highest priority
        if checked_symbol is Checked_Variable_Symbol or checked_symbol is Checked_Parameter_Symbol {
            let checked_symbol_type = checked_symbol.type
            if checked_symbol_type is Checked_Pointer_Type {
                let checked_symbol_type = checked_symbol_type.as(@Checked_Pointer_Type)
                if checked_symbol_type.pointed_type is Checked_Function_Type {
                    let checked_function_type = checked_symbol_type.pointed_type.as(@Checked_Function_Type)
                    if not checked_function_type.accepts(checked_call_arguments) {
                        abort(parsed_expression.location, "TODO: Report call arguments error")
                    }
                    return make @Checked_Dynamic_Call_Expression(
                        location = parsed_expression.location
                        type = checked_function_type.return_type
                        call_arguments = checked_call_arguments
                        callee_expression = checked_callee_expression
                    )
                }
            }
            abort(parsed_expression.location, "TODO: Report non-callable symbol error")
        }
        if checked_symbol is Checked_Macro_Parameter_Symbol {
            let checked_symbol = checked_symbol.as(@Checked_Macro_Parameter_Symbol)
            \ create macro call expression to be inlined at the statement level
            return make @Checked_Macro_Call_Expression(
                location = parsed_callee_expression.location
                type = self.nothing_type
                parsed_macro_type = checked_symbol.parsed_macro_type
                parsed_macro_body = checked_symbol.parsed_macro_body
                specialization_symbols = checked_symbol.local_symbols
                call_arguments = checked_call_arguments
            )
        }

        \ should be a callable symbol
        if checked_symbol is Checked_Function_Symbol or checked_symbol is Checked_Macro_Symbol or checked_symbol is Checked_Generic_Function_Symbol {
            if parsed_callee_expression is not Parsed_Symbol_Expression {
                abort(parsed_callee_expression.location, parsed_callee_expression.object_type)
            }
            return self.check_callable_call_expression(parsed_callee_expression.as(@Parsed_Symbol_Expression).name, checked_call_arguments)
        }

        \ unsupported symbol
        abort(checked_symbol.location, checked_symbol.object_type)
    }

    abort(checked_callee_expression.location, checked_callee_expression.object_type)
}

func check_cast_expression(self: @Checker, parsed_expression: @Parsed_Cast_Expression) -> @Checked_Expression {
    let checked_expression = self.check_expression(parsed_expression.value_expression, null)
    let checked_type = self.convert_type(parsed_expression.type)
    self.check_type(checked_type)
    if checked_expression.type.equals(checked_type) {
        stderr.write(parsed_expression.type.location).write(": ").warning().write("Redundant cast").reset().end_line()
    }
    if checked_expression.type is Checked_Pointer_Type {
        if checked_type is Checked_Pointer_Type or checked_type is Checked_Unchecked_Array_Type {
            return make @Checked_Cast_Expression(
                location = parsed_expression.location
                type = checked_type
                expression = checked_expression
            )
        }
    } else if checked_expression.type is Checked_Integer_Type {
        if checked_type is Checked_Integer_Type {
            return make @Checked_Cast_Expression(
                location = parsed_expression.location
                type = checked_type
                expression = checked_expression
            )
        }
    } else if checked_expression.type is Checked_Fixed_Array_Type {
        if checked_type is Checked_Unchecked_Array_Type {
            let checked_expression_type = checked_expression.type.as(@Checked_Fixed_Array_Type)
            let checked_type = checked_type.as(@Checked_Unchecked_Array_Type)
            if checked_expression_type.item_type == checked_type.item_type {
                return make @Checked_Cast_Expression(
                    location = parsed_expression.location
                    type = checked_type
                    expression = checked_expression
                )
            }
        }
    }
    abort(parsed_expression.location, clone("Cannot cast ").append(checked_expression.type.name).append(" to ").append(checked_type.name))
}

func check_divide_expression(self: @Checker, parsed_expression: @Parsed_Divide_Expression) -> @Checked_Expression {
    let left_expression = self.check_expression(parsed_expression.left_expression, null)
    if left_expression.type is not Checked_Integer_Type {
        abort(parsed_expression.left_expression.location, "Not an integer value")
    }
    let right_expression = self.check_expression(parsed_expression.right_expression, left_expression.type)
    return make @Checked_Divide_Expression(
        location = parsed_expression.location
        type = left_expression.type
        left_expression = left_expression
        right_expression = right_expression
    )
}

func check_equals_expression(self: @Checker, parsed_expression: @Parsed_Equals_Expression) -> @Checked_Expression {
    let left_expression = self.check_expression(parsed_expression.left_expression, null)
    let right_expression = self.check_expression(parsed_expression.right_expression, left_expression.type)
    return make @Checked_Equals_Expression(
        location = parsed_expression.location
        type = self.bool_type
        left_expression = left_expression
        right_expression = right_expression
    )
}

func check_function_expression(self: @Checker, parsed_expression: @Parsed_Function_Expression) -> @Checked_Expression {
    let checked_function_symbol = self.create_function_symbol(parsed_expression.function_statement, null)
    return make @Checked_Symbol_Expression(
        location = parsed_expression.location
        type = checked_function_symbol.type
        symbol = checked_function_symbol
    )
}

struct Callable_Match: Object {
    location: @Source_Location
    callable_type: @Checked_Callable_Type
}

struct Checked_Function_Match: Callable_Match {
    function_symbol: @Checked_Function_Symbol
}

struct Parsed_Generic_Function_Match: Callable_Match {
    function_statement: @Parsed_Function_Statement
    specialization_symbols: @Checked_Symbols
}

struct Parsed_Macro_Match: Callable_Match {
    macro_statement: @Parsed_Macro_Statement
    specialization_symbols: @Checked_Symbols
}

func check_callable_call_expression(self: @Checker, callable_name: @Identifier_Token, checked_call_arguments: @List[@Checked_Call_Argument]) -> @Checked_Expression {
    let callable_matches = make List[@Callable_Match]()

    \ find all matching functions
    self.checked_code.functions.for_each() {
        if callable_name.lexeme.equals(it.name) and it.function_type.accepts(checked_call_arguments) {
            callable_matches.append(make @Checked_Function_Match(
                location = it.location
                callable_type = it.function_type
                function_symbol = it
            ))
        }
    }
    \ find all matching generic functions
    self.generic_function_statements.for_each() {
        if callable_name.lexeme.equals(it.name.lexeme) {
            \ create function type
            let specialized_function_type = self.specialize_callable_type(it.type, checked_call_arguments)
            if specialized_function_type != null and specialized_function_type.checked_callable_type.accepts(checked_call_arguments) {
                \ check if generic funtion was already specialized
                let specialized_function_exists = false
                callable_matches.for_each() {
                    if it.callable_type.equals(specialized_function_type.checked_callable_type) {
                        specialized_function_exists = true
                        break
                    }
                }

                if not specialized_function_exists {
                    callable_matches.append(make @Parsed_Generic_Function_Match(
                        location = it.location
                        callable_type = specialized_function_type.checked_callable_type
                        function_statement = it
                        specialization_symbols = specialized_function_type.specialization_symbols
                    ))
                }
            }
        }
    }
    \ find all matching macros
    self.macro_statements.for_each() {
        if callable_name.lexeme.equals(it.name.lexeme) {
            \ create macro type
            let specialized_macro_type = self.specialize_callable_type(it.type, checked_call_arguments)
            if specialized_macro_type != null and specialized_macro_type.checked_callable_type.accepts(checked_call_arguments) {
                callable_matches.append(make @Parsed_Macro_Match(
                    location = it.location
                    callable_type = specialized_macro_type.checked_callable_type
                    macro_statement = it
                    specialization_symbols = specialized_macro_type.specialization_symbols
                ))
            }
        }
    }

    if callable_matches.size == 0 {
        \ list all named functions and report error
        stderr.write(callable_name.location).write(": ").error().write("Found no matching callable").reset().end_line()
        abort(callable_name.location, "TODO: List all named functions")
    }

    while callable_matches.size > 1 {
        \ find matches that accept parameters from another match
        let removed_callable_match = false
        let current_matches_item = callable_matches.first_item
        while current_matches_item != null {
            let current_match = current_matches_item.data
            let another_matches_item = current_matches_item.next_item
            while another_matches_item != null {
                let another_match = another_matches_item.data
                if current_match.callable_type.name.equals(another_match.callable_type.name) {
                    abort(another_match.location, clone("Callable declared first here: ").append(current_match.location))
                }
                if current_match.callable_type.accepts(another_match.callable_type) {
                    \ eliminate current_match
                    current_matches_item.is_removed = true
                    removed_callable_match = true
                }
                if another_match.callable_type.accepts(current_match.callable_type) {
                    \ eliminate current_match
                    another_matches_item.is_removed = true
                    removed_callable_match = true
                }
                another_matches_item = another_matches_item.next_item
            }
            current_matches_item = current_matches_item.next_item
        }

        if removed_callable_match {
            callable_matches.prune()
        } else {
            abort(callable_name.location, "TODO: Report ambiguous call")
        }
    }

    let callable_match = callable_matches.first()
    if callable_match is Checked_Function_Match {
        let callable_match = callable_match.as(@Checked_Function_Match)
        return make @Checked_Function_Call_Expression(
            location = callable_name.location
            type = callable_match.function_symbol.function_type.return_type
            call_arguments = checked_call_arguments
            function_symbol = callable_match.function_symbol
        )
    }
    if callable_match is Parsed_Generic_Function_Match {
        let callable_match = callable_match.as(@Parsed_Generic_Function_Match)
        let checked_function_symbol = self.create_function_symbol(callable_match.function_statement, callable_match.specialization_symbols)
        return make @Checked_Function_Call_Expression(
            location = callable_name.location
            type = checked_function_symbol.function_type.return_type
            call_arguments = checked_call_arguments
            function_symbol = checked_function_symbol
        )
    }
    if callable_match is Parsed_Macro_Match {
        let callable_match = callable_match.as(@Parsed_Macro_Match)
        \ return macro expression to be inlined at the statement level
        return make @Checked_Macro_Call_Expression(
            location = callable_name.location
            type = self.nothing_type
            parsed_macro_type = callable_match.macro_statement.type
            parsed_macro_body = callable_match.macro_statement.body
            specialization_symbols = callable_match.specialization_symbols
            call_arguments = checked_call_arguments
        )
    }
    abort(callable_name.location, callable_match.object_type)
}

struct Checked_Macro_Call_Expression: Checked_Expression {
    parsed_macro_type: @Parsed_Macro_Type
    parsed_macro_body: @Parsed_Statement
    specialization_symbols: @Checked_Symbols
    call_arguments: @List[@Checked_Call_Argument]
}

struct Specialized_Callable_Type {
    checked_callable_type: @Checked_Callable_Type
    specialization_symbols: @Checked_Symbols
}

func specialize_callable_type(self: @Checker, parsed_callable_type: @Parsed_Callable_Type, checked_call_arguments: @List[@Checked_Call_Argument]) -> @Specialized_Callable_Type {
    self.local_symbols = make @Checked_Symbols(
        parent = self.local_symbols
    )
    if parsed_callable_type.type_parameters != null {
        parsed_callable_type.type_parameters.for_each() {
            self.local_symbols.append(make @Checked_Specialization_Type_Symbol(
                location = it.name.location
                name = it.name.lexeme
                type = make @Checked_Placeholder_Type(
                    name = it.name.lexeme
                )
            ))
        }
    }

    \ check if callable parameters accept call arguments
    let parsed_parameter_item = parsed_callable_type.parameters.first_item
    let checked_argument_item = checked_call_arguments.first_item
    while parsed_parameter_item != null and checked_argument_item != null {
        let checked_parameter_type = self.convert_type(parsed_parameter_item.data.type)
        if not checked_parameter_type.accepts(checked_argument_item.data.expression.type) {
            self.local_symbols = self.local_symbols.parent
            return null
        }
        parsed_parameter_item = parsed_parameter_item.next_item
        checked_argument_item = checked_argument_item.next_item
    }

    if checked_argument_item != null or parsed_parameter_item != null {
        \ arguments number differs from parameters number 
        self.local_symbols = self.local_symbols.parent
        return null
    }

    \ check placeholder types
    self.local_symbols.for_each() {
        if it is not Checked_Specialization_Type_Symbol {
            abort()
        }
        if it.type is Checked_Placeholder_Type {
            let checked_type = it.type.as(@Checked_Placeholder_Type)
            if checked_type.solved_type == null {
                abort(parsed_callable_type.location, "TODO: Handle unsolved placeholder type")
            }
            \ replace placeholder type with solved type
            it.type = checked_type.solved_type
        }
    }
    let specialization_symbols = self.local_symbols

    \ create callable type
    let checked_callable_type = self.convert_type(parsed_callable_type)
    if checked_callable_type is not Checked_Callable_Type {
        abort(parsed_callable_type.location, checked_callable_type.object_type)
    }

    self.local_symbols = self.local_symbols.parent
    return make @Specialized_Callable_Type(
        checked_callable_type = checked_callable_type.as(@Checked_Callable_Type)
        specialization_symbols = specialization_symbols
    )
}

func check_greater_than_expression(self: @Checker, parsed_expression: @Parsed_Greater_Than_Expression) -> @Checked_Expression {
    let left_expression = self.check_expression(parsed_expression.left_expression, null)
    let right_expression = self.check_expression(parsed_expression.right_expression, left_expression.type)
    return make @Checked_Greater_Than_Expression(
        location = parsed_expression.location
        type = self.bool_type
        left_expression = left_expression
        right_expression = right_expression
    )
}

func check_greater_than_or_equal_expression(self: @Checker, parsed_expression: @Parsed_Greater_Than_Or_Equals_Expression) -> @Checked_Expression {
    let left_expression = self.check_expression(parsed_expression.left_expression, null)
    let right_expression = self.check_expression(parsed_expression.right_expression, left_expression.type)
    return make @Checked_Greater_Than_Or_Equals_Expression(
        location = parsed_expression.location
        type = self.bool_type
        left_expression = left_expression
        right_expression = right_expression
    )
}

func check_is_expression(self: @Checker, parsed_expression: @Parsed_Is_Expression) -> @Checked_Expression {
    \ check value expression
    let checked_value_expression = self.check_expression(parsed_expression.value_expression, null)
    if checked_value_expression.type is not Checked_Pointer_Type {
        abort(checked_value_expression.location, "Not a pointer value")
    }
    let checked_value_type = checked_value_expression.type.as(@Checked_Pointer_Type).pointed_type
    if checked_value_type is not Checked_Struct_Type {
        abort(checked_value_expression.location, "Not a struct value")
    }
    let checked_value_type = checked_value_type.as(@Checked_Struct_Type)
    let checked_object_type = self.convert_type(make @Parsed_Named_Type(name = make @Identifier_Token(location = null, lexeme = "Object")))
    if checked_object_type is not Checked_Struct_Type {
        abort("Object is not a struct type")
    }
    let checked_object_type = checked_object_type.as(@Checked_Struct_Type)
    if not checked_value_type.has_super_type(checked_object_type) {
        abort(checked_value_expression.location, "Not an Object value")
    }

    \ check other type
    let checked_type = self.convert_type(parsed_expression.type)
    self.check_type(checked_type)
    if checked_type is not Checked_Struct_Type {
        abort(parsed_expression.type.location, "Not a struct type")
    }
    let checked_type = checked_type.as(@Checked_Struct_Type)
    if not checked_type.has_super_type(checked_object_type) {
        abort(parsed_expression.type.location, "Not an Object type")
    }

    \ check type hierarchy
    if not checked_type.has_super_type(checked_value_type) {
        abort(parsed_expression.type.location, checked_type.name.clone().append(" is not a super type of ").append(checked_value_type.name))
    }
    \ if checked_value_type == checked_type or checked_value_type.has_super_type(checked_type) {
    \     stderr.write(parsed_expression.location).write(": ").warning().write("Redundant is operation").reset().end_line()
    \ }

    \ make expression
    return make @Checked_Is_Expression(
        location = parsed_expression.location
        type = self.bool_type
        value_expression = checked_value_expression
        object_type = checked_type
    )
}

func check_less_than_expression(self: @Checker, parsed_expression: @Parsed_Less_Than_Expression) -> @Checked_Expression {
    let left_expression = self.check_expression(parsed_expression.left_expression, null)
    let right_expression = self.check_expression(parsed_expression.right_expression, left_expression.type)
    return make @Checked_Less_Than_Expression(
        location = parsed_expression.location
        type = self.bool_type
        left_expression = left_expression
        right_expression = right_expression
    )
}

func check_less_than_or_equal_expression(self: @Checker, parsed_expression: @Parsed_Less_Than_Or_Equals_Expression) -> @Checked_Expression {
    let left_expression = self.check_expression(parsed_expression.left_expression, null)
    let right_expression = self.check_expression(parsed_expression.right_expression, left_expression.type)
    return make @Checked_Less_Than_Or_Equals_Expression(
        location = parsed_expression.location
        type = self.bool_type
        left_expression = left_expression
        right_expression = right_expression
    )
}

func check_literal_expression(self: @Checker, parsed_expression: @Parsed_Literal_Expression, expected_type: @Checked_Type) -> @Checked_Expression {
    let literal = parsed_expression.literal
    if literal is Boolean_Token {
        return make @Checked_Boolean_Literal_Expression(
            location = parsed_expression.location
            type = self.bool_type
            literal = parsed_expression.literal.as(@Boolean_Token)
        )
    }
    if literal is Character_Token {
        return make @Checked_Character_Literal_Expression(
            location = parsed_expression.location
            type = self.u8_type
            literal = parsed_expression.literal.as(@Character_Token)
        )
    }
    if literal is Integer_Token {
        let literal = literal.as(@Integer_Token)

        \ decide on literal type
        let literal_type: @Checked_Type
        if literal.type != null {
            \ type is part of the literal
            literal_type = self.global_symbols.find_type_symbol(literal.type).type
        } else if expected_type == null or expected_type is not Checked_Integer_Type {
            \ invalid expected_type
            literal_type = self.i32_type
        } else {
            \ use expected_type
            literal_type = expected_type
        }

        \ check value range
        let max_negative_value: u64
        let max_positive_value: u64
        if literal_type is Checked_Int16_Type {
            max_negative_value = 0x0000_0000_0000_8000u64
            max_positive_value = 0x0000_0000_0000_7fffu64
        } else if literal_type is Checked_Int32_Type {
            max_negative_value = 0x0000_0000_8000_0000u64
            max_positive_value = 0x0000_0000_7fff_ffffu64
        } else if literal_type is Checked_Int64_Type or literal_type is Checked_IntMax_Type {
            max_negative_value = 0x800_0000_0000_0000u64 \ TODO: Use 0x8000_0000_0000_0000u64
            max_positive_value = 0x7ff_ffff_ffff_ffffu64 \ TODO: Use 0x7fff_ffff_ffff_ffffu64
        } else if literal_type is Checked_Int8_Type {
            max_negative_value = 0x0000_0000_0000_0080u64
            max_positive_value = 0x0000_0000_0000_007fu64
        } else if literal_type is Checked_UInt16_Type {
            max_negative_value = 0x0000_0000_0000_0000u64
            max_positive_value = 0x0000_0000_0000_ffffu64
        } else if literal_type is Checked_UInt32_Type {
            max_negative_value = 0x0000_0000_0000_0000u64
            max_positive_value = 0x0000_0000_ffff_ffffu64
        } else if literal_type is Checked_UInt64_Type or literal_type is Checked_UIntMax_Type {
            max_negative_value = 0x000_0000_0000_0000u64 \ TODO: Use 0x0000_0000_0000_0000u64
            max_positive_value = 0xfff_ffff_ffff_ffffu64 \ TODO: Use 0xffff_ffff_ffff_ffffu64
        } else if literal_type is Checked_UInt8_Type {
            max_negative_value = 0x0000_0000_0000_0000u64
            max_positive_value = 0x0000_0000_0000_00ffu64
        } else {
            abort(parsed_expression.location, literal_type.object_type)
        }
        if (literal.negative and literal.value > max_negative_value) or (not literal.negative and literal.value > max_positive_value) {
            abort(parsed_expression.location, clone("Value out of ").append(literal_type.name).append(" range: -").append(max_negative_value).append(" .. ").append(max_positive_value))
        }

        return make @Checked_Integer_Literal_Expression(
            location = parsed_expression.location
            type = literal_type
            literal = literal
        )
    }
    if literal is Null_Token {
        return make @Checked_Null_Literal_Expression(
            location = parsed_expression.location
            type = self.null_type
            literal = literal.as(@Null_Token)
        )
    }
    if literal is String_Token {
        return make @Checked_String_Literal_Expression(
            location = parsed_expression.location
            type = self.convert_type(
                make @Parsed_Pointer_Type(
                    location = null
                    pointed_type = make @Parsed_Named_Type(
                        name = make @Identifier_Token(
                            location = null
                            lexeme = "String"
                        )
                    )
                )
            )
            literal = literal.as(@String_Token)
        )
    }
    if literal is Undefined_Token {
        return make @Checked_Undefined_Literal_Expression(
            location = parsed_expression.location
            type = self.undefined_type
            literal = literal.as(@Undefined_Token)
        )
    }
    abort(parsed_expression.location, literal.object_type)
}

func check_logic_and_expression(self: @Checker, parsed_expression: @Parsed_Logic_And_Expression) -> @Checked_Expression {
    return make @Checked_Logic_And_Expression(
        location = parsed_expression.location
        type = self.bool_type
        left_expression = self.check_expression(parsed_expression.left_expression, self.bool_type)
        right_expression = self.check_expression(parsed_expression.right_expression, self.bool_type)
    )
}

func check_logic_not_expression(self: @Checker, parsed_expression: @Parsed_Logic_Not_Expression) -> @Checked_Expression {
    return make @Checked_Logic_Not_Expression(
        location = parsed_expression.location
        type = self.bool_type
        expression = self.check_expression(parsed_expression.expression, self.bool_type)
    )
}

func check_logic_or_expression(self: @Checker, parsed_expression: @Parsed_Logic_Or_Expression) -> @Checked_Expression {
    return make @Checked_Logic_Or_Expression(
        location = parsed_expression.location
        type = self.bool_type
        left_expression = self.check_expression(parsed_expression.left_expression, self.bool_type)
        right_expression = self.check_expression(parsed_expression.right_expression, self.bool_type)
    )
}

func check_macro_body(self: @Checker, parsed_macro_body: @Parsed_Macro_Body) -> @Checked_Expression {
    return make @Checked_Macro_Body(
        location = parsed_macro_body.location
        type = make @Checked_Lazy_Macro_Type()
        parsed_macro_body = parsed_macro_body
    )
}

func check_make_expression(self: @Checker, parsed_expression: @Parsed_Make_Expression) -> @Checked_Expression {
    let checked_type = self.convert_type(parsed_expression.type)
    self.check_type(checked_type)
    let make_pointer = false
    if checked_type is Checked_Pointer_Type {
        checked_type = checked_type.as(@Checked_Pointer_Type).pointed_type
        make_pointer = true
    }
    if checked_type is Checked_Struct_Type {
        return self.check_make_struct_expression(parsed_expression, checked_type.as(@Checked_Struct_Type), make_pointer)
    }
    abort(parsed_expression.location, "Cannot make ".clone().append(checked_type.name))
}

func check_make_struct_expression(self: @Checker, parsed_expression: @Parsed_Make_Expression, checked_struct_type: @Checked_Struct_Type, make_pointer: bool) -> @Checked_Expression {
    let checked_expression_type: @Checked_Type
    if make_pointer {
        checked_expression_type = make_checked_pointer_type(checked_struct_type)
    } else {
        checked_expression_type = checked_struct_type
    }
    let checked_expression = make @Checked_Make_Expression(
        location = parsed_expression.location
        type = checked_expression_type
    )

    \ check init argument
    parsed_expression.init_arguments.for_each() {
        if it.name == null {
            abort(it.location, "Missing member name")
        }
        let checked_struct_member = checked_struct_type.get_member(it.name.lexeme)
        if checked_struct_member == null {
            abort(it.name.location, "TODO: List super type members")
        }
        if checked_expression.values.has(checked_struct_member) {
            abort(it.location, "Member already initialized")
        }
        let checked_value_expression = self.check_expression(it.value_expression, checked_struct_member.type)
        checked_expression.values.put(checked_struct_member, checked_value_expression)
    }

    \ put default values
    checked_struct_type.put_default_values(checked_expression.values)

    \ check if all members are initialized
    checked_struct_type.check_missing_values(parsed_expression.location, checked_expression.values)

    return checked_expression
}

func put_default_values(self: @Checked_Struct_Type, values: @Map[@Checked_Struct_Type_Member, @Checked_Expression]) -> Nothing {
    self.default_values.for_each() {
        if not values.has(key) {
            values.put(key, value)
        }
    }
    if self.super_type != null {
        self.super_type.put_default_values(values)
    }
}

func check_missing_values(self: @Checked_Struct_Type, location: @Source_Location, values: @Map[@Checked_Struct_Type_Member, @Checked_Expression]) -> Nothing {
    if self.super_type != null {
        self.super_type.check_missing_values(location, values)
    }
    self.members.for_each() {
        if not values.has(it) {
            stderr.write(location).write(": ").warning().write(self.name).write('.').write(it.name).write(" is not initialized").reset().end_line()
        }
    }
}

func check_member_access_expression(self: @Checker, parsed_expression: @Parsed_Member_Access_Expression) -> @Checked_Expression {
    let checked_object_expression = self.check_expression(parsed_expression.object_expression, null)
    let checked_object_type = checked_object_expression.type
    if checked_object_type is Checked_Fixed_Array_Type {
        if not parsed_expression.member_name.lexeme.equals("length") {
            abort(parsed_expression.member_name.location, "Did you mean length?")
        }
        return checked_object_type.as(@Checked_Fixed_Array_Type).size_expression
    }
    if checked_object_type is Checked_Pointer_Type {
        checked_object_type = checked_object_type.as(@Checked_Pointer_Type).pointed_type
    }
    if checked_object_type is not Checked_Struct_Type {
        abort(parsed_expression.location, clone("Not a struct type: ").append(checked_object_type.object_type.name))
    }
    let checked_struct_type = checked_object_type.as(@Checked_Struct_Type)
    let checked_struct_type_member = checked_struct_type.get_member(parsed_expression.member_name.lexeme)
    if checked_struct_type_member == null {
        if parsed_expression.member_name.lexeme.equals("super") {
            \ super access works as a cast
            if checked_struct_type.super_type == null {
                abort(parsed_expression.member_name.location, checked_struct_type.name.clone().append(" has no super type"))
            }
            if checked_object_expression.type is Checked_Pointer_Type {
                return make @Checked_Cast_Expression(
                    location = parsed_expression.member_name.location
                    type = make_checked_pointer_type(checked_struct_type.super_type)
                    expression = checked_object_expression
                )
            }
            return make @Checked_Cast_Expression(
                location = parsed_expression.member_name.location
                type = checked_struct_type.super_type
                expression = checked_object_expression
            )
        }
        abort(parsed_expression.member_name.location, clone(checked_struct_type.name).append(" has no ").append(parsed_expression.member_name.lexeme).append(" member"))
    }
    if checked_struct_type_member.type is Checked_Struct_Type {
        \ accessing a struct member requires the object to be a pointer
        if checked_object_expression.type is Checked_Pointer_Type {
            return make @Checked_Member_Access_Expression(
                location = parsed_expression.location
                type = make_checked_pointer_type(checked_struct_type_member.type)
                object_expression = checked_object_expression
                struct_member = checked_struct_type_member
            )
        }

        abort(checked_object_expression.location, "Not a pointer")
    }
    return make @Checked_Member_Access_Expression(
        location = parsed_expression.location
        type = checked_struct_type_member.type
        object_expression = checked_object_expression
        struct_member = checked_struct_type_member
    )
}

func check_modulo_expression(self: @Checker, parsed_expression: @Parsed_Modulo_Expression) -> @Checked_Expression {
    let left_expression = self.check_expression(parsed_expression.left_expression, null)
    if left_expression.type is not Checked_Integer_Type {
        abort(parsed_expression.left_expression.location, "Not an integer value")
    }
    let right_expression = self.check_expression(parsed_expression.right_expression, left_expression.type)
    return make @Checked_Modulo_Expression(
        location = parsed_expression.location
        type = left_expression.type
        left_expression = left_expression
        right_expression = right_expression
    )
}

func check_multiply_expression(self: @Checker, parsed_expression: @Parsed_Multiply_Expression) -> @Checked_Expression {
    let left_expression = self.check_expression(parsed_expression.left_expression, null)
    if left_expression.type is not Checked_Integer_Type {
        abort(parsed_expression.left_expression.location, "Not an integer value")
    }
    let right_expression = self.check_expression(parsed_expression.right_expression, left_expression.type)
    return make @Checked_Multiply_Expression(
        location = parsed_expression.location
        type = left_expression.type
        left_expression = left_expression
        right_expression = right_expression
    )
}

func check_negate_expression(self: @Checker, parsed_expression: @Parsed_Negate_Expression) -> @Checked_Expression {
    let checked_expression = self.check_expression(parsed_expression.expression, null)
    if checked_expression.type is not Checked_Integer_Type {
        abort(parsed_expression.expression.location, "Not an integer value")
    }
    return make @Checked_Negate_Expression(
        location = parsed_expression.location
        type = checked_expression.type
        expression = checked_expression
    )
}

func check_not_equals_expression(self: @Checker, parsed_expression: @Parsed_Not_Equals_Expression) -> @Checked_Expression {
    let left_expression = self.check_expression(parsed_expression.left_expression, null)
    let right_expression = self.check_expression(parsed_expression.right_expression, left_expression.type)
    return make @Checked_Not_Equals_Expression(
        location = parsed_expression.location
        type = self.bool_type
        left_expression = left_expression
        right_expression = right_expression
    )
}

func check_substract_expression(self: @Checker, parsed_expression: @Parsed_Substract_Expression) -> @Checked_Expression {
    let left_expression = self.check_expression(parsed_expression.left_expression, null)
    if left_expression.type is not Checked_Integer_Type {
        abort(parsed_expression.left_expression.location, "Not an integer value")
    }
    let right_expression = self.check_expression(parsed_expression.right_expression, left_expression.type)
    return make @Checked_Substract_Expression(
        location = parsed_expression.location
        type = left_expression.type
        left_expression = left_expression
        right_expression = right_expression
    )
}

func check_symbol_expression(self: @Checker, parsed_expression: @Parsed_Symbol_Expression) -> @Checked_Expression {
    let checked_symbol_name = parsed_expression.name.lexeme
    let checked_symbol = self.local_symbols.find_symbol(checked_symbol_name)
    if checked_symbol == null {
        \ symbol might refer to a generic function
        self.generic_function_statements.for_each() {
            if it.name.lexeme.equals(checked_symbol_name) {
                \ create special symbol
                let checked_function_type = make @Checked_Function_Type(
                    name = "func (...) -> Any"
                    return_type = self.any_type
                )
                checked_symbol = make @Checked_Generic_Function_Symbol(
                    location = parsed_expression.location
                    name = checked_symbol_name
                    type = make_checked_function_pointer_type(checked_function_type)
                )
                return make @Checked_Symbol_Expression(
                    location = parsed_expression.location
                    type = checked_symbol.type
                    symbol = checked_symbol
                )
            }
        }

        abort(parsed_expression.location, clone("Undefined symbol ").append(checked_symbol_name))
    }
    if checked_symbol is Checked_Constant_Symbol and checked_symbol.type == null {
        self.check_constant_symbol(checked_symbol.as(@Checked_Constant_Symbol))
    }
    return make @Checked_Symbol_Expression(
        location = parsed_expression.location
        type = checked_symbol.type
        symbol = checked_symbol
    )
}

struct Checked_Generic_Function_Symbol: Checked_Symbol {
}

func check_variable_reference_expression(self: @Checker, parsed_expression: @Parsed_Variable_Reference_Expression) -> @Checked_Expression {
    let checked_variable_expression = self.check_expression(parsed_expression.variable_expression, null)
    if checked_variable_expression is not Checked_Symbol_Expression {
        abort(checked_variable_expression.location, "Not a symbol expression")
    }
    let checked_symbol = checked_variable_expression.as(@Checked_Symbol_Expression).symbol
    if checked_symbol is not Checked_Variable_Symbol {
        abort(checked_variable_expression.location, "Not a variable")
    }
    if checked_symbol.type is not Checked_Struct_Type {
        abort(checked_variable_expression.location, "Cannot reference ".clone().append(checked_symbol.type.name).append(" variables yet"))
    }
    return make @Checked_Reference_Expression(
        location = parsed_expression.location
        type = make_checked_pointer_type(checked_variable_expression.type)
        object_expression = checked_variable_expression
    )
}

func convert_type(self: @Checker, parsed_type: @Parsed_Type) -> @Checked_Type {
    if parsed_type is Parsed_Array_Type {
        return self.convert_array_type(parsed_type.as(@Parsed_Array_Type))
    }
    if parsed_type is Parsed_Function_Type {
        return self.convert_function_type(parsed_type.as(@Parsed_Function_Type))
    }
    if parsed_type is Parsed_Macro_Type {
        return self.convert_macro_type(parsed_type.as(@Parsed_Macro_Type))
    }
    if parsed_type is Parsed_Named_Type {
        return self.convert_named_type(parsed_type.as(@Parsed_Named_Type))
    }
    if parsed_type is Parsed_Pointer_Type {
        return self.convert_pointer_type(parsed_type.as(@Parsed_Pointer_Type))
    }
    if parsed_type is Parsed_Specialized_Type {
        return self.convert_specialized_type(parsed_type.as(@Parsed_Specialized_Type))
    }
    abort(parsed_type.location, "TODO: Convert ".clone().append(parsed_type.object_type.name))
}

func convert_array_type(self: @Checker, parsed_type: @Parsed_Array_Type) -> @Checked_Array_Type {
    let checked_item_type = self.convert_type(parsed_type.item_type)
    if parsed_type.is_checked {
        if parsed_type.size_expression != null {
            let checked_size_expression = self.check_expression(parsed_type.size_expression, self.isize_type)
            if not checked_size_expression.is_constant() {
                abort(parsed_type.size_expression.location, "Not a constant")
            }
            let checked_size_expression = checked_size_expression.as(@Checked_Integer_Literal_Expression)
            let checked_size = checked_size_expression.literal.value
            return make @Checked_Fixed_Array_Type(
                name = "[".clone().append(checked_item_type.name).append("; ").append(checked_size).append(']')
                is_checked_type = checked_item_type.is_checked_type
                item_type = checked_item_type
                size = checked_size
                size_expression = checked_size_expression
            )
        }
        abort(parsed_type.location, "Resizable checked array types are not supported yet")
    }
    return make @Checked_Unchecked_Array_Type(
        name = "[".clone().append(checked_item_type.name).append("; ?]")
        is_checked_type = checked_item_type.is_checked_type
        item_type = checked_item_type
    )
}

func convert_function_type(self: @Checker, parsed_type: @Parsed_Function_Type) -> @Checked_Function_Type {
    if parsed_type.type_parameters != null {
        parsed_type.type_parameters.for_each() {
            let checked_type_symbol = self.local_symbols.find_type_symbol(it.name.lexeme)
            if checked_type_symbol == null {
                abort()
            }
            if checked_type_symbol is not Checked_Specialization_Type_Symbol {
                abort()
            }
        }
    }

    let checked_function_type = make @Checked_Function_Type(
        name = "func (".clone()
        return_type = self.convert_type(parsed_type.return_type)
    )
    parsed_type.parameters.for_each_indexed() {
        let checked_function_parameter = self.check_callable_parameter(checked_function_type, it)

        if it_index > 0 {
            checked_function_type.name.append(", ")
        }
        checked_function_type.name.append(checked_function_parameter.type.name)
    }
    checked_function_type.name.append(") -> ").append(checked_function_type.return_type.name)

    if checked_function_type.return_type is Checked_Any_Type {
        abort(parsed_type.return_type.location, "Unsupported return type")
    }

    return checked_function_type
}

func check_callable_parameter(self: @Checker, checked_callable_type: @Checked_Callable_Type, parsed_callable_parameter: @Parsed_Callable_Parameter) -> @Checked_Callable_Parameter {
    \ check parameter name
    let checked_callable_parameter_name = parsed_callable_parameter.name.lexeme
    checked_callable_type.parameters.for_each() {
        if checked_callable_parameter_name.equals(it.name) {
            abort(parsed_callable_parameter.name.location, "Duplicate function parameter name")
        }
    }

    \ check parameter type
    let checked_callable_parameter_type = self.convert_type(parsed_callable_parameter.type)
    if checked_callable_parameter_type is Checked_Any_Type {
        abort(parsed_callable_parameter.type.location, "Unsupported parameter type")
    } else if checked_callable_parameter_type is Checked_Function_Type {
        checked_callable_parameter_type = make_checked_function_pointer_type(checked_callable_parameter_type.as(@Checked_Function_Type))
    } else if checked_callable_parameter_type is Checked_Nothing_Type {
        abort(parsed_callable_parameter.type.location, "Unsupported parameter type")
    }

    \ create parameter
    let checked_callable_parameter = make @Checked_Callable_Parameter(
        location = parsed_callable_parameter.name.location
        name = checked_callable_parameter_name
        type = checked_callable_parameter_type
    )
    checked_callable_type.parameters.append(checked_callable_parameter)

    return checked_callable_parameter
}

func convert_macro_type(self: @Checker, parsed_type: @Parsed_Macro_Type) -> @Checked_Macro_Type {
    if parsed_type.type_parameters != null {
        parsed_type.type_parameters.for_each() {
            let checked_type_symbol = self.local_symbols.find_type_symbol(it.name.lexeme)
            if checked_type_symbol == null {
                abort()
            }
            if checked_type_symbol is not Checked_Specialization_Type_Symbol {
                abort()
            }
        }
    }

    let checked_macro_type = make @Checked_Macro_Type(
        name = "macro (".clone()
    )
    parsed_type.parameters.for_each() {
        let checked_macro_parameter = self.check_callable_parameter(checked_macro_type, it)

        if checked_macro_type.parameters.size > 1 {
            checked_macro_type.name.append(", ")
        }
        checked_macro_type.name.append(checked_macro_parameter.type.name)
    }
    checked_macro_type.name.append(')')

    return checked_macro_type
}

func convert_named_type(self: @Checker, parsed_type: @Parsed_Named_Type) -> @Checked_Type {
    let checked_type_name = parsed_type.name.lexeme

    let checked_type_symbol = self.local_symbols.find_type_symbol(checked_type_name)
    if checked_type_symbol != null {
        return checked_type_symbol.type
    }

    \ find type statement
    let parsed_type_statement = self.parsed_code.get_type_statement(checked_type_name)
    if parsed_type_statement == null {
        abort(parsed_type.name.location, clone("Unknown type: ").append(checked_type_name))
    }
    if parsed_type_statement is Parsed_External_Type_Statement {
        return self.create_opaque_type_symbol(parsed_type_statement.as(@Parsed_External_Type_Statement)).type
    }
    if parsed_type_statement is Parsed_Struct_Statement {
        let parsed_type_statement = parsed_type_statement.as(@Parsed_Struct_Statement)
        return self.create_struct_type_symbol(parsed_type_statement, parsed_type_statement.name.lexeme, null).type
    }
    abort(parsed_type_statement.location, parsed_type_statement.object_type)
}

func convert_pointer_type(self: @Checker, parsed_pointer_type: @Parsed_Pointer_Type) -> @Checked_Type {
    let checked_pointed_type = self.convert_type(parsed_pointer_type.pointed_type)
    return make_checked_pointer_type(checked_pointed_type)
}

func make_checked_pointer_type(checked_pointed_type: @Checked_Type) -> @Checked_Pointer_Type {
    return make @Checked_Pointer_Type(
        name = "@".clone().append(checked_pointed_type.name)
        is_checked_type = checked_pointed_type.is_checked_type
        pointed_type = checked_pointed_type
    )
}

func make_checked_function_pointer_type(checked_function_type: @Checked_Function_Type) -> @Checked_Function_Pointer_Type {
    return make @Checked_Function_Pointer_Type(
        name = "@(".clone().append(checked_function_type.name).append(')')
        is_checked_type = checked_function_type.is_checked_type
        pointed_type = checked_function_type
        function_type = checked_function_type
    )
}

func convert_specialized_type(self: @Checker, parsed_specialized_type: @Parsed_Specialized_Type) -> @Checked_Type {
    \ check if generic type exists
    let parsed_generic_struct_statement = self.generic_struct_statements.get(parsed_specialized_type.name.lexeme)
    if parsed_generic_struct_statement == null {
        abort(parsed_specialized_type.location, "No such generic struct")
    }

    \ create type name
    let has_placeholder_specialization_type = false
    let specialization_symbols = make @Checked_Symbols(
        parent = self.local_symbols
    )
    let checked_type_name = parsed_specialized_type.name.lexeme.clone().append('[')
    let parsed_type_parameter_item = parsed_generic_struct_statement.type_parameters.first_item
    let parsed_type_argument_item = parsed_specialized_type.type_arguments.first_item
    while parsed_type_parameter_item != null and parsed_type_argument_item != null {
        let checked_type_argument = self.convert_type(parsed_type_argument_item.data.type)
        specialization_symbols.append(make @Checked_Specialization_Type_Symbol(
            location = parsed_type_parameter_item.data.name.location
            name = parsed_type_parameter_item.data.name.lexeme
            type = checked_type_argument
        ))
        if checked_type_argument is Checked_Placeholder_Type {
            has_placeholder_specialization_type = true
        }
        checked_type_name.append(checked_type_argument.name)
        parsed_type_parameter_item = parsed_type_parameter_item.next_item
        parsed_type_argument_item = parsed_type_argument_item.next_item
        if parsed_type_argument_item != null {
            checked_type_name.append(", ")
        }
    }
    checked_type_name.append(']')

    \ check if we have a placeholder type
    if has_placeholder_specialization_type {
        return make @Checked_Specialized_Placeholder_Type(
            name = checked_type_name
            generic_struct_name = parsed_generic_struct_statement.name.lexeme
            specialization_symbols = specialization_symbols
        )
    }

    \ check if type already exists
    let checked_type_symbol = self.local_symbols.find_type_symbol(checked_type_name)
    if checked_type_symbol != null {
        return checked_type_symbol.type
    }

    \ create struct symbol
    let checked_struct_type_symbol = self.create_struct_type_symbol(parsed_generic_struct_statement.struct_statement, checked_type_name, specialization_symbols)
    return checked_struct_type_symbol.type
}

func inline_macro_call_expression(self: @Checker, checked_macro_call_expression: @Checked_Macro_Call_Expression) -> @Checked_Statement {
    \ remember parent symbols
    let parent_symbols = self.local_symbols

    \ prepare local symbols
    let specialization_symbols = checked_macro_call_expression.specialization_symbols
    let macro_symbols = make @Checked_Symbols(parent = specialization_symbols)
    self.local_symbols = macro_symbols

    \ create surrounding block
    let checked_statement = make @Checked_Block_Statement(
        location = checked_macro_call_expression.location
        local_symbols = macro_symbols
    )

    \ create local variable for each macro parameter
    let parsed_parameter_item = checked_macro_call_expression.parsed_macro_type.parameters.first_item
    let checked_call_argument_item = checked_macro_call_expression.call_arguments.first_item
    while parsed_parameter_item != null and checked_call_argument_item != null {
        let parsed_parameter = parsed_parameter_item.data
        let checked_call_argument_expression = checked_call_argument_item.data.expression
        let checked_call_argument_expression_type = checked_call_argument_expression.type

        \ check parameter type
        let checked_parameter_type = self.convert_type(parsed_parameter.type)
        if not checked_parameter_type.accepts(checked_call_argument_expression_type) {
            abort(checked_call_argument_expression.location, "TODO: Convert type or recheck parsed argument")
        }

        if checked_parameter_type is Checked_Macro_Type {
            if parsed_parameter.type is not Parsed_Macro_Type {
                abort(parsed_parameter.type.location, parsed_parameter.type.object_type)
            }
            if checked_call_argument_expression_type is not Checked_Lazy_Macro_Type {
                abort(checked_call_argument_expression.location, checked_call_argument_expression_type.object_type)
            }
            let checked_call_argument_expression_type = checked_call_argument_expression_type.as(@Checked_Lazy_Macro_Type)
            \ create macro parameter
            if checked_call_argument_expression is Checked_Macro_Body {
                self.local_symbols.append(make @Checked_Macro_Parameter_Symbol(
                    location = parsed_parameter.name.location
                    name = parsed_parameter.name.lexeme
                    type = checked_parameter_type
                    parsed_macro_type = parsed_parameter.type.as(@Parsed_Macro_Type)
                    parsed_macro_body = checked_call_argument_expression.as(@Checked_Macro_Body).parsed_macro_body.statement
                    local_symbols = specialization_symbols
                ))
            } else if checked_call_argument_expression is Checked_Symbol_Expression {
                let checked_symbol = checked_call_argument_expression.as(@Checked_Symbol_Expression).symbol
                if checked_symbol is not Checked_Macro_Symbol {
                    \ invalid state
                    abort()
                }
                let checked_symbol = checked_symbol.as(@Checked_Macro_Symbol)
                \ check macro type
                let checked_macro_type = self.convert_type(checked_symbol.parsed_macro_statement.type)
                if not checked_parameter_type.accepts(checked_macro_type) {
                    abort(checked_call_argument_expression.location, "Incompatible macro types")
                }
                self.local_symbols.append(make @Checked_Macro_Parameter_Symbol(
                    location = parsed_parameter.name.location
                    name = parsed_parameter.name.lexeme
                    type = checked_parameter_type
                    parsed_macro_type = parsed_parameter.type.as(@Parsed_Macro_Type)
                    parsed_macro_body = checked_symbol.parsed_macro_statement.body
                    local_symbols = specialization_symbols
                ))
            } else {
                abort(checked_call_argument_expression.location, checked_call_argument_expression.object_type)
            }
        } else {
            \ create variable statement
            let checked_variable_statement = make @Checked_Variable_Statement(
                location = checked_call_argument_expression.location
                variable = make @Checked_Variable_Symbol(
                    location = parsed_parameter.name.location
                    name = parsed_parameter.name.lexeme
                    type = checked_parameter_type
                    expression = checked_call_argument_expression
                )
            )
            self.local_symbols.append(checked_variable_statement.variable)
            checked_statement.statements.append(checked_variable_statement)
        }

        parsed_parameter_item = parsed_parameter_item.next_item
        checked_call_argument_item = checked_call_argument_item.next_item
    }
    if parsed_parameter_item != null or checked_call_argument_item != null {
        \ found a bug in the check_callable_call_expression
        abort()
    }

    \ inline macro body
    checked_statement.statements.append(self.check_statement(checked_macro_call_expression.parsed_macro_body))

    \ restore parent symbols
    self.local_symbols = parent_symbols

    return checked_statement
}

func is_specialization_type(self: @Checker, parsed_type: @Parsed_Type) -> bool {
    if parsed_type is not Parsed_Named_Type {
        return false
    }

    let checked_type_name = parsed_type.as(@Parsed_Named_Type).name.lexeme
    let checked_type_symbol = self.local_symbols.find_type_symbol(checked_type_name)
    if checked_type_symbol == null {
        \ unexpected state
        abort(parsed_type.location, "Type symbol not found")
    }
    return checked_type_symbol is Checked_Specialization_Type_Symbol
}
