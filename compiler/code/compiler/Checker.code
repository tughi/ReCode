include "./Checked_Code.code"

func check(parsed_code: @Parsed_Code) -> @Checked_Code {
    let checker = make Checker(
        parsed_code = parsed_code
        checked_code = make @Checked_Code()
        current_context = undefined
    )
    checker.current_context = checker.root_context

    \ add builtin types
    checker.put_named_type(make @Checked_Any_Type())
    checker.bool_type = checker.put_named_type(make @Checked_Bool_Type())
    checker.i16_type = checker.put_named_type(make @Checked_Int16_Type())
    checker.i32_type = checker.put_named_type(make @Checked_Int32_Type())
    checker.i64_type = checker.put_named_type(make @Checked_Int64_Type())
    checker.i8_type = checker.put_named_type(make @Checked_Int8_Type())
    checker.isize_type = checker.put_named_type(make @Checked_IntMax_Type())
    checker.null_type = checker.put_named_type(make @Checked_Null_Type())
    checker.u16_type = checker.put_named_type(make @Checked_UInt16_Type())
    checker.u32_type = checker.put_named_type(make @Checked_UInt32_Type())
    checker.u64_type = checker.put_named_type(make @Checked_UInt64_Type())
    checker.u8_type = checker.put_named_type(make @Checked_UInt8_Type())
    checker.usize_type = checker.put_named_type(make @Checked_UIntMax_Type())
    checker.undefined_type = checker.put_named_type(make @Checked_Undefined_Type())

    checker.check(parsed_code)

    return checker.checked_code
}

struct Checker {
    parsed_code: @Parsed_Code
    checked_code: @Checked_Code

    root_context = make Checker_Context()
    current_context: @Checker_Context

    expected_return_type: @Checked_Type = null

    named_types = make Map[@String, @Checked_Named_Type]()

    bool_type: @Checked_Type = undefined
    i16_type: @Checked_Type = undefined
    i32_type: @Checked_Type = undefined
    i64_type: @Checked_Type = undefined
    i8_type: @Checked_Type = undefined
    isize_type: @Checked_Type = undefined
    null_type: @Checked_Type = undefined
    u16_type: @Checked_Type = undefined
    u32_type: @Checked_Type = undefined
    u64_type: @Checked_Type = undefined
    u8_type: @Checked_Type = undefined
    usize_type: @Checked_Type = undefined
    undefined_type: @Checked_Type = undefined
}

func get_named_type(self: @Checker, name: @String) -> @Checked_Named_Type {
    return self.named_types.get(name)
}

func put_named_type(self: @Checker, type: @Checked_Named_Type) -> @Checked_Named_Type {
    self.named_types.put(type.name, type)
    return type
}

struct Checker_Context {
    parent: @Checker_Context = null

    symbols = make List[@Checked_Symbol]()
}

func find_symbol(self: @Checker_Context, name: @String) -> @Checked_Symbol {
    \ search local symbols
    self.symbols.for_each() {
        if it.name.equals(name) {
            return it
        }
    }

    \ search parent symbols
    if self.parent != null {
        return self.parent.find_symbol(name)
    }

    \ not found
    return null
}

func check(self: @Checker, parsed_code: @Parsed_Code) -> Nothing {
    \ create root statements
    parsed_code.statements.for_each() {
        if it is Parsed_Function_Statement {
            self.check_function_statement(it.as(@Parsed_Function_Statement))
        } else if it is Parsed_Struct_Statement {
            self.check_struct_statement(it.as(@Parsed_Struct_Statement))
        } else if it is Parsed_Variable_Statement {
            let checked_statement = self.check_variable_statement(it.as(@Parsed_Variable_Statement))
            let variable = checked_statement.variable
            if variable.expression != null {
                abort("TODO: Check constant expression")
            }
            self.checked_code.globals.put(variable.name, variable)
            self.root_context.symbols.append(variable)
        } else {
            abort(it.location, it.object_type)
        }
    }

    \ check types
    self.checked_code.globals.for_each() {
        if value is Checked_Struct_Symbol {
            self.check_struct_symbol(value.as(@Checked_Struct_Symbol))
        } else if value is Checked_Variable_Symbol {
            \ not a type symbol
        } else {
            abort(value.location, value.object_type)
        }
    }

    \ check functions
    self.checked_code.functions.for_each() {
        self.check_function_symbol(it)
    }
}

func check_function_statement(self: @Checker, parsed_function: @Parsed_Function_Statement) -> @Checked_Function_Symbol {
    \ create function type
    let checked_function_type = make @Checked_Function_Type(
        name = "func (".clone()
        return_type = self.convert_type(parsed_function.type.return_type)
    )
    parsed_function.type.parameters.for_each() {
        let parsed_function_parameter = it

        \ check parameter name
        let checked_function_parameter_name = parsed_function_parameter.name.lexeme
        checked_function_type.parameters.for_each() {
            if it.name.equals(checked_function_parameter_name) {
                abort(parsed_function_parameter.name.location, "Duplicate function parameter name")
            }
        }

        \ create parameter
        let checked_function_parameter = make @Checked_Function_Parameter(
            location = parsed_function_parameter.location
            name = checked_function_parameter_name
            type = self.convert_type(parsed_function_parameter.type)
        )
        checked_function_type.parameters.append(checked_function_parameter)

        \ add function parameter to function name
        if checked_function_type.parameters.size > 1 {
            checked_function_type.name.append(", ")
        }
        checked_function_type.name.append(checked_function_parameter.type.name)
    }
    checked_function_type.name.append(") -> ").append(checked_function_type.return_type.name)

    \ check for duplicates
    self.checked_code.functions.for_each() {
        if it.name.equals(parsed_function.name) {
            abort(parsed_function.location, "TODO: Compare function types")
        }
    }

    \ create function
    let checked_function = make @Checked_Function_Symbol(
        location = parsed_function.location
        name = parsed_function.name.lexeme
        type = make @Checked_Pointer_Type(
            name = "@(".clone().append(checked_function_type.name).append(')')
            pointed_type = checked_function_type
        )
        function_type = checked_function_type

        parsed_function = parsed_function
    )
    self.checked_code.functions.append(checked_function)
    if not parsed_function.is_anonymous {
        self.root_context.symbols.append(checked_function)
    }

    return checked_function
}

func check_function_symbol(self: @Checker, checked_function: @Checked_Function_Symbol) -> Nothing {
    let parsed_function = checked_function.parsed_function

    \ create function context
    self.current_context = make @Checker_Context(
        parent = self.current_context
    )
    let checked_function_type = checked_function.function_type
    checked_function_type.parameters.for_each() {
        self.current_context.symbols.prepend(make @Checked_Symbol(
            location = it.location
            name = it.name
            type = it.type
        ))
    }

    \ check function body
    self.expected_return_type = checked_function_type.return_type
    self.check_block_statement(parsed_function.body)
    self.expected_return_type = null

    \ restore context
    self.current_context = self.current_context.parent
}

func check_statement(self: @Checker, parsed_statement: @Parsed_Statement) -> @Checked_Statement {
    if parsed_statement is Parsed_Block_Statement {
        return self.check_block_statement(parsed_statement.as(@Parsed_Block_Statement))
    }
    if parsed_statement is Parsed_If_Statement {
        return self.check_if_statement(parsed_statement.as(@Parsed_If_Statement))
    }
    if parsed_statement is Parsed_Return_Statement {
        return self.check_return_statement(parsed_statement.as(@Parsed_Return_Statement))
    }
    if parsed_statement is Parsed_Variable_Statement {
        return self.check_variable_statement(parsed_statement.as(@Parsed_Variable_Statement))
    }
    abort("TODO: Check ".clone().append(parsed_statement.object_type.name))
}

func check_block_statement(self: @Checker, parsed_statement: @Parsed_Block_Statement) -> @Checked_Block_Statement {
    let checked_statement = make @Checked_Block_Statement(
        location = parsed_statement.location
    )

    \ create function context
    self.current_context = make @Checker_Context(
        parent = self.current_context
    )

    \ check function body
    parsed_statement.statements.for_each() {
        checked_statement.statements.append(self.check_statement(it))
    }

    \ restore context
    self.current_context = self.current_context.parent

    return checked_statement
}

func check_if_statement(self: @Checker, parsed_statement: @Parsed_If_Statement) -> @Checked_Statement {
    let checked_condition_expression = self.check_expression(parsed_statement.condition_expression, self.bool_type)
    let checked_true_statement = self.check_statement(parsed_statement.true_statement)
    let checked_false_statement: @Checked_Statement = null
    if parsed_statement.false_statement != null {
        checked_false_statement = self.check_statement(parsed_statement.true_statement)
    }
    return make @Checked_If_Statement(
        location = parsed_statement.location
        condition_expression = checked_condition_expression
        true_statement = checked_true_statement
        false_statement = checked_false_statement
    )
}

func check_return_statement(self: @Checker, parsed_statement: @Parsed_Return_Statement) -> @Checked_Statement {
    let checked_expression: @Checked_Expression = null
    if parsed_statement.value_expression != null {
        checked_expression = self.check_expression(parsed_statement.value_expression, self.expected_return_type)
    }
    return make @Checked_Return_Statement(
        location = parsed_statement.location
        expression = checked_expression
    )
}

func check_struct_statement(self: @Checker, parsed_struct_statement: @Parsed_Struct_Statement) -> @Checked_Struct_Symbol {
    let checked_struct_name = parsed_struct_statement.name.lexeme
    let checked_symbol = self.checked_code.globals.get(checked_struct_name)
    if checked_symbol != null {
        if checked_symbol is not Checked_Struct_Symbol or checked_symbol.as(@Checked_Struct_Symbol).parsed_struct_statement != parsed_struct_statement {
            abort(parsed_struct_statement.location, clone("Duplicate declaration: ").append(checked_struct_name))
        }
        return checked_symbol.as(@Checked_Struct_Symbol)
    }

    let checked_struct = make @Checked_Struct_Symbol(
        location = parsed_struct_statement.name.location
        name = checked_struct_name
        type = make @Checked_Struct_Type(
            name = checked_struct_name
        )
        parsed_struct_statement = parsed_struct_statement
    )

    self.checked_code.globals.put(checked_struct.name, checked_struct)
    self.root_context.symbols.append(checked_struct)

    return checked_struct
}

func check_struct_symbol(self: @Checker, check_struct: @Checked_Struct_Symbol) -> Nothing {
    let checked_struct_type = check_struct.type.as(@Checked_Struct_Type)
    let parsed_struct_statement = check_struct.parsed_struct_statement

    \ check super
    if parsed_struct_statement.super_type != null {
        abort(parsed_struct_statement.super_type.location, "TODO: check super type")
    }

    \ check struct members
    if parsed_struct_statement.members != null {
        parsed_struct_statement.members.for_each() {
            let parsed_struct_member = it
            let checked_struct_member_name = parsed_struct_member.name.lexeme
            if checked_struct_member_name.equals("super") {
                abort(parsed_struct_member.name.location, "'super' cannot be used as member name")
            }
            let checked_struct_member_type: @Checked_Type = null
            if parsed_struct_member.type != null {
                checked_struct_member_type = self.convert_type(parsed_struct_member.type)
            }
            let checked_struct_member_value_expression: @Checked_Expression = null
            if parsed_struct_member.default_value_expression != null {
                checked_struct_member_value_expression = self.check_expression(parsed_struct_member.default_value_expression, checked_struct_member_type)
                if checked_struct_member_type != null {
                    if not checked_struct_member_type.accepts(checked_struct_member_value_expression.type) {
                        abort(checked_struct_member_value_expression.location, clone("Cannot assign a '").append(checked_struct_member_value_expression.type.name).append("' value to a '").append(checked_struct_member_type.name).append("' struct member"))
                    }
                    \ if checked_struct_member_type.equals(checked_struct_member_value_expression) and not self.is_type_argument(parsed_struct_member.type) {
                    \     stderr.write(parsed_struct_member.type.location).write(": ").warning().write("Redundant type declaration").reset().end_line()
                    \ }
                } else {
                    if checked_struct_member_value_expression.type is Checked_Null_Type {
                        abort(checked_struct_member_value_expression.location, clone("Cannot infer type from a null value"))
                    }
                    if checked_struct_member_value_expression.type is Checked_Undefined_Type {
                        abort(checked_struct_member_value_expression.location, clone("Cannot infer type from an undefined value"))
                    }
                    checked_struct_member_type = checked_struct_member_value_expression.type
                }
            }
            if checked_struct_member_type == null {
                abort(parsed_struct_member.name.location, "Cannot infer type of struct member")
            }
            if checked_struct_member_type is Checked_Struct_Type {
                let checked_struct_member_type = checked_struct_member_type.as(@Checked_Struct_Type)
                if checked_struct_member_type == checked_struct_type or checked_struct_member_type.has_super_type(checked_struct_type) {
                    abort(parsed_struct_member.type.location, "Type recursivity")
                }
            }
            checked_struct_type.add_member(checked_struct_member_name, checked_struct_member_type, checked_struct_member_value_expression)
        }
    }
}

func check_type_statement(self: @Checker, parsed_type_statement: @Parsed_Type_Statement) -> @Checked_Symbol {
    if parsed_type_statement is Parsed_Struct_Statement {
        return self.check_struct_statement(parsed_type_statement.as(@Parsed_Struct_Statement))
    }
    abort(parsed_type_statement.location, parsed_type_statement.object_type)
}

func check_variable_statement(self: @Checker, parsed_statement: @Parsed_Variable_Statement) -> @Checked_Variable_Statement {
    \ check variable type
    let checked_type: @Checked_Type = null
    if parsed_statement.type != null {
        checked_type = self.convert_type(parsed_statement.type)
        if checked_type is Checked_Opaque_Type {
            abort(parsed_statement.type.location, "Variable cannot have an opaque type")
        }
        if checked_type is Checked_Any_Type or checked_type is Checked_Nothing_Type {
            abort(parsed_statement.type.location, "Variable cannot have the ".clone().append(checked_type.name).append(" type"))
        }
    }

    \ check variable expression
    let checked_expression: @Checked_Expression = null
    if parsed_statement.value_expression != null {
        checked_expression = self.check_expression(parsed_statement.value_expression, checked_type)
        if checked_type == null {
            checked_type = checked_expression.type
            if checked_type is Checked_Null_Type or checked_type is Checked_Undefined_Type {
                abort(checked_expression.location, "Cannot infer variable type from ".clone().append(checked_type.name).append(" value"))
            }
        } else {
            if not checked_type.accepts(checked_expression.type) {
                abort(checked_expression.location, "Cannot assign a '".clone().append(checked_expression.type.name).append("' value to a '").append(checked_type.name).append("' variable"))
            }
            if checked_type.equals(checked_expression.type) { \ TODO: and not self.is_type_argument(parsed_statement.type) {
                stderr.write(parsed_statement.type.location).write(": ").warning().write("Redundant type declaration").reset().end_line()
            }
        }
    } else if not parsed_statement.is_external and checked_type == null {
        abort(parsed_statement.location, "Missing variable type")
    }

    \ create variable statement
    let checked_statement = make @Checked_Variable_Statement(
        location = parsed_statement.location
        variable = make @Checked_Variable_Symbol(
            location = parsed_statement.name.location
            name = parsed_statement.name.lexeme
            type = checked_type
            expression = checked_expression
        )
    )
    self.current_context.symbols.prepend(checked_statement.variable)

    return checked_statement
}

func check_expression(self: @Checker, parsed_expression: @Parsed_Expression, expected_type: @Checked_Type) -> @Checked_Expression {
    let checked_expression: @Checked_Expression
    if parsed_expression is Parsed_Call_Expression {
        checked_expression = self.check_call_expression(parsed_expression.as(@Parsed_Call_Expression))
    } else if parsed_expression is Parsed_Cast_Expression {
        checked_expression = self.check_cast_expression(parsed_expression.as(@Parsed_Cast_Expression))
    } else if parsed_expression is Parsed_Equals_Expression {
        checked_expression = self.check_equals_expression(parsed_expression.as(@Parsed_Equals_Expression))
    } else if parsed_expression is Parsed_Function_Expression {
        checked_expression = self.check_function_expression(parsed_expression.as(@Parsed_Function_Expression))
    } else if parsed_expression is Parsed_Literal_Expression {
        checked_expression = self.check_literal_expression(parsed_expression.as(@Parsed_Literal_Expression), expected_type)
    } else if parsed_expression is Parsed_Logic_Not_Expression {
        checked_expression = self.check_logic_not_expression(parsed_expression.as(@Parsed_Logic_Not_Expression))
    } else if parsed_expression is Parsed_Member_Access_Expression {
        checked_expression = self.check_member_access_expression(parsed_expression.as(@Parsed_Member_Access_Expression))
    } else if parsed_expression is Parsed_Modulo_Expression {
        checked_expression = self.check_modulo_expression(parsed_expression.as(@Parsed_Modulo_Expression))
    } else if parsed_expression is Parsed_Not_Equals_Expression {
        checked_expression = self.check_not_equals_expression(parsed_expression.as(@Parsed_Not_Equals_Expression))
    } else if parsed_expression is Parsed_Symbol_Expression {
        checked_expression = self.check_symbol_expression(parsed_expression.as(@Parsed_Symbol_Expression))
    } else if parsed_expression is Parsed_Wrapped_Expression {
        checked_expression = self.check_expression(parsed_expression.as(@Parsed_Wrapped_Expression).expression, expected_type)
    } else {
        abort("TODO: Check ".clone().append(parsed_expression.object_type.name))
    }

    if expected_type != null and not expected_type.accepts(checked_expression.type) {
        abort(parsed_expression.location, "TODO: Report unexpected type")
    }

    return checked_expression
}

func check_call_expression(self: @Checker, parsed_expression: @Parsed_Call_Expression) -> @Checked_Expression {
    \ check call arguments
    let checked_call_arguments = make @List[@Checked_Call_Argument]()
    parsed_expression.arguments.for_each() {
        let checked_call_argument_name: @String = null
        if it.name != null {
            checked_call_argument_name = it.name.lexeme
            abort("TODO: Check for duplicate argument names")
        }
        checked_call_arguments.append(make @Checked_Call_Argument(
            location = it.location
            name = checked_call_argument_name
            expression = self.check_expression(it.value_expression, null)
        ))
    }

    \ check callee expression
    let parsed_callee_expression = parsed_expression.callee_expression
    let checked_callee_expression = self.check_expression(parsed_callee_expression, null)
    if checked_callee_expression is Checked_Symbol_Expression {
        \ we have a `symbol(...)` call
        let checked_callee_expression = checked_callee_expression.as(@Checked_Symbol_Expression)
        let checked_symbol = checked_callee_expression.symbol

        \ dynamic calls have highest priority
        if checked_symbol is Checked_Variable_Symbol {
            let checked_symbol_type = checked_symbol.type
            if checked_symbol_type is Checked_Pointer_Type {
                let checked_symbol_type = checked_symbol_type.as(@Checked_Pointer_Type)
                if checked_symbol_type.pointed_type is Checked_Function_Type {
                    let checked_function_type = checked_symbol_type.pointed_type.as(@Checked_Function_Type)
                    if not checked_function_type.accepts(checked_call_arguments) {
                        abort(parsed_expression.location, "TODO: Report call arguments error")
                    }
                    return make @Checked_Dynamic_Call_Expression(
                        location = parsed_expression.location
                        type = checked_function_type.return_type
                        call_arguments = checked_call_arguments
                        callee_expression = checked_callee_expression
                    )
                }
            }
            abort(parsed_expression.location, "TODO: Report non-callable symbol error")
        }

        \ should be a function call
        if checked_symbol is Checked_Function_Symbol {
            if parsed_callee_expression is not Parsed_Symbol_Expression {
                abort(parsed_callee_expression.location, parsed_callee_expression.object_type)
            }
            return self.check_function_call_expression(parsed_callee_expression.as(@Parsed_Symbol_Expression), checked_call_arguments)
        }

        \ unsupported symbol
        abort(checked_callee_expression.location, checked_callee_expression.object_type)
    }
    abort(checked_callee_expression.location, checked_callee_expression.object_type)
}

func check_cast_expression(self: @Checker, parsed_expression: @Parsed_Cast_Expression) -> @Checked_Expression {
    let checked_expression = self.check_expression(parsed_expression.value_expression, null)
    let checked_type = self.convert_type(parsed_expression.type)
    if checked_expression.type.equals(checked_type) {
        stderr.write(parsed_expression.type.location).write(": ").warning().write("Redundant cast").reset().end_line()
    }
    if checked_expression.type is Checked_Pointer_Type {
        if checked_type is Checked_Pointer_Type or checked_type is Checked_Unchecked_Array_Type {
            return make @Checked_Cast_Expression(
                location = parsed_expression.location
                type = checked_type
                expression = checked_expression
            )
        }
    } else if checked_expression.type is Checked_Integer_Type {
        if checked_type is Checked_Integer_Type {
            return make @Checked_Cast_Expression(
                location = parsed_expression.location
                type = checked_type
                expression = checked_expression
            )
        }
    } else if checked_expression.type is Checked_Fixed_Array_Type {
        if checked_type is Checked_Unchecked_Array_Type {
            let checked_expression_type = checked_expression.type.as(@Checked_Fixed_Array_Type)
            let checked_type = checked_type.as(@Checked_Unchecked_Array_Type)
            if checked_expression_type.item_type == checked_type.item_type {
                return make @Checked_Cast_Expression(
                    location = parsed_expression.location
                    type = checked_type
                    expression = checked_expression
                )
            }
        }
    }
    abort(parsed_expression.location, clone("Cannot cast ").append(checked_expression.type.name).append(" to ").append(checked_type.name))
}

func check_equals_expression(self: @Checker, parsed_expression: @Parsed_Equals_Expression) -> @Checked_Expression {
    let left_expression = self.check_expression(parsed_expression.left_expression, null)
    let right_expression = self.check_expression(parsed_expression.right_expression, left_expression.type)
    return make @Checked_Equals_Expression(
        location = parsed_expression.location
        type = self.bool_type
        left_expression = left_expression
        right_expression = right_expression
    )
}

func check_function_expression(self: @Checker, parsed_expression: @Parsed_Function_Expression) -> @Checked_Expression {
    let checked_function_symbol = self.check_function_statement(parsed_expression.function_statement)
    return make @Checked_Symbol_Expression(
        location = parsed_expression.location
        type = checked_function_symbol.type
        symbol = checked_function_symbol
    )
}

func check_function_call_expression(self: @Checker, parsed_expression: @Parsed_Symbol_Expression, checked_call_arguments: @List[@Checked_Call_Argument]) -> @Checked_Expression {
    let function_name = parsed_expression.name.lexeme

    \ search all functions and mark the matching ones
    let function_symbol: @Checked_Function_Symbol = null
    let function_matches = 0
    self.checked_code.functions.for_each() {
        if function_name.equals(it.name) and it.function_type.accepts(checked_call_arguments) {
            it._is_match = true
            function_symbol = it
            function_matches = function_matches + 1
        } else {
            it._is_match = false
        }
    }

    if function_matches == 0 {
        \ list all similar functions and report error
        abort(parsed_expression.location, "TODO: List all similar functions")
    }

    if function_matches > 1 {
        abort(parsed_expression.location, "TODO: Pick best matching function")
    }

    \ validate match
    if function_matches != 1 or function_symbol == null {
        \ there is a bug
        abort()
    }

    return make @Checked_Function_Call_Expression(
        location = parsed_expression.location
        type = function_symbol.function_type.return_type
        call_arguments = checked_call_arguments
        function_symbol = function_symbol
    )
}

func check_literal_expression(self: @Checker, parsed_expression: @Parsed_Literal_Expression, expected_type: @Checked_Type) -> @Checked_Expression {
    let literal = parsed_expression.literal
    if literal is Boolean_Token {
        return make @Checked_Boolean_Literal_Expression(
            location = parsed_expression.location
            type = self.bool_type
            literal = parsed_expression.literal.as(@Boolean_Token)
        )
    }
    if literal is Character_Token {
        return make @Checked_Character_Literal_Expression(
            location = parsed_expression.location
            type = self.u8_type
            literal = parsed_expression.literal.as(@Character_Token)
        )
    }
    if literal is Integer_Token {
        let literal = literal.as(@Integer_Token)

        \ decide on literal type
        let literal_type: @Checked_Type
        if literal.type != null {
            \ type is part of the literal
            literal_type = self.get_named_type(literal.type)
        } else if expected_type == null or expected_type is not Checked_Integer_Type {
            \ invalid expected_type
            literal_type = self.i32_type
        } else {
            \ use expected_type
            literal_type = expected_type
        }

        \ check value range
        let max_negative_value: u64
        let max_positive_value: u64
        if literal_type is Checked_Int16_Type {
            max_negative_value = 0x0000_0000_0000_8000u64
            max_positive_value = 0x0000_0000_0000_7fffu64
        } else if literal_type is Checked_Int32_Type {
            max_negative_value = 0x0000_0000_8000_0000u64
            max_positive_value = 0x0000_0000_7fff_ffffu64
        } else if literal_type is Checked_Int64_Type or literal_type is Checked_IntMax_Type {
            max_negative_value = 0x800_0000_0000_0000u64 \ TODO: Use 0x8000_0000_0000_0000u64
            max_positive_value = 0x7ff_ffff_ffff_ffffu64 \ TODO: Use 0x7fff_ffff_ffff_ffffu64
        } else if literal_type is Checked_Int8_Type {
            max_negative_value = 0x0000_0000_0000_0080u64
            max_positive_value = 0x0000_0000_0000_007fu64
        } else if literal_type is Checked_UInt16_Type {
            max_negative_value = 0x0000_0000_0000_0000u64
            max_positive_value = 0x0000_0000_0000_ffffu64
        } else if literal_type is Checked_UInt32_Type {
            max_negative_value = 0x0000_0000_0000_0000u64
            max_positive_value = 0x0000_0000_ffff_ffffu64
        } else if literal_type is Checked_UInt64_Type or literal_type is Checked_UIntMax_Type {
            max_negative_value = 0x000_0000_0000_0000u64 \ TODO: Use 0x0000_0000_0000_0000u64
            max_positive_value = 0xfff_ffff_ffff_ffffu64 \ TODO: Use 0xffff_ffff_ffff_ffffu64
        } else if literal_type is Checked_UInt8_Type {
            max_negative_value = 0x0000_0000_0000_0000u64
            max_positive_value = 0x0000_0000_0000_00ffu64
        } else {
            abort(parsed_expression.location, literal_type.object_type)
        }
        if (literal.negative and literal.value > max_negative_value) or (not literal.negative and literal.value > max_positive_value) {
            abort(parsed_expression.location, clone("Value out of ").append(literal_type.name).append(" range: -").append(max_negative_value).append(" .. ").append(max_positive_value))
        }

        return make @Checked_Integer_Literal_Expression(
            location = parsed_expression.location
            type = literal_type
            literal = literal
        )
    }
    if literal is Null_Token {
        return make @Checked_Literal_Expression(
            location = parsed_expression.location
            type = self.null_type
        )
    }
    if literal is String_Token {
        return make @Checked_String_Literal_Expression(
            location = parsed_expression.location
            type = self.convert_type(
                make @Parsed_Pointer_Type(
                    location = null
                    pointed_type = make @Parsed_Named_Type(
                        name = make @Identifier_Token(
                            location = null
                            lexeme = "String"
                        )
                    )
                )
            )
            literal = literal.as(@String_Token)
        )
    }
    if literal is Undefined_Token {
        return make @Checked_Literal_Expression(
            location = parsed_expression.location
            type = self.undefined_type
        )
    }
    abort(parsed_expression.location, literal.object_type)
}

func check_logic_not_expression(self: @Checker, parsed_expression: @Parsed_Logic_Not_Expression) -> @Checked_Expression {
    return make @Checked_Logic_Not_Expression(
        location = parsed_expression.location
        type = self.bool_type
        expression = self.check_expression(parsed_expression.expression, self.bool_type)
    )
}

func check_member_access_expression(self: @Checker, parsed_expression: @Parsed_Member_Access_Expression) -> @Checked_Expression {
    let checked_object_expression = self.check_expression(parsed_expression.object_expression, null)
    let checked_object_type = checked_object_expression.type
    while checked_object_type is Checked_Pointer_Type {
        checked_object_type = checked_object_type.as(@Checked_Pointer_Type).pointed_type
    }
    if checked_object_type is not Checked_Struct_Type {
        abort(parsed_expression.location, clone("Not a struct type: ").append(checked_object_type.object_type.name))
    }
    let checked_struct_type = checked_object_type.as(@Checked_Struct_Type)
    let checked_struct_type_member = checked_struct_type.get_member(parsed_expression.member_name.lexeme)
    if checked_struct_type_member == null {
        abort(parsed_expression.member_name.location, clone(checked_struct_type.name).append(" has no such member: ").append(parsed_expression.member_name.lexeme))
    }
    return make @Checked_Member_Access_Expression(
        location = parsed_expression.location
        type = checked_struct_type_member.type
        object_expression = checked_object_expression
        struct_member = checked_struct_type_member
    )
}

func check_modulo_expression(self: @Checker, parsed_expression: @Parsed_Modulo_Expression) -> @Checked_Expression {
    let left_expression = self.check_expression(parsed_expression.left_expression, null)
    if left_expression.type is not Checked_Integer_Type {
        abort(parsed_expression.left_expression.location, "Not an integer value")
    }
    let right_expression = self.check_expression(parsed_expression.right_expression, left_expression.type)
    return make @Checked_Modulo_Expression(
        location = parsed_expression.location
        type = left_expression.type
        left_expression = left_expression
        right_expression = right_expression
    )
}

func check_not_equals_expression(self: @Checker, parsed_expression: @Parsed_Not_Equals_Expression) -> @Checked_Expression {
    let left_expression = self.check_expression(parsed_expression.left_expression, null)
    let right_expression = self.check_expression(parsed_expression.right_expression, left_expression.type)
    return make @Checked_Not_Equals_Expression(
        location = parsed_expression.location
        type = self.bool_type
        left_expression = left_expression
        right_expression = right_expression
    )
}

func check_symbol_expression(self: @Checker, parsed_expression: @Parsed_Symbol_Expression) -> @Checked_Expression {
    let symbol = self.current_context.find_symbol(parsed_expression.name.lexeme)
    if symbol == null {
        abort(parsed_expression.location, clone("Undeclared symbol: ").append(parsed_expression.name.lexeme))
    }
    return make @Checked_Symbol_Expression(
        location = parsed_expression.location
        type = symbol.type
        symbol = symbol
    )
}

func convert_type(self: @Checker, parsed_type: @Parsed_Type) -> @Checked_Type {
    \ if parsed_type is Parsed_Array_Type {
    \     return self.convert_array_type(parsed_type.as(@Parsed_Array_Type))
    \ }
    \ if parsed_type is Parsed_Function_Type {
    \     return self.convert_function_type(parsed_type.as(@Parsed_Function_Type))
    \ }
    \ if parsed_type is Parsed_Macro_Type {
    \     return self.convert_macro_type(parsed_type.as(@Parsed_Macro_Type))
    \ }
    if parsed_type is Parsed_Named_Type {
        return self.convert_named_type(parsed_type.as(@Parsed_Named_Type))
    }
    \ if parsed_type is Parsed_Placeholder_Type {
    \     let parsed_type = parsed_type.as(@Parsed_Placeholder_Type)
    \     return make @Checked_Placeholder_Type(name = parsed_type.name, parsed_type = parsed_type)
    \ }
    if parsed_type is Parsed_Pointer_Type {
        return self.convert_pointer_type(parsed_type.as(@Parsed_Pointer_Type))
    }
    \ if parsed_type is Parsed_Specialized_Type {
    \     return self.convert_specialized_type(parsed_type.as(@Parsed_Specialized_Type))
    \ }
    abort("TODO: Convert ".clone().append(parsed_type.object_type.name))
}

func convert_named_type(self: @Checker, parsed_type: @Parsed_Named_Type) -> @Checked_Type {
    let checked_type_name = parsed_type.name.lexeme

    \ let context = self.context
    \ while context != null {
    \     if context.type_arguments != null {
    \         for_each(context.type_arguments) {
    \             let type_argument = it
    \             if type_argument.name == null {
    \                 abort("Invalid state")
    \             }
    \             if type_argument.name.equals(checked_type_name) {
    \                 return self.convert_type(type_argument.type)
    \             }
    \         }
    \     }
    \     context = context.parent
    \ }

    let checked_type: @Checked_Type = self.named_types.get(checked_type_name)
    if checked_type == null {
        \ find type statement
        let parsed_type_statement = self.parsed_code.get_type_statement(checked_type_name)
        if parsed_type_statement != null {
            checked_type = self.check_type_statement(parsed_type_statement).type
        } else {
            abort(parsed_type.name.location, clone("Unknown type: ").append(checked_type_name))
        }
    }

    return checked_type
}

func convert_pointer_type(self: @Checker, parsed_pointer_type: @Parsed_Pointer_Type) -> @Checked_Type {
    let checked_pointed_type = self.convert_type(parsed_pointer_type.pointed_type)
    return make @Checked_Pointer_Type(
        name = "@".clone().append(checked_pointed_type.name)
        pointed_type = checked_pointed_type
    )
}
