include "./Checked_Code.code"

func check(parsed_code: @Parsed_Code) -> @Checked_Code {
    let checker = make Checker(
        parsed_code = parsed_code
        checked_code = make @Checked_Code()
        current_context = undefined
    )
    checker.current_context = checker.root_context

    \ add builtin types
    checker.put_global_type(make @Checked_Any_Type())
    checker.bool_type = checker.put_global_type(make @Checked_Bool_Type())
    checker.i16_type = checker.put_global_type(make @Checked_Int16_Type())
    checker.i32_type = checker.put_global_type(make @Checked_Int32_Type())
    checker.i64_type = checker.put_global_type(make @Checked_Int64_Type())
    checker.i8_type = checker.put_global_type(make @Checked_Int8_Type())
    checker.isize_type = checker.put_global_type(make @Checked_IntMax_Type())
    checker.nothing_type = checker.put_global_type(make @Checked_Nothing_Type())
    checker.null_type = checker.put_global_type(make @Checked_Null_Type())
    checker.u16_type = checker.put_global_type(make @Checked_UInt16_Type())
    checker.u32_type = checker.put_global_type(make @Checked_UInt32_Type())
    checker.u64_type = checker.put_global_type(make @Checked_UInt64_Type())
    checker.u8_type = checker.put_global_type(make @Checked_UInt8_Type())
    checker.usize_type = checker.put_global_type(make @Checked_UIntMax_Type())
    checker.undefined_type = checker.put_global_type(make @Checked_Undefined_Type())

    checker.check(parsed_code)

    return checker.checked_code
}

struct Checker {
    parsed_code: @Parsed_Code
    checked_code: @Checked_Code

    root_context = make Checker_Context(parent = null)
    current_context: @Checker_Context

    expected_return_type: @Checked_Type = null

    global_types = make Map[@String, @Checked_Type]()
    local_types: @Map[@String, @Checked_Type] = null

    generic_struct_statements = make Map[@String, @Parsed_Generic_Struct_Statement]()
    generic_function_statements = make List[@Parsed_Function_Statement]()
    macro_statements = make List[@Parsed_Macro_Statement]()

    bool_type: @Checked_Type = undefined
    i16_type: @Checked_Type = undefined
    i32_type: @Checked_Type = undefined
    i64_type: @Checked_Type = undefined
    i8_type: @Checked_Type = undefined
    isize_type: @Checked_Type = undefined
    nothing_type: @Checked_Type = undefined
    null_type: @Checked_Type = undefined
    u16_type: @Checked_Type = undefined
    u32_type: @Checked_Type = undefined
    u64_type: @Checked_Type = undefined
    u8_type: @Checked_Type = undefined
    usize_type: @Checked_Type = undefined
    undefined_type: @Checked_Type = undefined
}

func get_global_type(self: @Checker, name: @String) -> @Checked_Type {
    if self.local_types != null and self.local_types.has(name) {
        return self.local_types.get(name)
    }
    return self.global_types.get(name)
}

func put_global_type(self: @Checker, type: @Checked_Named_Type) -> @Checked_Type {
    self.global_types.put(type.name, type)
    return type
}

struct Checker_Context {
    parent: @Checker_Context

    symbols = make List[@Checked_Symbol]()
}

func find_symbol(self: @Checker_Context, name: @String) -> @Checked_Symbol {
    \ search local symbols
    self.symbols.for_each() {
        if it.name.equals(name) {
            return it
        }
    }

    \ search parent symbols
    if self.parent != null {
        return self.parent.find_symbol(name)
    }

    \ not found
    return null
}

func find_function_symbol(self: @Checker_Context, name: @String) -> @Checked_Function_Symbol {
    \ search local symbols
    self.symbols.for_each() {
        if it is Checked_Function_Symbol and it.name.equals(name) {
            return it.as(@Checked_Function_Symbol)
        }
    }

    \ search parent symbols
    if self.parent != null {
        return self.parent.find_function_symbol(name)
    }

    \ not found
    return null
}

func check(self: @Checker, parsed_code: @Parsed_Code) -> Nothing {
    \ create root statements
    parsed_code.statements.for_each() {
        if it is Parsed_Generic_Struct_Statement {
            \ generic structs are checked only during specialization
            let parsed_generic_struct_statement = it.as(@Parsed_Generic_Struct_Statement)
            if self.generic_struct_statements.has(parsed_generic_struct_statement.name.lexeme) {
                abort(it.location, "TODO: Report duplicate generic type error")
            }
            self.generic_struct_statements.put(parsed_generic_struct_statement.name.lexeme, parsed_generic_struct_statement)
        } else if it is Parsed_Function_Statement {
            let parsed_function_statement = it.as(@Parsed_Function_Statement)
            if parsed_function_statement.type.type_parameters != null {
                \ generic functions are checked only during specialization
                self.generic_function_statements.append(parsed_function_statement)
            } else {
                self.check_function_statement(parsed_function_statement)
            }
        } else if it is Parsed_Macro_Statement {
            let parsed_macro_statement = it.as(@Parsed_Macro_Statement)
            self.macro_statements.append(parsed_macro_statement)
            self.root_context.symbols.append(make @Checked_Macro_Symbol(
                location = parsed_macro_statement.location
                name = parsed_macro_statement.name.lexeme
                type = self.nothing_type
                parsed_macro_statement = parsed_macro_statement
            ))
        } else if it is Parsed_Struct_Statement {
            self.check_struct_statement(it.as(@Parsed_Struct_Statement))
        } else if it is Parsed_Variable_Statement {
            let checked_statement = self.check_variable_statement(it.as(@Parsed_Variable_Statement))
            let variable = checked_statement.variable
            if variable.expression != null {
                abort("TODO: Check constant expression")
            }
            self.checked_code.globals.put(variable.name, variable)
            self.root_context.symbols.append(variable)
        } else {
            abort(it.location, it.object_type)
        }
    }

    \ check functions
    self.checked_code.functions.for_each() {
        if it.parsed_function_statement.body != null {
            self.check_function_symbol(it)
        }
    }
}

func check_function_statement(self: @Checker, parsed_function_statement: @Parsed_Function_Statement) -> @Checked_Function_Symbol {
    \ create function type
    let checked_function_type = self.convert_function_type(parsed_function_statement.type)

    \ check for duplicates
    self.checked_code.functions.for_each() {
        if it.name.equals(parsed_function_statement.name) {
            abort(parsed_function_statement.location, "TODO: Compare function types")
        }
    }

    \ create function
    let checked_function = make @Checked_Function_Symbol(
        location = parsed_function_statement.location
        name = parsed_function_statement.name.lexeme
        type = make @Checked_Pointer_Type(
            name = "@(".clone().append(checked_function_type.name).append(')')
            pointed_type = checked_function_type
        )
        function_type = checked_function_type

        parsed_function_statement = parsed_function_statement
    )
    self.checked_code.functions.append(checked_function)
    if not parsed_function_statement.is_anonymous {
        self.root_context.symbols.append(checked_function)
    }

    return checked_function
}

func check_function_symbol(self: @Checker, checked_function: @Checked_Function_Symbol) -> Nothing {
    let parsed_function_statement = checked_function.parsed_function_statement

    \ create function context
    self.current_context = make @Checker_Context(
        parent = self.current_context
    )
    let checked_function_type = checked_function.function_type
    checked_function_type.parameters.for_each() {
        self.current_context.symbols.prepend(make @Checked_Parameter_Symbol(
            location = it.location
            name = it.name
            type = it.type
        ))
    }

    \ check function body
    self.expected_return_type = checked_function_type.return_type
    self.check_block_statement(parsed_function_statement.body)
    self.expected_return_type = null

    \ restore context
    self.current_context = self.current_context.parent
}

func check_statement(self: @Checker, parsed_statement: @Parsed_Statement) -> @Checked_Statement {
    if parsed_statement is Parsed_Assignment_Statement {
        return self.check_assignment_statement(parsed_statement.as(@Parsed_Assignment_Statement))
    }
    if parsed_statement is Parsed_Block_Statement {
        return self.check_block_statement(parsed_statement.as(@Parsed_Block_Statement))
    }
    if parsed_statement is Parsed_Expression_Statement {
        return self.check_expression_statement(parsed_statement.as(@Parsed_Expression_Statement))
    }
    if parsed_statement is Parsed_If_Statement {
        return self.check_if_statement(parsed_statement.as(@Parsed_If_Statement))
    }
    if parsed_statement is Parsed_Return_Statement {
        return self.check_return_statement(parsed_statement.as(@Parsed_Return_Statement))
    }
    if parsed_statement is Parsed_Variable_Statement {
        return self.check_variable_statement(parsed_statement.as(@Parsed_Variable_Statement))
    }
    if parsed_statement is Parsed_While_Statement {
        return self.check_while_statement(parsed_statement.as(@Parsed_While_Statement))
    }
    abort(parsed_statement.location, parsed_statement.object_type)
}

func check_assignment_statement(self: @Checker, parsed_statement: @Parsed_Assignment_Statement) -> @Checked_Statement {
    let checked_destination_expression = self.check_expression(parsed_statement.storage_expression, null)
    if checked_destination_expression.type is Checked_Struct_Type {
        abort(parsed_statement.location, "Struct assignement is currently not supported")
    }
    if checked_destination_expression is Checked_Member_Access_Expression {
        return make @Checked_Assignment_Statement(
            location = parsed_statement.location
            destination_expression = checked_destination_expression
            value_expression = self.check_expression(parsed_statement.value_expression, checked_destination_expression.type)
        )
    }
    abort(checked_destination_expression.location, checked_destination_expression.object_type)
}

func check_block_statement(self: @Checker, parsed_statement: @Parsed_Block_Statement) -> @Checked_Block_Statement {
    let checked_statement = make @Checked_Block_Statement(
        location = parsed_statement.location
    )

    \ create function context
    self.current_context = make @Checker_Context(
        parent = self.current_context
    )

    \ check function body
    parsed_statement.statements.for_each() {
        checked_statement.statements.append(self.check_statement(it))
    }

    \ restore context
    self.current_context = self.current_context.parent

    return checked_statement
}

func check_expression_statement(self: @Checker, parsed_statement: @Parsed_Expression_Statement) -> @Checked_Statement {
    let checked_expression = self.check_expression(parsed_statement.expression, null)
    if checked_expression.type is not Checked_Nothing_Type {
        abort(checked_expression.location, "TODO: Warn about unhandled expression value")
    }
    if checked_expression is Checked_Macro_Call_Expression {
        return self.inline_macro_call_expression(checked_expression.as(@Checked_Macro_Call_Expression))
    }
    return make @Checked_Expression_Statement(
        location = parsed_statement.location
        expression = checked_expression
    )
}

func check_if_statement(self: @Checker, parsed_statement: @Parsed_If_Statement) -> @Checked_Statement {
    let checked_condition_expression = self.check_expression(parsed_statement.condition_expression, self.bool_type)
    let checked_true_statement = self.check_statement(parsed_statement.true_statement)
    let checked_false_statement: @Checked_Statement = null
    if parsed_statement.false_statement != null {
        checked_false_statement = self.check_statement(parsed_statement.true_statement)
    }
    return make @Checked_If_Statement(
        location = parsed_statement.location
        condition_expression = checked_condition_expression
        true_statement = checked_true_statement
        false_statement = checked_false_statement
    )
}

func check_return_statement(self: @Checker, parsed_statement: @Parsed_Return_Statement) -> @Checked_Statement {
    let checked_expression: @Checked_Expression = null
    if parsed_statement.value_expression != null {
        checked_expression = self.check_expression(parsed_statement.value_expression, self.expected_return_type)
    }
    return make @Checked_Return_Statement(
        location = parsed_statement.location
        expression = checked_expression
    )
}

func check_struct_statement(self: @Checker, parsed_struct_statement: @Parsed_Struct_Statement) -> @Checked_Struct_Symbol {
    return self.check_struct_statement(parsed_struct_statement, parsed_struct_statement.name.lexeme, null)
}

func check_struct_statement(self: @Checker, parsed_struct_statement: @Parsed_Struct_Statement, checked_struct_name: @String, specialization_types: @Map[@String, @Checked_Named_Type]) -> @Checked_Struct_Symbol {
    \ check for uniqueness
    let checked_symbol = self.checked_code.globals.get(checked_struct_name)
    if checked_symbol != null {
        if checked_symbol is not Checked_Struct_Symbol {
            abort(parsed_struct_statement.location, clone("Duplicate declaration: ").append(checked_struct_name))
        }
        return checked_symbol.as(@Checked_Struct_Symbol)
    }

    \ create struct type
    let checked_struct_type: @Checked_Struct_Type
    if specialization_types != null {
        checked_struct_type = make @Checked_Specialized_Struct_Type(
            name = checked_struct_name
            generic_struct_name = parsed_struct_statement.name.lexeme
            specialization_types = specialization_types
        )
    } else {
        checked_struct_type = make @Checked_Struct_Type(
            name = checked_struct_name
        )
    }

    self.put_global_type(checked_struct_type)

    \ create struct symbol
    let checked_struct_symbol = make @Checked_Struct_Symbol(
        location = parsed_struct_statement.name.location
        name = checked_struct_name
        type = checked_struct_type
    )
    self.checked_code.globals.put(checked_struct_name, checked_struct_symbol)
    self.root_context.symbols.append(checked_struct_symbol)

    \ apply specialization, if any
    let local_types = self.local_types
    if specialization_types != null {
        self.local_types = specialization_types
    }

    \ check super type
    if parsed_struct_statement.super_type != null {
        let checked_super_type = self.convert_type(parsed_struct_statement.super_type)
        if checked_super_type is not Checked_Struct_Type {
            abort(parsed_struct_statement.super_type.location, "Not a struct type")
        }
        let checked_super_type = checked_super_type.as(@Checked_Struct_Type)
        if checked_super_type == checked_struct_type or checked_super_type.has_super_type(checked_struct_type) {
            abort(parsed_struct_statement.super_type.location, "Type recursivity")
        }

        checked_struct_type.super_type = checked_super_type
        checked_super_type.derived_types.append(checked_struct_type)

        if parsed_struct_statement.super_arguments.size > 0 {
            abort(parsed_struct_statement.super_type.location, "TODO: Check super arguments")
        }
    }

    \ check struct members
    if parsed_struct_statement.members != null {
        parsed_struct_statement.members.for_each() {
            let parsed_struct_member = it
            let checked_struct_member_name = parsed_struct_member.name.lexeme
            if checked_struct_member_name.equals("super") {
                abort(parsed_struct_member.name.location, "'super' cannot be used as member name")
            }
            let checked_struct_member_type: @Checked_Type = null
            if parsed_struct_member.type != null {
                checked_struct_member_type = self.convert_type(parsed_struct_member.type)
            }
            let checked_struct_member_value_expression: @Checked_Expression = null
            if parsed_struct_member.default_value_expression != null {
                checked_struct_member_value_expression = self.check_expression(parsed_struct_member.default_value_expression, checked_struct_member_type)
                if checked_struct_member_type != null {
                    if not checked_struct_member_type.accepts(checked_struct_member_value_expression.type) {
                        abort(checked_struct_member_value_expression.location, clone("Cannot assign a '").append(checked_struct_member_value_expression.type.name).append("' value to a '").append(checked_struct_member_type.name).append("' struct member"))
                    }
                    if checked_struct_member_type.equals(checked_struct_member_value_expression.type) { \ and not self.is_type_argument(parsed_struct_member.type) {
                        stderr.write(parsed_struct_member.type.location).write(": ").warning().write("Redundant type declaration").reset().end_line()
                    }
                } else {
                    if checked_struct_member_value_expression.type is Checked_Null_Type {
                        abort(checked_struct_member_value_expression.location, clone("Cannot infer type from a null value"))
                    }
                    if checked_struct_member_value_expression.type is Checked_Undefined_Type {
                        abort(checked_struct_member_value_expression.location, clone("Cannot infer type from an undefined value"))
                    }
                    checked_struct_member_type = checked_struct_member_value_expression.type
                }
            }
            if checked_struct_member_type == null {
                abort(parsed_struct_member.name.location, "Cannot infer type of struct member")
            }
            if checked_struct_member_type is Checked_Struct_Type {
                let checked_struct_member_type = checked_struct_member_type.as(@Checked_Struct_Type)
                if checked_struct_member_type == checked_struct_type or checked_struct_member_type.has_super_type(checked_struct_type) {
                    abort(parsed_struct_member.type.location, "Type recursivity")
                }
            }
            checked_struct_type.add_member(checked_struct_member_name, checked_struct_member_type, checked_struct_member_value_expression)
        }
    }

    \ restore local_types
    self.local_types = local_types

    return checked_struct_symbol
}

func check_type_statement(self: @Checker, parsed_type_statement: @Parsed_Type_Statement) -> @Checked_Symbol {
    if parsed_type_statement is Parsed_Struct_Statement {
        return self.check_struct_statement(parsed_type_statement.as(@Parsed_Struct_Statement))
    }
    abort(parsed_type_statement.location, parsed_type_statement.object_type)
}

func check_variable_statement(self: @Checker, parsed_statement: @Parsed_Variable_Statement) -> @Checked_Variable_Statement {
    \ check variable type
    let checked_type: @Checked_Type = null
    if parsed_statement.type != null {
        checked_type = self.convert_type(parsed_statement.type)
        if checked_type is Checked_Opaque_Type {
            abort(parsed_statement.type.location, "Variable cannot have an opaque type")
        }
        if checked_type is Checked_Any_Type or checked_type is Checked_Nothing_Type {
            abort(parsed_statement.type.location, "Variable cannot have the ".clone().append(checked_type.name).append(" type"))
        }
        if checked_type is Checked_Function_Type {
            \ make function pointer type
            checked_type = make @Checked_Pointer_Type(
                name = "@(".clone().append(checked_type.name).append(')')
                pointed_type = checked_type
            )
        }
    }

    \ check variable expression
    let checked_expression: @Checked_Expression = null
    if parsed_statement.value_expression != null {
        checked_expression = self.check_expression(parsed_statement.value_expression, checked_type)
        if checked_type == null {
            checked_type = checked_expression.type
            if checked_type is Checked_Null_Type or checked_type is Checked_Undefined_Type {
                abort(checked_expression.location, "Cannot infer variable type from ".clone().append(checked_type.name).append(" value"))
            }
        } else {
            if not checked_type.accepts(checked_expression.type) {
                abort(checked_expression.location, "Cannot assign a '".clone().append(checked_expression.type.name).append("' value to a '").append(checked_type.name).append("' variable"))
            }
            if checked_type.equals(checked_expression.type) { \ TODO: and not self.is_type_argument(parsed_statement.type) {
                stderr.write(parsed_statement.type.location).write(": ").warning().write("Redundant type declaration").reset().end_line()
            }
        }
    } else if not parsed_statement.is_external and checked_type == null {
        abort(parsed_statement.location, "Missing variable type")
    }

    \ create variable statement
    let checked_statement = make @Checked_Variable_Statement(
        location = parsed_statement.location
        variable = make @Checked_Variable_Symbol(
            location = parsed_statement.name.location
            name = parsed_statement.name.lexeme
            type = checked_type
            expression = checked_expression
        )
    )
    self.current_context.symbols.prepend(checked_statement.variable)

    return checked_statement
}

func check_while_statement(self: @Checker, parsed_statement: @Parsed_While_Statement) -> @Checked_Statement {
    let checked_condition_expression = self.check_expression(parsed_statement.condition_expression, self.bool_type)
    let checked_body_statement = self.check_statement(parsed_statement.body_statement)
    return make @Checked_While_Statement(
        location = parsed_statement.location
        condition_expression = checked_condition_expression
        body_statement = checked_body_statement
    )
}

func check_expression(self: @Checker, parsed_expression: @Parsed_Expression, expected_type: @Checked_Type) -> @Checked_Expression {
    let checked_expression: @Checked_Expression
    if parsed_expression is Parsed_Call_Expression {
        checked_expression = self.check_call_expression(parsed_expression.as(@Parsed_Call_Expression))
    } else if parsed_expression is Parsed_Cast_Expression {
        checked_expression = self.check_cast_expression(parsed_expression.as(@Parsed_Cast_Expression))
    } else if parsed_expression is Parsed_Equals_Expression {
        checked_expression = self.check_equals_expression(parsed_expression.as(@Parsed_Equals_Expression))
    } else if parsed_expression is Parsed_Function_Expression {
        checked_expression = self.check_function_expression(parsed_expression.as(@Parsed_Function_Expression))
    } else if parsed_expression is Parsed_Literal_Expression {
        checked_expression = self.check_literal_expression(parsed_expression.as(@Parsed_Literal_Expression), expected_type)
    } else if parsed_expression is Parsed_Logic_Not_Expression {
        checked_expression = self.check_logic_not_expression(parsed_expression.as(@Parsed_Logic_Not_Expression))
    } else if parsed_expression is Parsed_Macro_Body {
        checked_expression = self.check_macro_body(parsed_expression.as(@Parsed_Macro_Body))
    } else if parsed_expression is Parsed_Make_Expression {
        checked_expression = self.check_make_expression(parsed_expression.as(@Parsed_Make_Expression))
    } else if parsed_expression is Parsed_Member_Access_Expression {
        checked_expression = self.check_member_access_expression(parsed_expression.as(@Parsed_Member_Access_Expression))
    } else if parsed_expression is Parsed_Modulo_Expression {
        checked_expression = self.check_modulo_expression(parsed_expression.as(@Parsed_Modulo_Expression))
    } else if parsed_expression is Parsed_Not_Equals_Expression {
        checked_expression = self.check_not_equals_expression(parsed_expression.as(@Parsed_Not_Equals_Expression))
    } else if parsed_expression is Parsed_Symbol_Expression {
        checked_expression = self.check_symbol_expression(parsed_expression.as(@Parsed_Symbol_Expression))
    } else if parsed_expression is Parsed_Wrapped_Expression {
        checked_expression = self.check_expression(parsed_expression.as(@Parsed_Wrapped_Expression).expression, expected_type)
    } else {
        abort(parsed_expression.location, "TODO: Check ".clone().append(parsed_expression.object_type.name))
    }

    if expected_type != null and not expected_type.accepts(checked_expression.type) {
        abort(parsed_expression.location, "TODO: Report unexpected type")
    }

    return checked_expression
}

func check_call_expression(self: @Checker, parsed_expression: @Parsed_Call_Expression) -> @Checked_Expression {
    let parsed_callee_expression = parsed_expression.callee_expression

    \ check call arguments
    let checked_call_arguments = make @List[@Checked_Call_Argument]()
    parsed_expression.arguments.for_each() {
        let checked_call_argument_name: @String = null
        if it.name != null {
            checked_call_argument_name = it.name.lexeme
            abort("TODO: Check for duplicate argument names")
        }
        checked_call_arguments.append(make @Checked_Call_Argument(
            location = it.location
            name = checked_call_argument_name
            expression = self.check_expression(it.value_expression, null)
        ))
    }

    \ treat Parsed_Member_Access_Expression specially
    if parsed_callee_expression is Parsed_Member_Access_Expression {
        \ we have a foo.bar(...) call which needs special attention
        let parsed_member_access_expression = parsed_callee_expression.as(@Parsed_Member_Access_Expression)
        let parsed_member_name = parsed_member_access_expression.member_name.lexeme

        \ check object expression
        let checked_object_expression = self.check_expression(parsed_member_access_expression.object_expression, null)
        let checked_object_type = checked_object_expression.type
        if checked_object_type is Checked_Struct_Type {
            let checked_object_type = checked_object_type.as(@Checked_Struct_Type)
            let checked_struct_member = checked_object_type.get_member(parsed_member_name)
            if checked_struct_member != null {
                \ check if member is callable
                abort(parsed_member_access_expression.member_name.location, "TODO: Check if member is callable")
                abort(parsed_member_access_expression.member_name.location, "TODO: Check callable member accepts arguments")
                abort(parsed_member_access_expression.member_name.location, "TODO: Create callable expression")
            }

            \ add object reference as first call argument
            checked_call_arguments.prepend(make @Checked_Call_Argument(
                location = checked_object_expression.location
                name = null
                expression = make @Checked_Reference_Expression( \ struct objects have always an address
                    location = checked_object_expression.location
                    type = make @Checked_Pointer_Type(
                        name = "@".clone().append(checked_object_type.name)
                        pointed_type = checked_object_type
                    )
                    object_expression = checked_object_expression
                )
            ))
        } else {
            \ add object as first call argument
            checked_call_arguments.prepend(make @Checked_Call_Argument(
                location = checked_object_expression.location
                name = null
                expression = checked_object_expression
            ))
        }

        \ treat as uniform callable call syntax
        return self.check_callable_call_expression(parsed_member_access_expression.member_name, checked_call_arguments)
    }

    \ check callee expression
    let checked_callee_expression = self.check_expression(parsed_callee_expression, null)
    if checked_callee_expression is Checked_Symbol_Expression {
        \ we have a `baz(...)` call
        let checked_callee_expression = checked_callee_expression.as(@Checked_Symbol_Expression)
        let checked_symbol = checked_callee_expression.symbol

        \ dynamic calls have highest priority
        if checked_symbol is Checked_Variable_Symbol or checked_symbol is Checked_Parameter_Symbol {
            let checked_symbol_type = checked_symbol.type
            if checked_symbol_type is Checked_Pointer_Type {
                let checked_symbol_type = checked_symbol_type.as(@Checked_Pointer_Type)
                if checked_symbol_type.pointed_type is Checked_Function_Type {
                    let checked_function_type = checked_symbol_type.pointed_type.as(@Checked_Function_Type)
                    if not checked_function_type.accepts(checked_call_arguments) {
                        abort(parsed_expression.location, "TODO: Report call arguments error")
                    }
                    return make @Checked_Dynamic_Call_Expression(
                        location = parsed_expression.location
                        type = checked_function_type.return_type
                        call_arguments = checked_call_arguments
                        callee_expression = checked_callee_expression
                    )
                }
            }
            abort(parsed_expression.location, "TODO: Report non-callable symbol error")
        }

        \ should be a callable symbol
        if checked_symbol is Checked_Function_Symbol or checked_symbol is Checked_Macro_Symbol {
            if parsed_callee_expression is not Parsed_Symbol_Expression {
                abort(parsed_callee_expression.location, parsed_callee_expression.object_type)
            }
            return self.check_callable_call_expression(parsed_callee_expression.as(@Parsed_Symbol_Expression).name, checked_call_arguments)
        }

        \ unsupported symbol
        abort(checked_symbol.location, checked_symbol.object_type)
    }
    abort(checked_callee_expression.location, checked_callee_expression.object_type)
}

func check_cast_expression(self: @Checker, parsed_expression: @Parsed_Cast_Expression) -> @Checked_Expression {
    let checked_expression = self.check_expression(parsed_expression.value_expression, null)
    let checked_type = self.convert_type(parsed_expression.type)
    if checked_expression.type.equals(checked_type) {
        stderr.write(parsed_expression.type.location).write(": ").warning().write("Redundant cast").reset().end_line()
    }
    if checked_expression.type is Checked_Pointer_Type {
        if checked_type is Checked_Pointer_Type or checked_type is Checked_Unchecked_Array_Type {
            return make @Checked_Cast_Expression(
                location = parsed_expression.location
                type = checked_type
                expression = checked_expression
            )
        }
    } else if checked_expression.type is Checked_Integer_Type {
        if checked_type is Checked_Integer_Type {
            return make @Checked_Cast_Expression(
                location = parsed_expression.location
                type = checked_type
                expression = checked_expression
            )
        }
    } else if checked_expression.type is Checked_Fixed_Array_Type {
        if checked_type is Checked_Unchecked_Array_Type {
            let checked_expression_type = checked_expression.type.as(@Checked_Fixed_Array_Type)
            let checked_type = checked_type.as(@Checked_Unchecked_Array_Type)
            if checked_expression_type.item_type == checked_type.item_type {
                return make @Checked_Cast_Expression(
                    location = parsed_expression.location
                    type = checked_type
                    expression = checked_expression
                )
            }
        }
    }
    abort(parsed_expression.location, clone("Cannot cast ").append(checked_expression.type.name).append(" to ").append(checked_type.name))
}

func check_equals_expression(self: @Checker, parsed_expression: @Parsed_Equals_Expression) -> @Checked_Expression {
    let left_expression = self.check_expression(parsed_expression.left_expression, null)
    let right_expression = self.check_expression(parsed_expression.right_expression, left_expression.type)
    return make @Checked_Equals_Expression(
        location = parsed_expression.location
        type = self.bool_type
        left_expression = left_expression
        right_expression = right_expression
    )
}

func check_function_expression(self: @Checker, parsed_expression: @Parsed_Function_Expression) -> @Checked_Expression {
    let checked_function_symbol = self.check_function_statement(parsed_expression.function_statement)
    return make @Checked_Symbol_Expression(
        location = parsed_expression.location
        type = checked_function_symbol.type
        symbol = checked_function_symbol
    )
}

struct Callable_Match: Object {
    callable_type: @Checked_Callable_Type
}

struct Checked_Function_Match: Callable_Match {
    function_symbol: @Checked_Function_Symbol
}

struct Parsed_Generic_Function_Match: Callable_Match {
    function_statement: @Parsed_Function_Statement
    specialization_types: @Map[@String, @Checked_Type]
}

struct Parsed_Macro_Match: Callable_Match {
    macro_statement: @Parsed_Macro_Statement
    specialization_types: @Map[@String, @Checked_Type]
}

func check_callable_call_expression(self: @Checker, callable_name: @Identifier_Token, checked_call_arguments: @List[@Checked_Call_Argument]) -> @Checked_Expression {
    let callable_matches = make List[@Callable_Match]()

    \ find all matching functions
    self.checked_code.functions.for_each() {
        if callable_name.lexeme.equals(it.name) and it.function_type.accepts(checked_call_arguments) {
            callable_matches.append(make @Checked_Function_Match(
                callable_type = it.function_type
                function_symbol = it
            ))
        }
    }
    \ find all matching generic functions
    self.generic_function_statements.for_each() {
        if callable_name.lexeme.equals(it.name.lexeme) {
            \ create function type
            let specialized_function_type = self.specialize_callable_type(it.type, checked_call_arguments)
            if specialized_function_type != null and specialized_function_type.checked_callable_type.accepts(checked_call_arguments) {
                \ abort(callable_name.location, "TODO: Check if generic funtion was already specialized")
                callable_matches.append(make @Parsed_Generic_Function_Match(
                    callable_type = specialized_function_type.checked_callable_type
                    function_statement = it
                    specialization_types = specialized_function_type.specialization_types
                ))
            }
        }
    }
    \ find all matching macros
    self.macro_statements.for_each() {
        if callable_name.lexeme.equals(it.name.lexeme) {
            \ create function type
            let specialized_macro_type = self.specialize_callable_type(it.type, checked_call_arguments)
            if specialized_macro_type != null and specialized_macro_type.checked_callable_type.accepts(checked_call_arguments) {
                \ abort(callable_name.location, "TODO: Check if generic funtion was already specialized")
                callable_matches.append(make @Parsed_Macro_Match(
                    callable_type = specialized_macro_type.checked_callable_type
                    macro_statement = it
                    specialization_types = specialized_macro_type.specialization_types
                ))
            }
        }
    }

    if callable_matches.size == 0 {
        \ list all named functions and report error
        abort(callable_name.location, "TODO: List all named functions")
    }

    if callable_matches.size > 1 {
        abort(callable_name.location, "TODO: Pick best matching function")
    }

    let callable_match = callable_matches.first()
    if callable_match is Checked_Function_Match {
        let callable_match = callable_match.as(@Checked_Function_Match)
        return make @Checked_Function_Call_Expression(
            location = callable_name.location
            type = callable_match.function_symbol.function_type.return_type
            call_arguments = checked_call_arguments
            function_symbol = callable_match.function_symbol
        )
    }
    if callable_match is Parsed_Generic_Function_Match {
        let callable_match = callable_match.as(@Parsed_Generic_Function_Match)

        let local_types = self.local_types
        self.local_types = callable_match.specialization_types

        let checked_function_symbol = self.check_function_statement(callable_match.function_statement)

        self.local_types = local_types

        return make @Checked_Function_Call_Expression(
            location = callable_name.location
            type = checked_function_symbol.function_type.return_type
            call_arguments = checked_call_arguments
            function_symbol = checked_function_symbol
        )
    }
    if callable_match is Parsed_Macro_Match {
        let callable_match = callable_match.as(@Parsed_Macro_Match)
        \ return macro expression to be inlined at the statement level
        return make @Checked_Macro_Call_Expression(
            location = callable_name.location
            type = self.nothing_type
            parsed_macro_statement = callable_match.macro_statement
            specialization_types = callable_match.specialization_types
            call_arguments = checked_call_arguments
        )
    }
    abort(callable_name.location, callable_match.object_type)
}

struct Checked_Macro_Call_Expression: Checked_Expression {
    parsed_macro_statement: @Parsed_Macro_Statement
    specialization_types: @Map[@String, @Checked_Type]
    call_arguments: @List[@Checked_Call_Argument]
}

struct Specialized_Callable_Type {
    checked_callable_type: @Checked_Callable_Type
    specialization_types: @Map[@String, @Checked_Type]
}

func specialize_callable_type(self: @Checker, parsed_callable_type: @Parsed_Callable_Type, checked_call_arguments: @List[@Checked_Call_Argument]) -> @Specialized_Callable_Type {
    let local_types = self.local_types
    self.local_types = make @Map[@String, @Checked_Type]()
    parsed_callable_type.type_parameters.for_each() {
        self.local_types.put(it.name.lexeme, make @Checked_Placeholder_Type(
            name = it.name.lexeme
        ))
    }

    \ check if callable parameters accept call arguments
    let parsed_parameter_item = parsed_callable_type.parameters.first_item
    let checked_argument_item = checked_call_arguments.first_item
    while parsed_parameter_item != null and checked_argument_item != null {
        let checked_parameter_type = self.convert_type(parsed_parameter_item.data.type)
        if not checked_parameter_type.accepts(checked_argument_item.data.expression.type) {
            self.local_types = local_types
            return null
        }
        parsed_parameter_item = parsed_parameter_item.next_item
        checked_argument_item = checked_argument_item.next_item
    }

    if checked_argument_item != null or parsed_parameter_item != null {
        \ arguments number differs from parameters number 
        self.local_types = local_types
        return null
    }

    \ check placeholder types
    self.local_types.for_each() {
        if value is Checked_Placeholder_Type {
            let checked_type = value.as(@Checked_Placeholder_Type)
            if checked_type.solved_type == null {
                abort(parsed_callable_type.location, "TODO: Handle unsolved placeholder type")
            }
            \ replace placeholder type with solved type
            self.local_types.put(key, checked_type.solved_type)
        }
    }
    let specialization_types = self.local_types

    \ create callable type
    let checked_callable_type = self.convert_type(parsed_callable_type)
    if checked_callable_type is not Checked_Callable_Type {
        abort(parsed_callable_type.location, checked_callable_type.object_type)
    }

    self.local_types = local_types
    return make @Specialized_Callable_Type(
        checked_callable_type = checked_callable_type.as(@Checked_Callable_Type)
        specialization_types = specialization_types
    )
}

func check_literal_expression(self: @Checker, parsed_expression: @Parsed_Literal_Expression, expected_type: @Checked_Type) -> @Checked_Expression {
    let literal = parsed_expression.literal
    if literal is Boolean_Token {
        return make @Checked_Boolean_Literal_Expression(
            location = parsed_expression.location
            type = self.bool_type
            literal = parsed_expression.literal.as(@Boolean_Token)
        )
    }
    if literal is Character_Token {
        return make @Checked_Character_Literal_Expression(
            location = parsed_expression.location
            type = self.u8_type
            literal = parsed_expression.literal.as(@Character_Token)
        )
    }
    if literal is Integer_Token {
        let literal = literal.as(@Integer_Token)

        \ decide on literal type
        let literal_type: @Checked_Type
        if literal.type != null {
            \ type is part of the literal
            literal_type = self.get_global_type(literal.type)
        } else if expected_type == null or expected_type is not Checked_Integer_Type {
            \ invalid expected_type
            literal_type = self.i32_type
        } else {
            \ use expected_type
            literal_type = expected_type
        }

        \ check value range
        let max_negative_value: u64
        let max_positive_value: u64
        if literal_type is Checked_Int16_Type {
            max_negative_value = 0x0000_0000_0000_8000u64
            max_positive_value = 0x0000_0000_0000_7fffu64
        } else if literal_type is Checked_Int32_Type {
            max_negative_value = 0x0000_0000_8000_0000u64
            max_positive_value = 0x0000_0000_7fff_ffffu64
        } else if literal_type is Checked_Int64_Type or literal_type is Checked_IntMax_Type {
            max_negative_value = 0x800_0000_0000_0000u64 \ TODO: Use 0x8000_0000_0000_0000u64
            max_positive_value = 0x7ff_ffff_ffff_ffffu64 \ TODO: Use 0x7fff_ffff_ffff_ffffu64
        } else if literal_type is Checked_Int8_Type {
            max_negative_value = 0x0000_0000_0000_0080u64
            max_positive_value = 0x0000_0000_0000_007fu64
        } else if literal_type is Checked_UInt16_Type {
            max_negative_value = 0x0000_0000_0000_0000u64
            max_positive_value = 0x0000_0000_0000_ffffu64
        } else if literal_type is Checked_UInt32_Type {
            max_negative_value = 0x0000_0000_0000_0000u64
            max_positive_value = 0x0000_0000_ffff_ffffu64
        } else if literal_type is Checked_UInt64_Type or literal_type is Checked_UIntMax_Type {
            max_negative_value = 0x000_0000_0000_0000u64 \ TODO: Use 0x0000_0000_0000_0000u64
            max_positive_value = 0xfff_ffff_ffff_ffffu64 \ TODO: Use 0xffff_ffff_ffff_ffffu64
        } else if literal_type is Checked_UInt8_Type {
            max_negative_value = 0x0000_0000_0000_0000u64
            max_positive_value = 0x0000_0000_0000_00ffu64
        } else {
            abort(parsed_expression.location, literal_type.object_type)
        }
        if (literal.negative and literal.value > max_negative_value) or (not literal.negative and literal.value > max_positive_value) {
            abort(parsed_expression.location, clone("Value out of ").append(literal_type.name).append(" range: -").append(max_negative_value).append(" .. ").append(max_positive_value))
        }

        return make @Checked_Integer_Literal_Expression(
            location = parsed_expression.location
            type = literal_type
            literal = literal
        )
    }
    if literal is Null_Token {
        return make @Checked_Literal_Expression(
            location = parsed_expression.location
            type = self.null_type
        )
    }
    if literal is String_Token {
        return make @Checked_String_Literal_Expression(
            location = parsed_expression.location
            type = self.convert_type(
                make @Parsed_Pointer_Type(
                    location = null
                    pointed_type = make @Parsed_Named_Type(
                        name = make @Identifier_Token(
                            location = null
                            lexeme = "String"
                        )
                    )
                )
            )
            literal = literal.as(@String_Token)
        )
    }
    if literal is Undefined_Token {
        return make @Checked_Literal_Expression(
            location = parsed_expression.location
            type = self.undefined_type
        )
    }
    abort(parsed_expression.location, literal.object_type)
}

func check_logic_not_expression(self: @Checker, parsed_expression: @Parsed_Logic_Not_Expression) -> @Checked_Expression {
    return make @Checked_Logic_Not_Expression(
        location = parsed_expression.location
        type = self.bool_type
        expression = self.check_expression(parsed_expression.expression, self.bool_type)
    )
}

func check_macro_body(self: @Checker, parsed_macro_body: @Parsed_Macro_Body) -> @Checked_Expression {
    return make @Checked_Macro_Body(
        location = parsed_macro_body.location
        type = make @Checked_Macro_Body_Type(name = "__macro__")
        parsed_macro_body = parsed_macro_body
    )
}

func check_make_expression(self: @Checker, parsed_expression: @Parsed_Make_Expression) -> @Checked_Expression {
    let checked_type = self.convert_type(parsed_expression.type)
    if checked_type is Checked_Struct_Type {
        return self.check_make_struct_expression(parsed_expression, checked_type.as(@Checked_Struct_Type))
    }
    abort(parsed_expression.location, checked_type.object_type)
}

func check_make_struct_expression(self: @Checker, parsed_expression: @Parsed_Make_Expression, checked_struct_type: @Checked_Struct_Type) -> @Checked_Expression {
    let checked_expression = make @Checked_Make_Expression(
        location = parsed_expression.location
        type = checked_struct_type
    )

    \ check init arguments
    parsed_expression.init_arguments.for_each() {
        abort(it.location, "TODO: Require argument name")
        abort(it.location, "TODO: Find member type")
        abort(it.location, "TODO: Check argument expression")
        abort(it.location, "TODO: Check member type")
        abort(it.location, "TODO: Create init argument")
    }

    return checked_expression
}

func check_member_access_expression(self: @Checker, parsed_expression: @Parsed_Member_Access_Expression) -> @Checked_Expression {
    let checked_object_expression = self.check_expression(parsed_expression.object_expression, null)
    let checked_object_type = checked_object_expression.type
    while checked_object_type is Checked_Pointer_Type {
        checked_object_type = checked_object_type.as(@Checked_Pointer_Type).pointed_type
    }
    if checked_object_type is not Checked_Struct_Type {
        abort(parsed_expression.location, clone("Not a struct type: ").append(checked_object_type.object_type.name))
    }
    let checked_struct_type = checked_object_type.as(@Checked_Struct_Type)
    let checked_struct_type_member = checked_struct_type.get_member(parsed_expression.member_name.lexeme)
    if checked_struct_type_member == null {
        abort(parsed_expression.member_name.location, clone(checked_struct_type.name).append(" has no such member: ").append(parsed_expression.member_name.lexeme))
    }
    return make @Checked_Member_Access_Expression(
        location = parsed_expression.location
        type = checked_struct_type_member.type
        object_expression = checked_object_expression
        struct_member = checked_struct_type_member
    )
}

func check_modulo_expression(self: @Checker, parsed_expression: @Parsed_Modulo_Expression) -> @Checked_Expression {
    let left_expression = self.check_expression(parsed_expression.left_expression, null)
    if left_expression.type is not Checked_Integer_Type {
        abort(parsed_expression.left_expression.location, "Not an integer value")
    }
    let right_expression = self.check_expression(parsed_expression.right_expression, left_expression.type)
    return make @Checked_Modulo_Expression(
        location = parsed_expression.location
        type = left_expression.type
        left_expression = left_expression
        right_expression = right_expression
    )
}

func check_not_equals_expression(self: @Checker, parsed_expression: @Parsed_Not_Equals_Expression) -> @Checked_Expression {
    let left_expression = self.check_expression(parsed_expression.left_expression, null)
    let right_expression = self.check_expression(parsed_expression.right_expression, left_expression.type)
    return make @Checked_Not_Equals_Expression(
        location = parsed_expression.location
        type = self.bool_type
        left_expression = left_expression
        right_expression = right_expression
    )
}

func check_symbol_expression(self: @Checker, parsed_expression: @Parsed_Symbol_Expression) -> @Checked_Expression {
    let symbol = self.current_context.find_symbol(parsed_expression.name.lexeme)
    if symbol == null {
        abort(parsed_expression.location, clone("Undeclared symbol: ").append(parsed_expression.name.lexeme))
    }
    return make @Checked_Symbol_Expression(
        location = parsed_expression.location
        type = symbol.type
        symbol = symbol
    )
}

func convert_type(self: @Checker, parsed_type: @Parsed_Type) -> @Checked_Type {
    \ if parsed_type is Parsed_Array_Type {
    \     return self.convert_array_type(parsed_type.as(@Parsed_Array_Type))
    \ }
    if parsed_type is Parsed_Function_Type {
        return self.convert_function_type(parsed_type.as(@Parsed_Function_Type))
    }
    if parsed_type is Parsed_Macro_Type {
        return self.convert_macro_type(parsed_type.as(@Parsed_Macro_Type))
    }
    if parsed_type is Parsed_Named_Type {
        return self.convert_named_type(parsed_type.as(@Parsed_Named_Type))
    }
    if parsed_type is Parsed_Pointer_Type {
        return self.convert_pointer_type(parsed_type.as(@Parsed_Pointer_Type))
    }
    if parsed_type is Parsed_Specialized_Type {
        return self.convert_specialized_type(parsed_type.as(@Parsed_Specialized_Type))
    }
    abort(parsed_type.location, "TODO: Convert ".clone().append(parsed_type.object_type.name))
}

func convert_function_type(self: @Checker, parsed_type: @Parsed_Function_Type) -> @Checked_Function_Type {
    if parsed_type.type_parameters != null {
        if self.local_types == null {
            abort(parsed_type.location, "TODO: Handle type parameters")
        }
    }

    let checked_function_type = make @Checked_Function_Type(
        name = "func (".clone()
        return_type = self.convert_type(parsed_type.return_type)
    )
    parsed_type.parameters.for_each() {
        let checked_function_parameter = self.check_callable_parameter(checked_function_type, it)

        if checked_function_type.parameters.size > 1 {
            checked_function_type.name.append(", ")
        }
        checked_function_type.name.append(checked_function_parameter.type.name)
    }
    checked_function_type.name.append(") -> ").append(checked_function_type.return_type.name)

    return checked_function_type
}

func check_callable_parameter(self: @Checker, checked_callable_type: @Checked_Callable_Type, parsed_callable_parameter: @Parsed_Callable_Parameter) -> @Checked_Callable_Parameter {
    \ check parameter name
    let checked_callable_parameter_name = parsed_callable_parameter.name.lexeme
    checked_callable_type.parameters.for_each() {
        if checked_callable_parameter_name.equals(it.name) {
            abort(parsed_callable_parameter.name.location, "Duplicate function parameter name")
        }
    }

    \ check parameter type
    let checked_callable_parameter_type = self.convert_type(parsed_callable_parameter.type)
    if checked_callable_parameter_type is Checked_Function_Type {
        checked_callable_parameter_type = make @Checked_Pointer_Type(
            name = "@(".clone().append(checked_callable_parameter_type.name).append(')')
            pointed_type = checked_callable_parameter_type
        )
    }

    \ create parameter
    let checked_callable_parameter = make @Checked_Callable_Parameter(
        location = parsed_callable_parameter.name.location
        name = checked_callable_parameter_name
        type = checked_callable_parameter_type
    )
    checked_callable_type.parameters.append(checked_callable_parameter)

    return checked_callable_parameter
}

func convert_macro_type(self: @Checker, parsed_type: @Parsed_Macro_Type) -> @Checked_Macro_Type {
    if parsed_type.type_parameters != null {
        if self.local_types == null {
            abort(parsed_type.location, "TODO: Handle type parameters")
        }
    }

    let checked_macro_type = make @Checked_Macro_Type(
        name = "macro (".clone()
    )
    parsed_type.parameters.for_each() {
        let checked_macro_parameter = self.check_callable_parameter(checked_macro_type, it)

        if checked_macro_type.parameters.size > 1 {
            checked_macro_type.name.append(", ")
        }
        checked_macro_type.name.append(checked_macro_parameter.type.name)
    }
    checked_macro_type.name.append(')')

    return checked_macro_type
}

func convert_named_type(self: @Checker, parsed_type: @Parsed_Named_Type) -> @Checked_Type {
    let checked_type_name = parsed_type.name.lexeme

    let checked_type = self.get_global_type(checked_type_name)
    if checked_type == null {
        \ find type statement
        let parsed_type_statement = self.parsed_code.get_type_statement(checked_type_name)
        if parsed_type_statement != null {
            checked_type = self.check_type_statement(parsed_type_statement).type
        } else {
            abort(parsed_type.name.location, clone("Unknown type: ").append(checked_type_name))
        }
    }

    return checked_type
}

func convert_pointer_type(self: @Checker, parsed_pointer_type: @Parsed_Pointer_Type) -> @Checked_Type {
    let checked_pointed_type = self.convert_type(parsed_pointer_type.pointed_type)
    return make @Checked_Pointer_Type(
        name = "@".clone().append(checked_pointed_type.name)
        pointed_type = checked_pointed_type
    )
}

func convert_specialized_type(self: @Checker, parsed_specialized_type: @Parsed_Specialized_Type) -> @Checked_Type {
    \ check if generic type exists
    let parsed_generic_struct_statement = self.generic_struct_statements.get(parsed_specialized_type.name.lexeme)
    if parsed_generic_struct_statement == null {
        abort(parsed_specialized_type.location, "No such generic struct")
    }

    \ create type name
    let has_placeholder_specialization_type = false
    let specialization_types = make @Map[@String, @Checked_Named_Type]()
    let checked_type_name = parsed_specialized_type.name.lexeme.clone().append('[')
    let parsed_type_parameter_item = parsed_generic_struct_statement.type_parameters.first_item
    let parsed_type_argument_item = parsed_specialized_type.type_arguments.first_item
    while parsed_type_parameter_item != null and parsed_type_argument_item != null {
        let checked_type_argument = self.convert_type(parsed_type_argument_item.data.type)
        specialization_types.put(parsed_type_parameter_item.data.name.lexeme, checked_type_argument)
        if checked_type_argument is Checked_Placeholder_Type {
            has_placeholder_specialization_type = true
        }
        checked_type_name.append(checked_type_argument.name)
        parsed_type_parameter_item = parsed_type_parameter_item.next_item
        parsed_type_argument_item = parsed_type_argument_item.next_item
        if parsed_type_argument_item != null {
            checked_type_name.append(", ")
        }
    }
    checked_type_name.append(']')

    \ check if we have a placeholder type
    if has_placeholder_specialization_type {
        return make @Checked_Specialized_Placeholder_Type(
            name = checked_type_name
            generic_struct_name = parsed_generic_struct_statement.name.lexeme
            specialization_types = specialization_types
        )
    }

    \ check if type already exists
    let checked_type = self.get_global_type(checked_type_name)
    if checked_type != null {
        return checked_type
    }

    \ create struct symbol
    let checked_struct_symbol = self.check_struct_statement(parsed_generic_struct_statement.struct_statement, checked_type_name, specialization_types)
    return checked_struct_symbol.type
}

func inline_macro_call_expression(self: @Checker, checked_macro_call_expression: @Checked_Macro_Call_Expression) -> @Checked_Statement {
    let parsed_macro_statement = checked_macro_call_expression.parsed_macro_statement

    \ prepare local context
    self.current_context = make @Checker_Context(
        parent = self.current_context
    )
    let local_types = self.local_types
    if checked_macro_call_expression.specialization_types != null {
        self.local_types = checked_macro_call_expression.specialization_types
    }

    \ create surrounding block
    let checked_statement = make @Checked_Block_Statement(location = checked_macro_call_expression.location)

    \ create local variable for each macro parameter
    let parsed_parameter_item = parsed_macro_statement.type.parameters.first_item
    let checked_call_argument_item = checked_macro_call_expression.call_arguments.first_item
    while parsed_parameter_item != null and checked_call_argument_item != null {
        let parsed_parameter = parsed_parameter_item.data
        let checked_call_argument = checked_call_argument_item.data

        \ check parameter type
        let checked_parameter_type = self.convert_type(parsed_parameter.type)
        if not checked_parameter_type.accepts(checked_call_argument.expression.type) {
            abort(checked_call_argument.expression.location, "TODO: Convert type or recheck parsed argument")
        }

        if checked_parameter_type is Checked_Macro_Type {
            if checked_call_argument.expression is not Checked_Macro_Body {
                abort(checked_call_argument.expression.location, checked_call_argument.expression.type.object_type)
            }
            self.current_context.symbols.prepend(make @Checked_Macro_Parameter_Symbol(
                location = parsed_parameter.name.location
                name = parsed_parameter.name.lexeme
                type = checked_parameter_type
                parsed_macro_body = checked_call_argument.expression.as(@Checked_Macro_Body).parsed_macro_body
            ))
        } else {
            \ create variable statement
            let checked_variable_statement = make @Checked_Variable_Statement(
                location = checked_call_argument.expression.location
                variable = make @Checked_Variable_Symbol(
                    location = parsed_parameter.name.location
                    name = parsed_parameter.name.lexeme
                    type = checked_parameter_type
                    expression = checked_call_argument.expression
                )
            )
            self.current_context.symbols.prepend(checked_variable_statement.variable)
            checked_statement.statements.append(checked_variable_statement)
        }

        parsed_parameter_item = parsed_parameter_item.next_item
        checked_call_argument_item = checked_call_argument_item.next_item
    }
    if parsed_parameter_item != null or checked_call_argument_item != null {
        \ found a bug in the check_callable_call_expression
        abort()
    }

    \ inline macro body
    checked_statement.statements.append(self.check_statement(parsed_macro_statement.body))

    \ restore type context
    self.local_types = local_types
    self.current_context = self.current_context.parent

    return checked_statement
}
