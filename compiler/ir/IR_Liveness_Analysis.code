func compute_live_values(self: @IR_Code) -> Nothing {
    self.global_symbols.for_each() {
        let symbol = it
        if symbol is IR_Function {
            symbol.as(@IR_Function).compute_live_values()
        }
    }
}

func compute_live_values(self: @IR_Function) -> Nothing {
    if self.blocks == null {
        \ external function
        return
    }

    let blocks = make List[@IR_Block]()
    self.blocks.for_each() {
        let block = it
        blocks.append(block)
        \ add live values from phi instructions to last intruction of each predecessor block
        block.for_each_instruction() {
            let instruction = it
            if instruction is IR_Phi_Instruction {
                instruction.as(@IR_Phi_Instruction).value_block_mapping.for_each() {
                    let predecessor_block = value
                    let value = key
                    predecessor_block.last_instruction.live_in_values.append(value)
                }
            } else {
                break
            }
        }
    }

    if blocks.size >= 0 {
        \ return
    }

    \ compute live-in values for each instruction
    blocks.for_each() {
        let block = it
        let instruction = block.last_instruction
        loop {
            if instruction is not IR_Phi_Instruction {
                \ mark all operands as live
                instruction.operand_values.for_each() {
                    let use_value = value
                    if not instruction.live_in_values.contains(use_value) {
                        instruction.live_in_values.append(use_value)
                    }
                }
            }
            \ remove defined value from live values
            let def_value = instruction.result_value
            if def_value != null and instruction.live_in_values.contains(def_value) {
                instruction.live_in_values.remove(def_value).prune()
            }
            if instruction.prev_instruction == null {
                \ check predecessor blocks
                block.predecessors.for_each() {
                    let predecessor_block = it
                    if predecessor_block.last_instruction.append_live_in_values(instruction.live_in_values) {
                        \ new live values were added, so we need to reprocess this block
                        blocks.append(predecessor_block)
                    }
                }
                \ no more instructions to process
                break
            }
            instruction = instruction.prev_instruction
            instruction.append_live_in_values(instruction.next_instruction.live_in_values)
        }
    }

    \ compute live-out values for each instruction
    blocks.for_each() {
        let block = it

        let instruction = block.last_instruction
        instruction.live_out_values = make @List[@IR_Value]()
        if instruction is IR_Branch_Instruction {
            let instruction = instruction.as(@IR_Branch_Instruction)
            instruction.append_live_out_values_from_jump_block(instruction.true_block)
            instruction.append_live_out_values_from_jump_block(instruction.false_block)
        } else if instruction is IR_Jump_Instruction {
            let instruction = instruction.as(@IR_Jump_Instruction)
            instruction.append_live_out_values_from_jump_block(instruction.jump_block)
        } else if instruction is IR_Return_Instruction {
            \ validate that live-out values are empty
            if instruction.live_out_values.size != 0 {
                abort(instruction.location, "Invalid state: live-out values for return instruction should be empty")
            }
        } else if instruction is IR_Direct_Call_Instruction {
            \ validate that live-out values are empty
            if not instruction.is_exit_instruction() {
                abort(instruction.location, "Invalid state: not an exit function")
            }
            if instruction.live_out_values.size != 0 {
                abort(instruction.location, "Invalid state: live-out values for exit instruction should be empty")
            }
        } else {
            abort(instruction.object_type)
        }

        instruction = instruction.prev_instruction
        while instruction != null {
            \ live-out values are live-in values of the next instruction
            instruction.live_out_values = instruction.next_instruction.live_in_values
            instruction = instruction.prev_instruction
        }
    }
}

func append_live_in_values(self: @IR_Instruction, live_values: @List[@IR_Value]) -> bool {
    let added = false
    live_values.for_each() {
        if not self.live_in_values.contains(it) and it != self.result_value {
            self.live_in_values.append(it)
            added = true
        }
    }
    return added
}

func append_live_out_values_from_jump_block(self: @IR_Instruction, block: @IR_Block) -> Nothing {
    block.first_instruction.live_in_values.for_each() {
        if not self.live_out_values.contains(it) {
            self.live_out_values.append(it)
        }
    }
    block.for_each_instruction() {
        if it is IR_Phi_Instruction {
            it.as(@IR_Phi_Instruction).value_block_mapping.for_each() {
                if value == self.block {
                    if not self.live_out_values.contains(key) {
                        self.live_out_values.append(key)
                    }
                }
            }
        } else {
            break
        }
    }
}
