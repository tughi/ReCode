struct IR_Code {
    types: @List[@IR_Type]
    global_symbols: @List[@IR_Symbol]
}

func print(self: @IR_Code, file: @FILE, live: bool) -> @FILE {
    self.types.for_each() {
        if it is IR_User_Defined_Type {
            let type = it.as(@IR_User_Defined_Type)
            type.print(file)
            file.end_line()
        }
    }

    let symbols_iterator = self.global_symbols.create_iterator()
    if symbols_iterator.has_next() {
        loop {
            let symbol = symbols_iterator.next()
            symbol.print(file, live)
            if symbols_iterator.has_next() {
                file.end_line()
            } else {
                break
            }
        }
    }
    return file
}

struct IR_Type: Object {
    name: @String
    size = 0
    compute_size = func (self: @IR_Type) -> i32 {
        abort(self.object_type)
    }
}

func accepts(self: @IR_Type, other: @IR_Type) -> bool {
    if self == other {
        return true
    }
    if self is IR_Pointer_Type {
        let self_pointed_type = self.as(@IR_Pointer_Type).pointed_type
        if self_pointed_type is IR_Any_Type {
            return other is IR_Pointer_Type
        } else if self_pointed_type is IR_Function_Type {
            if other is IR_Pointer_Type {
                let other_pointed_type = other.as(@IR_Pointer_Type).pointed_type
                if other_pointed_type is IR_Function_Type {
                    let self_function_type = self_pointed_type.as(@IR_Function_Type)
                    let other_function_type = other_pointed_type.as(@IR_Function_Type)
                    if self_function_type.return_type.accepts(other_function_type.return_type) {
                        let self_parameters = self_function_type.parameters.create_iterator()
                        let other_parameters = other_function_type.parameters.create_iterator()
                        while self_parameters.has_next() and other_parameters.has_next() {
                            let self_parameter = self_parameters.next()
                            let other_parameter = other_parameters.next()
                            if not self_parameter.type.accepts(other_parameter.type) {
                                return false
                            }
                        }
                        return not self_parameters.has_next() and not other_parameters.has_next()
                    }
                }
            }
        }
    }
    return false
}

func get_size(self: @IR_Type) -> i32 {
    if self.size == 0 {
        self.size = self.compute_size()
    }
    return self.size
}

struct IR_Any_Type: IR_Type(name = "Any") {
}

struct IR_Boolean_Type: IR_Type(name = "bool", size = 1) {
}

struct IR_Integer_Type: IR_Type {
}

struct IR_Int_Type: IR_Integer_Type {
}

struct IR_Int16_Type: IR_Int_Type(name = "i16", size = 2) {
}

struct IR_Int32_Type: IR_Int_Type(name = "i32", size = 4) {
}

struct IR_Int64_Type: IR_Int_Type(name = "i64", size = 8) {
}

struct IR_Int8_Type: IR_Int_Type(name = "i8", size = 1) {
}

struct IR_UInt_Type: IR_Integer_Type {
}

struct IR_UInt16_Type: IR_UInt_Type(name = "u16", size = 2) {
}

struct IR_UInt32_Type: IR_UInt_Type(name = "u32", size = 4) {
}

struct IR_UInt64_Type: IR_UInt_Type(name = "u64", size = 8) {
}

struct IR_UInt8_Type: IR_UInt_Type(name = "u8", size = 1) {
}

struct IR_Null_Type: IR_Type(name = "Null") {
}

struct IR_Undefined_Type: IR_Type(name = "Undefined") {
}

struct IR_Nothing_Type: IR_Type(name = "Nothing") {
}

struct IR_Pointer_Type: IR_Type(size = 8) {
    pointed_type: @IR_Type
}

struct IR_Fixed_Array_Type: IR_Type {
    item_type: @IR_Type
    size: i64
}

struct IR_Function_Type: IR_Type {
    parameters: @List[@IR_Function_Type_Parameter]
    return_type: @IR_Type
}

struct IR_Function_Type_Parameter {
    name: @String
    type: @IR_Type
}

struct IR_User_Defined_Type: IR_Type {
    print = func (self: @IR_Type, file: @FILE) -> Nothing {
        abort(self.object_type)
    }
}

struct IR_Opaque_Type: IR_User_Defined_Type(
    print = func (self: @IR_Type, file: @FILE) -> Nothing {
        file.write("type ").write(self.name).write(" = opaque").end_line()
    }
) {
}

struct IR_Struct_Type: IR_User_Defined_Type(
    compute_size = func (self: @IR_Type) -> i32 {
        let struct_type = self.as(@IR_Struct_Type)
        let size = 0
        if struct_type.super_type != null {
            size = size + struct_type.super_type.get_size()
        }
        struct_type.members.for_each() {
            size = size + it.type.get_size()
        }
        return size
    }

    print = func (self: @IR_Type, file: @FILE) -> Nothing {
        let struct_type = self.as(@IR_Struct_Type)
        file.write("type ").write(struct_type.name).write(" = struct {").end_line()
        if struct_type.super_type != null {
            file.write("  super: ").write(struct_type.super_type.name).end_line()
        }
        struct_type.members.for_each() {
            file.write("  ").write(it.name).write(": ").write(it.type.name).end_line()
        }
        file.write("}").end_line()
    }
) {
    super_type: @IR_Struct_Type = null
    derived_types = make @List[@IR_Struct_Type]()
    members = make @List[@IR_Struct_Type_Member]()
    checked_struct_type: @Checked_Struct_Type
    \ object_type_variable: @IR_Global_Variable = null
    \ object_type_id = 0u32
    \ object_type_max_derivate_id = 0u32
}

struct IR_Struct_Type_Member {
    struct_type: @IR_Struct_Type
    name: @String
    type: @IR_Type
    offset: i32
    checked_struct_type_member: @Checked_Struct_Type_Member
    default_value_expression: @Parsed_Expression
}

func add_member(self: @IR_Struct_Type, name: @String, type: @IR_Type, checked_struct_type_member: @Checked_Struct_Type_Member, default_value_expression: @Parsed_Expression) -> @IR_Struct_Type_Member {
    let last_member = self.members.last()
    let offset: i32
    if last_member != null {
        offset = last_member.offset + last_member.type.get_size()
    } else if self.super_type != null {
        offset = self.super_type.get_size()
    } else {
        offset = 0
    }

    let member = make @IR_Struct_Type_Member(
        struct_type = self
        name = name
        type = type
        offset = offset
        checked_struct_type_member = checked_struct_type_member
        default_value_expression = default_value_expression
    )
    self.members.append(member)
    return member
}

func get_member(self: @IR_Struct_Type, checked_struct_type_member: @Checked_Struct_Type_Member) -> @IR_Struct_Type_Member {
    self.members.for_each() {
        if it.checked_struct_type_member == checked_struct_type_member {
            return it
        }
    }
    abort(clone("Member not found: ").append(checked_struct_type_member.name))
}

func is_object_type(self: @IR_Struct_Type) -> bool {
    let struct_type = self
    loop {
        if struct_type.name.equals("Object") {
            return true
        }
        struct_type = struct_type.super_type
        if struct_type == null {
            return false
        }
    }
}

struct IR_Symbol: Object {
    checked_symbol: @Checked_Symbol
    name: @String
    type: @IR_Type

    print = func (self: @IR_Symbol, file: @FILE, live: bool) -> Nothing {
        abort(self.object_type)
    }
}

func write(file: @FILE, symbol: @IR_Symbol) -> @FILE {
    if symbol is IR_Function_Parameter {
        file.write("%")
    } else {
        file.write("$")
    }
    return file.write(symbol.name)
}

struct IR_Function: IR_Symbol(
    print = func (self: @IR_Symbol, file: @FILE, live: bool) -> Nothing {
        let function = self.as(@IR_Function)

        file.write(function).write("(")
        let function_type = function.function_type
        let function_parameters = function.parameters.create_iterator()
        while function_parameters.has_next() {
            let function_parameter = function_parameters.next()
            file.write(function_parameter).write(": ").write(function_parameter.type.name)
            if function_parameters.has_next() {
                file.write(", ")
            }
        }
        if function_type.return_type is IR_Nothing_Type {
            file.write(")")
        } else {
            file.write("): ").write(function_type.return_type.name)
        }
        if function.blocks != null {
            file.write(" {").end_line()
            let block_item = function.blocks.first_item
            while block_item != null {
                block_item.data.print(file, live)
                block_item = block_item.next_item
            }
            file.write('}')
        }
        file.end_line()
    }
) {
    function_type: @IR_Function_Type
    parameters: @List[@IR_Function_Parameter]
    return_type: @IR_Type
    blocks: @List[@IR_Block]
}

struct IR_Function_Parameter: IR_Symbol {
    value: @IR_Value
}

func create_block(self: @IR_Function) -> @IR_Block {
    let block = make @IR_Block(
        function = self
        name = clone("").append(self.blocks.size + 1)
    )
    self.blocks.append(block)
    return block
}

struct IR_Global_Variable: IR_Symbol(
    print = func (self: @IR_Symbol, file: @FILE, live: bool) -> Nothing {
        let global_variable = self.as(@IR_Global_Variable)
        if global_variable.is_external {
            file.write("external $").write(global_variable.name).write(": ").write(global_variable.type.name).end_line()
            return
        }
        abort("TODO: Write global variable")
    }
) {
    value_pointer: @IR_Value
    is_external = false
}

struct IR_Local_Variable: IR_Symbol {
    value_pointer: @IR_Value
    value_counter = make Counter[i32]()
}

struct IR_Value: Object {
    name: @String
    type: @IR_Type
    init_instruction: @IR_Instruction = null
    user_instructions = make List[@IR_Instruction]()
}

func write(file: @FILE, value: @IR_Value) -> @FILE {
    return file.write(value.name)
}

struct IR_Block {
    function: @IR_Function
    name: @String
    predecessors = make List[@IR_Block]()
    first_instruction: @IR_Instruction = null
    last_instruction: @IR_Instruction = null

    processed = false
}

func append(self: @IR_Block, instruction: @IR_Instruction) -> @IR_Instruction {
    instruction.block = self
    if self.last_instruction == null {
        self.first_instruction = instruction
    } else {
        self.last_instruction.next_instruction = instruction
        instruction.prev_instruction = self.last_instruction
    }
    self.last_instruction = instruction
    if instruction.result_value != null {
        instruction.result_value.init_instruction = instruction
    }
    return instruction
}

macro for_each_instruction(self: @IR_Block, body: macro (it: @IR_Instruction)) {
    let instruction = self.first_instruction
    while instruction != null {
        body(instruction)
        instruction = instruction.next_instruction
    }
}

func print(self: @IR_Block, file: @FILE, live: bool) -> @FILE {
    file.write_name(self).write(':').end_line()
    self.for_each_instruction() {
        let block_instruction = it
        if live {
            file.write("  [")
            block_instruction.live_in_values.for_each() {
                file.write(' ').write(it)
            }
            file.write(" ]").end_line()
        }
        file.write("  ").write(block_instruction).end_line()
    }
    if live {
        file.write("  [")
        self.last_instruction.live_out_values.for_each() {
            file.write(' ').write(it)
        }
        file.write(" ]").end_line()
    }
    return file
}

func write_name(file: @FILE, block: @IR_Block) -> @FILE {
    return file.write('@').write(block.name)
}

struct IR_Instruction: Object {
    location: @Source_Location = null
    result_value: @IR_Value = null
    operand_values = make Map[@Any, @IR_Value]()
    block: @IR_Block = undefined
    prev_instruction: @IR_Instruction = null
    next_instruction: @IR_Instruction = null
    live_in_values = make List[@IR_Value]()
    live_out_values: @List[@IR_Value] = null

    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        file.flush()
        abort(clone("Unsupported type: ").append(self.object_type.name))
    }
}

func is_exit_instruction(self: @IR_Instruction) -> bool {
    if self == null {
        return false
    }
    if self is IR_Branch_Instruction or self is IR_Jump_Instruction or self is IR_Return_Instruction {
        return true
    }
    if self is IR_Direct_Call_Instruction {
        let self = self.as(@IR_Direct_Call_Instruction)
        let function = self.function
        if function.name.equals("abort") and function.parameters.size == 0 {
            return true
        }
        if function.name.equals("exit") and function.parameters.size == 1 {
            let function_parameter = function.parameters.get(0i64)
            if function_parameter.type is IR_Int32_Type {
                return true
            }
        }
    }
    return false
}

func set_operand_value(self: @IR_Instruction, key: @Any, value: @IR_Value) -> Nothing {
    self.operand_values.put(key, value)
    value.user_instructions.append(self)
}

func write(file: @FILE, instruction: @IR_Instruction) -> @FILE {
    if instruction.result_value != null {
        file.write(instruction.result_value).write(": ").write(instruction.result_value.type.name).write(" = ")
    }
    instruction.print(file)
    return file
}

struct IR_Add_Instruction: IR_Binary_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Binary_Instruction)
        file.write("add ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Alloc_Instruction: IR_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Alloc_Instruction)
        file.write("alloc ").write(instruction.type.name)
    }
) {
    type: @IR_Type
}

struct IR_Array_Item_Offset_Instruction: IR_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Array_Item_Offset_Instruction)
        file.write("offset ").write(instruction.get_array_pointer()).write(' ').write(instruction.get_index_value())
    }
) {
}

func init(self: @IR_Array_Item_Offset_Instruction, array_pointer: @IR_Value, index_value: @IR_Value) -> @IR_Array_Item_Offset_Instruction {
    self.set_operand_value("array_pointer", array_pointer)
    self.set_operand_value("index_value", index_value)
    return self
}

func get_array_pointer(self: @IR_Array_Item_Offset_Instruction) -> @IR_Value {
    return self.operand_values.get("array_pointer")
}

func get_index_value(self: @IR_Array_Item_Offset_Instruction) -> @IR_Value {
    return self.operand_values.get("index_value")
}

struct IR_Binary_Instruction: IR_Instruction {
}

func init(self: @IR_Binary_Instruction, left_value: @IR_Value, right_value: @IR_Value) -> @IR_Binary_Instruction {
    self.set_operand_value("left_value", left_value)
    self.set_operand_value("right_value", right_value)
    return self
}

func get_left_value(self: @IR_Binary_Instruction) -> @IR_Value {
    return self.operand_values.get("left_value")
}

func get_right_value(self: @IR_Binary_Instruction) -> @IR_Value {
    return self.operand_values.get("right_value")
}

struct IR_Branch_Instruction: IR_Terminator_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Branch_Instruction)
        file.write("br ").write(instruction.get_condition()).write(' ').write_name(instruction.true_block).write(' ').write_name(instruction.false_block)
    }
) {
    true_block: @IR_Block
    false_block: @IR_Block
}

func init(self: @IR_Branch_Instruction, condition: @IR_Value) -> @IR_Branch_Instruction {
    if condition.type is not IR_Boolean_Type {
        abort(clone("Not a boolean type: ").append(condition.type.name))
    }
    self.set_operand_value("condition", condition)
    return self
}

func get_condition(self: @IR_Branch_Instruction) -> @IR_Value {
    return self.operand_values.get("condition")
}

struct IR_Call_Instruction: IR_Instruction {
    arguments_size = 0
}

func write_call_arguments(file: @FILE, instruction: @IR_Call_Instruction) -> @FILE {
    let call_argument_index = 0
    while call_argument_index < instruction.arguments_size {
        file.write(' ').write(instruction.get_argument_value(call_argument_index))
        call_argument_index = call_argument_index + 1
    }
    return file
}

struct IR_Call_Argument {
    name: @String = null
    value: @IR_Value
}

func add_arguments(self: @IR_Call_Instruction, call_arguments: @List[@IR_Call_Argument]) -> @IR_Call_Instruction {
    let call_arguments_item = call_arguments.first_item
    while call_arguments_item != null {
        let call_argument = call_arguments_item.data
        self.set_operand_value(get_argument_key(self.arguments_size), call_argument.value)
        self.arguments_size = self.arguments_size + 1
        call_arguments_item = call_arguments_item.next_item
    }
    return self
}

func get_argument_value(self: @IR_Call_Instruction, index: i32) -> @IR_Value {
    return self.operand_values.get(get_argument_key(index))
}

func get_argument_key(index: i32) -> @String {
    if index == 0 {
        return "argument-0-value"
    } else if index == 1 {
        return "argument-1-value"
    } else if index == 2 {
        return "argument-2-value"
    } else if index == 3 {
        return "argument-3-value"
    } else if index == 4 {
        return "argument-4-value"
    } else if index == 5 {
        return "argument-5-value"
    }
    abort(clone("Missing argument index: ").append(index))
}

struct IR_Comparison_Instruction: IR_Binary_Instruction {
}

struct IR_Constant_Instruction: IR_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Constant_Instruction)
        file.write("const ").write(instruction.literal)
    }
) {
    literal: @Literal_Token
}

func create_ir_constant_instruction(result_value: @IR_Value, literal: @Literal_Token) -> @IR_Constant_Instruction {
    let instruction = make @IR_Constant_Instruction(
        result_value = result_value
        literal = literal
    )
    return instruction
}

struct IR_Direct_Call_Instruction: IR_Call_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Direct_Call_Instruction)
        file.write("call ").write(instruction.function).write_call_arguments(instruction)
    }
) {
    function: @IR_Function
}

func create_ir_direct_call_instruction(result_value: @IR_Value, call_arguments: @List[@IR_Call_Argument], function: @IR_Function) -> @IR_Call_Instruction {
    let instruction = make @IR_Direct_Call_Instruction(result_value = result_value, function = function)
    instruction.add_arguments(call_arguments)
    return instruction
}

struct IR_Divide_Instruction: IR_Binary_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Binary_Instruction)
        file.write("div ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Dynamic_Call_Instruction: IR_Call_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Dynamic_Call_Instruction)
        file.write("call ").write(instruction.get_function_pointer()).write_call_arguments(instruction)
    }
) {
}

func create_ir_dynamic_call_instruction(result_value: @IR_Value, call_arguments: @List[@IR_Call_Argument], function_pointer: @IR_Value) -> @IR_Call_Instruction {
    let instruction = make @IR_Dynamic_Call_Instruction(result_value = result_value)
    if function_pointer.type is not IR_Pointer_Type {
        abort("Not a function pointer")
    }
    instruction.set_operand_value("!function_pointer", function_pointer)
    instruction.add_arguments(call_arguments)
    return instruction
}

func get_function_pointer(self: @IR_Dynamic_Call_Instruction) -> @IR_Value {
    return self.operand_values.get("!function_pointer")
}

struct IR_Equality_Instruction: IR_Comparison_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Comparison_Instruction)
        file.write("cmp_eq ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Function_Address_Instruction: IR_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Function_Address_Instruction)
        file.write("address ").write(instruction.function)
    }
) {
    function: @IR_Function
}

struct IR_Greater_Than_Instruction: IR_Comparison_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Comparison_Instruction)
        file.write("cmp_gt ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Greater_Than_Or_Equal_Instruction: IR_Comparison_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Comparison_Instruction)
        file.write("cmp_ge ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Inequality_Instruction: IR_Comparison_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Comparison_Instruction)
        file.write("cmp_ne ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Integer_Cast_Instruction: IR_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Integer_Cast_Instruction)
        file.write("cast ").write(instruction.get_value())
    }
) {
}

func init(self: @IR_Integer_Cast_Instruction, value: @IR_Value) -> @IR_Integer_Cast_Instruction {
    self.set_operand_value("value", value)
    return self
}

func get_value(self: @IR_Integer_Cast_Instruction) -> @IR_Value {
    return self.operand_values.get("value")
}

struct IR_Jump_Instruction: IR_Terminator_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Jump_Instruction)
        file.write("jmp ").write_name(instruction.jump_block)
    }
) {
    jump_block: @IR_Block
}

struct IR_Less_Than_Instruction: IR_Comparison_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Comparison_Instruction)
        file.write("cmp_lt ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Less_Than_Or_Equal_Instruction: IR_Comparison_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Comparison_Instruction)
        file.write("cmp_le ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Load_Instruction: IR_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Load_Instruction)
        file.write("load ").write(instruction.get_value_pointer())
    }
) {
}

func init(self: @IR_Load_Instruction, value_pointer: @IR_Value) -> @IR_Load_Instruction {
    if value_pointer.type is not IR_Pointer_Type {
        abort(clone("Not a pointer type: ").append(value_pointer.type.name))
    }
    let pointed_type = value_pointer.type.as(@IR_Pointer_Type).pointed_type
    if pointed_type != self.result_value.type {
        abort(clone("Type mismatch: ").append(pointed_type.name).append(" != ").append(self.result_value.type.name))
    }
    self.set_operand_value("value_pointer", value_pointer)
    return self
}

func get_value_pointer(self: @IR_Load_Instruction) -> @IR_Value {
    return self.operand_values.get("value_pointer")
}

struct IR_Malloc_Instruction: IR_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Malloc_Instruction)
        file.write("malloc ").write(instruction.type.name)
    }
) {
    type: @IR_Type
}

struct IR_Modulo_Instruction: IR_Binary_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Binary_Instruction)
        file.write("mod ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Multiply_Instruction: IR_Binary_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Binary_Instruction)
        file.write("mul ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Negate_Instruction: IR_Unary_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Negate_Instruction)
        file.write("neg ").write(instruction.get_value())
    }
) {
}

struct IR_Not_Instruction: IR_Unary_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Not_Instruction)
        file.write("not ").write(instruction.get_value())
    }
) {
}

struct IR_Phi_Instruction: IR_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Phi_Instruction)
        file.write("phi")
        let operand_values_entry = instruction.operand_values.first_entry
        while operand_values_entry != null {
            file.write(' ').write_name(instruction.value_block_mapping.get(operand_values_entry.value)).write(' ').write(operand_values_entry.value)
            operand_values_entry = operand_values_entry.next_entry
        }
    }
) {
    value_block_mapping = make Map[@IR_Value, @IR_Block]()
}

func append(self: @IR_Phi_Instruction, value: @IR_Value, block: @IR_Block) -> @IR_Phi_Instruction {
    self.value_block_mapping.put(value, block)
    self.set_operand_value(value, value)
    return self
}

struct IR_Store_Instruction: IR_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Store_Instruction)
        file.write("store ").write(instruction.get_value_pointer()).write(' ').write(instruction.get_value())
    }
) {
}

func init(self: @IR_Store_Instruction, value_pointer: @IR_Value, value: @IR_Value) -> @IR_Store_Instruction {
    if value_pointer.type is not IR_Pointer_Type {
        abort(clone("Not a pointer type: ").append(value_pointer.type.name))
    }
    let pointed_type = value_pointer.type.as(@IR_Pointer_Type).pointed_type
    if not pointed_type.accepts(value.type) {
        abort(clone("Type mismatch: ").append(pointed_type.name).append(" != ").append(value.type.name))
    }
    self.set_operand_value("value_pointer", value_pointer)
    self.set_operand_value("value", value)
    return self
}

func get_value_pointer(self: @IR_Store_Instruction) -> @IR_Value {
    return self.operand_values.get("value_pointer")
}

func get_value(self: @IR_Store_Instruction) -> @IR_Value {
    return self.operand_values.get("value")
}

struct IR_Struct_Literal_Instruction: IR_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Struct_Literal_Instruction)
        file.write("struct {")
        let operand_values_entry = instruction.operand_values.first_entry
        if operand_values_entry != null {
            loop {
                let member = operand_values_entry.key.as(@IR_Struct_Type_Member)
                file.write(' ').write(member.struct_type.name).write('.').write(member.name).write(": ").write(operand_values_entry.value)
                operand_values_entry = operand_values_entry.next_entry
                if operand_values_entry == null {
                    break
                }
                file.write(',')
            }
        }
        file.write(" }")
    }
) {
    type: @IR_Struct_Type
}

func create_ir_struct_literal_instruction(result_value: @IR_Value, type: @IR_Struct_Type, member_values: @Map[@IR_Struct_Type_Member, @IR_Value]) -> @IR_Struct_Literal_Instruction {
    let instruction = make @IR_Struct_Literal_Instruction(result_value = result_value, type = type)
    member_values.for_each() {
        instruction.set_operand_value(key, value)
    }
    return instruction
}

struct IR_Struct_Member_Offset_Instruction: IR_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Struct_Member_Offset_Instruction)
        file.write("offset ").write(instruction.get_struct_pointer()).write(' ').write(instruction.struct_type_member.struct_type.name).write('.').write(instruction.struct_type_member.name)
    }
) {
    struct_type_member: @IR_Struct_Type_Member
}

func init(self: @IR_Struct_Member_Offset_Instruction, struct_pointer: @IR_Value) -> @IR_Struct_Member_Offset_Instruction {
    self.set_operand_value("struct_pointer", struct_pointer)
    return self
}

func get_struct_pointer(self: @IR_Struct_Member_Offset_Instruction) -> @IR_Value {
    return self.operand_values.get("struct_pointer")
}

struct IR_Return_Instruction: IR_Terminator_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Return_Instruction)
        if instruction.get_return_value() == null {
            file.write("ret")
            return
        }
        file.write("ret ").write(instruction.get_return_value().name)
    }
) {
}

func create_ir_return_instruction(return_value: @IR_Value) -> @IR_Return_Instruction {
    let instruction = make @IR_Return_Instruction(result_value = null)
    if return_value != null {
        instruction.set_operand_value("return_value", return_value)
    }
    return instruction
}

func get_return_value(self: @IR_Return_Instruction) -> @IR_Value {
    return self.operand_values.get("return_value")
}

struct IR_Substract_Instruction: IR_Binary_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Binary_Instruction)
        file.write("sub ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Terminator_Instruction: IR_Instruction {
}

struct IR_Unary_Instruction: IR_Instruction {
}

func init(self: @IR_Unary_Instruction, value: @IR_Value) -> @IR_Unary_Instruction {
    self.set_operand_value("value", value)
    return self
}

func get_value(self: @IR_Unary_Instruction) -> @IR_Value {
    return self.operand_values.get("value")
}

struct IR_Unsafe_Cast_Instruction: IR_Instruction(
    print = func (self: @IR_Instruction, file: @FILE) -> Nothing {
        let instruction = self.as(@IR_Unsafe_Cast_Instruction)
        file.write("cast ").write(instruction.get_value())
    }
) {
}

func init(self: @IR_Unsafe_Cast_Instruction, value: @IR_Value) -> @IR_Unsafe_Cast_Instruction {
    self.set_operand_value("value", value)
    return self
}

func get_value(self: @IR_Unsafe_Cast_Instruction) -> @IR_Value {
    return self.operand_values.get("value")
}
