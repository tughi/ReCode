struct IR_Code {
    types = make Map[@String, @IR_Type]()
    global_symbols: @List[@IR_Symbol]
}

func write(file: @FILE, code: @IR_Code, live: bool) -> @FILE {
    let symbols_iterator = code.global_symbols.create_iterator()
    if symbols_iterator.has_next() {
        loop {
            let symbol = symbols_iterator.next()
            file.write(symbol, live)
            if symbols_iterator.has_next() {
                file.end_line()
            } else {
                break
            }
        }
    }
    return file
}

func write_cfg(file: @FILE, code: @IR_Code) -> @FILE {
    let cluster = 0
    file.write("digraph {").end_line()
    file.write("   fontname=monospace").end_line()
    file.write("   node [shape=record]").end_line()
    code.global_symbols.for_each() {
        if it is IR_Function {
            file.write_cfg(it.as(@IR_Function), cluster)
            cluster = cluster + 1
        }
    }
    return file.write('}').end_line()
}

struct IR_Type: Object {
    name: @String
    size = 0
    compute_size = func (self: @IR_Type) -> i32 {
        abort(clone("Unsupported type: ").append(self.name))
    }
}

func get_size(self: @IR_Type) -> i32 {
    if self.size == 0 {
        self.size = self.compute_size()
    }
    return self.size
}

func write_cfg(file: @FILE, type: @IR_Type) -> @FILE {
    if type is IR_Pointer_Type {
        return file.write("ptr&lt;").write_cfg(type.as(@IR_Pointer_Type).pointed_type).write("&gt;")
    }
    return file.write(type.name)
}

struct IR_Boolean_Type: IR_Type(name = "bool", size = 1) {
}

struct IR_Integer_Type: IR_Type {
}

struct IR_Int_Type: IR_Integer_Type {
}

struct IR_Int16_Type: IR_Int_Type(name = "i16") {
}

struct IR_Int32_Type: IR_Int_Type(name = "i32", size = 4) {
}

struct IR_Int64_Type: IR_Int_Type(name = "i64") {
}

struct IR_Int8_Type: IR_Int_Type(name = "i8") {
}

struct IR_UInt_Type: IR_Integer_Type {
}

struct IR_UInt16_Type: IR_UInt_Type(name = "u16") {
}

struct IR_UInt32_Type: IR_UInt_Type(name = "u32") {
}

struct IR_UInt64_Type: IR_UInt_Type(name = "u64") {
}

struct IR_UInt8_Type: IR_UInt_Type(name = "u8") {
}

struct IR_Null_Type: IR_Type(name = "Null") {
}

struct IR_Undefined_Type: IR_Type(name = "Undefined") {
}

struct IR_Nothing_Type: IR_Type(name = "Nothing") {
}

struct IR_Pointer_Type: IR_Type {
    pointed_type: @IR_Type
}

struct IR_Unchecked_Array_Type: IR_Type {
    item_type: @IR_Type
}

struct IR_Fixed_Array_Type: IR_Type {
    item_type: @IR_Type
    size: i64
}

struct IR_Function_Type: IR_Type {
    parameters: @List[@IR_Function_Type_Parameter]
    return_type: @IR_Type
}

struct IR_Function_Type_Parameter {
    name: @String
    type: @IR_Type
}

struct IR_Opaque_Type: IR_Type {
}

struct IR_Struct_Type: IR_Type {
    super_type: @IR_Struct_Type = null
    derived_types = make @List[@IR_Struct_Type]()
    members = make @List[@IR_Struct_Type_Member]()
    checked_struct_type: @Checked_Struct_Type
    \ object_type_variable: @IR_Global_Variable = null
    \ object_type_id = 0u32
    \ object_type_max_derivate_id = 0u32
}

struct IR_Struct_Type_Member {
    struct_type: @IR_Struct_Type
    name: @String
    type: @IR_Type
    checked_struct_type_member: @Checked_Struct_Type_Member
    default_value_expression: @Parsed_Expression
}

func add_member(self: @IR_Struct_Type, name: @String, type: @IR_Type, checked_struct_type_member: @Checked_Struct_Type_Member, default_value_expression: @Parsed_Expression) -> @IR_Struct_Type_Member {
    let member = make @IR_Struct_Type_Member(
        struct_type = self
        name = name
        type = type
        checked_struct_type_member = checked_struct_type_member
        default_value_expression = default_value_expression
    )
    self.members.append(member)
    return member
}

func is_object_type(self: @IR_Struct_Type) -> bool {
    let struct_type = self
    loop {
        if struct_type.name.equals("Object") {
            return true
        }
        struct_type = struct_type.super_type
        if struct_type == null {
            return false
        }
    }
}

struct IR_Symbol: Object {
    checked_symbol: @Checked_Symbol
    name: @String
    type: @IR_Type
}

func write(file: @FILE, symbol: @IR_Symbol, live: bool) -> Nothing {
    if symbol is IR_Function {
        file.write(symbol.as(@IR_Function), live)
    } else if symbol is IR_Global_Variable {
        file.write(symbol.as(@IR_Global_Variable), live)
    } else {
        abort(symbol.object_type)
    }
}

func write_name(file: @FILE, symbol: @IR_Symbol) -> @FILE {
    if symbol is IR_Function_Parameter {
        file.write("%")
    } else {
        file.write("$")
    }
    return file.write(symbol.name)
}

struct IR_Function: IR_Symbol {
    function_type: @IR_Function_Type
    parameters: @List[@IR_Function_Parameter]
    return_type: @IR_Type
    blocks: @List[@IR_Block]
}

struct IR_Function_Parameter: IR_Symbol {
    value: @IR_Value
}

func create_block(self: @IR_Function) -> @IR_Block {
    let block = make @IR_Block(
        function = self
        name = clone("").append(self.blocks.size + 1)
    )
    self.blocks.append(block)
    return block
}

func write(file: @FILE, function: @IR_Function, live: bool) -> @FILE {
    file.write_name(function).write("(")
    let function_type = function.function_type
    let function_parameters = function.parameters.create_iterator()
    while function_parameters.has_next() {
        let function_parameter = function_parameters.next()
        file.write_name(function_parameter).write(": ").write(function_parameter.type.name)
        if function_parameters.has_next() {
            file.write(", ")
        }
    }
    if function_type.return_type is IR_Nothing_Type {
        file.write(")")
    } else {
        file.write("): ").write(function_type.return_type.name)
    }
    if function.blocks != null {
        file.write(" {").end_line()
        let block_item = function.blocks.first_item
        while block_item != null {
            file.write(block_item.data, live)
            block_item = block_item.next_item
        }
        file.write('}')
    }
    return file.end_line()
}

func write_cfg(file: @FILE, function: @IR_Function, cluster: i32) -> @FILE {
    file.end_line().write("   subgraph cluster_").write(cluster).write(" {").end_line()
    file.write("      label=\"").write_name(function).write('(')
    let function_parameters = function.parameters.create_iterator()
    while function_parameters.has_next() {
        let function_parameter = function_parameters.next()
        file.write(function_parameter.value.name).write(": ").write_cfg(function_parameter.type)
        if function_parameters.has_next() {
            file.write(", ")
        }
    }
    file.write(')')
    if function.return_type != null {
        file.write(": ").write_cfg(function.return_type)
    }
    file.write('"').end_line()
    if function.blocks != null {
        function.blocks.for_each() {
            file.end_line().write_cfg(it)
        }
    }
    return file.write("   }").end_line()
}

struct IR_Global_Variable: IR_Symbol {
    value_pointer: @IR_Value
    is_external = false
}

func write(file: @FILE, global_variable: @IR_Global_Variable, live: bool) -> @FILE {
    if global_variable.is_external {
        return file.write("external $").write(global_variable.name).write(": ").write(global_variable.type.name).end_line()
    }
    abort("TODO: Write global variable")
}

struct IR_Local_Variable: IR_Symbol {
    value_pointer: @IR_Value
    value_counter = make Counter[i32]()
}

struct IR_Value: Object {
    name: @String
    type: @IR_Type
    init_instruction: @IR_Instruction = null
    user_instructions = make List[@IR_Instruction]()
}

func write(file: @FILE, value: @IR_Value) -> @FILE {
    return file.write(value.name)
}

struct IR_Block {
    function: @IR_Function
    name: @String
    predecessors = make List[@IR_Block]()
    first_instruction: @IR_Instruction = null
    last_instruction: @IR_Instruction = null

    processed = false
}

func append(self: @IR_Block, instruction: @IR_Instruction) -> @IR_Instruction {
    instruction.block = self
    if self.last_instruction == null {
        self.first_instruction = instruction
    } else {
        self.last_instruction.next_instruction = instruction
        instruction.prev_instruction = self.last_instruction
    }
    self.last_instruction = instruction
    if instruction.result_value != null {
        instruction.result_value.init_instruction = instruction
    }
    return instruction
}

macro for_each_instruction(self: @IR_Block, body: macro (it: @IR_Instruction)) {
    let instruction = self.first_instruction
    while instruction != null {
        body(instruction)
        instruction = instruction.next_instruction
    }
}

func write(file: @FILE, block: @IR_Block, live: bool) -> @FILE {
    file.write_name(block).write(':').end_line()
    block.for_each_instruction() {
        let block_instruction = it
        if live {
            file.write("   [")
            block_instruction.live_in_values.for_each() {
                file.write(' ').write(it)
            }
            file.write(" ]").end_line()
        }
        file.write("   ").write(block_instruction).end_line()
    }
    if live {
        file.write("   [")
        block.last_instruction.live_out_values.for_each() {
            file.write(' ').write(it)
        }
        file.write(" ]").end_line()
    }
    return file
}

func write_name(file: @FILE, block: @IR_Block) -> @FILE {
    return file.write('@').write(block.name)
}

func write_cfg(file: @FILE, block: @IR_Block) -> @FILE {
    file.write("      ").write_cfg_name(block).write(" [label=\"").write_name(block).write('|')
    block.for_each_instruction() {
        file.write_cfg(it).write("\\l")
    }
    file.write("\"]").end_line()
    let last_instruction = block.last_instruction
    if last_instruction != null {
        if last_instruction is IR_Jump_Instruction {
            let last_instruction = last_instruction.as(@IR_Jump_Instruction)
            file.write("      ").write_cfg_name(block).write(" -> ").write_cfg_name(last_instruction.block).end_line()
        } else if last_instruction is IR_Branch_Instruction {
            let last_instruction = last_instruction.as(@IR_Branch_Instruction)
            file.write("      ").write_cfg_name(block).write(" -> ").write_cfg_name(last_instruction.true_block).write(" [label=\"true\"]").end_line()
            file.write("      ").write_cfg_name(block).write(" -> ").write_cfg_name(last_instruction.false_block).write(" [label=\"false\"]").end_line()
        }
        return file
    }
    return file
}

func write_cfg_name(file: @FILE, block: @IR_Block) -> @FILE {
    return file.write('"').write_name(block.function).write_name(block).write('"')
}

struct IR_Instruction: Object {
    location: @Source_Location = null
    result_value: @IR_Value = null
    operand_values = make Map[@Any, @IR_Value]()
    block: @IR_Block = undefined
    prev_instruction: @IR_Instruction = null
    next_instruction: @IR_Instruction = null
    live_in_values = make List[@IR_Value]()
    live_out_values: @List[@IR_Value] = null
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        file.flush()
        abort(clone("Unsupported type: ").append(instruction.object_type.name))
    }
}

func is_exit_instruction(self: @IR_Instruction) -> bool {
    if self == null {
        return false
    }
    if self is IR_Branch_Instruction or self is IR_Jump_Instruction or self is IR_Return_Instruction {
        return true
    }
    if self is IR_Direct_Call_Instruction {
        let self = self.as(@IR_Direct_Call_Instruction)
        let function = self.function
        if function.name.equals("abort") and function.parameters.size == 0 {
            return true
        }
        if function.name.equals("exit") and function.parameters.size == 1 {
            let function_parameter = function.parameters.get(0i64)
            if function_parameter.type is IR_Int32_Type {
                return true
            }
        }
    }
    return false
}

func set_operand_value(self: @IR_Instruction, key: @Any, value: @IR_Value) -> Nothing {
    self.operand_values.put(key, value)
    value.user_instructions.append(self)
}

func write(file: @FILE, instruction: @IR_Instruction) -> @FILE {
    if instruction.result_value != null {
        file.write(instruction.result_value).write(": ").write(instruction.result_value.type.name).write(" = ")
    }
    return instruction.write(file)
}

func write_cfg(file: @FILE, instruction: @IR_Instruction) -> @FILE {
    if instruction.result_value != null {
        file.write(instruction.result_value.name).write(": ").write_cfg(instruction.result_value.type).write(" = ")
    }
    return instruction.write(file)
}

struct IR_Add_Instruction: IR_Binary_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Binary_Instruction)
        return file.write("add ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Alloc_Instruction: IR_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Alloc_Instruction)
        return file.write("alloc ").write(instruction.type.name)
    }
) {
    type: @IR_Type
}

struct IR_Binary_Instruction: IR_Instruction {
}

func init(self: @IR_Binary_Instruction, left_value: @IR_Value, right_value: @IR_Value) -> @IR_Binary_Instruction {
    self.set_operand_value("left_value", left_value)
    self.set_operand_value("right_value", right_value)
    return self
}

func get_left_value(self: @IR_Binary_Instruction) -> @IR_Value {
    return self.operand_values.get("left_value")
}

func get_right_value(self: @IR_Binary_Instruction) -> @IR_Value {
    return self.operand_values.get("right_value")
}

struct IR_Branch_Instruction: IR_Terminator_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Branch_Instruction)
        return file.write("br ").write(instruction.get_condition()).write(' ').write_name(instruction.true_block).write(' ').write_name(instruction.false_block)
    }
) {
    true_block: @IR_Block
    false_block: @IR_Block
}

func init(self: @IR_Branch_Instruction, condition: @IR_Value) -> @IR_Branch_Instruction {
    if condition.type is not IR_Boolean_Type {
        abort(clone("Not a boolean type: ").append(condition.type.name))
    }
    self.set_operand_value("condition", condition)
    return self
}

func get_condition(self: @IR_Branch_Instruction) -> @IR_Value {
    return self.operand_values.get("condition")
}

struct IR_Call_Instruction: IR_Instruction {
    arguments_size = 0
}

func write_call_arguments(file: @FILE, instruction: @IR_Call_Instruction) -> @FILE {
    let call_argument_index = 0
    while call_argument_index < instruction.arguments_size {
        file.write(' ').write(instruction.get_argument_value(call_argument_index))
        call_argument_index = call_argument_index + 1
    }
    return file
}

struct IR_Call_Argument {
    name: @String = null
    value: @IR_Value
}

func add_arguments(self: @IR_Call_Instruction, call_arguments: @List[@IR_Call_Argument]) -> @IR_Call_Instruction {
    let call_arguments_item = call_arguments.first_item
    while call_arguments_item != null {
        let call_argument = call_arguments_item.data
        self.set_operand_value(get_argument_key(self.arguments_size), call_argument.value)
        self.arguments_size = self.arguments_size + 1
        call_arguments_item = call_arguments_item.next_item
    }
    return self
}

func get_argument_value(self: @IR_Call_Instruction, index: i32) -> @IR_Value {
    return self.operand_values.get(get_argument_key(index))
}

func get_argument_key(index: i32) -> @String {
    if index == 0 {
        return "argument-0-value"
    } else if index == 1 {
        return "argument-1-value"
    } else if index == 2 {
        return "argument-2-value"
    } else if index == 3 {
        return "argument-3-value"
    } else if index == 4 {
        return "argument-4-value"
    } else if index == 5 {
        return "argument-5-value"
    }
    abort(clone("Missing argument index: ").append(index))
}

struct IR_Comparison_Instruction: IR_Binary_Instruction {
}

struct IR_Constant_Instruction: IR_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Constant_Instruction)
        return file.write("const ").write(instruction.literal)
    }
) {
    literal: @Literal_Token
}

func create_ir_constant_instruction(result_value: @IR_Value, literal: @Literal_Token) -> @IR_Constant_Instruction {
    let instruction = make @IR_Constant_Instruction(
        result_value = result_value
        literal = literal
    )
    return instruction
}

struct IR_Direct_Call_Instruction: IR_Call_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Direct_Call_Instruction)
        return file.write("call ").write_name(instruction.function).write_call_arguments(instruction)
    }
) {
    function: @IR_Function
}

func create_ir_direct_call_instruction(result_value: @IR_Value, call_arguments: @List[@IR_Call_Argument], function: @IR_Function) -> @IR_Call_Instruction {
    let instruction = make @IR_Direct_Call_Instruction(result_value = result_value, function = function)
    instruction.add_arguments(call_arguments)
    return instruction
}

struct IR_Divide_Instruction: IR_Binary_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Binary_Instruction)
        return file.write("div ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Equality_Instruction: IR_Comparison_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Comparison_Instruction)
        return file.write("cmp_eq ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Greater_Than_Instruction: IR_Comparison_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Comparison_Instruction)
        return file.write("cmp_gt ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Greater_Than_Or_Equal_Instruction: IR_Comparison_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Comparison_Instruction)
        return file.write("cmp_ge ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Inequality_Instruction: IR_Comparison_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Comparison_Instruction)
        return file.write("cmp_ne ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Jump_Instruction: IR_Terminator_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Jump_Instruction)
        return file.write("jmp ").write_name(instruction.block)
    }
) {
    block: @IR_Block
}

struct IR_Less_Than_Instruction: IR_Comparison_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Comparison_Instruction)
        return file.write("cmp_lt ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Less_Than_Or_Equal_Instruction: IR_Comparison_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Comparison_Instruction)
        return file.write("cmp_le ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Load_Instruction: IR_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Load_Instruction)
        return file.write("load ").write(instruction.get_value_pointer())
    }
) {
}

func init(self: @IR_Load_Instruction, value_pointer: @IR_Value) -> @IR_Load_Instruction {
    if value_pointer.type is not IR_Pointer_Type {
        abort(clone("Not a pointer type: ").append(value_pointer.type.name))
    }
    let pointed_type = value_pointer.type.as(@IR_Pointer_Type).pointed_type
    if pointed_type != self.result_value.type {
        abort(clone("Type mismatch: ").append(pointed_type.name).append(" != ").append(self.result_value.type.name))
    }
    self.set_operand_value("value_pointer", value_pointer)
    return self
}

func get_value_pointer(self: @IR_Load_Instruction) -> @IR_Value {
    return self.operand_values.get("value_pointer")
}

struct IR_Modulo_Instruction: IR_Binary_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Binary_Instruction)
        return file.write("mod ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Multiply_Instruction: IR_Binary_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Binary_Instruction)
        return file.write("mul ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Negate_Instruction: IR_Unary_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Negate_Instruction)
        return file.write("neg ").write(instruction.get_value())
    }
) {
}

struct IR_Not_Instruction: IR_Unary_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Not_Instruction)
        return file.write("not ").write(instruction.get_value())
    }
) {
}

struct IR_Phi_Instruction: IR_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Phi_Instruction)
        file.write("phi")
        let operand_values_entry = instruction.operand_values.first_entry
        while operand_values_entry != null {
            file.write(' ').write_name(instruction.value_block_mapping.get(operand_values_entry.value)).write(' ').write(operand_values_entry.value)
            operand_values_entry = operand_values_entry.next_entry
        }
        return file
    }
) {
    value_block_mapping = make Map[@IR_Value, @IR_Block]()
}

func append(self: @IR_Phi_Instruction, value: @IR_Value, block: @IR_Block) -> @IR_Phi_Instruction {
    self.value_block_mapping.put(value, block)
    self.set_operand_value(value, value)
    return self
}

struct IR_Store_Instruction: IR_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Store_Instruction)
        return file.write("store ").write(instruction.get_value_pointer()).write(' ').write(instruction.get_value())
    }
) {
}

func init(self: @IR_Store_Instruction, value_pointer: @IR_Value, value: @IR_Value) -> @IR_Store_Instruction {
    if value_pointer.type is not IR_Pointer_Type {
        abort(clone("Not a pointer type: ").append(value_pointer.type.name))
    }
    let pointed_type = value_pointer.type.as(@IR_Pointer_Type).pointed_type
    if pointed_type != value.type {
        abort(clone("Type mismatch: ").append(pointed_type.name).append(" != ").append(value.type.name))
    }
    self.set_operand_value("value_pointer", value_pointer)
    self.set_operand_value("value", value)
    return self
}

func get_value_pointer(self: @IR_Store_Instruction) -> @IR_Value {
    return self.operand_values.get("value_pointer")
}

func get_value(self: @IR_Store_Instruction) -> @IR_Value {
    return self.operand_values.get("value")
}

struct IR_Return_Instruction: IR_Terminator_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Return_Instruction)
        if instruction.get_return_value() == null {
            return file.write("ret")
        }
        return file.write("ret ").write(instruction.get_return_value().name)
    }
) {
}

func create_ir_return_instruction(return_value: @IR_Value) -> @IR_Return_Instruction {
    let instruction = make @IR_Return_Instruction(result_value = null)
    if return_value != null {
        instruction.set_operand_value("return_value", return_value)
    }
    return instruction
}

func get_return_value(self: @IR_Return_Instruction) -> @IR_Value {
    return self.operand_values.get("return_value")
}

struct IR_Substract_Instruction: IR_Binary_Instruction(
    write = func (instruction: @IR_Instruction, file: @FILE) -> @FILE {
        let instruction = instruction.as(@IR_Binary_Instruction)
        return file.write("sub ").write(instruction.get_left_value()).write(' ').write(instruction.get_right_value())
    }
) {
}

struct IR_Terminator_Instruction: IR_Instruction {
}

struct IR_Unary_Instruction: IR_Instruction {
}

func init(self: @IR_Unary_Instruction, value: @IR_Value) -> @IR_Unary_Instruction {
    self.set_operand_value("value", value)
    return self
}

func get_value(self: @IR_Unary_Instruction) -> @IR_Value {
    return self.operand_values.get("value")
}
