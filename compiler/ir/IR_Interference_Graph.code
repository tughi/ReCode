struct IR_Interference_Graph {
    nodes = make Map[@IR_Value, @List[@IR_Value]]()
}

func add_edge(self: @IR_Interference_Graph, node: @IR_Value, neighbour: @IR_Value) -> Nothing {
    let neighbours = self.nodes.get(node)
    if neighbours == null {
        neighbours = make @List[@IR_Value]()
        self.nodes.put(node, neighbours)
    }
    if node != neighbour and not neighbours.contains(neighbour) {
        neighbours.append(neighbour)
    }
}

func write(file: @FILE, graphs: @Map[@IR_Function, @IR_Interference_Graph]) -> @FILE {
    let cluster = 0
    file.write("graph {").end_line()
    file.write("   fontname=monospace").end_line()
    file.write("   layout=fdp").end_line()
    graphs.for_each() {
        let function = key
        let graph = value
        file.end_line().write("   subgraph cluster_").write(cluster).write(" {").end_line()
        file.write("      label=\"").write_name(function).write('"').end_line()
        let visited_nodes = make List[@IR_Value]()
        graph.nodes.for_each() {
            let node = key
            let neighbours = value
            file.write("      \"").write_name(function).write(node).write("\" [label=\"").write(node).write("\"]").end_line()
            neighbours.for_each() {
                let neighbour = it
                if not visited_nodes.contains(neighbour) {
                    file.write("      \"").write_name(function).write(node).write("\" -- \"").write_name(function).write(neighbour).write('"').end_line()
                }
            }
            visited_nodes.append(node)
        }
        file.write("   }").end_line()
        cluster = cluster + 1
    }
    return file.write('}').end_line()
}

func build_interference_graphs(code: @IR_Code) -> @Map[@IR_Function, @IR_Interference_Graph] {
    let graphs = make @Map[@IR_Function, @IR_Interference_Graph]()

    code.global_symbols.for_each() {
        if it is IR_Function {
            let function = it.as(@IR_Function)
            graphs.put(
                function
                build_interference_graph(function)
            )
        }
    }

    return graphs
}

func build_interference_graph(function: @IR_Function) -> @IR_Interference_Graph {
    function.compute_live_values()

    let graph = make @IR_Interference_Graph()

    if function.blocks != null {
        function.blocks.for_each() {
            let block = it
            block.for_each_instruction() {
                let instruction = it
                \ add edges between all live values
                instruction.live_in_values.for_each() {
                    let node = it
                    instruction.live_in_values.for_each() {
                        let neighbour = it
                        graph.add_edge(node, neighbour)
                    }
                }
            }
        }
    }

    return graph
}

