func build(checked_code: @Checked_Code) -> @IR_Code {
    let builder = create_ir_builder(checked_code)
    builder.build()
    return make @IR_Code(
        types = builder.types
        global_symbols = builder.global_context.symbols
    )
}

struct IR_Builder {
    checked_code: @Checked_Code

    types: @List[@IR_Type]
    global_context = make IR_Context()

    current_function_context: @IR_Function_Context = null
    current_block_context: @IR_Block_Context = null
    current_loop: @IR_Loop = null
}

struct IR_Context {
    parent: @IR_Context = null
    symbols = make List[@IR_Symbol]()
}

func find_symbol(self: @IR_Context, checked_symbol: @Checked_Symbol) -> @IR_Symbol {
    let context = self
    loop {
        context.symbols.for_each() {
            if it.checked_symbol == checked_symbol {
                return it
            }
        }
        context = context.parent
        if context == null {
            return null
        }
    }
}

struct IR_Function_Context: IR_Context {
    function: @IR_Function
    value_counter = make Counter[i32]()
}

struct IR_Block_Context: IR_Context {
    block: @IR_Block
}

struct IR_Loop {
    parent: @IR_Loop
    end_block: @IR_Block
}

func create_ir_builder(checked_code: @Checked_Code) -> @IR_Builder {
    let types = make @List[@IR_Type]()
    types.append(make @IR_Any_Type())
    types.append(make @IR_Boolean_Type())
    types.append(make @IR_Int8_Type())
    types.append(make @IR_Int16_Type())
    types.append(make @IR_Int32_Type())
    types.append(make @IR_Int64_Type())
    types.append(make @IR_Nothing_Type())
    types.append(make @IR_Null_Type())
    types.append(make @IR_UInt8_Type())
    types.append(make @IR_UInt16_Type())
    types.append(make @IR_UInt32_Type())
    types.append(make @IR_UInt64_Type())
    types.append(make @IR_Undefined_Type())

    return make @IR_Builder(
        checked_code = checked_code
        types = types
    )
}

func append(self: @IR_Builder, instruction: @IR_Instruction, location: @Source_Location) -> @IR_Value {
    instruction.location = location
    self.current_block_context.block.append(instruction)
    return instruction.result_value
}

func append_branch(self: @IR_Builder, condition: @IR_Value, true_block: @IR_Block, false_block: @IR_Block, location: @Source_Location) -> Nothing {
    self.current_block_context.block.append(
        make @IR_Branch_Instruction(location = location, true_block = true_block, false_block = false_block).init(condition)
    )
    true_block.predecessors.append(self.current_block_context.block)
    false_block.predecessors.append(self.current_block_context.block)
}

func append_jump(self: @IR_Builder, jump_block: @IR_Block, location: @Source_Location) -> Nothing {
    self.current_block_context.block.append(
        make @IR_Jump_Instruction(location = location, jump_block = jump_block)
    )
    jump_block.predecessors.append(self.current_block_context.block)
}

func create_named_value(self: @IR_Builder, name: @String, type: @IR_Type) -> @IR_Value {
    return make @IR_Value(
        type = type
        name = clone("%").append(name)
    )
}

func create_temp_value(self: @IR_Builder, type: @IR_Type) -> @IR_Value {
    return make @IR_Value(
        type = type
        name = clone("%").append(self.current_function_context.value_counter.next())
    )
}

func create_variable_value(self: @IR_Builder, variable: @IR_Local_Variable) -> @IR_Value {
    return make @IR_Value(
        type = variable.type
        name = clone("%").append(variable.name).append('.').append(variable.value_counter.next())
    )
}

func find_named_type(self: @IR_Builder, name: @String) -> @IR_Type {
    self.types.for_each() {
        if name.equals(it.name) {
            return it
        }
    }
    return null
}

func build(self: @IR_Builder) -> Nothing {
    self.checked_code.global_symbols.for_each() {
        if value is Checked_Type_Symbol {
            \ ignored
        } else if value is Checked_Variable_Symbol {
            self.create_global_variable(value.as(@Checked_Variable_Symbol))
        } else {
            abort(value.location, value.object_type)
        }
    }

    self.checked_code.functions.for_each() {
        self.create_function(it)
    }

    self.global_context.symbols.for_each() {
        if it is IR_Function {
            self.convert_function(it.as(@IR_Function))
        }
    }
}

func create_function(self: @IR_Builder, checked_function_symbol: @Checked_Function_Symbol) -> Nothing {
    let ir_function_type = self.convert_function_type(checked_function_symbol.function_type)

    \ create IR function parameters
    let ir_function_parameters = make @List[@IR_Function_Parameter]()
    let ir_function_type_parameters_iterator = ir_function_type.parameters.create_iterator()
    let checked_function_symbol_parameters_iterator = checked_function_symbol.parameters.create_iterator()
    while ir_function_type_parameters_iterator.has_next() and checked_function_symbol_parameters_iterator.has_next() {
        let ir_function_type_parameter = ir_function_type_parameters_iterator.next()
        let checked_function_symbol_parameter = checked_function_symbol_parameters_iterator.next()
        ir_function_parameters.append(make @IR_Function_Parameter(
            checked_symbol = checked_function_symbol_parameter
            name = ir_function_type_parameter.name
            type = ir_function_type_parameter.type
            value = make @IR_Value(
                name = clone("%").append(ir_function_type_parameter.name)
                type = ir_function_type_parameter.type
            )
        ))
    }

    \ prepare IR function blocks
    let ir_function_blocks: @List[@IR_Block]
    if checked_function_symbol.body != null {
        ir_function_blocks = make @List[@IR_Block]()
    } else {
        ir_function_blocks = null
    }

    let ir_function = make @IR_Function(
        checked_symbol = checked_function_symbol
        name = checked_function_symbol.unique_name
        type = self.create_ir_pointer_type(ir_function_type)
        function_type = ir_function_type
        parameters = ir_function_parameters
        return_type = ir_function_type.return_type
        blocks = ir_function_blocks
    )
    self.global_context.symbols.append(ir_function)
}

func create_global_variable(self: @IR_Builder, checked_variable_symbol: @Checked_Variable_Symbol) -> Nothing {
    let ir_variable_type = self.convert_type(checked_variable_symbol.type)
    let ir_variable = make @IR_Global_Variable(
        checked_symbol = checked_variable_symbol
        name = checked_variable_symbol.name
        type = ir_variable_type
        value_pointer = make @IR_Value(
            name = "$".clone().append(checked_variable_symbol.name)
            type = self.create_ir_pointer_type(ir_variable_type)
        )
        is_external = checked_variable_symbol.is_external
    )
    if not checked_variable_symbol.is_external {
        abort("TODO: Create variable value")
    }
    self.global_context.symbols.append(ir_variable)
}

func convert_function(self: @IR_Builder, ir_function: @IR_Function) -> Nothing {
    if ir_function.checked_symbol is not Checked_Function_Symbol {
        abort("Invalid state")
    }
    let checked_function_symbol = ir_function.checked_symbol.as(@Checked_Function_Symbol)
    if checked_function_symbol.body != null {
        self.current_function_context = make @IR_Function_Context(
            parent = self.global_context
            function = ir_function
        )

        ir_function.parameters.for_each() {
            self.current_function_context.symbols.append(it)
        }

        self.current_block_context = make @IR_Block_Context(
            parent = self.current_function_context
            block = ir_function.create_block()
        )

        \ convert function parameters into local variables so that each symbol has a value pointer
        ir_function.parameters.for_each() {
            let ir_parameter = it
            let ir_parameter_value = self.current_function_context.find_symbol(ir_parameter.checked_symbol).as(@IR_Function_Parameter).value
            let ir_local_variable = make @IR_Local_Variable(
                checked_symbol = ir_parameter.checked_symbol
                name = ir_parameter.name
                type = ir_parameter.type
                value_pointer = undefined
            )
            self.current_block_context.symbols.append(ir_local_variable)
            ir_local_variable.value_pointer = self.append(
                make @IR_Alloc_Instruction(
                    result_value = self.create_named_value(
                        clone(ir_parameter.name).append(".ptr")
                        self.create_ir_pointer_type(ir_parameter.type)
                    )
                    type = ir_parameter.type
                )
                ir_parameter.checked_symbol.location
            )
            self.convert_store_value(
                ir_local_variable.value_pointer
                ir_parameter_value
                ir_parameter.checked_symbol.location
            )
        }

        self.convert_block_statement(checked_function_symbol.body)

        \ cleanup last block
        let last_block = self.current_block_context.block
        if last_block.last_instruction == null {
            if last_block.predecessors.size == 0 and last_block != ir_function.blocks.first() {
                \ unreachable empty block
                ir_function.blocks.remove(last_block).prune()
            } else if ir_function.return_type is IR_Nothing_Type {
                self.append(create_ir_return_instruction(null), null)
            } else {
                abort(checked_function_symbol.location, "Missing return statement")
            }
        } else if not last_block.last_instruction.is_exit_instruction() {
            if ir_function.return_type is IR_Nothing_Type {
                self.append(create_ir_return_instruction(null), null)
            } else {
                abort(checked_function_symbol.location, "Missing return statement")
            }
        }

        self.current_block_context = null

        \ self.remove_redundant_blocks(ir_function)
        \ self.populate_phi_instructions(ir_function)
        \ self.remove_trivial_phi_instructions(ir_function)
        \ self.remove_redundant_set_instructions(ir_function)
    }
}

func convert_type(self: @IR_Builder, checked_type: @Checked_Type) -> @IR_Type {
    let ir_type: @IR_Type
    if checked_type is Checked_Function_Type {
        return self.convert_function_type(checked_type.as(@Checked_Function_Type))
    } else if checked_type is Checked_Named_Type {
        let ir_type_name = checked_type.name
        ir_type = self.find_named_type(ir_type_name)
        if ir_type != null {
            return ir_type
        }
        if checked_type is Checked_Opaque_Type {
            ir_type = make @IR_Opaque_Type(
                name = ir_type_name
            )
        } else if checked_type is Checked_Struct_Type {
            return self.convert_struct_type(checked_type.as(@Checked_Struct_Type))
        } else if checked_type is Checked_Trait_Type {
            return self.convert_struct_type(checked_type.as(@Checked_Trait_Type).struct_type)
        } else {
            abort(checked_type.object_type)
        }
    } else if checked_type is Checked_Pointer_Type {
        let ir_pointed_type = self.convert_type(checked_type.as(@Checked_Pointer_Type).pointed_type)
        return self.create_ir_pointer_type(ir_pointed_type)
    } else if checked_type is Checked_Unchecked_Array_Type {
        let ir_item_type = self.convert_type(checked_type.as(@Checked_Unchecked_Array_Type).item_type)
        return self.create_ir_pointer_type(ir_item_type)
    } else {
        abort(checked_type.object_type)
    }
    self.types.append(ir_type)
    return ir_type
}

func create_ir_pointer_type(self: @IR_Builder, ir_pointed_type: @IR_Type) -> @IR_Pointer_Type {
    self.types.for_each() {
        if it is IR_Pointer_Type and it.as(@IR_Pointer_Type).pointed_type == ir_pointed_type {
            return it.as(@IR_Pointer_Type)
        }
    }
    let ir_type_name = clone("ptr<").append(ir_pointed_type.name).append('>')
    let ir_type = make @IR_Pointer_Type(
        name = ir_type_name
        pointed_type = ir_pointed_type
    )
    self.types.append(ir_type)
    return ir_type
}

func convert_function_type(self: @IR_Builder, checked_function_type: @Checked_Function_Type) -> @IR_Function_Type {
    let ir_function_type_name = make @String().append("func (")
    let ir_function_type_parameters = make @List[@IR_Function_Type_Parameter]()
    checked_function_type.parameters.for_each_indexed() {
        let checked_callable_parameter = it
        if it_index > 0 {
            ir_function_type_name.append(", ")
        }
        let ir_callable_parameter_name = checked_callable_parameter.name
        let ir_callable_parameter_type = self.convert_type(checked_callable_parameter.type)
        ir_function_type_name.append(ir_callable_parameter_name).append(": ").append(ir_callable_parameter_type.name)
        ir_function_type_parameters.append(make @IR_Function_Type_Parameter(
            name = ir_callable_parameter_name
            type = ir_callable_parameter_type
        ))
    }
    ir_function_type_name.append(')')
    let ir_function_type_return_type = self.convert_type(checked_function_type.return_type)
    if ir_function_type_return_type is not IR_Nothing_Type {
        ir_function_type_name.append(" -> ").append(ir_function_type_return_type.name)
    }

    \ check if function type already exists
    self.types.for_each() {
        if it is IR_Function_Type {
            let that = it.as(@IR_Function_Type)
            let same = that.return_type == ir_function_type_return_type and that.parameters.size == ir_function_type_parameters.size
            if same {
                let that_parameters_item = that.parameters.first_item
                let this_parameters_item = ir_function_type_parameters.first_item
                while same and that_parameters_item != null and this_parameters_item != null {
                    let that_parameter = that_parameters_item.data
                    let this_parameter = this_parameters_item.data
                    same = (that_parameter.name == null or (this_parameter.name != null and this_parameter.name.equals(that_parameter.name))) and that_parameter.type == this_parameter.type
                    that_parameters_item = that_parameters_item.next_item
                    this_parameters_item = this_parameters_item.next_item
                }
                if same {
                    return that
                }
            }
        }
    }

    \ TODO: create function_name here

    let ir_function_type = make @IR_Function_Type(
        name = ir_function_type_name
        parameters = ir_function_type_parameters
        return_type = ir_function_type_return_type
    )

    self.types.append(ir_function_type)

    return ir_function_type
}

func convert_struct_type(self: @IR_Builder, checked_struct_type: @Checked_Struct_Type) -> @IR_Struct_Type {
    let ir_struct_type = make @IR_Struct_Type(
        name = checked_struct_type.name
        checked_struct_type = checked_struct_type
    )
    self.types.append(ir_struct_type)

    if checked_struct_type.super_type != null {
        let super_type = self.convert_type(checked_struct_type.super_type)
        if super_type is not IR_Struct_Type {
            abort("Invalid state")
        }
        let super_type = super_type.as(@IR_Struct_Type)
        ir_struct_type.super_type = super_type
        ir_struct_type.super_type.derived_types.append(ir_struct_type)
    }

    checked_struct_type.members.for_each() {
        ir_struct_type.add_member(
            it.name
            self.convert_type(it.type)
            it
            null \ TODO: checked_struct_type.default_values.get(it)
        )
    }

    if ir_struct_type.is_object_type() {
        \ let object_type_type = self.convert_type(make @Parsed_Pointer_Type(pointed_type = make @Parsed_Named_Type(name = make @Identifier_Token(location = null, lexeme = "Object_Type"))))
        \ if object_type_type is not IR_Pointer_Type {
        \     abort(struct_statement.location, "Invalid state")
        \ }
        \ let object_type_struct_type = object_type_type.as(@IR_Pointer_Type).pointed_type
        \ if object_type_struct_type is not IR_Struct_Type {
        \     abort(struct_statement.location, "Invalid state")
        \ }

        \ \ TODO: Build Object_Type value
        \ let object_type_value = make @IR_Undefined_Value(type = object_type_type)

        \ let object_type_variable = make @IR_Global_Variable(
        \     location = type.statement.location
        \     name = clone(struct_statement.name.lexeme).append("__").append(self.types_counter.next())
        \     type = object_type_type
        \     value = object_type_value
        \     is_external = false
        \ )
        \ type.object_type_variable = object_type_variable

        \ self.add_symbol(object_type_variable) \ TODO: add symbol to root context

        abort("TODO: Prepare object type")
    }

    return ir_struct_type
}

func convert_statement(self: @IR_Builder, checked_statement: @Checked_Statement) -> Nothing {
    if checked_statement is Checked_Assignment_Statement {
        self.convert_assignment_statement(checked_statement.as(@Checked_Assignment_Statement))
    } else if checked_statement is Checked_Block_Statement {
        self.convert_block_statement(checked_statement.as(@Checked_Block_Statement))
    } else if checked_statement is Checked_Break_Statement {
        self.convert_break_statement(checked_statement.as(@Checked_Break_Statement))
    } else if checked_statement is Checked_Expression_Statement {
        self.convert_expression_statement(checked_statement.as(@Checked_Expression_Statement))
    } else if checked_statement is Checked_If_Statement {
        self.convert_if_statement(checked_statement.as(@Checked_If_Statement))
    } else if checked_statement is Checked_Loop_Statement {
        self.convert_loop_statement(checked_statement.as(@Checked_Loop_Statement))
    } else if checked_statement is Checked_Return_Statement {
        self.convert_return_statement(checked_statement.as(@Checked_Return_Statement))
    } else if checked_statement is Checked_Variable_Statement {
        self.convert_variable_statement(checked_statement.as(@Checked_Variable_Statement))
    } else if checked_statement is Checked_While_Statement {
        self.convert_while_statement(checked_statement.as(@Checked_While_Statement))
    } else {
        abort(checked_statement.location, checked_statement.object_type)
    }
}

func convert_assignment_statement(self: @IR_Builder, checked_statement: @Checked_Assignment_Statement) -> Nothing {
    let checked_destination_expression = checked_statement.destination_expression
    if checked_destination_expression is Checked_Symbol_Expression {
        let ir_symbol = self.current_block_context.find_symbol(checked_destination_expression.as(@Checked_Symbol_Expression).symbol)
        if ir_symbol is IR_Local_Variable {
            let ir_symbol = ir_symbol.as(@IR_Local_Variable)
            let value = self.convert_expression(checked_statement.value_expression, ir_symbol.type)
            self.convert_store_value(ir_symbol.value_pointer, value, checked_statement.location)
        } else {
            abort(checked_destination_expression.location, ir_symbol.object_type)
        }
    } else if checked_destination_expression is Checked_Member_Access_Expression {
        let destination_pointer = self.convert_expression_pointer(checked_destination_expression, null)
        let value_type = destination_pointer.type.as(@IR_Pointer_Type).pointed_type
        let value = self.convert_expression(checked_statement.value_expression, value_type)
        self.convert_store_value(destination_pointer, value, checked_statement.location)
    } else {
        abort(checked_destination_expression.location, checked_destination_expression.object_type)
    }
}

func convert_store_value(self: @IR_Builder, value_pointer: @IR_Value, value: @IR_Value, location: @Source_Location) -> Nothing {
    if value.type is IR_Struct_Type {
        let struct_type = value.type.as(@IR_Struct_Type)
        if value.init_instruction is not IR_Struct_Literal_Instruction {
            abort("Unsupported init instruction")
        }
        \ store each struct member individually
        value.init_instruction.as(@IR_Struct_Literal_Instruction).operand_values.for_each() {
            let struct_type_member = key.as(@IR_Struct_Type_Member)
            let struct_member_value = value

            self.convert_store_value(
                self.append(
                    self.create_ir_struct_member_offset_instruction(value_pointer, struct_type_member)
                    location
                )
                struct_member_value
                location
            )
        }
    } else {
        self.append(
            make @IR_Store_Instruction().init(value_pointer, value)
            location
        )
    }
}

func create_ir_struct_member_offset_instruction(self: @IR_Builder, struct_value_pointer: @IR_Value, struct_type_member: @IR_Struct_Type_Member) -> @IR_Struct_Member_Offset_Instruction {
    if struct_value_pointer.type is not IR_Pointer_Type {
        abort("Unexpected value type: ".clone().append(struct_value_pointer.type.name))
    }
    let struct_pointer_type = struct_value_pointer.type.as(@IR_Pointer_Type)
    if struct_pointer_type.pointed_type is not IR_Struct_Type {
        abort("Unexpected pointed type: ".clone().append(struct_pointer_type.pointed_type.name))
    }
    let struct_type = struct_pointer_type.pointed_type.as(@IR_Struct_Type)
    if struct_type_member.struct_type != struct_type {
        abort("Incompatible struct types")
    }
    return make @IR_Struct_Member_Offset_Instruction(
        result_value = self.create_temp_value(self.create_ir_pointer_type(struct_type_member.type))
        struct_type_member = struct_type_member
    ).init(struct_value_pointer)
}

func convert_block_statement(self: @IR_Builder, checked_block_statement: @Checked_Block_Statement) -> Nothing {
    checked_block_statement.statements.for_each() {
        self.convert_statement(it)
    }
}

func convert_break_statement(self: @IR_Builder, checked_statement: @Checked_Break_Statement) -> Nothing {
    if self.current_loop == null {
        abort(checked_statement.location, "Break statement outside of a loop")
    }
    self.append_jump(self.current_loop.end_block, checked_statement.location)

    \ code after break will be added to an unreachable block
    self.current_block_context = make @IR_Block_Context(
        parent = self.current_block_context.parent
        block = self.current_function_context.function.create_block()
    )
}

func convert_expression_statement(self: @IR_Builder, checked_statement: @Checked_Expression_Statement) -> Nothing {
    self.convert_expression(checked_statement.expression, null)
}

func convert_if_statement(self: @IR_Builder, checked_statement: @Checked_If_Statement) -> Nothing {
    \ create blocks
    let true_block = self.current_function_context.function.create_block()
    let end_block = self.current_function_context.function.create_block()
    let false_block = end_block
    if checked_statement.false_statement != null {
        end_block = self.current_function_context.function.create_block()
    }

    let condition_value = self.convert_expression(checked_statement.condition_expression, self.find_named_type("bool"))
    self.append_branch(condition_value, true_block, false_block, checked_statement.location)

    \ true block
    self.current_block_context = make @IR_Block_Context(
        parent = self.current_block_context
        block = true_block
    )
    self.convert_statement(checked_statement.true_statement)
    if not self.current_block_context.block.last_instruction.is_exit_instruction() {
        self.append_jump(end_block, checked_statement.location)
    }

    \ false block
    if end_block != false_block {
        self.current_block_context = make @IR_Block_Context(
            parent = self.current_block_context.parent
            block = false_block
        )
        self.convert_statement(checked_statement.false_statement)
        if not self.current_block_context.block.last_instruction.is_exit_instruction() {
            self.append_jump(end_block, checked_statement.location)
        }
    }

    \ end block
    self.current_block_context = make @IR_Block_Context(
        parent = self.current_block_context.parent
        block = end_block
    )
}

func convert_loop_statement(self: @IR_Builder, checked_statement: @Checked_Loop_Statement) -> Nothing {
    \ create blocks
    let body_block = self.current_function_context.function.create_block()
    let end_block = self.current_function_context.function.create_block()

    self.append_jump(body_block, checked_statement.location)

    \ body block
    self.current_block_context = make @IR_Block_Context(
        parent = self.current_block_context
        block = body_block
    )
    self.current_loop = make @IR_Loop(
        parent = self.current_loop
        end_block = end_block
    )
    self.convert_statement(checked_statement.body_statement)
    if not self.current_block_context.block.last_instruction.is_exit_instruction() {
        self.append_jump(body_block, checked_statement.location)
    }

    \ end block
    self.current_block_context = make @IR_Block_Context(
        parent = self.current_block_context
        block = end_block
    )
    self.current_loop = self.current_loop.parent
}

func convert_return_statement(self: @IR_Builder, checked_statement: @Checked_Return_Statement) -> Nothing {
    if checked_statement.expression != null {
        let return_value = self.convert_expression(checked_statement.expression, self.current_function_context.function.return_type)
        self.append(create_ir_return_instruction(return_value), checked_statement.location)
    } else {
        self.append(create_ir_return_instruction(null), checked_statement.location)
    }
}

func convert_variable_statement(self: @IR_Builder, checked_statement: @Checked_Variable_Statement) -> Nothing {
    let variable_type = self.convert_type(checked_statement.variable.type)
    let variable = make @IR_Local_Variable(
        checked_symbol = checked_statement.variable
        name = checked_statement.variable.name
        type = variable_type
        value_pointer = undefined
    )
    self.current_block_context.symbols.append(variable)
    let value_pointer = self.append(
        make @IR_Alloc_Instruction(
            result_value = self.create_named_value(
                clone(checked_statement.variable.name).append(".ptr")
                self.create_ir_pointer_type(variable_type)
            )
            type = variable_type
        )
        checked_statement.location
    )
    variable.value_pointer = value_pointer
    if checked_statement.variable.expression != null {
        let variable_value = self.convert_expression(checked_statement.variable.expression, variable_type)
        self.convert_store_value(variable.value_pointer, variable_value, checked_statement.location)
    }
}

func convert_while_statement(self: @IR_Builder, checked_statement: @Checked_While_Statement) -> Nothing {
    \ create blocks
    let condition_block = self.current_function_context.function.create_block()
    let body_block = self.current_function_context.function.create_block()
    let end_block = self.current_function_context.function.create_block()

    \ condition block
    self.append_jump(condition_block, checked_statement.location)
    self.current_block_context = make @IR_Block_Context(
        parent = self.current_block_context
        block = condition_block
    )
    let condition_value = self.convert_expression(checked_statement.condition_expression, self.find_named_type("bool"))
    self.append_branch(condition_value, body_block, end_block, checked_statement.location)

    \ body block
    self.current_block_context = make @IR_Block_Context(
        parent = self.current_block_context
        block = body_block
    )
    self.current_loop = make @IR_Loop(
        parent = self.current_loop
        end_block = end_block
    )
    self.convert_statement(checked_statement.body_statement)
    if not self.current_block_context.block.last_instruction.is_exit_instruction() {
        self.append_jump(condition_block, checked_statement.location)
    }

    \ end block
    self.current_block_context = make @IR_Block_Context(
        parent = self.current_block_context
        block = end_block
    )
    self.current_loop = self.current_loop.parent
}

func convert_expression(self: @IR_Builder, checked_expression: @Checked_Expression, expected_type: @IR_Type) -> @IR_Value {
    let value: @IR_Value
    if checked_expression is Checked_Add_Expression {
        value = self.convert_add_expression(checked_expression.as(@Checked_Add_Expression), expected_type)
    } else if checked_expression is Checked_Array_Access_Expression {
        value = self.convert_array_access_expression(checked_expression.as(@Checked_Array_Access_Expression), expected_type)
    } else if checked_expression is Checked_Cast_Expression {
        value = self.convert_cast_expression(checked_expression.as(@Checked_Cast_Expression), expected_type)
    } else if checked_expression is Checked_Dereference_Expression {
        value = self.convert_dereference_expression(checked_expression.as(@Checked_Dereference_Expression), expected_type)
    } else if checked_expression is Checked_Divide_Expression {
        value = self.convert_divide_expression(checked_expression.as(@Checked_Divide_Expression), expected_type)
    } else if checked_expression is Checked_Dynamic_Call_Expression {
        value = self.convert_dynamic_call_expression(checked_expression.as(@Checked_Dynamic_Call_Expression), expected_type)
    } else if checked_expression is Checked_Equals_Expression {
        value = self.convert_equals_expression(checked_expression.as(@Checked_Equals_Expression), expected_type)
    } else if checked_expression is Checked_Function_Call_Expression {
        value = self.convert_function_call_expression(checked_expression.as(@Checked_Function_Call_Expression), expected_type)
    } else if checked_expression is Checked_Greater_Than_Expression {
        value = self.convert_greater_than_expression(checked_expression.as(@Checked_Greater_Than_Expression), expected_type)
    } else if checked_expression is Checked_Greater_Than_Or_Equals_Expression {
        value = self.convert_greater_than_or_equals_expression(checked_expression.as(@Checked_Greater_Than_Or_Equals_Expression), expected_type)
    } else if checked_expression is Checked_Less_Than_Expression {
        value = self.convert_less_than_expression(checked_expression.as(@Checked_Less_Than_Expression), expected_type)
    } else if checked_expression is Checked_Less_Than_Or_Equals_Expression {
        value = self.convert_less_than_or_equals_expression(checked_expression.as(@Checked_Less_Than_Or_Equals_Expression), expected_type)
    } else if checked_expression is Checked_Literal_Expression {
        value = self.convert_literal_expression(checked_expression.as(@Checked_Literal_Expression), expected_type)
    } else if checked_expression is Checked_Logic_And_Expression {
        value = self.convert_logic_and_expression(checked_expression.as(@Checked_Logic_And_Expression), expected_type)
    } else if checked_expression is Checked_Logic_Not_Expression {
        value = self.convert_logic_not_expression(checked_expression.as(@Checked_Logic_Not_Expression), expected_type)
    } else if checked_expression is Checked_Logic_Or_Expression {
        value = self.convert_logic_or_expression(checked_expression.as(@Checked_Logic_Or_Expression), expected_type)
    } else if checked_expression is Checked_Make_Expression {
        value = self.convert_make_expression(checked_expression.as(@Checked_Make_Expression), expected_type)
    } else if checked_expression is Checked_Member_Access_Expression {
        value = self.convert_member_access_expression(checked_expression.as(@Checked_Member_Access_Expression), expected_type)
    } else if checked_expression is Checked_Modulo_Expression {
        value = self.convert_modulo_expression(checked_expression.as(@Checked_Modulo_Expression), expected_type)
    } else if checked_expression is Checked_Multiply_Expression {
        value = self.convert_multiply_expression(checked_expression.as(@Checked_Multiply_Expression), expected_type)
    } else if checked_expression is Checked_Negate_Expression {
        value = self.convert_negate_expression(checked_expression.as(@Checked_Negate_Expression), expected_type)
    } else if checked_expression is Checked_Not_Equals_Expression {
        value = self.convert_not_equals_expression(checked_expression.as(@Checked_Not_Equals_Expression), expected_type)
    } else if checked_expression is Checked_Reference_Expression {
        value = self.convert_reference_expression(checked_expression.as(@Checked_Reference_Expression), expected_type)
    } else if checked_expression is Checked_Substract_Expression {
        value = self.convert_substract_expression(checked_expression.as(@Checked_Substract_Expression), expected_type)
    } else if checked_expression is Checked_Super_Access_Expression {
        value = self.convert_super_access_expression(checked_expression.as(@Checked_Super_Access_Expression), expected_type)
    } else if checked_expression is Checked_Symbol_Expression {
        value = self.convert_symbol_expression(checked_expression.as(@Checked_Symbol_Expression), expected_type)
    } else {
        abort(checked_expression.location, checked_expression.object_type)
    }
    if expected_type != null and expected_type != value.type {
        abort(checked_expression.location, clone("Type mismatch: got ").append(value.type.name).append(" instead of ").append(expected_type.name))
    }
    return value
}

func convert_expression_pointer(self: @IR_Builder, checked_expression: @Checked_Expression, expected_type: @IR_Type) -> @IR_Value {
    let value: @IR_Value
    if checked_expression is Checked_Array_Access_Expression {
        value = self.convert_array_access_expression_pointer(checked_expression.as(@Checked_Array_Access_Expression), expected_type)
    } else if checked_expression is Checked_Member_Access_Expression {
        value = self.convert_member_access_expression_pointer(checked_expression.as(@Checked_Member_Access_Expression), expected_type)
    } else if checked_expression is Checked_Symbol_Expression {
        value = self.convert_symbol_expression_pointer(checked_expression.as(@Checked_Symbol_Expression), expected_type)
    } else {
        abort(checked_expression.location, checked_expression.object_type)
    }
    if value.type is not IR_Pointer_Type {
        abort(checked_expression.location, "Expected pointer type")
    }
    return value
}

func convert_add_expression(self: @IR_Builder, checked_expression: @Checked_Add_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, expected_type)
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Add_Instruction(
            result_value = self.create_temp_value(left_value.type)
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_array_access_expression(self: @IR_Builder, checked_expression: @Checked_Array_Access_Expression, expected_type: @IR_Type) -> @IR_Value {
    let value_pointer = self.convert_array_access_expression_pointer(checked_expression, null)
    return self.append(
        make @IR_Load_Instruction(
            result_value = self.create_temp_value(value_pointer.type.as(@IR_Pointer_Type).pointed_type)
        ).init(value_pointer)
        checked_expression.location
    )
}

func convert_array_access_expression_pointer(self: @IR_Builder, checked_expression: @Checked_Array_Access_Expression, expected_type: @IR_Type) -> @IR_Value {
    let value_pointer = self.convert_expression_pointer(checked_expression.array_expression, null)
    let value_type = value_pointer.type.as(@IR_Pointer_Type).pointed_type
    if value_type is not IR_Pointer_Type {
        abort(checked_expression.array_expression.location, "Not an array type")
    }
    let array_item_type = value_type.as(@IR_Pointer_Type).pointed_type
    let index_value = self.convert_expression(checked_expression.index_expression, null)
    if index_value.type is not IR_Integer_Type {
        abort(checked_expression.index_expression.location, "Not an integer type")
    }
    return self.append(
        make @IR_Array_Item_Offset_Instruction(
            result_value = self.create_temp_value(value_type)
        ).init(value_pointer, index_value)
        checked_expression.location
    )
}

func convert_cast_expression(self: @IR_Builder, checked_expression: @Checked_Cast_Expression, expected_type: @IR_Type) -> @IR_Value {
    let value = self.convert_expression(checked_expression.expression, null)
    let result_value = self.create_temp_value(self.convert_type(checked_expression.type))
    if value.type is IR_Integer_Type and result_value.type is IR_Integer_Type {
        return self.append(
            make @IR_Integer_Cast_Instruction(
                result_value = result_value
            ).init(value)
            checked_expression.location
        )
    }
    abort(checked_expression.location, "Cannot cast ".clone().append(value.type.name).append(" to ").append(result_value.type.name))
}

func convert_dereference_expression(self: @IR_Builder, checked_expression: @Checked_Dereference_Expression, expected_type: @IR_Type) -> @IR_Value {
    let value = self.convert_expression(checked_expression.target_expression, null)
    if value.type is not IR_Pointer_Type {
        abort(checked_expression.target_expression.location, "Not a pointer type")
    }
    return self.append(
        make @IR_Load_Instruction(
            result_value = self.create_temp_value(value.type.as(@IR_Pointer_Type).pointed_type)
        ).init(value)
        checked_expression.location
    )
}

func convert_call_arguments(self: @IR_Builder, checked_call_arguments: @List[@Checked_Call_Argument]) -> @List[@IR_Call_Argument] {
    let has_named_arguments = false
    let ir_call_arguments = make @List[@IR_Call_Argument]()
    checked_call_arguments.for_each() {
        let call_argument = it
        let call_argument_value = self.convert_expression(call_argument.expression, null)
        if call_argument.label != null {
            ir_call_arguments.append(make @IR_Call_Argument(name = call_argument.label, value = call_argument_value))
            has_named_arguments = true
        } else {
            if has_named_arguments {
                abort(call_argument.expression.location, "Positional arguments cannot be added after named ones")
            }
            ir_call_arguments.append(make @IR_Call_Argument(value = call_argument_value))
        }
    }
    return ir_call_arguments
}

func convert_divide_expression(self: @IR_Builder, checked_expression: @Checked_Divide_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, expected_type)
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Divide_Instruction(
            result_value = self.create_temp_value(left_value.type)
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_dynamic_call_expression(self: @IR_Builder, checked_expression: @Checked_Dynamic_Call_Expression, expected_type: @IR_Type) -> @IR_Value {
    abort("TODO: Convert dynamic call expression")
}

func convert_equals_expression(self: @IR_Builder, checked_expression: @Checked_Equals_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, null)
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Equality_Instruction(
            result_value = self.create_temp_value(self.find_named_type("bool"))
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_function_call_expression(self: @IR_Builder, checked_expression: @Checked_Function_Call_Expression, expected_type: @IR_Type) -> @IR_Value {
    let ir_function = self.global_context.find_symbol(checked_expression.function_symbol)
    if ir_function == null or ir_function is not IR_Function {
        abort(checked_expression.location, "Missing IR_Function for Checked_Function_Symbol: ".clone().append(checked_expression.function_symbol.name))
    }
    let ir_function = ir_function.as(@IR_Function)

    let ir_call_arguments = self.convert_call_arguments(checked_expression.call_arguments)

    let result_value: @IR_Value = null
    if ir_function.return_type is not IR_Nothing_Type {
        result_value = self.create_temp_value(ir_function.return_type)
    }
    return self.append(create_ir_direct_call_instruction(result_value, ir_call_arguments, ir_function), checked_expression.location)
}

func convert_greater_than_expression(self: @IR_Builder, checked_expression: @Checked_Greater_Than_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, null)
    if left_value.type is not IR_Integer_Type {
        abort(checked_expression.left_expression.location, "Not an integer type: ".clone().append(left_value.type.name))
    }
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Greater_Than_Instruction(
            result_value = self.create_temp_value(self.find_named_type("bool"))
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_greater_than_or_equals_expression(self: @IR_Builder, checked_expression: @Checked_Greater_Than_Or_Equals_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, null)
    if left_value.type is not IR_Integer_Type {
        abort(checked_expression.left_expression.location, "Not an integer type: ".clone().append(left_value.type.name))
    }
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Greater_Than_Or_Equal_Instruction(
            result_value = self.create_temp_value(self.find_named_type("bool"))
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_less_than_expression(self: @IR_Builder, checked_expression: @Checked_Less_Than_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, null)
    if left_value.type is not IR_Integer_Type {
        abort(checked_expression.left_expression.location, "Not an integer type: ".clone().append(left_value.type.name))
    }
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Less_Than_Instruction(
            result_value = self.create_temp_value(self.find_named_type("bool"))
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_less_than_or_equals_expression(self: @IR_Builder, checked_expression: @Checked_Less_Than_Or_Equals_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, null)
    if left_value.type is not IR_Integer_Type {
        abort(checked_expression.left_expression.location, "Not an integer type: ".clone().append(left_value.type.name))
    }
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Less_Than_Or_Equal_Instruction(
            result_value = self.create_temp_value(self.find_named_type("bool"))
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_literal_expression(self: @IR_Builder, checked_expression: @Checked_Literal_Expression, expected_type: @IR_Type) -> @IR_Value {
    if checked_expression is Checked_Boolean_Literal_Expression {
        return self.append(
            create_ir_constant_instruction(
                self.create_temp_value(self.find_named_type("bool"))
                checked_expression.as(@Checked_Boolean_Literal_Expression).literal
            )
            checked_expression.location
        )
    }
    if checked_expression is Checked_Character_Literal_Expression {
        return self.append(
            create_ir_constant_instruction(
                self.create_temp_value(self.find_named_type("u8"))
                checked_expression.as(@Checked_Character_Literal_Expression).literal
            )
            checked_expression.location
        )
    }
    if checked_expression is Checked_Integer_Literal_Expression {
        let checked_expression = checked_expression.as(@Checked_Integer_Literal_Expression)
        let ir_expression_type = self.convert_type(checked_expression.type)
        return self.append(
            create_ir_constant_instruction(
                self.create_temp_value(ir_expression_type)
                checked_expression.literal
            )
            checked_expression.location
        )
    }
    if checked_expression is Checked_Null_Literal_Expression {
        return self.append(
            create_ir_constant_instruction(
                self.create_temp_value(self.find_named_type("Null"))
                checked_expression.as(@Checked_Null_Literal_Expression).literal
            )
            checked_expression.location
        )
    }
    abort(checked_expression.location, checked_expression.object_type)
}

func convert_logic_and_expression(self: @IR_Builder, checked_expression: @Checked_Logic_And_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, self.find_named_type("bool"))
    let left_block = self.current_block_context.block
    let next_block = self.current_function_context.function.create_block()
    let end_block = self.current_function_context.function.create_block()
    self.append_branch(left_value, next_block, end_block, checked_expression.location)
    self.current_block_context = make @IR_Block_Context(
        parent = self.current_block_context
        block = next_block
    )
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    let right_block = self.current_block_context.block
    self.append_jump(end_block, checked_expression.location)
    self.current_block_context = make @IR_Block_Context(
        parent = self.current_block_context
        block = end_block
    )
    return self.append(
        make @IR_Phi_Instruction(
            result_value = self.create_temp_value(left_value.type)
        ).append(left_value, left_block).append(right_value, right_block)
        checked_expression.location
    )
}

func convert_logic_not_expression(self: @IR_Builder, checked_expression: @Checked_Logic_Not_Expression, expected_type: @IR_Type) -> @IR_Value {
    let value = self.convert_expression(checked_expression.expression, self.find_named_type("bool"))
    return self.append(
        make @IR_Not_Instruction(
            result_value = self.create_temp_value(value.type)
        ).init(value)
        checked_expression.location
    )
}

func convert_logic_or_expression(self: @IR_Builder, checked_expression: @Checked_Logic_Or_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, self.find_named_type("bool"))
    let left_block = self.current_block_context.block
    let next_block = self.current_function_context.function.create_block()
    let end_block = self.current_function_context.function.create_block()
    self.append_branch(left_value, end_block, next_block, checked_expression.location)
    self.current_block_context = make @IR_Block_Context(
        parent = self.current_block_context
        block = next_block
    )
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    let right_block = self.current_block_context.block
    self.append_jump(end_block, checked_expression.location)
    self.current_block_context = make @IR_Block_Context(
        parent = self.current_block_context
        block = end_block
    )
    return self.append(
        make @IR_Phi_Instruction(
            result_value = self.create_temp_value(left_value.type)
        ).append(left_value, left_block).append(right_value, right_block)
        checked_expression.location
    )
}

func convert_make_expression(self: @IR_Builder, checked_expression: @Checked_Make_Expression, expected_type: @IR_Type) -> @IR_Value {
    let expression_type = self.convert_type(checked_expression.type)
    if expression_type is IR_Pointer_Type {
        let pointed_type = expression_type.as(@IR_Pointer_Type).pointed_type
        if pointed_type is IR_Struct_Type {
            let struct_type = pointed_type.as(@IR_Struct_Type)
            \ find malloc function
            let checked_malloc_function: @Checked_Function_Symbol = null
            self.checked_code.functions.for_each() {
                if it.name.equals("malloc") {
                    if it.parameters.size == 1 and it.parameters.first().type is Checked_UInt64_Type {
                        checked_malloc_function = it
                    }
                }
            }
            if checked_malloc_function == null {
                abort(checked_expression.location, "Missing malloc function")
            }
            \ call malloc
            let ir_malloc_function = self.global_context.find_symbol(checked_malloc_function)
            if ir_malloc_function == null or ir_malloc_function is not IR_Function {
                abort(checked_expression.location, "Missing IR_Function for Checked_Function_Symbol: ".clone().append(checked_malloc_function.name))
            }
            let ir_malloc_function = ir_malloc_function.as(@IR_Function)
            let ir_malloc_call_arguments = make @List[@IR_Call_Argument]()
            let ir_malloc_size = struct_type.get_size().as(u64)
            ir_malloc_call_arguments.append(make @IR_Call_Argument(
                name = "size"
                value = self.append(
                    create_ir_constant_instruction(
                        self.create_temp_value(self.find_named_type("u64"))
                        make @Integer_Token(
                            lexeme = "".clone().append(ir_malloc_size)
                            location = checked_expression.location
                            value = ir_malloc_size
                            negative = false
                            type = "u64"
                        )
                    )
                    checked_expression.location
                )
            ))
            let value = self.append(
                create_ir_direct_call_instruction(
                    self.create_temp_value(expression_type)
                    ir_malloc_call_arguments
                    ir_malloc_function
                )
                checked_expression.location
            )
            \ store struct members
            self.convert_store_value(
                value
                self.convert_struct_literal_expression(checked_expression, struct_type)
                checked_expression.location
            )
            return value
        }
        abort(checked_expression.location, expression_type.object_type)
    }
    if expression_type is IR_Struct_Type {
        return self.convert_struct_literal_expression(checked_expression, expression_type.as(@IR_Struct_Type))
    }
    abort(checked_expression.location, expression_type.object_type)
}

func convert_member_access_expression(self: @IR_Builder, checked_expression: @Checked_Member_Access_Expression, expected_type: @IR_Type) -> @IR_Value {
    let value_pointer = self.convert_member_access_expression_pointer(checked_expression, null)
    return self.append(
        make @IR_Load_Instruction(
            result_value = self.create_temp_value(value_pointer.type.as(@IR_Pointer_Type).pointed_type)
        ).init(value_pointer)
        checked_expression.location
    )
}

func convert_member_access_expression_pointer(self: @IR_Builder, checked_expression: @Checked_Member_Access_Expression, expected_type: @IR_Type) -> @IR_Value {
    let value_pointer = self.convert_expression_pointer(checked_expression.object_expression, null)
    let value_type = value_pointer.type.as(@IR_Pointer_Type).pointed_type
    if value_type is IR_Pointer_Type {
        let pointer_type = value_type.as(@IR_Pointer_Type)
        value_pointer = self.append(
            make @IR_Load_Instruction(
                result_value = self.create_temp_value(pointer_type)
            ).init(value_pointer)
            checked_expression.object_expression.location
        )
        value_type = pointer_type.pointed_type
    }
    if value_type is not IR_Struct_Type {
        abort(checked_expression.object_expression.location, "Unexpected value type")
    }
    let struct_type = value_type.as(@IR_Struct_Type)
    let struct_type_member = struct_type.get_member(checked_expression.struct_member)
    if struct_type_member == null {
        abort(checked_expression.location, "Unknown struct member: ".clone().append(checked_expression.struct_member.name))
    }
    return self.append(
        self.create_ir_struct_member_offset_instruction(value_pointer, struct_type_member)
        checked_expression.location
    )
}

func convert_modulo_expression(self: @IR_Builder, checked_expression: @Checked_Modulo_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, expected_type)
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Modulo_Instruction(
            result_value = self.create_temp_value(left_value.type)
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_multiply_expression(self: @IR_Builder, checked_expression: @Checked_Multiply_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, expected_type)
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Multiply_Instruction(
            result_value = self.create_temp_value(left_value.type)
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_negate_expression(self: @IR_Builder, checked_expression: @Checked_Negate_Expression, expected_type: @IR_Type) -> @IR_Value {
    let value = self.convert_expression(checked_expression.expression, expected_type)
    if value.type is not IR_Int_Type {
        abort(checked_expression.expression.location, "Not a signed integer type: ".clone().append(value.type.name))
    }
    return self.append(
        make @IR_Negate_Instruction(
            result_value = self.create_temp_value(value.type)
        ).init(value)
        checked_expression.location
    )
}

func convert_not_equals_expression(self: @IR_Builder, checked_expression: @Checked_Not_Equals_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, null)
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Inequality_Instruction(
            result_value = self.create_temp_value(self.find_named_type("bool"))
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_reference_expression(self: @IR_Builder, checked_expression: @Checked_Reference_Expression, expected_type: @IR_Type) -> @IR_Value {
    let object_expression = checked_expression.object_expression
    if object_expression is Checked_Symbol_Expression {
        return self.convert_expression_pointer(object_expression, expected_type)
    }
    if object_expression is Checked_Member_Access_Expression {
        return self.convert_expression_pointer(object_expression, expected_type)
    }
    abort(object_expression.location, object_expression.object_type)
}

func convert_struct_literal_expression(self: @IR_Builder, checked_expression: @Checked_Make_Expression, struct_type: @IR_Struct_Type) -> @IR_Value {
    let ir_struct_type_member_values = make @Map[@IR_Struct_Type_Member, @IR_Value]()
    checked_expression.values.for_each() {
        let checked_struct_type_member = key
        let checked_struct_type_member_value = value

        let ir_struct_type_member = struct_type.get_member(checked_struct_type_member)
        let it_struct_type_member_value = self.convert_expression(checked_struct_type_member_value, ir_struct_type_member.type)

        ir_struct_type_member_values.put(ir_struct_type_member, it_struct_type_member_value)
    }
    return self.append(
        create_ir_struct_literal_instruction(
            self.create_temp_value(struct_type)
            struct_type
            ir_struct_type_member_values
        )
        checked_expression.location
    )
}

func convert_substract_expression(self: @IR_Builder, checked_expression: @Checked_Substract_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, expected_type)
    if left_value.type is not IR_Integer_Type {
        abort(checked_expression.location, "Not an integer type: ".clone().append(left_value.type.name))
    }
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Substract_Instruction(
            result_value = self.create_temp_value(left_value.type)
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_super_access_expression(self: @IR_Builder, checked_expression: @Checked_Super_Access_Expression, expected_type: @IR_Type) -> @IR_Value {
    abort("TODO: Convert super access expression")
}

func convert_symbol_expression(self: @IR_Builder, checked_expression: @Checked_Symbol_Expression, expected_type: @IR_Type) -> @IR_Value {
    let ir_symbol = self.current_block_context.find_symbol(checked_expression.symbol)
    if ir_symbol == null {
        abort(checked_expression.location, clone("Unknown symbol: ").append(checked_expression.symbol.name))
    }
    if ir_symbol is IR_Global_Variable {
        let ir_symbol = ir_symbol.as(@IR_Global_Variable)
        return self.append(
            make @IR_Load_Instruction(
                result_value = self.create_temp_value(ir_symbol.type)
            ).init(ir_symbol.value_pointer)
            checked_expression.location
        )
    }
    if ir_symbol is IR_Function_Parameter {
        return ir_symbol.as(@IR_Function_Parameter).value
    }
    if ir_symbol is IR_Local_Variable {
        let ir_symbol = ir_symbol.as(@IR_Local_Variable)
        return self.append(
            make @IR_Load_Instruction(
                result_value = self.create_variable_value(ir_symbol)
            ).init(ir_symbol.value_pointer)
            checked_expression.location
        )
    }
    \ if ir_symbol is IR_Constant {
    \     \ return ir_symbol.as(@IR_Constant).value
    \ }
    if ir_symbol is IR_Function {
        let ir_function = ir_symbol.as(@IR_Function)
        return self.append(
            make @IR_Function_Address_Instruction(
                result_value = self.create_temp_value(ir_function.type)
                function = ir_function
            )
            checked_expression.location
        )
    }
    abort(checked_expression.location, clone("Unsupported symbol type: ").append(ir_symbol.object_type.name))
}

func convert_symbol_expression_pointer(self: @IR_Builder, checked_expression: @Checked_Symbol_Expression, expected_type: @IR_Type) -> @IR_Value {
    let ir_symbol = self.current_block_context.find_symbol(checked_expression.symbol)
    if ir_symbol is IR_Local_Variable {
        let ir_symbol = ir_symbol.as(@IR_Local_Variable)
        return ir_symbol.value_pointer
    }
    abort(checked_expression.location, ir_symbol.object_type)
}
