func build(checked_code: @Checked_Code) -> @IR_Code {
    let builder = create_ir_builder(checked_code)
    builder.build()
    return make @IR_Code(
        global_symbols = builder.global_context.symbols
    )
}

struct IR_Builder {
    checked_code: @Checked_Code

    types: @List[@IR_Type]
    global_context = make IR_Context()

    current_function_context: @IR_Function_Context = null
    current_block_context: @IR_Block_Context = null
}

struct IR_Context {
    parent: @IR_Context = null
    symbols = make List[@IR_Symbol]()
}

func find_symbol(self: @IR_Context, checked_symbol: @Checked_Symbol) -> @IR_Symbol {
    let context = self
    loop {
        context.symbols.for_each() {
            if it.checked_symbol == checked_symbol {
                return it
            }
        }
        context = context.parent
        if context == null {
            return null
        }
    }
}

struct IR_Function_Context: IR_Context {
    function: @IR_Function
    value_counter = make Counter[i32]()
}

struct IR_Block_Context: IR_Context {
    block: @IR_Block
}

struct IR_Loop {
    parent: @IR_Loop
    end_block: @IR_Block
}

func create_ir_builder(checked_code: @Checked_Code) -> @IR_Builder {
    let types = make @List[@IR_Type]()
    types.append(make @IR_Boolean_Type())
    types.append(make @IR_Int8_Type())
    types.append(make @IR_Int16_Type())
    types.append(make @IR_Int32_Type())
    types.append(make @IR_Int64_Type())
    types.append(make @IR_Nothing_Type())
    types.append(make @IR_Null_Type())
    types.append(make @IR_UInt8_Type())
    types.append(make @IR_UInt16_Type())
    types.append(make @IR_UInt32_Type())
    types.append(make @IR_UInt64_Type())
    types.append(make @IR_Undefined_Type())

    return make @IR_Builder(
        checked_code = checked_code
        types = types
    )
}

func append(self: @IR_Builder, instruction: @IR_Instruction, location: @Source_Location) -> @IR_Value {
    instruction.location = location
    self.current_block_context.block.append(instruction)
    return instruction.result_value
}

func append_branch(self: @IR_Builder, condition: @IR_Value, true_block: @IR_Block, false_block: @IR_Block, location: @Source_Location) -> Nothing {
    self.current_block_context.block.append(
        make @IR_Branch_Instruction(location = location, true_block = true_block, false_block = false_block).init(condition)
    )
    true_block.predecessors.append(self.current_block_context.block)
    false_block.predecessors.append(self.current_block_context.block)
}

func append_jump(self: @IR_Builder, block: @IR_Block, location: @Source_Location) -> Nothing {
    self.current_block_context.block.append(
        make @IR_Jump_Instruction(location = location, block = block)
    )
    block.predecessors.append(self.current_block_context.block)
}

func create_named_value(self: @IR_Builder, name: @String, type: @IR_Type) -> @IR_Value {
    return make @IR_Value(
        type = type
        name = clone("%").append(name)
    )
}

func create_temp_value(self: @IR_Builder, type: @IR_Type) -> @IR_Value {
    return make @IR_Value(
        type = type
        name = clone("%").append(self.current_function_context.value_counter.next())
    )
}

func create_variable_value(self: @IR_Builder, variable: @IR_Local_Variable) -> @IR_Value {
    return make @IR_Value(
        type = variable.type
        name = clone("%").append(variable.name).append('.').append(variable.value_counter.next())
    )
}

func find_named_type(self: @IR_Builder, name: @String) -> @IR_Type {
    self.types.for_each() {
        if name.equals(it.name) {
            return it
        }
    }
    return null
}

func build(self: @IR_Builder) -> Nothing {
    self.checked_code.global_symbols.for_each() {
        if value is Checked_Function_Symbol {
            self.create_function(value.as(@Checked_Function_Symbol))
        } else if value is Checked_Type_Symbol {
            \ ignored
        } else {
            abort(value.location, value.object_type)
        }
    }

    self.global_context.symbols.for_each() {
        if it is IR_Function {
            self.convert_function(it.as(@IR_Function))
        }
    }
}

func create_function(self: @IR_Builder, checked_function_symbol: @Checked_Function_Symbol) -> Nothing {
    let ir_function_type = self.convert_function_type(checked_function_symbol.function_type)

    \ create IR function parameters
    let ir_function_parameters = make @List[@IR_Function_Parameter]()
    let ir_function_type_parameters_iterator = ir_function_type.parameters.create_iterator()
    let checked_function_symbol_parameters_iterator = checked_function_symbol.parameters.create_iterator()
    while ir_function_type_parameters_iterator.has_next() and checked_function_symbol_parameters_iterator.has_next() {
        let ir_function_type_parameter = ir_function_type_parameters_iterator.next()
        let checked_function_symbol_parameter = checked_function_symbol_parameters_iterator.next()
        ir_function_parameters.append(make @IR_Function_Parameter(
            checked_symbol = checked_function_symbol_parameter
            name = ir_function_type_parameter.name
            type = ir_function_type_parameter.type
            value = make @IR_Value(
                name = clone("%").append(ir_function_type_parameter.name)
                type = ir_function_type_parameter.type
            )
        ))
    }

    \ Prepare IR function blocks
    let ir_function_blocks: @List[@IR_Block]
    if checked_function_symbol.body != null {
        ir_function_blocks = make @List[@IR_Block]()
    } else {
        ir_function_blocks = null
    }

    let ir_function = make @IR_Function(
        checked_symbol = checked_function_symbol
        name = clone("$").append(checked_function_symbol.name) \ TODO: Generate unique name using hex hash of parameter types
        type = self.create_ir_pointer_type(ir_function_type)
        function_type = ir_function_type
        parameters = ir_function_parameters
        return_type = ir_function_type.return_type
        blocks = ir_function_blocks
    )
    self.global_context.symbols.append(ir_function)
}

func convert_function(self: @IR_Builder, ir_function: @IR_Function) -> Nothing {
    if ir_function.checked_symbol is not Checked_Function_Symbol {
        abort("Invalid state")
    }
    let checked_function_symbol = ir_function.checked_symbol.as(@Checked_Function_Symbol)
    if checked_function_symbol.body != null {
        self.current_function_context = make @IR_Function_Context(function = ir_function)

        ir_function.parameters.for_each() {
            self.current_function_context.symbols.append(it)
        }

        self.current_block_context = make @IR_Block_Context(
            parent = self.current_function_context
            block = ir_function.create_block()
        )
        self.convert_block_statement(checked_function_symbol.body)

        \ cleanup last block
        let last_block = self.current_block_context.block
        if last_block.last_instruction == null {
            if last_block.predecessors.size == 0 and last_block != ir_function.blocks.first() {
                \ unreachable empty block
                ir_function.blocks.remove(last_block).prune()
            } else if ir_function.return_type is IR_Nothing_Type {
                self.append(create_ir_return_instruction(null), null)
            } else {
                abort(checked_function_symbol.location, "Missing return statement")
            }
        }

        self.current_block_context = null

        \ self.remove_redundant_blocks(ir_function)
        \ self.populate_phi_instructions(ir_function)
        \ self.remove_trivial_phi_instructions(ir_function)
        \ self.remove_redundant_set_instructions(ir_function)
    }
}

func convert_type(self: @IR_Builder, checked_type: @Checked_Type) -> @IR_Type {
    let ir_type: @IR_Type
    if checked_type is Checked_Function_Type {
        return self.convert_function_type(checked_type.as(@Checked_Function_Type))
    } else if checked_type is Checked_Named_Type {
        let ir_type_name = checked_type.name
        ir_type = self.find_named_type(ir_type_name)
        if ir_type != null {
            return ir_type
        }
        if checked_type is Checked_Opaque_Type {
            ir_type = make @IR_Opaque_Type(
                name = ir_type_name
            )
        } else if checked_type is Checked_Struct_Type {
            return self.convert_struct_type(checked_type.as(@Checked_Struct_Type))
        } else {
            abort(checked_type.object_type)
        }
    } else if checked_type is Checked_Pointer_Type {
        let ir_pointed_type = self.convert_type(checked_type.as(@Checked_Pointer_Type).pointed_type)
        return self.create_ir_pointer_type(ir_pointed_type)
    } else if checked_type is Checked_Unchecked_Array_Type {
        let ir_item_type = self.convert_type(checked_type.as(@Checked_Unchecked_Array_Type).item_type)
        return self.create_ir_unchecked_array_type(ir_item_type)
    } else {
        abort(checked_type.object_type)
    }
    self.types.append(ir_type)
    return ir_type
}

func create_ir_pointer_type(self: @IR_Builder, ir_pointed_type: @IR_Type) -> @IR_Pointer_Type {
    self.types.for_each() {
        if it is IR_Pointer_Type and it.as(@IR_Pointer_Type).pointed_type == ir_pointed_type {
            return it.as(@IR_Pointer_Type)
        }
    }
    let ir_type_name = clone("ptr<").append(ir_pointed_type.name).append('>')
    let ir_type = make @IR_Pointer_Type(
        name = ir_type_name
        pointed_type = ir_pointed_type
    )
    self.types.append(ir_type)
    return ir_type
}

func create_ir_unchecked_array_type(self: @IR_Builder, ir_item_type: @IR_Type) -> @IR_Unchecked_Array_Type {
    self.types.for_each() {
        if it is IR_Unchecked_Array_Type and it.as(@IR_Unchecked_Array_Type).item_type == ir_item_type {
            return it.as(@IR_Unchecked_Array_Type)
        }
    }
    let ir_type = make @IR_Unchecked_Array_Type(
        name = clone("[").append(ir_item_type.name).append(", ?").append(']')
        item_type = ir_item_type
    )
    self.types.append(ir_type)
    return ir_type
}

func convert_function_type(self: @IR_Builder, checked_function_type: @Checked_Function_Type) -> @IR_Function_Type {
    \ TODO: Check if function type already exists
    let ir_function_type_name = make @String().append("func (")
    let ir_function_type_parameters = make @List[@IR_Function_Type_Parameter]()
    checked_function_type.parameters.for_each_indexed() {
        let checked_callable_parameter = it
        if it_index > 0 {
            ir_function_type_name.append(", ")
        }
        let ir_callable_parameter_name = checked_callable_parameter.name
        let ir_callable_parameter_type = self.convert_type(checked_callable_parameter.type)
        ir_function_type_name.append(ir_callable_parameter_name).append(": ").append(ir_callable_parameter_type.name)
        ir_function_type_parameters.append(make @IR_Function_Type_Parameter(
            name = ir_callable_parameter_name
            type = ir_callable_parameter_type
        ))
    }
    ir_function_type_name.append(')')
    let ir_function_type_return_type = self.convert_type(checked_function_type.return_type)
    if ir_function_type_return_type is not IR_Nothing_Type {
        ir_function_type_name.append(" -> ").append(ir_function_type_return_type.name)
    }
    return make @IR_Function_Type(name = ir_function_type_name, parameters = ir_function_type_parameters, return_type = ir_function_type_return_type)
}

func convert_struct_type(self: @IR_Builder, checked_struct_type: @Checked_Struct_Type) -> @IR_Struct_Type {
    let ir_struct_type = make @IR_Struct_Type(
        name = checked_struct_type.name
        checked_struct_type = checked_struct_type
    )
    self.types.append(ir_struct_type)

    if checked_struct_type.super_type != null {
        let super_type = self.convert_type(checked_struct_type.super_type)
        if super_type is not IR_Struct_Type {
            abort("Invalid state")
        }
        let super_type = super_type.as(@IR_Struct_Type)
        ir_struct_type.super_type = super_type
        ir_struct_type.super_type.derived_types.append(ir_struct_type)
    }

    checked_struct_type.members.for_each() {
        ir_struct_type.add_member(
            it.name
            self.convert_type(it.type)
            it
            null \ TODO: checked_struct_type.default_values.get(it)
        )
    }

    if ir_struct_type.is_object_type() {
        \ let object_type_type = self.convert_type(make @Parsed_Pointer_Type(pointed_type = make @Parsed_Named_Type(name = make @Identifier_Token(location = null, lexeme = "Object_Type"))))
        \ if object_type_type is not IR_Pointer_Type {
        \     abort(struct_statement.location, "Invalid state")
        \ }
        \ let object_type_struct_type = object_type_type.as(@IR_Pointer_Type).pointed_type
        \ if object_type_struct_type is not IR_Struct_Type {
        \     abort(struct_statement.location, "Invalid state")
        \ }

        \ \ TODO: Build Object_Type value
        \ let object_type_value = make @IR_Undefined_Value(type = object_type_type)

        \ let object_type_variable = make @IR_Global_Variable(
        \     location = type.statement.location
        \     name = clone(struct_statement.name.lexeme).append("__").append(self.types_counter.next())
        \     type = object_type_type
        \     value = object_type_value
        \     is_external = false
        \ )
        \ type.object_type_variable = object_type_variable

        \ self.add_symbol(object_type_variable) \ TODO: add symbol to root context

        abort("TODO: Prepare object type")
    }

    return ir_struct_type
}

func convert_statement(self: @IR_Builder, checked_statement: @Checked_Statement) -> Nothing {
    if checked_statement is Checked_Assignment_Statement {
        self.convert_assignment_statement(checked_statement.as(@Checked_Assignment_Statement))
    } else if checked_statement is Checked_Block_Statement {
        self.convert_block_statement(checked_statement.as(@Checked_Block_Statement))
    } else if checked_statement is Checked_Break_Statement {
        self.convert_break_statement(checked_statement.as(@Checked_Break_Statement))
    } else if checked_statement is Checked_Expression_Statement {
        self.convert_expression_statement(checked_statement.as(@Checked_Expression_Statement))
    } else if checked_statement is Checked_If_Statement {
        self.convert_if_statement(checked_statement.as(@Checked_If_Statement))
    } else if checked_statement is Checked_Loop_Statement {
        self.convert_loop_statement(checked_statement.as(@Checked_Loop_Statement))
    } else if checked_statement is Checked_Return_Statement {
        self.convert_return_statement(checked_statement.as(@Checked_Return_Statement))
    } else if checked_statement is Checked_Variable_Statement {
        self.convert_variable_statement(checked_statement.as(@Checked_Variable_Statement))
    } else if checked_statement is Checked_While_Statement {
        self.convert_while_statement(checked_statement.as(@Checked_While_Statement))
    } else {
        abort(checked_statement.location, checked_statement.object_type)
    }
}

func convert_assignment_statement(self: @IR_Builder, checked_statement: @Checked_Assignment_Statement) -> Nothing {
    let checked_destination_expression = checked_statement.destination_expression
    if checked_destination_expression is Checked_Symbol_Expression {
        let ir_symbol = self.current_block_context.find_symbol(checked_destination_expression.as(@Checked_Symbol_Expression).symbol)
        if ir_symbol is IR_Local_Variable {
            let ir_symbol = ir_symbol.as(@IR_Local_Variable)
            let value = self.convert_expression(checked_statement.value_expression, ir_symbol.type)
            self.append(
                make @IR_Store_Instruction().init(ir_symbol.value_pointer, value)
                checked_statement.location
            )
        } else {
            abort(checked_destination_expression.location, ir_symbol.object_type)
        }
    } else {
        abort(checked_destination_expression.location, checked_destination_expression.object_type)
    }
}

func convert_block_statement(self: @IR_Builder, checked_block_statement: @Checked_Block_Statement) -> Nothing {
    checked_block_statement.statements.for_each() {
        self.convert_statement(it)
    }
}

func convert_break_statement(self: @IR_Builder, checked_statement: @Checked_Break_Statement) -> Nothing {
    abort("TODO: Convert break statement")
}

func convert_expression_statement(self: @IR_Builder, checked_statement: @Checked_Expression_Statement) -> Nothing {
    self.convert_expression(checked_statement.expression, null)
}

func convert_if_statement(self: @IR_Builder, checked_statement: @Checked_If_Statement) -> Nothing {
    \ create blocks
    let true_block = self.current_function_context.function.create_block()
    let end_block = self.current_function_context.function.create_block()
    let false_block = end_block
    if checked_statement.false_statement != null {
        end_block = self.current_function_context.function.create_block()
    }

    let condition_value = self.convert_expression(checked_statement.condition_expression, self.find_named_type("bool"))
    self.append_branch(condition_value, true_block, false_block, checked_statement.location)

    \ true block
    self.current_block_context = make @IR_Block_Context(
        parent = self.current_block_context
        block = true_block
    )
    self.convert_statement(checked_statement.true_statement)
    if not true_block.last_instruction.is_exit_instruction() {
        self.append_jump(end_block, checked_statement.location)
    }

    \ false block
    if end_block != false_block {
        self.current_block_context = make @IR_Block_Context(
            parent = self.current_block_context.parent
            block = false_block
        )
        self.convert_statement(checked_statement.false_statement)
        if not false_block.last_instruction.is_exit_instruction() {
            self.append_jump(end_block, checked_statement.location)
        }
    }

    \ end block
    self.current_block_context = make @IR_Block_Context(
        parent = self.current_block_context.parent
        block = end_block
    )
}

func convert_loop_statement(self: @IR_Builder, checked_statement: @Checked_Loop_Statement) -> Nothing {
    abort("TODO: Convert loop statement")
}

func convert_return_statement(self: @IR_Builder, checked_statement: @Checked_Return_Statement) -> Nothing {
    if checked_statement.expression != null {
        let return_value = self.convert_expression(checked_statement.expression, self.current_function_context.function.return_type)
        self.append(create_ir_return_instruction(return_value), checked_statement.location)
    } else {
        self.append(create_ir_return_instruction(null), checked_statement.location)
    }
    \ self.current_block = self.current_block.function.create_block()
}

func convert_variable_statement(self: @IR_Builder, checked_statement: @Checked_Variable_Statement) -> Nothing {
    let variable_type = self.convert_type(checked_statement.variable.type)
    let variable = make @IR_Local_Variable(
        checked_symbol = checked_statement.variable
        name = checked_statement.variable.name
        type = variable_type
        value_pointer = undefined
    )
    self.current_block_context.symbols.append(variable)
    let value_pointer = self.append(
        make @IR_Alloc_Instruction(
            result_value = self.create_named_value(
                clone(checked_statement.variable.name).append(".ptr")
                self.create_ir_pointer_type(variable_type)
            )
            type = variable_type
        )
        checked_statement.location
    )
    variable.value_pointer = value_pointer
    if checked_statement.variable.expression != null {
        let variable_value = self.convert_expression(checked_statement.variable.expression, variable_type)
        self.append(
            make @IR_Store_Instruction().init(value_pointer, variable_value)
            checked_statement.location
        )
    }
}

func convert_while_statement(self: @IR_Builder, checked_statement: @Checked_While_Statement) -> Nothing {
    abort("TODO: Convert while statement")
}

func convert_expression(self: @IR_Builder, checked_expression: @Checked_Expression, expected_type: @IR_Type) -> @IR_Value {
    let value: @IR_Value
    if checked_expression is Checked_Add_Expression {
        value = self.convert_add_expression(checked_expression.as(@Checked_Add_Expression), expected_type)
    } else if checked_expression is Checked_Cast_Expression {
        value = self.convert_cast_expression(checked_expression.as(@Checked_Cast_Expression), expected_type)
    } else if checked_expression is Checked_Divide_Expression {
        value = self.convert_divide_expression(checked_expression.as(@Checked_Divide_Expression), expected_type)
    } else if checked_expression is Checked_Dynamic_Call_Expression {
        value = self.convert_dynamic_call_expression(checked_expression.as(@Checked_Dynamic_Call_Expression), expected_type)
    } else if checked_expression is Checked_Equals_Expression {
        value = self.convert_equals_expression(checked_expression.as(@Checked_Equals_Expression), expected_type)
    } else if checked_expression is Checked_Function_Call_Expression {
        value = self.convert_function_call_expression(checked_expression.as(@Checked_Function_Call_Expression), expected_type)
    } else if checked_expression is Checked_Greater_Than_Expression {
        value = self.convert_greater_than_expression(checked_expression.as(@Checked_Greater_Than_Expression), expected_type)
    } else if checked_expression is Checked_Greater_Than_Or_Equals_Expression {
        value = self.convert_greater_than_or_equals_expression(checked_expression.as(@Checked_Greater_Than_Or_Equals_Expression), expected_type)
    } else if checked_expression is Checked_Less_Than_Expression {
        value = self.convert_less_than_expression(checked_expression.as(@Checked_Less_Than_Expression), expected_type)
    } else if checked_expression is Checked_Less_Than_Or_Equals_Expression {
        value = self.convert_less_than_or_equals_expression(checked_expression.as(@Checked_Less_Than_Or_Equals_Expression), expected_type)
    } else if checked_expression is Checked_Literal_Expression {
        value = self.convert_literal_expression(checked_expression.as(@Checked_Literal_Expression), expected_type)
    } else if checked_expression is Checked_Logic_And_Expression {
        value = self.convert_logic_and_expression(checked_expression.as(@Checked_Logic_And_Expression), expected_type)
    } else if checked_expression is Checked_Logic_Not_Expression {
        value = self.convert_logic_not_expression(checked_expression.as(@Checked_Logic_Not_Expression), expected_type)
    } else if checked_expression is Checked_Logic_Or_Expression {
        value = self.convert_logic_or_expression(checked_expression.as(@Checked_Logic_Or_Expression), expected_type)
    } else if checked_expression is Checked_Make_Expression {
        value = self.convert_make_expression(checked_expression.as(@Checked_Make_Expression), expected_type)
    } else if checked_expression is Checked_Member_Access_Expression {
        value = self.convert_member_access_expression(checked_expression.as(@Checked_Member_Access_Expression), expected_type)
    } else if checked_expression is Checked_Modulo_Expression {
        value = self.convert_modulo_expression(checked_expression.as(@Checked_Modulo_Expression), expected_type)
    } else if checked_expression is Checked_Multiply_Expression {
        value = self.convert_multiply_expression(checked_expression.as(@Checked_Multiply_Expression), expected_type)
    } else if checked_expression is Checked_Negate_Expression {
        value = self.convert_negate_expression(checked_expression.as(@Checked_Negate_Expression), expected_type)
    } else if checked_expression is Checked_Not_Equals_Expression {
        value = self.convert_not_equals_expression(checked_expression.as(@Checked_Not_Equals_Expression), expected_type)
    } else if checked_expression is Checked_Reference_Expression {
        value = self.convert_reference_expression(checked_expression.as(@Checked_Reference_Expression), expected_type)
    } else if checked_expression is Checked_Substract_Expression {
        value = self.convert_substract_expression(checked_expression.as(@Checked_Substract_Expression), expected_type)
    } else if checked_expression is Checked_Super_Access_Expression {
        value = self.convert_super_access_expression(checked_expression.as(@Checked_Super_Access_Expression), expected_type)
    } else if checked_expression is Checked_Symbol_Expression {
        value = self.convert_symbol_expression(checked_expression.as(@Checked_Symbol_Expression), expected_type)
    } else {
        abort(checked_expression.location, checked_expression.object_type)
    }
    \ if expected_type != null and not expected_type.accepts(value.type) {
    \     abort(checked_expression.location, clone("Incompatible types: got ").append(value.type.name).append(" instead of ").append(expected_type.name))
    \ }
    return value
}

func convert_add_expression(self: @IR_Builder, checked_expression: @Checked_Add_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, expected_type)
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Add_Instruction(
            result_value = self.create_temp_value(left_value.type)
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_cast_expression(self: @IR_Builder, checked_expression: @Checked_Cast_Expression, expected_type: @IR_Type) -> @IR_Value {
    abort("TODO: Convert cast expression")
}

func convert_call_arguments(self: @IR_Builder, checked_call_arguments: @List[@Checked_Call_Argument]) -> @List[@IR_Call_Argument] {
    let has_named_arguments = false
    let ir_call_arguments = make @List[@IR_Call_Argument]()
    checked_call_arguments.for_each() {
        let call_argument = it
        let call_argument_value = self.convert_expression(call_argument.expression, null)
        if call_argument.name != null {
            ir_call_arguments.append(make @IR_Call_Argument(name = call_argument.name, value = call_argument_value))
            has_named_arguments = true
        } else {
            if has_named_arguments {
                abort(call_argument.expression.location, "Positional arguments cannot be added after named ones")
            }
            ir_call_arguments.append(make @IR_Call_Argument(value = call_argument_value))
        }
    }
    return ir_call_arguments
}

func convert_divide_expression(self: @IR_Builder, checked_expression: @Checked_Divide_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, expected_type)
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Divide_Instruction(
            result_value = self.create_temp_value(left_value.type)
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_dynamic_call_expression(self: @IR_Builder, checked_expression: @Checked_Dynamic_Call_Expression, expected_type: @IR_Type) -> @IR_Value {
    abort("TODO: Convert dynamic call expression")
}

func convert_equals_expression(self: @IR_Builder, checked_expression: @Checked_Equals_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, null)
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Equality_Instruction(
            result_value = self.create_temp_value(self.find_named_type("bool"))
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_function_call_expression(self: @IR_Builder, checked_expression: @Checked_Function_Call_Expression, expected_type: @IR_Type) -> @IR_Value {
    let ir_function = self.global_context.find_symbol(checked_expression.function_symbol)
    if ir_function == null or ir_function is not IR_Function {
        abort(checked_expression.location, "Missing IR_Function for Checked_Function_Symbol: ".clone().append(checked_expression.function_symbol.name))
    }
    let ir_function = ir_function.as(@IR_Function)

    let ir_call_arguments = self.convert_call_arguments(checked_expression.call_arguments)

    let result_value: @IR_Value = null
    if ir_function.return_type is not IR_Nothing_Type {
        result_value = self.create_temp_value(ir_function.return_type)
    }
    return self.append(create_ir_direct_call_instruction(result_value, ir_call_arguments, ir_function), checked_expression.location)
}

func convert_greater_than_expression(self: @IR_Builder, checked_expression: @Checked_Greater_Than_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, null)
    if left_value.type is not IR_Integer_Type {
        abort(checked_expression.left_expression.location, "Not an integer type: ".clone().append(left_value.type.name))
    }
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Greater_Than_Instruction(
            result_value = self.create_temp_value(self.find_named_type("bool"))
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_greater_than_or_equals_expression(self: @IR_Builder, checked_expression: @Checked_Greater_Than_Or_Equals_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, null)
    if left_value.type is not IR_Integer_Type {
        abort(checked_expression.left_expression.location, "Not an integer type: ".clone().append(left_value.type.name))
    }
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Greater_Than_Or_Equal_Instruction(
            result_value = self.create_temp_value(self.find_named_type("bool"))
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_less_than_expression(self: @IR_Builder, checked_expression: @Checked_Less_Than_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, null)
    if left_value.type is not IR_Integer_Type {
        abort(checked_expression.left_expression.location, "Not an integer type: ".clone().append(left_value.type.name))
    }
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Less_Than_Instruction(
            result_value = self.create_temp_value(self.find_named_type("bool"))
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_less_than_or_equals_expression(self: @IR_Builder, checked_expression: @Checked_Less_Than_Or_Equals_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, null)
    if left_value.type is not IR_Integer_Type {
        abort(checked_expression.left_expression.location, "Not an integer type: ".clone().append(left_value.type.name))
    }
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Less_Than_Or_Equal_Instruction(
            result_value = self.create_temp_value(self.find_named_type("bool"))
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_literal_expression(self: @IR_Builder, checked_expression: @Checked_Literal_Expression, expected_type: @IR_Type) -> @IR_Value {
    if checked_expression is Checked_Boolean_Literal_Expression {
        return self.append(
            create_ir_constant_instruction(
                self.create_temp_value(self.find_named_type("bool"))
                checked_expression.as(@Checked_Boolean_Literal_Expression).literal
            )
            checked_expression.location
        )
    }
    if checked_expression is Checked_Character_Literal_Expression {
        return self.append(
            create_ir_constant_instruction(
                self.create_temp_value(self.find_named_type("u8"))
                checked_expression.as(@Checked_Character_Literal_Expression).literal
            )
            checked_expression.location
        )
    }
    if checked_expression is Checked_Integer_Literal_Expression {
        let integer_literal = checked_expression.as(@Checked_Integer_Literal_Expression).literal
        if integer_literal.type != null {
            expected_type = self.find_named_type(integer_literal.type)
        } else if expected_type == null or expected_type is not IR_Integer_Type {
            expected_type = self.find_named_type("i32")
        }
        return self.append(
            create_ir_constant_instruction(
                self.create_temp_value(expected_type)
                checked_expression.as(@Checked_Integer_Literal_Expression).literal
            )
            checked_expression.location
        )
    }
    if checked_expression is Checked_Null_Literal_Expression {
        return self.append(
            create_ir_constant_instruction(
                self.create_temp_value(self.find_named_type("Null"))
                checked_expression.as(@Checked_Null_Literal_Expression).literal
            )
            checked_expression.location
        )
    }
    abort(checked_expression.location, checked_expression.object_type)
}

func convert_logic_and_expression(self: @IR_Builder, checked_expression: @Checked_Logic_And_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, self.find_named_type("bool"))
    let left_block = self.current_block_context.block
    let next_block = self.current_function_context.function.create_block()
    let end_block = self.current_function_context.function.create_block()
    self.append_branch(left_value, next_block, end_block, checked_expression.location)
    self.current_block_context = make @IR_Block_Context(
        parent = self.current_block_context
        block = next_block
    )
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    let right_block = self.current_block_context.block
    self.append_jump(end_block, checked_expression.location)
    self.current_block_context = make @IR_Block_Context(
        parent = self.current_block_context
        block = end_block
    )
    return self.append(
        make @IR_Phi_Instruction(
            result_value = self.create_temp_value(left_value.type)
        ).append(left_value, left_block).append(right_value, right_block)
        checked_expression.location
    )
}

func convert_logic_not_expression(self: @IR_Builder, checked_expression: @Checked_Logic_Not_Expression, expected_type: @IR_Type) -> @IR_Value {
    let value = self.convert_expression(checked_expression.expression, self.find_named_type("bool"))
    return self.append(
        make @IR_Not_Instruction(
            result_value = self.create_temp_value(value.type)
        ).init(value)
        checked_expression.location
    )
}

func convert_logic_or_expression(self: @IR_Builder, checked_expression: @Checked_Logic_Or_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, self.find_named_type("bool"))
    let left_block = self.current_block_context.block
    let next_block = self.current_function_context.function.create_block()
    let end_block = self.current_function_context.function.create_block()
    self.append_branch(left_value, end_block, next_block, checked_expression.location)
    self.current_block_context = make @IR_Block_Context(
        parent = self.current_block_context
        block = next_block
    )
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    let right_block = self.current_block_context.block
    self.append_jump(end_block, checked_expression.location)
    self.current_block_context = make @IR_Block_Context(
        parent = self.current_block_context
        block = end_block
    )
    return self.append(
        make @IR_Phi_Instruction(
            result_value = self.create_temp_value(left_value.type)
        ).append(left_value, left_block).append(right_value, right_block)
        checked_expression.location
    )
}

func convert_make_expression(self: @IR_Builder, checked_expression: @Checked_Make_Expression, expected_type: @IR_Type) -> @IR_Value {
    abort("TODO: Convert make expression")
}

func convert_member_access_expression(self: @IR_Builder, checked_expression: @Checked_Member_Access_Expression, expected_type: @IR_Type) -> @IR_Value {
    abort("TODO: Convert member access expression")
}

func convert_modulo_expression(self: @IR_Builder, checked_expression: @Checked_Modulo_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, expected_type)
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Modulo_Instruction(
            result_value = self.create_temp_value(left_value.type)
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_multiply_expression(self: @IR_Builder, checked_expression: @Checked_Multiply_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, expected_type)
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Multiply_Instruction(
            result_value = self.create_temp_value(left_value.type)
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_negate_expression(self: @IR_Builder, checked_expression: @Checked_Negate_Expression, expected_type: @IR_Type) -> @IR_Value {
    abort("TODO: Convert negate expression")
}

func convert_not_equals_expression(self: @IR_Builder, checked_expression: @Checked_Not_Equals_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, null)
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Inequality_Instruction(
            result_value = self.create_temp_value(self.find_named_type("bool"))
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_reference_expression(self: @IR_Builder, checked_expression: @Checked_Reference_Expression, expected_type: @IR_Type) -> @IR_Value {
    abort("TODO: Convert reference expression")
}

func convert_substract_expression(self: @IR_Builder, checked_expression: @Checked_Substract_Expression, expected_type: @IR_Type) -> @IR_Value {
    let left_value = self.convert_expression(checked_expression.left_expression, expected_type)
    let right_value = self.convert_expression(checked_expression.right_expression, left_value.type)
    return self.append(
        make @IR_Substract_Instruction(
            result_value = self.create_temp_value(left_value.type)
        ).init(left_value, right_value)
        checked_expression.location
    )
}

func convert_super_access_expression(self: @IR_Builder, checked_expression: @Checked_Super_Access_Expression, expected_type: @IR_Type) -> @IR_Value {
    abort("TODO: Convert super access expression")
}

func convert_symbol_expression(self: @IR_Builder, checked_expression: @Checked_Symbol_Expression, expected_type: @IR_Type) -> @IR_Value {
    let ir_symbol = self.current_block_context.find_symbol(checked_expression.symbol)
    if ir_symbol == null {
        abort(checked_expression.location, clone("Unknown symbol: ").append(checked_expression.symbol.name))
    }
    if ir_symbol is IR_Function_Parameter {
        return ir_symbol.as(@IR_Function_Parameter).value
    }
    if ir_symbol is IR_Local_Variable {
        let ir_symbol = ir_symbol.as(@IR_Local_Variable)
        return self.append(
            make @IR_Load_Instruction(
                result_value = self.create_variable_value(ir_symbol)
            ).init(ir_symbol.value_pointer)
            checked_expression.location
        )
    }
    \ if ir_symbol is IR_Constant {
    \     \ return ir_symbol.as(@IR_Constant).value
    \ }
    \ if ir_symbol is IR_Function {
    \     let ir_function = ir_symbol.as(@IR_Function)
    \     return make @IR_Function_Address_Value(
    \         type = self.create_ir_pointer_type(ir_function.type)
    \         function = ir_function
    \     )
    \ }
    abort(checked_expression.location, clone("Unsupported symbol type: ").append(ir_symbol.object_type.name))
}
