include "./code/io/File.code"

Expression :: struct {
    dump: (self: @Expression) -> Nothing
    evaluate: (self: @Expression) -> Int = null
}

Int_Expression :: struct : Expression(dump = dump_int, evaluate = evaluate_int) {
    value: Int
}

dump_int :: (self: @Expression) -> Nothing {
    self := self as @Int_Expression
    stdout.write(self.value)
}

evaluate_int :: (self: @Expression) -> Int {
    self := self as @Int_Expression
    return self.value
}

Binary_Expression :: struct : Expression(dump = dump_binary_expression) {
    operator: @String
    left_expression: @Expression
    right_expression: @Expression
}

dump_binary_expression :: (self: @Expression) -> Nothing {
    self := self as @Binary_Expression
    stdout.write('(')
    self.left_expression.dump()
    stdout.write(' ').write(self.operator).write(' ')
    self.right_expression.dump()
    stdout.write(')')
}

Addition_Expression :: struct : Binary_Expression(operator = "+", evaluate = evaluate_addition) {
}

evaluate_addition :: (self: @Expression) -> Int {
    self := self as @Addition_Expression
    return self.left_expression.evaluate() + self.right_expression.evaluate()
}

Substraction_Expression :: struct : Binary_Expression(operator = "-", evaluate = evaluate_substraction) {
}

evaluate_substraction :: (self: @Expression) -> Int {
    self := self as @Substraction_Expression
    return self.left_expression.evaluate() - self.right_expression.evaluate()
}

main :: () -> Int {
    one := new Int_Expression(value = 1)

    expression: @Expression = new Addition_Expression(
        left_expression = new Int_Expression(
            value = 2
        )
        right_expression = new Int_Expression(
            value = 3
        )
    )
    while (expression.evaluate() > 0) {
        expression = new Substraction_Expression(
            left_expression = expression
            right_expression = one
        )
    }

    expression.dump()
    stdout.write(" = ").write(expression.evaluate()).end_line()

    return 0
}
