\ Copyright (c) 2020, Stefan Selariu

let text: String

define main = func () -> i32 {
    text = read_file("editor/Editor.code")

    if (SDL_Init(SDL_INIT_VIDEO) != 0) {
        stderr.write("Unable to initialize SDL: ").write(SDL_GetError()).end_line()
        return 1
    }

    SDL_ShowCursor(0)

    let window_width = 1024
    let window_height = 768

    let window = SDL_CreateWindow("ReCode".data, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, window_width, window_height, SDL_WINDOW_RESIZABLE)
    if (window == null) {
        stderr.write("Failed to create window: ").write(SDL_GetError()).end_line()
        return 1
    }

    let window_surface = SDL_GetWindowSurface(window)
    if (window_surface == null) {
        stderr.write("Failed to get window surface: ").write(SDL_GetError()).end_line()
        return 1
    }

    if (window_surface.format.bits_per_pixel != 32u8) {
        stderr.write("Unsupported surface format").end_line()
        return 1
    }

    let canvas = new Canvas(
        pixels = window_surface.pixels
        width = window_surface.width
        height = window_surface.height
        clip_rect = Rect(
            left = 0
            top = 0
            right = window_surface.width - 1
            bottom = window_surface.height - 1
            width = window_surface.width
            height = window_surface.height
        )
    )

    init_font()

    let event: SDL_Event = new SDL_Undefined_Event()

    let mouse_x = 0
    let mouse_y = 0
    let mouse_button = 0u8

    let glyph = font_glyphs['A' as i32]

    loop {
        if (SDL_WaitEvent(event) != 0) {
            if (event.type == SDL_QUIT) {
                break
            } else if (event.type == SDL_MOUSEMOTION) {
                let event = event as SDL_MouseMotionEvent
                mouse_x = event.x
                mouse_y = event.y
                \ stdout.write("mouse moved event -- state").write(event.state, 2u8).end_line()
            } else if (event.type == SDL_MOUSEBUTTONDOWN) {
                let event = event as SDL_MouseButtonEvent
                mouse_button = event.button
            } else if (event.type == SDL_MOUSEBUTTONUP) {
                let event = event as SDL_MouseButtonEvent
                mouse_button = 0
            } else if (event.type == SDL_WINDOWEVENT) {
                let event = event as SDL_WindowEvent
                \ stdout.write("window event: ").write(event.event as u32).end_line()
                if (event.event == SDL_WINDOWEVENT_RESIZED) {
                    let window_surface = SDL_GetWindowSurface(window)
                    if (window_surface == null) {
                        stderr.write("Failed to get window surface: ").write(SDL_GetError()).end_line()
                        return 1
                    }
                    canvas.pixels = window_surface.pixels
                    canvas.width = window_surface.width
                    canvas.height = window_surface.height
                    canvas.clip_rect = Rect(
                        left = 0
                        top = 0
                        right = window_surface.width - 1
                        bottom = window_surface.height - 1
                        width = window_surface.width
                        height = window_surface.height
                    )
                }
            }
        }

        canvas.set_color(COLOR_BACKGROUND)
        canvas.clear()

        \ canvas.set_color(COLOR_TEXT)
        \ canvas.draw_text(" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", 32, 8)

        canvas.draw_glyph_editor(glyph, 32, mouse_x, mouse_y, mouse_button)

        canvas.draw_cursor(mouse_x, mouse_y)

        SDL_UpdateWindowSurface(window)
    }

    SDL_DestroyWindow(window)

    SDL_Quit()
    return 0
}

define COLOR_BACKGROUND = 0x333333u32
define COLOR_TEXT = 0xbfbfafu32

define draw_cursor = func (canvas: Canvas, x: i32, y: i32) -> Nothing {
    canvas.set_color(0x666666u32)
    canvas.draw_vertical_line(x + 1, y - 11, y + 13)
    canvas.draw_horizontal_line(x - 11, x + 13, y + 1)
    canvas.set_color(0xffffffu32)
    canvas.draw_vertical_line(x, y - 12, y + 12)
    canvas.draw_horizontal_line(x - 12, x + 12, y)
}

define draw_glyph_editor = func (canvas: Canvas, glyph: Glyph, cell_size: i32, mouse_x: i32, mouse_y: i32, mouse_button: u8) -> Nothing {
    let rows = glyph.mask.length as i32
    let columns = glyph.mask[0].length as i32

    define MARGIN = 32

    canvas.set_color(COLOR_TEXT)
    canvas.draw_rect(MARGIN, MARGIN, MARGIN + cell_size * columns + 1, MARGIN + cell_size * rows + 1)

    canvas.set_color(COLOR_TEXT)
    let row = 0
    while (row < rows) {
        let column = 0
        while (column < columns) {
            let cell_bounds = Rect(
                left = MARGIN + cell_size * column + 1
                top = MARGIN + cell_size * row + 1
                right = MARGIN + cell_size * column + cell_size
                bottom = MARGIN + cell_size * row + cell_size
                width = undefined
                height = undefined
            )

            let is_hovered = cell_bounds.contains(mouse_x, mouse_y)

            let is_filled = glyph.mask[row][column] != 0u8
            if (is_filled && mouse_button == 2u8) {
                glyph.mask[row][column] = 0u8
                is_filled = false
            }
            if (is_hovered) {
                if (is_filled == false && mouse_button == 1u8) {
                    glyph.mask[row][column] = 255u8
                    is_filled = true
                } else if (is_filled == true && mouse_button == 3u8) {
                    glyph.mask[row][column] = 0u8
                    is_filled = false
                }
                let hover_color_delta = 0x070707u32
                if (is_filled) {
                    canvas.set_color(COLOR_TEXT - hover_color_delta)
                } else {
                    canvas.set_color(COLOR_BACKGROUND + hover_color_delta)
                }
            }

            if (is_filled || is_hovered) {
                canvas.fill_rect(cell_bounds.left, cell_bounds.top, cell_bounds.right, cell_bounds.bottom)
            }

            if (is_hovered) {
                canvas.set_color(COLOR_TEXT)
            }
            column = column + 1
        }
        row = row + 1
    }

    canvas.set_color(0x0000ffu32)
    canvas.draw_horizontal_line(MARGIN, MARGIN + cell_size * columns + 1, MARGIN + cell_size * glyph.base_line + 1)

    canvas.set_color(COLOR_TEXT)
    let char = ' ' as u8
    let char_bounds = Rect()
    let char_bounds = char_bounds.reference()
    char_bounds.set_size(glyph.mask[0].length as i32, glyph.mask.length as i32)
    let margin = MARGIN
    char_bounds.set_location(margin * 2 + cell_size * columns + 2, MARGIN) \ TODO: replace margin with MARGIN
    while (char < 127) {
        let is_selected = font_glyphs[char] == glyph
        let is_hovered = char_bounds.contains(mouse_x, mouse_y)
        if (is_selected) {
            canvas.set_color(0x0000ffu32)
            canvas.fill_rect(char_bounds)
            canvas.set_color(COLOR_TEXT)
        } else if (is_hovered) {
            let hover_color_delta = 0x070707u32
            canvas.set_color(COLOR_BACKGROUND + hover_color_delta)
            canvas.fill_rect(char_bounds)
            canvas.set_color(COLOR_TEXT)
        }

        canvas.draw_char(char, char_bounds.left, char_bounds.top)

        char = char + 1
        if (char_bounds.right < canvas.width - MARGIN) {
            char_bounds.set_location(char_bounds.left + glyph.mask[0].length as i32, char_bounds.top)
        } else {
            char_bounds.set_location(margin * 2 + cell_size * columns + 2, char_bounds.top + glyph.mask.length as i32) \ TODO: replace margin with MARGIN
        }
    }

    canvas.draw_text(text, margin * 2 + cell_size * columns + 2, char_bounds.bottom + MARGIN)
}

define abort = func () -> Nothing

include "./Canvas.code"
include "./File.code"
