\ Copyright (c) 2020-2021, Stefan Selariu

include "./Button.code"
include "./File.code"
include "./gui/Layout.code"

define COLOR_BACKGROUND = 0x333333u32
define COLOR_TEXT = 0xbfbfafu32

define glyph_editor = func (context: GUI_Context, glyph_editor: Old_Glyph_Editor) -> Nothing {
    let cell_size = glyph_editor.cell_size
    let glyph = font_glyphs[glyph_editor.selected_glyph]
    let rows = glyph.mask.length as i32
    let columns = glyph.mask[0].length as i32

    define MARGIN = 32

    let canvas = context.canvas

    let is_reset = false

    let context_event = context.event
    let context_event_type = context_event.type
    if (context_event_type == GUI_EVENT_TYPE_INIT) {
        glyph_editor.bounds.set_size(cell_size * columns + 2, cell_size * rows + 2)
        glyph_editor.bounds.set_location(MARGIN, MARGIN)
    } else if (context_event_type == GUI_EVENT_TYPE_MOUSE_MOVED) {
        let context_event = context_event as GUI_Event_Mouse_Moved
        if (glyph_editor.bounds.contains(context_event.x, context_event.y)) {
            context.hovered_view = glyph_editor
            glyph_editor.hovered_row = (context_event.y - MARGIN - 1) / glyph_editor.cell_size
            glyph_editor.hovered_column = (context_event.x - MARGIN - 1) / glyph_editor.cell_size
        }
    } else if (context_event_type == GUI_EVENT_TYPE_MOUSE_BUTTON_PRESSED) {
        if (context.hovered_view == glyph_editor as GUI_View) {
            let context_event = context.event as GUI_Event_Mouse_Button_Pressed
            if (context_event.which == 1u8) {
                glyph_editor.is_drawing = true
            } else if (context_event.which == 3u8) {
                glyph_editor.is_erasing = true
            } else if (context_event.which == 2u8) {
                glyph_editor.is_resetting = true
            }
        }
    } else if (context_event_type == GUI_EVENT_TYPE_MOUSE_BUTTON_RELEASED) {
        let context_event = context.event as GUI_Event_Mouse_Button_Released
        if (context_event.which == 1u8) {
            glyph_editor.is_drawing = false
        } else if (context_event.which == 3u8) {
            glyph_editor.is_erasing = false
        } else if (context_event.which == 2u8) {
            if (context.hovered_view == glyph_editor as GUI_View) {
                is_reset = true
                glyph_editor.is_resetting = false
            }
        }
    }

    canvas.set_color(COLOR_TEXT)
    canvas.draw_rect(glyph_editor.bounds)

    canvas.set_color(COLOR_TEXT)
    let row = 0
    while (row < rows) {
        let column = 0
        while (column < columns) {
            let cell_bounds = Rect(
                left = MARGIN + cell_size * column + 1
                top = MARGIN + cell_size * row + 1
                right = MARGIN + cell_size * column + cell_size
                bottom = MARGIN + cell_size * row + cell_size
                width = undefined
                height = undefined
            )

            let is_hovered = glyph_editor.hovered_row == row && glyph_editor.hovered_column == column

            let is_filled = glyph.mask[row][column] != 0u8
            if (is_filled && is_reset) {
                glyph.mask[row][column] = 0u8
                is_filled = false
            }

            if (is_hovered) {
                if (is_filled == false && glyph_editor.is_drawing) {
                    glyph.mask[row][column] = 255u8
                    is_filled = true
                } else if (is_filled == true && glyph_editor.is_erasing) {
                    glyph.mask[row][column] = 0u8
                    is_filled = false
                }
                let hover_color_delta = 0x070707u32
                if (is_filled) {
                    canvas.set_color(COLOR_TEXT - hover_color_delta)
                } else {
                    canvas.set_color(COLOR_BACKGROUND + hover_color_delta)
                }
            }

            if (is_filled || is_hovered) {
                canvas.fill_rect(cell_bounds.left, cell_bounds.top, cell_bounds.right, cell_bounds.bottom)
            }

            if (is_hovered) {
                canvas.set_color(COLOR_TEXT)
            }
            column = column + 1
        }
        row = row + 1
    }

    canvas.set_color(0x0000ffu32)
    canvas.draw_horizontal_line(MARGIN, MARGIN + cell_size * columns + 1, MARGIN + cell_size * glyph.base_line + 1)

    let char = ' ' as i32
    while (char < 127) {
        if (glyph_editor.selected_glyph == char as u8) {
            canvas.set_color(0x0000ffu32)
            canvas.fill_rect(glyph_editor.select_glyph_buttons[char].bounds)
        }
        if (context.button(glyph_editor.select_glyph_buttons[char])) {
            glyph_editor.selected_glyph = char as u8
        }
        char = char + 1
    }

    let margin = MARGIN
    canvas.set_color(COLOR_TEXT)
    canvas.draw_text(text, glyph_editor.bounds.right + MARGIN, glyph_editor.select_glyph_buttons[126].bounds.bottom + MARGIN)

    if (context.button(glyph_editor.save_button)) {
        dump_font()
    }

    if (context_event_type == GUI_EVENT_TYPE_INIT) {
        let char_left = glyph_editor.bounds.right + MARGIN
        let char_top = glyph_editor.bounds.top
        let char = ' ' as i32
        while (char < 127) {
            glyph_editor.select_glyph_buttons[char].bounds.set_location(char_left, char_top)
            char_left = char_left + glyph_editor.select_glyph_buttons[char].bounds.width + 2
            if (char_left > canvas.width - 2 - MARGIN) {
                char_left = glyph_editor.bounds.right + MARGIN
                char_top = glyph_editor.select_glyph_buttons[char].bounds.bottom + 2
            }
            char = char + 1
        }

        glyph_editor.save_button.bounds.set_location(MARGIN, glyph_editor.bounds.bottom + MARGIN)
        glyph_editor.save_button.bounds.set_size(glyph_editor.bounds.width, glyph_editor.save_button.bounds.height)
    }
}

define Old_Glyph_Editor = struct {
    extends GUI_View
    cell_size: i32
    selected_glyph: u8
    select_glyph_buttons: [!Button; 128]
    save_button: !Button
    hovered_row: i32 = undefined
    hovered_column: i32 = undefined
    is_drawing: bool = false
    is_erasing: bool = false
    is_resetting: bool = false
}

define glyph_editor = func (parent: GUI_Layout, glyph: Glyph) -> Glyph_Editor {
    let glyph_editor = new Glyph_Editor(gui = parent.gui, parent = parent, glyph = glyph)
    parent.add(glyph_editor)

    let glyph_rows = glyph.mask.length as i32
    let glyph_columns = glyph.mask[0].length as i32
    glyph_editor.width_hint = (glyph_editor.pixel_size + 1) * glyph_columns + 1
    glyph_editor.height_hint = (glyph_editor.pixel_size + 1) * glyph_rows + 1

    return glyph_editor
}

define Glyph_Editor = struct {
    extends GUI_Widget(
        name = "Glyph_Editor"
        update_hovered_widget = func (self: GUI_Widget, x: i32, y: i32) -> Nothing {
            self.widget_updates_hovered_widget(x, y)

            let self = self as Glyph_Editor
            if (self.bounds.contains(x, y)) {
                self.hovered_row = (y - self.bounds.left) / (self.pixel_size + 1)
                self.hovered_column = (x - self.bounds.left) / (self.pixel_size + 1)
            } else {
                self.hovered_row = -1
                self.hovered_column = -1
            }
        }
        measure = measure_glyph_editor
        draw = draw_glyph_editor
    )
    glyph: Glyph
    pixel_size: i32 = 23
    hovered_row: i32 = -1
    hovered_column: i32 = -1
}

define measure_glyph_editor = func (self: GUI_Widget, width_spec: Measure_Spec, height_spec: Measure_Spec) -> Nothing {
    let self = self as Glyph_Editor

    if (width_spec.mode == MEASURE_SPEC_MODE_EXACTLY) {
        self.width_hint = width_spec.size
    } else if (width_spec.mode == MEASURE_SPEC_MODE_LIMITED) {
        let glyph_columns = self.glyph.mask[0].length as i32
        self.width_hint = (self.pixel_size + 1) * glyph_columns + 1
        if (self.width_hint > width_spec.size) {
            self.width_hint = width_spec.size
        }
    } else if (width_spec.mode == MEASURE_SPEC_MODE_UNLIMITED) {
        let glyph_columns = self.glyph.mask[0].length as i32
        self.width_hint = (self.pixel_size + 1) * glyph_columns + 1
    } else {
        self.abort("width", width_spec)
    }

    if (height_spec.mode == MEASURE_SPEC_MODE_EXACTLY) {
        self.height_hint = height_spec.size
    } else if (height_spec.mode == MEASURE_SPEC_MODE_UNLIMITED) {
        let glyph_rows = self.glyph.mask.length as i32
        self.height_hint = (self.pixel_size + 1) * glyph_rows + 1
    } else {
        self.abort("height", width_spec)
    }

    \ stdout.write(self.name).write(" size hint: ").write(self.width_hint).write(" x ").write(self.height_hint).end_line()
}

define draw_glyph_editor = func (self: GUI_Widget, canvas: Canvas) -> Nothing {
    let self = self as Glyph_Editor

    canvas.set_color(0xffff00u32)

    let glyph_mask = self.glyph.mask
    let glyph_row = 0
    while (glyph_row <= glyph_mask.length as i32) {
        canvas.draw_horizontal_line(self.bounds.left, self.bounds.right, self.bounds.top + glyph_row * (self.pixel_size + 1))
        glyph_row = glyph_row + 1
    }
    let glyph_column = 0
    while (glyph_column <= glyph_mask[0].length as i32) {
        canvas.draw_vertical_line(self.bounds.left + glyph_column * (self.pixel_size + 1), self.bounds.top, self.bounds.bottom)
        glyph_column = glyph_column + 1
    }

    let glyph_row = 0
    while (glyph_row < glyph_mask.length as i32) {
        let glyph_row_mask = glyph_mask[glyph_row]
        let glyph_column = 0
        while (glyph_column < glyph_row_mask.length as i32) {
            if (glyph_row_mask[glyph_column] != 0u8) {
                canvas.fill_rect(
                    self.bounds.left + glyph_column * (self.pixel_size + 1) + 1
                    self.bounds.top + glyph_row * (self.pixel_size + 1) + 1
                    self.bounds.left + glyph_column * (self.pixel_size + 1) + self.pixel_size
                    self.bounds.top + glyph_row * (self.pixel_size + 1) + self.pixel_size
                )
            }
            glyph_column = glyph_column + 1
        }
        glyph_row = glyph_row + 1
    }

    if (self.hovered_row >= 0 && self.hovered_column >= 0) {
        if (glyph_mask[self.hovered_row][self.hovered_column] == 0u8) {
            canvas.set_color(0x666600u32)
        } else {
            canvas.set_color(0xcccc00u32)
        }
        canvas.fill_rect(
            self.bounds.left + self.hovered_column * (self.pixel_size + 1) + 1
            self.bounds.top + self.hovered_row * (self.pixel_size + 1) + 1
            self.bounds.left + self.hovered_column * (self.pixel_size + 1) + self.pixel_size
            self.bounds.top + self.hovered_row * (self.pixel_size + 1) + self.pixel_size
        )
    }

    canvas.set_color(0xff0000u32)
    canvas.draw_horizontal_line(self.bounds.left, self.bounds.right, self.bounds.top + self.glyph.base_line * (self.pixel_size + 1))
}

define glyph_chooser = func (parent: GUI_Layout, selected_glyph: u8) -> Glyph_Chooser {
    let glyph_chooser = new Glyph_Chooser(gui = parent.gui, parent = parent, selected_glyph = selected_glyph)
    parent.add(glyph_chooser)

    let glyph = ' '
    while (glyph <= '~') {
        let button = glyph_chooser.button(new String().append(glyph as u8))
        button.data = new Glyph_Chooser_Button_Data(glyph_chooser = glyph_chooser, glyph = glyph as u8)
        button.handle_click_event = func (self: GUI_Widget) -> Nothing {
            let data = (self as GUI_Button).data as Glyph_Chooser_Button_Data
            data.glyph_chooser.handle_glyph_selected(data.glyph)
        }
        glyph = glyph + 1
    }

    return glyph_chooser
}

define Glyph_Chooser = struct {
    extends GUI_Layout(
        name = "Glyph_Chooser"
        measure = measure_glyph_chooser
        layout = layout_glyph_chooser
        draw = draw_glyph_chooser
    )
    selected_glyph: u8
    handle_glyph_selected: func (self: Glyph_Chooser, glyph: u8) -> Nothing = func (self: Glyph_Chooser, glyph: u8) -> Nothing {
        stderr.write(self.name).write(" doesn't have the 'handle_glyph_selected' callback").end_line()
        abort()
    }
}

define Glyph_Chooser_Button_Data = struct {
    extends GUI_Data
    glyph_chooser: Glyph_Chooser
    glyph: u8
}

define measure_glyph_chooser = func (self: GUI_Widget, width_spec: Measure_Spec, height_spec: Measure_Spec) -> Nothing {
    let self = self as Glyph_Chooser
    if (width_spec.mode == MEASURE_SPEC_MODE_LIMITED) {
        if (self.width_policy.mode == SIZE_POLICY_MODE_STRETCHED) {
            self.width_hint = width_spec.size
        } else {
            self.abort("width", self.width_policy)
        }
    } else {
        self.abort("width", width_spec)
    }
    if (height_spec.mode == MEASURE_SPEC_MODE_UNLIMITED) {
        self.height_hint = -3
        let child_width_spec = Measure_Spec(mode = MEASURE_SPEC_MODE_UNLIMITED)
        let child_height_spec = Measure_Spec(mode = MEASURE_SPEC_MODE_UNLIMITED)
        let row_width = 0
        let row_height = 0
        self.for_each_child() {
            child.measure(@child_width_spec, @child_height_spec)
            if (row_width + child.width_hint < self.width_hint) {
                row_width = row_width + child.width_hint + 4
                if (row_height < child.height_hint) {
                    row_height = child.height_hint
                }
            } else {
                row_width = child.width_hint + 4
                self.height_hint = self.height_hint + row_height + 3
                row_height = 0
            }
        }
        self.height_hint = self.height_hint + row_height + 3


        \ self.abort("height", height_spec)
    } else {
        self.abort("height", height_spec)
    }
}

define layout_glyph_chooser = func (self: GUI_Widget, left: i32, top: i32, right: i32, bottom: i32) -> Nothing {
    let self = self as Glyph_Chooser

    self.bounds.set(left, top, right, bottom)

    let child_left = left
    let child_top = top
    self.for_each_child() {
        let child_right = child_left + child.width_hint - 1
        if (child_right > right) {
            child_left = left
            child_right = left + child.width_hint - 1
            child_top = child_top + child.height_hint + 3
        }
        let child_bottom = child_top + child.height_hint - 1
        child.layout(child_left, child_top, child_right, child_bottom)
        child_left = child_right + 5
    }
}

define draw_glyph_chooser = func (self: GUI_Widget, canvas: Canvas) -> Nothing {
    let self = self as Glyph_Chooser

    canvas.set_color(0x00ff77u32)
    canvas.draw_rect(self.bounds)

    self.for_each_child() {
        child.draw(canvas)
    }
}

define dump_font = func () -> Nothing {
    let file = open_file("editor/Font.code", "w")

    file.write("\\ Copyright (c) 2020-2021, Stefan Selariu").end_line()
    file.end_line()
    file.write("let font_glyphs: [!Glyph; 256]").end_line()
    file.end_line()
    file.write("define Glyph = struct {").end_line()
    file.write("    mask: [[u8; 9]; 18]").end_line()
    file.write("    base_line: i32").end_line()
    file.write("}").end_line()
    file.end_line()
    file.write("define init_font = func () -> Nothing {").end_line()
    file.write("    let index = 0isize").end_line()
    file.write("    while (index < font_glyphs.length) {").end_line()
    file.write("        if (index < ' ' as isize || index >= 127) {").end_line()
    file.write("            let font_glyph = font_glyphs[index]").end_line()
    file.write("            font_glyphs[index].base_line = 13").end_line()
    file.write("            let left = 1").end_line()
    file.write("            let top = 2").end_line()
    file.write("            let right = font_glyph.mask[0].length as i32 - 2").end_line()
    file.write("            let bottom = font_glyph.base_line - 1").end_line()
    file.write("            let x = left").end_line()
    file.write("            while (x <= right) {").end_line()
    file.write("                font_glyph.mask[top][x] = 255u8").end_line()
    file.write("                font_glyph.mask[bottom][x] = 255u8").end_line()
    file.write("                x = x + 1").end_line()
    file.write("            }").end_line()
    file.write("            let y = top + 1").end_line()
    file.write("            while (y < bottom) {").end_line()
    file.write("                font_glyph.mask[y][left] = 255u8").end_line()
    file.write("                font_glyph.mask[y][right] = 255u8").end_line()
    file.write("                y = y + 1").end_line()
    file.write("            }").end_line()
    file.write("        }").end_line()
    file.write("        index = index + 1").end_line()
    file.write("    }").end_line()

    let char = ' ' as i32
    while (char < 127) {
        file.end_line()
        file.write("    \\ ").write(char as u8).end_line()
        let glyph = font_glyphs[char]
        file.write("    font_glyphs[0x").write(char as u32, 16u8).write("].base_line = ").write(glyph.base_line).end_line()
        let row = 0isize
        while (row < glyph.mask.length) {
            let column = 0isize
            while (column < glyph.mask[0].length) {
                if (glyph.mask[row][column] != 0u8) {
                    file.write("    font_glyphs[0x").write(char as u32, 16u8).write("].mask[").write(row).write("][").write(column).write("] = ").write(glyph.mask[row][column] as i32).end_line()
                }
                column = column + 1
            }
            row = row + 1
        }

        char = char + 1
    }

    file.write("}").end_line()

    file.close()
}
