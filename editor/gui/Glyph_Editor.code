\ Copyright (c) 2020-2021, 2023, Stefan Selariu

include "code/gui/Widget.code"

func glyph_editor(parent: @GUI_Layout, glyph: @Glyph) -> @Glyph_Editor {
    let glyph_editor = make @Glyph_Editor(gui = parent.gui, parent = parent, glyph = glyph)
    parent.add(glyph_editor)

    let glyph_rows = glyph.mask.length.as(i32)
    let glyph_columns = glyph.mask[0].length.as(i32)
    glyph_editor.width_hint = (glyph_editor.pixel_size + 1) * glyph_columns + 1
    glyph_editor.height_hint = (glyph_editor.pixel_size + 1) * glyph_rows + 1

    return glyph_editor
}

struct Glyph_Editor: GUI_Widget(
    name = "Glyph_Editor"
    on_mouse_moved = func (self: @GUI_Widget, event: @GUI_Event_Mouse_Moved) -> Nothing {
        let self = self.as(@Glyph_Editor)
        let last_hovered_row = self.hovered_row
        let last_hovered_column = self.hovered_column
        if self.bounds.contains(event.x, event.y) and event.x < self.bounds.right and event.y < self.bounds.bottom {
            self.gui.hovered_widget = self

            self.hovered_row = (event.y - self.bounds.left) / (self.pixel_size + 1)
            self.hovered_column = (event.x - self.bounds.left) / (self.pixel_size + 1)

            if self.is_drawing {
                self.update_glyph_cell(self.hovered_row, self.hovered_column, 255u8)
            } else if self.is_erasing {
                self.update_glyph_cell(self.hovered_row, self.hovered_column, 0u8)
            }
        } else {
            self.hovered_row = -1
            self.hovered_column = -1
        }
        if last_hovered_row != self.hovered_row or last_hovered_column != self.hovered_column {
            self.gui.post(make @GUI_Event_Widget_Updated(widget = self))
        }
    }
    on_mouse_button_pressed = func (self: @GUI_Widget, event: @GUI_Event_Mouse_Button_Pressed) -> Nothing {
        let self = self.as(@Glyph_Editor)
        self.gui.pressed_widget = self
        if event.button == 1u8 {
            self.is_drawing = true
            self.update_glyph_cell(self.hovered_row, self.hovered_column, 255u8)
        } else if event.button == 3u8 {
            self.is_erasing = true
            self.update_glyph_cell(self.hovered_row, self.hovered_column, 0u8)
        }
    }
    on_mouse_button_released = func (self: @GUI_Widget, event: @GUI_Event_Mouse_Button_Released) -> Nothing {
        if self.gui.pressed_widget == self {
            let self = self.as(@Glyph_Editor)
            if event.button == 1u8 {
                self.is_drawing = false
            } else if event.button == 2u8 and self.gui.hovered_widget == self.as(@GUI_Widget) {
                let glyph_mask = self.glyph.mask
                let glyph_row = 0
                while glyph_row < glyph_mask.length.as(i32) {
                    let glyph_row_mask = glyph_mask[glyph_row]
                    let glyph_column = 0
                    while glyph_column < glyph_row_mask.length.as(i32) {
                        glyph_row_mask[glyph_column] = 0u8
                        glyph_column = glyph_column + 1
                    }
                    glyph_row = glyph_row + 1
                }
                self.gui.post(make @GUI_Event_Widget_Updated(widget = self.gui))
            } else if event.button == 3u8 {
                self.is_erasing = false
            }
        }
    }
    measure = measure_glyph_editor
    draw = draw_glyph_editor
) {
    glyph: @Glyph
    pixel_size = 23
    hovered_row = -1
    hovered_column = -1
    is_drawing = false
    is_erasing = false
}

func measure_glyph_editor(self: @GUI_Widget, width_spec: @Measure_Spec, height_spec: @Measure_Spec) -> Nothing {
    let self = self.as(@Glyph_Editor)

    if width_spec.mode == MEASURE_SPEC_MODE_EXACTLY {
        self.width_hint = width_spec.size
    } else if width_spec.mode == MEASURE_SPEC_MODE_LIMITED {
        let glyph_columns = self.glyph.mask[0].length.as(i32)
        self.width_hint = (self.pixel_size + 1) * glyph_columns + 1
        if self.width_hint > width_spec.size {
            self.width_hint = width_spec.size
        }
    } else if width_spec.mode == MEASURE_SPEC_MODE_UNLIMITED {
        let glyph_columns = self.glyph.mask[0].length.as(i32)
        self.width_hint = (self.pixel_size + 1) * glyph_columns + 1
    } else {
        self.abort("width", width_spec)
    }

    if height_spec.mode == MEASURE_SPEC_MODE_EXACTLY {
        self.height_hint = height_spec.size
    } else if height_spec.mode == MEASURE_SPEC_MODE_UNLIMITED {
        let glyph_rows = self.glyph.mask.length.as(i32)
        self.height_hint = (self.pixel_size + 1) * glyph_rows + 1
    } else {
        self.abort("height", width_spec)
    }

    \ stdout.write(self.name).write(" size hint: ").write(self.width_hint).write(" x ").write(self.height_hint).end_line()
}

func draw_glyph_editor(self: @GUI_Widget, canvas: @Canvas) -> Nothing {
    let self = self.as(@Glyph_Editor)

    canvas.set_color(COLOR_BACKGROUND)
    canvas.fill_rect(self.bounds)

    canvas.set_color(0xffff00u32)

    let glyph_mask = self.glyph.mask
    let glyph_row = 0
    while glyph_row <= glyph_mask.length.as(i32) {
        canvas.draw_horizontal_line(self.bounds.left, self.bounds.right, self.bounds.top + glyph_row * (self.pixel_size + 1))
        glyph_row = glyph_row + 1
    }
    let glyph_column = 0
    while glyph_column <= glyph_mask[0].length.as(i32) {
        canvas.draw_vertical_line(self.bounds.left + glyph_column * (self.pixel_size + 1), self.bounds.top, self.bounds.bottom)
        glyph_column = glyph_column + 1
    }

    let glyph_row = 0
    while glyph_row < glyph_mask.length.as(i32) {
        let glyph_row_mask = glyph_mask[glyph_row]
        let glyph_column = 0
        while glyph_column < glyph_row_mask.length.as(i32) {
            if glyph_row_mask[glyph_column] != 0u8 {
                canvas.fill_rect(
                    self.bounds.left + glyph_column * (self.pixel_size + 1) + 1
                    self.bounds.top + glyph_row * (self.pixel_size + 1) + 1
                    self.bounds.left + glyph_column * (self.pixel_size + 1) + self.pixel_size
                    self.bounds.top + glyph_row * (self.pixel_size + 1) + self.pixel_size
                )
            }
            glyph_column = glyph_column + 1
        }
        glyph_row = glyph_row + 1
    }

    if self.hovered_row >= 0 and self.hovered_column >= 0 {
        if glyph_mask[self.hovered_row][self.hovered_column] == 0u8 {
            canvas.set_color(0x666600u32)
        } else {
            canvas.set_color(0xcccc00u32)
        }
        canvas.fill_rect(
            self.bounds.left + self.hovered_column * (self.pixel_size + 1) + 1
            self.bounds.top + self.hovered_row * (self.pixel_size + 1) + 1
            self.bounds.left + self.hovered_column * (self.pixel_size + 1) + self.pixel_size
            self.bounds.top + self.hovered_row * (self.pixel_size + 1) + self.pixel_size
        )
    }

    canvas.set_color(0xff0000u32)
    canvas.draw_horizontal_line(self.bounds.left, self.bounds.right, self.bounds.top + font.base_line * (self.pixel_size + 1))
}

macro update_glyph_cell(self: @Glyph_Editor, glyph_row: i32, glyph_column: i32, value: u8) {
    if self.glyph.mask[glyph_row][glyph_column] != value {
        self.glyph.mask[glyph_row][glyph_column] = value
        self.gui.post(make @GUI_Event_Widget_Updated(widget = self.gui))
    }
}
